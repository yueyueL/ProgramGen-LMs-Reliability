public com.google.gwtjsonrpc.client.VoidResult run ( final com.google.gerrit.reviewdb.ReviewDb db ) throws com.google.gerrit.httpd.rpc.account.Failure , com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.AccountGroup group = db.accountGroups ( ) . get ( groupId ) ; assertAmGroupOwner ( db , group ) ; group.setType ( newType ) ; db.accountGroups ( ) . update ( java.util.Collections.singleton ( group ) ) ; groupCache.evict ( group ) ; return com.google.gwtjsonrpc.client.VoidResult.INSTANCE ; }
public void onSuccess ( com.google.gwt.core.client.JsArray < com.google.gerrit.client.account.AccountInfo > in ) { java.util.List < com.google.gerrit.client.ui.AccountSuggestOracle.AccountSuggestion > r = new java.util.ArrayList ( in.length ( ) ) ; for ( com.google.gerrit.client.account.AccountInfo p : com.google.gerrit.client.rpc.Natives.asList ( in ) ) { r.add ( new com.google.gerrit.client.ui.AccountSuggestOracle.AccountSuggestion ( p ) ) ; } cb.onSuggestionsReady ( req , new com.google.gerrit.client.ui.Response ( r ) ) ; }
public void testShow ( ) throws java.lang.Exception { assertGone ( com.google.gitiles.GitwebRedirectFilterTest.newRequest ( "a=commit" ) ) ; assertGone ( com.google.gitiles.GitwebRedirectFilterTest.newRequest ( "a=commit;p=test" ) ) ; org.eclipse.jgit.revwalk.RevCommit commit = repo.branch ( "refs/heads/master" ) . commit ( ) . create ( ) ; assertRedirectsTo ( com.google.gitiles.GitilesView.revision ( ) . setHostName ( com.google.gitiles.TestGitilesUrls.HOST_NAME ) . setServletPath ( com.google.gitiles.FakeHttpServletRequest.SERVLET_PATH ) . setRepositoryName ( "test" ) . setRevision ( commit ) . toUrl ( ) , com.google.gitiles.GitwebRedirectFilterTest.newRequest ( ( "a=commit;p=test&h=" + ( org.eclipse.jgit.lib.ObjectId.toString ( commit ) ) ) ) ) ; }
public com.google.gerrit.extensions.common.RevisionInfo addRevisionActions ( com.google.gerrit.extensions.common.RevisionInfo to , com.google.gerrit.server.change.RevisionResource rsrc ) { to.actions = toActionMap ( rsrc ) ; return to ; }
private void loadCommit ( final com.google.gerrit.client.changes.ChangeInfo.RevisionInfo rev , com.google.gerrit.client.rpc.CallbackGroup group ) { if ( rev.is_edit ( ) ) { return ; } com.google.gerrit.client.changes.ChangeApi.commitWithLinks ( changeId.get ( ) , rev.name ( ) , group.add ( new com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.client.changes.ChangeInfo.CommitInfo > ( ) { @ java.lang.Override public void onSuccess ( com.google.gerrit.client.changes.ChangeInfo.CommitInfo info ) { rev.set_commit ( info ) ; } @ java.lang.Override public void onFailure ( java.lang.Throwable caught ) { } } ) ) ; }
private Change.Id insertPatchSet ( org.eclipse.jgit.lib.Repository git , org.eclipse.jgit.revwalk.RevWalk revWalk , com.google.gerrit.reviewdb.client.Change change , com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId , org.eclipse.jgit.revwalk.RevCommit cherryPickCommit , com.google.gerrit.server.project.RefControl refControl ) throws com.google.gerrit.server.project.InvalidChangeOperationException , com.google.gerrit.server.project.NoSuchChangeException , com.google.gwtorm.server.OrmException , java.io.IOException { patchSetInserterFactory.create ( git , revWalk , refControl , change , cherryPickCommit ) . setMessage ( buildChangeMessage ( patchSetId , change ) ) . insert ( ) ; return change.getId ( ) ; }
public com.google.common.util.concurrent.ListenableFuture < ? > index ( com.google.gerrit.reviewdb.client.Change change , com.google.gerrit.server.util.RequestScopePropagator prop ) { java.lang.Runnable task = new com.google.gerrit.server.index.ChangeIndexerImpl.Task ( change ) ; if ( prop != null ) { task = prop.wrap ( task ) ; } return executor.submit ( task ) ; }
private java.nio.file.Path polyGerritBasePath ( ) { com.google.gerrit.httpd.raw.StaticModule.Paths p = getPaths ( ) ; boolean forceDev = options.forcePolyGerritDev ( ) ; if ( forceDev ) { com.google.common.base.Preconditions.checkArgument ( ( ( p.buckOut ) != null ) , "no buck-out directory found for PolyGerrit developer mode" ) ; } return forceDev || ( ( p.warFs ) == null ) ? p.buckOut.getParent ( ) . resolve ( "polygerrit-ui" ) . resolve ( "app" ) : p.warFs.getPath ( "/polygerrit_ui" ) ; }
private java.lang.String extractWhat ( java.lang.String commandName , java.lang.String [ ] args ) { java.lang.String result = commandName ; if ( "gerrit" . equals ( commandName ) ) { if ( ( args.length ) > 1 ) result = ( "gerrit" + "." ) + ( args [ 1 ] ) ; } return result ; }
private java.lang.String parseOneFooter ( org.eclipse.jgit.revwalk.RevCommit commit , org.eclipse.jgit.revwalk.FooterKey footerKey ) throws org.eclipse.jgit.errors.ConfigInvalidException { java.util.List < java.lang.String > footerLines = commit.getFooterLines ( footerKey ) ; if ( footerLines.isEmpty ( ) ) { return null ; } else if ( ( footerLines.size ( ) ) > 1 ) { throw expectedOneFooter ( footerKey , footerLines ) ; } return footerLines.get ( 0 ) ; }
public static com.google.common.base.Optional < java.util.TimeZone > getTimeZone ( org.eclipse.jgit.lib.Config config , java.lang.String section , java.lang.String subsection , java.lang.String name ) { java.lang.String id = config.getString ( section , subsection , name ) ; return id != null ? com.google.common.base.Optional.of ( java.util.TimeZone.getTimeZone ( id ) ) : com.google.common.base.Optional.< java.util.TimeZone > absent ( ) ; }
protected static java.util.List < java.lang.Integer > query ( com.google.gerrit.extensions.api.changes.Changes.QueryRequest query ) throws java.lang.Exception { return com.google.common.collect.FluentIterable.from ( query.get ( ) ) . transform ( new com.google.common.base.Function < com.google.gerrit.extensions.common.ChangeInfo , java.lang.Integer > ( ) { @ java.lang.Override public java.lang.Integer apply ( com.google.gerrit.extensions.common.ChangeInfo in ) { return in._number ; } } ) . toList ( ) ; }
public void patchScript ( final com.google.gerrit.client.reviewdb.Patch.Key patchKey , final com.google.gerrit.client.reviewdb.PatchSet.Id psa , final com.google.gerrit.client.reviewdb.PatchSet.Id psb , final com.google.gerrit.client.data.PatchScriptSettings s , final com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.client.data.PatchScript > callback ) { if ( psb == null ) { callback.onFailure ( new com.google.gerrit.client.rpc.NoSuchEntityException ( ) ) ; return ; } run ( callback , new com.google.gerrit.server.patch.PatchScriptAction ( server , registry , patchKey , psa , psb , s ) ) ; }
private java.util.Map < java.lang.String , org.eclipse.jgit.lib.Ref > visibleTags ( com.google.gerrit.server.project.ProjectControl control , org.eclipse.jgit.lib.Repository repo , java.util.Map < java.lang.String , org.eclipse.jgit.lib.Ref > tags ) { return refFilterFactory.create ( control.getProjectState ( ) , repo ) . setShowMetadata ( false ) . filter ( tags , true ) ; }
public com.google.gerrit.server.config.GetServerInfo.ServerInfo apply ( com.google.gerrit.server.config.ConfigResource rsrc ) throws java.net.MalformedURLException { com.google.gerrit.server.config.GetServerInfo.ServerInfo info = new com.google.gerrit.server.config.GetServerInfo.ServerInfo ( ) ; info.auth = new com.google.gerrit.server.config.GetServerInfo.AuthInfo ( authConfig , realm ) ; info.change = getChangeInfo ( config ) ; info.contactStore = getContactStoreInfo ( ) ; info.download = new com.google.gerrit.server.config.GetServerInfo.DownloadInfo ( downloadSchemes , downloadCommands , archiveFormats ) ; info.gerrit = getGerritInfo ( config , allProjectsName , allUsersName ) ; info.gitWeb = getGitWebInfo ( gitWebConfig ) ; info.suggest = getSuggestInfo ( config ) ; info.user = getUserInfo ( anonymousCowardName ) ; return info ; }
public java.lang.String getComment ( java.lang.String projectName , java.lang.String commitId ) throws java.io.IOException { final org.eclipse.jgit.lib.Repository repo = repoManager.openRepository ( new com.google.gerrit.reviewdb.client.Project.NameKey ( projectName ) ) ; try { org.eclipse.jgit.revwalk.RevWalk revWalk = new org.eclipse.jgit.revwalk.RevWalk ( repo ) ; org.eclipse.jgit.revwalk.RevCommit commit = revWalk.parseCommit ( org.eclipse.jgit.lib.ObjectId.fromString ( commitId ) ) ; return commit.getFullMessage ( ) ; } finally { repo.close ( ) ; } }
private static com.google.gerrit.client.rpc.RestApi queryWithParameter ( java.lang.String query ) { return new com.google.gerrit.client.rpc.RestApi ( com.google.gerrit.client.changes.ChangeList.URI ) . addParameterRaw ( "q" , com.google.gwtorm.client.KeyUtil.encode ( query ) ) ; }
public void add ( final com.google.gerrit.client.reviewdb.ChangeApproval ca ) { approvals.add ( ca ) ; final java.sql.Timestamp g = ca.getGranted ( ) ; if ( ( g != null ) && ( ( g.compareTo ( sortOrder ) ) < 0 ) ) { sortOrder = g ; } if ( ( ca.getValue ( ) ) != 0 ) { hasNonZero = 1 ; } }
private java.lang.String configurationToString ( ) { java.lang.StringBuilder b = new java.lang.StringBuilder ( ) ; b.append ( ( ( "number of configuration entries: " + ( config.size ( ) ) ) + "\n" ) ) ; for ( com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.ConfigEntry c : config ) { b.append ( ( ( c.toString ( ) ) + "\n" ) ) ; } return b.toString ( ) ; }
protected void configureServlets ( ) { install ( new com.google.gerrit.server.config.FactoryModule ( ) { @ java.lang.Override protected void configure ( ) { factory ( SaveDraft.Factory.class ) ; } } ) ; rpc ( com.google.gerrit.httpd.rpc.patch.PatchDetailServiceImpl.class ) ; }
public void serverConfigWithPlugin ( ) throws java.lang.Exception { java.nio.file.Path plugins = tempSiteDir.newFolder ( "plugins" ) . toPath ( ) ; java.nio.file.Path jsplugin = plugins.resolve ( "js-plugin-1.js" ) ; java.nio.file.Files.write ( jsplugin , "Gerrit.install(function(self){});\n" . getBytes ( java.nio.charset.StandardCharsets.UTF_8 ) ) ; sshSession.exec ( "gerrit plugin reload" ) ; com.google.gerrit.acceptance.RestResponse r = adminSession.get ( "/config/server/info/" ) ; com.google.gerrit.server.config.GetServerInfo.ServerInfo i = newGson ( ) . fromJson ( r.getReader ( ) , com.google.gerrit.server.config.GetServerInfo.ServerInfo.class ) ; com.google.common.truth.Truth.assertThat ( i.plugin.jsResourcePaths ) . hasSize ( 1 ) ; }
private com.google.gerrit.server.notedb.ChangeUpdate newUpdate ( com.google.gerrit.reviewdb.client.Change c , final com.google.gerrit.server.IdentifiedUser user ) throws java.lang.Exception { return injector.createChildInjector ( new com.google.gerrit.server.config.FactoryModule ( ) { @ java.lang.Override public void configure ( ) { factory ( ChangeUpdate.Factory.class ) ; bind ( com.google.gerrit.server.IdentifiedUser.class ) . toInstance ( user ) ; } } ) . getInstance ( ChangeUpdate.Factory.class ) . create ( stubChangeControl ( c , user ) , com.google.gerrit.server.util.TimeUtil.nowTs ( ) , com.google.common.collect.Ordering.< java.lang.String > natural ( ) ) ; }
public void parseAuthor ( ) throws java.lang.Exception { assertParseSucceeds ( ( "Update change\n" + ( ( ( ( "\n" + "Branch: refs/heads/master\n" ) + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" ) + "Patch-set: 1\n" ) + "Subject: This is a test change\n" ) ) ) ; assertParseFails ( writeCommit ( ( "Update change\n" + ( "\n" + "Patch-set: 1\n" ) ) , new org.eclipse.jgit.lib.PersonIdent ( "Change Owner" , "owner@example.com" , serverIdent.getWhen ( ) , serverIdent.getTimeZone ( ) ) ) ) ; assertParseFails ( writeCommit ( ( "Update change\n" + ( "\n" + "Patch-set: 1\n" ) ) , new org.eclipse.jgit.lib.PersonIdent ( "Change Owner" , "x@gerrit" , serverIdent.getWhen ( ) , serverIdent.getTimeZone ( ) ) ) ) ; }
com.google.gerrit.client.diff.DraftBox addReply ( com.google.gerrit.client.changes.CommentInfo replyTo , java.lang.String initMessage , boolean doSave ) { com.google.gerrit.common.changes.Side side = replyTo.side ( ) ; int line = replyTo.line ( ) ; com.google.gerrit.client.changes.CommentInfo info = com.google.gerrit.client.changes.CommentInfo.create ( path , side , line , replyTo.id ( ) , initMessage ) ; return addDraftBox ( info , doSave ) ; }
private java.io.File getSiteFromReviewDb ( java.sql.Connection conn ) { try ( java.sql.Statement stmt = conn.createStatement ( ) ; java.sql.ResultSet rs = stmt.executeQuery ( "SELECT site_path FROM system_config" ) ) { if ( rs.next ( ) ) { return new java.io.File ( rs.getString ( 1 ) ) ; } } catch ( java.sql.SQLException e ) { return null ; } return null ; }
void onDelete ( int idx ) { java.lang.String path = list.get ( idx ) . path ( ) ; com.google.gerrit.client.changes.ChangeFileApi.deleteContent ( curr , path , new com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.client.VoidResult > ( ) { @ java.lang.Override public void onSuccess ( com.google.gerrit.client.VoidResult result ) { com.google.gerrit.client.Gerrit.display ( com.google.gerrit.common.PageLinks.toChangeInEditMode ( curr.getParentKey ( ) ) ) ; } @ java.lang.Override public void onFailure ( java.lang.Throwable caught ) { } } ) ; }
public java.lang.Void call ( ) throws java.lang.Exception { int rc = daemon.main ( new java.lang.String [ ] { "-d" , sitePath , "--headless" } ) ; if ( rc != 0 ) { java.lang.System.out.println ( ( ( "Failed to start Gerrit daemon. Check " + sitePath ) + "/logs/error_log" ) ) ; serverStarted.reset ( ) ; } return null ; }
private void appendLineNumber ( final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder m , final int idx , boolean isForSideA ) { m.openTd ( ) ; m.setStyleName ( Gerrit.RESOURCES.css ( ) . lineNumber ( ) ) ; if ( isForSideA ) { m.addStyleName ( Gerrit.RESOURCES.css ( ) . rightBorder ( ) ) ; } m.append ( com.google.gwtexpui.safehtml.client.SafeHtml.asis ( ( ( "<a href=\"javascript:void(0)\">" + ( idx + 1 ) ) + "</a>" ) ) ) ; m.closeTd ( ) ; }
public void newPatchSetOnReviewableWipChangeInNoteDb ( ) throws java.lang.Exception { com.google.common.truth.TruthJUnit.assume ( ) . that ( notesMigration.readChanges ( ) ) . isTrue ( ) ; com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableWipChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.NEW_PATCHSETS ) ; pushTo ( sc , "refs/for/master%wip" , sc.owner ) ; assertThat ( sender ) . sent ( "newpatchset" , sc ) . notTo ( sc.owner ) . to ( sc.reviewer ) . to ( sc.reviewerByEmail ) . cc ( sc.ccer ) . cc ( sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.NEW_PATCHSETS ) ; }
void onSave ( @ java.lang.SuppressWarnings ( value = "unused" ) com.google.gwt.event.dom.client.ClickEvent e ) { com.google.gerrit.client.changes.ChangeFileApi.putContent ( id , file.getText ( ) , content.getText ( ) , new com.google.gerrit.client.rpc.GerritCallback < com.google.gerrit.client.VoidResult > ( ) { @ java.lang.Override public void onSuccess ( com.google.gerrit.client.VoidResult result ) { com.google.gerrit.client.Gerrit.display ( com.google.gerrit.common.PageLinks.toChangeInEditMode ( id.getParentKey ( ) ) ) ; hide ( ) ; } } ) ; }
protected void initName ( final java.lang.String fieldName , final com.google.gwtorm.client.Column col ) throws com.google.gwtorm.client.OrmException { if ( col == null ) { throw new com.google.gwtorm.client.OrmException ( ( ( ( ( "Field " + fieldName ) + " is missing " ) + ( com.google.gwtorm.client.Column.class . getName ( ) ) ) + " annotation" ) ) ; } column = col ; origName = com.google.gwtorm.schema.Util.any ( column.name ( ) , fieldName ) ; columnName = origName ; }
public static synchronized void schedule ( final java.lang.Runnable task , final long delay , final java.util.concurrent.TimeUnit unit ) { if ( ( com.google.gerrit.git.WorkQueue.pool ) == null ) { com.google.gerrit.git.WorkQueue.pool = new java.util.concurrent.ScheduledThreadPoolExecutor ( 1 ) ; com.google.gerrit.git.WorkQueue.pool.setKeepAliveTime ( 60 , java.util.concurrent.TimeUnit.SECONDS ) ; com.google.gerrit.git.WorkQueue.pool.setMaximumPoolSize ( 5 ) ; } com.google.gerrit.git.WorkQueue.pool.schedule ( task , delay , unit ) ; }
private java.util.Map < org.eclipse.jgit.lib.ObjectId , org.eclipse.jgit.lib.Ref > changeRefsById ( ) { if ( ( refsById ) == null ) { refsById = new java.util.HashMap < org.eclipse.jgit.lib.ObjectId , org.eclipse.jgit.lib.Ref > ( ) ; for ( final org.eclipse.jgit.lib.Ref r : repo.getAllRefs ( ) . values ( ) ) { if ( com.google.gerrit.reviewdb.PatchSet.isRef ( r.getName ( ) ) ) { refsById.put ( r.getObjectId ( ) , r ) ; } } } return refsById ; }
public static com.google.gerrit.client.changes.CommentInfo create ( java.lang.String path , com.google.gerrit.extensions.common.Side side , int line , com.google.gerrit.client.diff.CommentRange range ) { com.google.gerrit.client.changes.CommentInfo n = createObject ( ) . cast ( ) ; n.path ( path ) ; n.side ( side ) ; if ( range != null ) { n.line ( range.end_line ( ) ) ; n.range ( range ) ; } else if ( line > 0 ) { n.line ( line ) ; } return n ; }
public com.google.gerrit.rules.PrologEnvironment newPrologEnvironment ( ) throws com.googlecode.prolog_cafe.compiler.CompileException { com.googlecode.prolog_cafe.lang.PrologMachineCopy pmc = rulesMachine ; if ( pmc == null ) { pmc = rulesCache.loadMachine ( getProject ( ) . getNameKey ( ) , getConfig ( ) . getRulesId ( ) ) ; rulesMachine = pmc ; } return envFactory.create ( pmc ) ; }
private void stopRemovedPlugins ( java.util.List < java.io.File > jars ) { java.util.Set < java.lang.String > unload = com.google.common.collect.Sets.newHashSet ( running.keySet ( ) ) ; for ( java.io.File jar : jars ) { unload.remove ( com.google.gerrit.server.plugins.PluginLoader.nameOf ( jar ) ) ; } for ( java.lang.String name : unload ) { com.google.gerrit.server.plugins.PluginLoader.log.info ( java.lang.String.format ( "Unloading plugin %s" , name ) ) ; running.remove ( name ) . stop ( ) ; } }
public void allRefsVisibleWithRefsMetaConfig ( ) throws java.lang.Exception { allow ( Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS , "refs/*" ) ; allow ( Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS , "refs/meta/config" ) ; assertRefs ( "HEAD" , "refs/changes/01/1/1" , "refs/changes/02/2/1" , "refs/heads/branch" , "refs/heads/master" ) ; }
private com.google.gerrit.server.change.ChangeJson.ChangeInfo format ( com.google.gerrit.server.query.change.ChangeData cd , com.google.gerrit.reviewdb.client.PatchSet.Id psId ) throws com.google.gwtorm.server.OrmException { accountLoader = accountLoaderFactory.create ( has ( com.google.gerrit.common.changes.ListChangesOption.DETAILED_ACCOUNTS ) ) ; com.google.gerrit.server.change.ChangeJson.ChangeInfo res = toChangeInfo ( cd , psId ) ; accountLoader.fill ( ) ; return res ; }
protected void doDelete ( javax.servlet.http.HttpServletRequest req , javax.servlet.http.HttpServletResponse rsp ) { try { setUnhealthy ( ) ; rsp.setStatus ( javax.servlet.http.HttpServletResponse.SC_NO_CONTENT ) ; } catch ( java.io.IOException e ) { com.ericsson.gerrit.plugins.highavailability.health.HealthServlet.log.error ( "Failed to set unhealthy" , e ) ; sendError ( rsp , javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR ) ; } }
public int compare ( com.google.gerrit.reviewdb.client.Project o1 , com.google.gerrit.reviewdb.client.Project o2 ) { return o1.getName ( ) . compareTo ( o2.getName ( ) ) ; }
private void assertAdminsAreOwnersAndDevsAreNot ( ) { com.google.gerrit.server.project.ProjectControl uBlah = user ( local , com.google.gerrit.server.project.Util.DEVS ) ; com.google.gerrit.server.project.ProjectControl uAdmin = user ( local , com.google.gerrit.server.project.Util.DEVS , com.google.gerrit.server.project.Util.ADMIN ) ; com.google.common.truth.Truth.assertThat ( uBlah.isOwner ( ) ) . named ( "not owner" ) . isFalse ( ) ; com.google.common.truth.Truth.assertThat ( uAdmin.isOwner ( ) ) . named ( "is owner" ) . isTrue ( ) ; }
public void newPatchSetByOtherOnReviewableChangeNotifyOwnerInReviewDb ( ) throws java.lang.Exception { com.google.common.truth.TruthJUnit.assume ( ) . that ( notesMigration.readChanges ( ) ) . isFalse ( ) ; com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.NEW_PATCHSETS ) ; pushTo ( sc , "refs/for/master%notify=OWNER" , other ) ; assertThat ( sender ) . sent ( "newpatchset" , sc ) . to ( sc.reviewer , sc.ccer ) . notTo ( sc.owner , sc.starrer , other ) . notTo ( sc.reviewerByEmail , sc.ccerByEmail ) . notTo ( com.google.gerrit.server.account.WatchConfig.NotifyType.NEW_PATCHSETS ) ; }
private static org.apache.lucene.store.Directory dir ( com.google.gerrit.server.index.Schema < com.google.gerrit.server.project.ProjectState > schema , org.eclipse.jgit.lib.Config cfg , com.google.gerrit.server.config.SitePaths sitePaths ) throws java.io.IOException { if ( com.google.gerrit.lucene.LuceneIndexModule.isInMemoryTest ( cfg ) ) { return new org.apache.lucene.store.RAMDirectory ( ) ; } java.nio.file.Path indexDir = com.google.gerrit.lucene.LuceneVersionManager.getDir ( sitePaths , com.google.gerrit.lucene.LuceneProjectIndex.PROJECTS , schema ) ; return org.apache.lucene.store.FSDirectory.open ( indexDir ) ; }
public java.lang.String toString ( ) { return ( ( ( ( ( ( ( ( ( ( ( ( "ChangeMessage{" + "key=" ) + ( key ) ) + ", author=" ) + ( author ) ) + ", writtenOn=" ) + ( writtenOn ) ) + ", patchset=" ) + ( patchset ) ) + ", tag=" ) + ( tag ) ) + ", message=[" ) + ( message ) ) + "]}" ; }
public void indexChange ( ) throws java.lang.Exception { java.lang.String changeId = createChange ( ) . getChangeId ( ) ; com.google.gerrit.acceptance.RestResponse r = adminSession.post ( ( ( "/changes/" + changeId ) + "/index/" ) ) ; com.google.common.truth.Truth.assertThat ( r.getStatusCode ( ) ) . isEqualTo ( HttpStatus.SC_NO_CONTENT ) ; }
public com.googlesource.gerrit.plugins.hooks.its.ItsIssue call ( ) throws java.lang.Exception { com.j2bugzilla.base.Bug bug = client ( ) . getBug ( bugId ) ; com.googlesource.gerrit.plugins.hooks.its.ItsIssue result = ( bug == null ) ? null : new com.googlesource.gerrit.plugins.hooks.its.ItsIssue ( bugId , bug ) ; log.debug ( ( ( ( "Got issue " + bugId ) + ", " ) + result ) ) ; return result ; }
public com.google.gerrit.extensions.common.ChangeInfo format ( com.google.gerrit.reviewdb.client.Change.Id id ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change c ; try { c = db.get ( ) . changes ( ) . get ( id ) ; } catch ( com.google.gwtorm.server.OrmException e ) { if ( ! ( has ( com.google.gerrit.extensions.common.ListChangesOption.CHECK ) ) ) { throw e ; } return checkOnly ( changeDataFactory.create ( db.get ( ) , id ) ) ; } return format ( changeDataFactory.create ( db.get ( ) , c ) ) ; }
public void afterUpdateRepos ( ) throws com.google.gerrit.extensions.restapi.ResourceConflictException { try { markCleanMerges ( ) ; java.util.List < com.google.gerrit.reviewdb.client.Change.Id > alreadyMerged = checkCommitStatus ( ) ; findUnmergedChanges ( alreadyMerged ) ; } catch ( com.google.gerrit.server.git.IntegrationException e ) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException ( e.getMessage ( ) , e ) ; } }
public com.google.gerrit.extensions.common.PushCertificateInfo checkPushCertificate ( java.lang.String certStr , com.google.gerrit.server.IdentifiedUser expectedUser ) throws com.google.gerrit.server.GpgException { try { org.eclipse.jgit.transport.PushCertificate cert = org.eclipse.jgit.transport.PushCertificateParser.fromString ( certStr ) ; com.google.gerrit.gpg.PushCertificateChecker.Result result = pushCertCheckerFactory.create ( expectedUser , false ) . check ( cert ) ; com.google.gerrit.extensions.common.PushCertificateInfo info = new com.google.gerrit.extensions.common.PushCertificateInfo ( ) ; info.certificate = certStr ; info.key = com.google.gerrit.gpg.server.GpgKeys.toJson ( result.getPublicKey ( ) , result.getCheckResult ( ) ) ; return info ; } catch ( java.io.IOException e ) { throw new com.google.gerrit.server.GpgException ( e ) ; } }
public void write ( int b ) throws java.io.IOException { actualBody.write ( b ) ; }
public void remove ( ) { descriptions.remove ( name ) ; registry.remove ( name ) ; }
public static < T > void setOf ( com.google.inject.Binder binder , com.google.inject.TypeLiteral < T > member ) { @ java.lang.SuppressWarnings ( value = "unchecked" ) com.google.inject.Key < com.google.gerrit.extensions.registration.DynamicSet < T > > key = ( ( com.google.inject.Key < com.google.gerrit.extensions.registration.DynamicSet < T > > ) ( com.google.inject.Key.get ( com.google.inject.util.Types.newParameterizedType ( com.google.gerrit.extensions.registration.DynamicSet.class , member.getType ( ) ) ) ) ) ; binder.bind ( key ) . toProvider ( new com.google.gerrit.extensions.registration.DynamicSetProvider ( member ) ) . in ( Scopes.SINGLETON ) ; }
public void testIsEnabledRefNoParentNonMatchingBranchEnabled ( ) { java.lang.String [ ] branches = new java.lang.String [ ] { "^refs/heads/foo.*" } ; setupIsEnabled ( "true" , null , branches ) ; com.googlesource.gerrit.plugins.its.base.its.ItsConfig itsConfig = createItsConfig ( ) ; replayMocks ( ) ; assertFalse ( itsConfig.isEnabled ( "testProject" , "refs/heads/testBranch" ) ) ; }
public void delete ( com.google.gerrit.server.query.change.ChangeData cd ) throws java.io.IOException { org.apache.lucene.index.Term id = com.google.gerrit.lucene.QueryBuilder.idTerm ( cd ) ; try { com.google.common.util.concurrent.Futures.allAsList ( openIndex.delete ( id ) , closedIndex.delete ( id ) ) . get ( ) ; } catch ( java.util.concurrent.ExecutionException | java.lang.InterruptedException e ) { throw new java.io.IOException ( e ) ; } }
private com.google.gerrit.server.account.AuthResult byPreferredEmail ( java.lang.String email ) { try ( com.google.gerrit.reviewdb.server.ReviewDb db = schema.open ( ) ) { java.util.Optional < com.google.gerrit.reviewdb.client.Account > match = queryProvider.get ( ) . byPreferredEmail ( email ) . stream ( ) . map ( AccountState :: getAccount ) . findFirst ( ) ; return match.isPresent ( ) ? auth ( match.get ( ) ) : null ; } catch ( com.google.gwtorm.server.OrmException e ) { getServletContext ( ) . log ( "cannot query database" , e ) ; return null ; } }
private void initChangeAction ( com.google.gerrit.client.changes.ChangeInfo info ) { if ( ( info.status ( ) ) == ( com.google.gerrit.reviewdb.client.Change.Status.DRAFT ) ) { com.google.gerrit.client.rpc.NativeMap < com.google.gerrit.client.actions.ActionInfo > actions = ( info.has_actions ( ) ) ? info.actions ( ) : com.google.gerrit.client.rpc.NativeMap.< com.google.gerrit.client.actions.ActionInfo > create ( ) ; actions.copyKeysIntoChildren ( "id" ) ; if ( actions.containsKey ( "/" ) ) { deleteChange.setVisible ( true ) ; deleteChange.setTitle ( actions.get ( "/" ) . title ( ) ) ; } } }
private void fakeClick ( final com.google.gerrit.client.patches.HistoryTable.HistoryRadio b ) { if ( ( ! ( b.isChecked ( ) ) ) && ( b.isEnabled ( ) ) ) { for ( final com.google.gerrit.client.patches.HistoryTable.HistoryRadio a : all ) { if ( ( a.isChecked ( ) ) && ( a.getName ( ) . equals ( b.getName ( ) ) ) ) { a.setChecked ( false ) ; break ; } } b.setChecked ( true ) ; onClick ( b ) ; } }
void setExpandAllComments ( boolean b ) { for ( com.google.gerrit.client.diff.CommentGroup g : sideA.values ( ) ) { g.setOpenAll ( b ) ; } for ( com.google.gerrit.client.diff.CommentGroup g : sideB.values ( ) ) { g.setOpenAll ( b ) ; } }
public void testUpsertTwoNotExistsing ( ) throws com.google.gwtorm.client.OrmException , java.sql.SQLException { stubExecuteBatchOK ( com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE ) ; java.sql.PreparedStatement insert = stubExecuteBatchOK ( com.google.gwtorm.jdbc.TestJdbcAccess.INSERT , 1 , 1 ) ; createClassUnderTest ( ) . upsert ( com.google.gwtorm.jdbc.TestJdbcAccess.TWO_ROWS ) ; verifyIds ( insert , 1 , 2 ) ; }
private static void error ( final javax.servlet.http.HttpServletResponse resp , final int status , final java.lang.String message ) throws java.io.IOException { resp.setStatus ( status ) ; resp.setContentType ( ( "text/plain; charset=" + ( com.google.gwtjsonrpc.server.JsonServlet.ENC ) ) ) ; final java.io.Writer w = new java.io.OutputStreamWriter ( resp.getOutputStream ( ) , com.google.gwtjsonrpc.server.JsonServlet.ENC ) ; try { w.write ( message ) ; } finally { w.close ( ) ; } }
private void parseDelete ( final org.eclipse.jgit.transport.ReceiveCommand cmd ) { com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef ( cmd.getRefName ( ) ) ; if ( ctl.canDelete ( ) ) { cmd.execute ( rp ) ; } else { if ( GitRepositoryManager.REF_CONFIG.equals ( ctl.getRefName ( ) ) ) { reject ( cmd , "cannot delete project configuration" ) ; } else { errors.put ( com.google.gerrit.server.git.ReceiveCommits.Error.DELETE , ctl.getRefName ( ) ) ; reject ( cmd , "can not delete references" ) ; } } }
public com.google.gerrit.reviewdb.client.AccountSshKey create ( com.google.gerrit.reviewdb.client.AccountSshKey.Id id , java.lang.String encoded ) throws com.google.gerrit.common.errors.InvalidSshKeyException { try { com.google.gerrit.reviewdb.client.AccountSshKey key = new com.google.gerrit.reviewdb.client.AccountSshKey ( id , com.google.gerrit.sshd.SshUtil.toOpenSshPublicKey ( encoded ) ) ; com.google.gerrit.sshd.SshUtil.parse ( key ) ; return key ; } catch ( java.security.NoSuchAlgorithmException | java.security.spec.InvalidKeySpecException e ) { throw new com.google.gerrit.common.errors.InvalidSshKeyException ( ) ; } catch ( java.security.NoSuchProviderException e ) { com.google.gerrit.sshd.SshKeyCreatorImpl.log.error ( "Cannot parse SSH key" , e ) ; throw new com.google.gerrit.common.errors.InvalidSshKeyException ( ) ; } }
private void restoreSelection ( ) { if ( ( ( getFromTo ( ) ) != null ) && ( ( comment.in_reply_to ( ) ) == null ) ) { getCm ( ) . setSelection ( getFromTo ( ) . from ( ) , getFromTo ( ) . to ( ) ) ; } }
public static boolean compareCommitValidationMessage ( com.google.gerrit.server.git.validators.CommitValidationMessage msg1 , com.google.gerrit.server.git.validators.CommitValidationMessage msg2 ) { if ( ( msg1.getMessage ( ) . equals ( msg2.getMessage ( ) ) ) && ( ( msg1.isError ( ) ) == ( msg2.isError ( ) ) ) ) { return true ; } else { return false ; } }
public void postUpdate ( com.google.gerrit.server.git.BatchUpdate.Context ctx ) { if ( ( changeMessage ) == null ) { return ; } emailReviewers ( ctx.getProject ( ) , currChange , del , changeMessage ) ; try { hooks.doReviewerDeletedHook ( currChange , reviewer , currPs , changeMessage.getMessage ( ) , newApprovals , oldApprovals , dbProvider.get ( ) ) ; } catch ( com.google.gwtorm.server.OrmException e ) { com.google.gerrit.server.change.DeleteReviewer.log.warn ( "ChangeHook.doCommentAddedHook delivery failed" , e ) ; } }
public void onError ( com.google.gwt.http.client.Request req , java.lang.Throwable err ) { RpcStatus.INSTANCE.onRpcComplete ( ) ; if ( err.getMessage ( ) . contains ( "XmlHttpRequest.status" ) ) { cb.onFailure ( new com.google.gwt.user.client.rpc.StatusCodeException ( com.google.gerrit.client.rpc.RestApi.SC_UNAVAILABLE , RpcConstants.C.errorServerUnavailable ( ) ) ) ; } else { cb.onFailure ( new com.google.gwt.user.client.rpc.StatusCodeException ( com.google.gerrit.client.rpc.RestApi.SC_BAD_TRANSPORT , err.getMessage ( ) ) ) ; } }
private static void publish ( final com.google.gerrit.reviewdb.client.PatchSet.Id ps ) { java.lang.String token = com.google.gerrit.client.Dispatcher.toPublish ( ps ) ; new com.google.gerrit.client.Dispatcher.AsyncSplit ( token ) { public void onSuccess ( ) { com.google.gerrit.client.Gerrit.display ( token , select ( ) ) ; } private com.google.gerrit.client.ui.Screen select ( ) { return new com.google.gerrit.client.changes.PublishCommentScreen ( ps ) ; } } . onSuccess ( ) ; }
public void evictAfterRename ( final com.google.gerrit.reviewdb.client.AccountGroup.NameKey oldName , final com.google.gerrit.reviewdb.client.AccountGroup.NameKey newName ) { byName.remove ( oldName ) ; updateGroupList ( oldName , newName ) ; }
public int compare ( java.io.File a , java.io.File b ) { int cmp = java.lang.Long.compare ( b.lastModified ( ) , a.lastModified ( ) ) ; if ( cmp != 0 ) { return cmp ; } return a.getName ( ) . compareTo ( b.getName ( ) ) ; }
private java.lang.String url ( ) { if ( ( info.hasChangeNumber ( ) ) && ( info.hasRevisionNumber ( ) ) ) { return "#" + ( com.google.gerrit.common.PageLinks.toChange ( info.patchSetId ( ) ) ) ; } com.google.gerrit.client.info.GitwebInfo gw = com.google.gerrit.client.Gerrit.info ( ) . gitweb ( ) ; if ( ( gw != null ) && ( ( project ) != null ) ) { return gw.toRevision ( project , info.commit ( ) . commit ( ) ) ; } return null ; }
public void display ( final java.util.List < com.google.gerrit.client.reviewdb.Patch > list ) { final java.lang.StringBuilder nc = new java.lang.StringBuilder ( ) ; appendHeader ( nc ) ; for ( final com.google.gerrit.client.reviewdb.Patch p : list ) { appendRow ( nc , p ) ; } appendRow ( nc , null ) ; resetHtml ( nc.toString ( ) ) ; int row = 1 ; for ( final com.google.gerrit.client.reviewdb.Patch p : list ) { setRowItem ( ( row ++ ) , p ) ; } }
public void testCreate ( ) throws java.io.FileNotFoundException { final com.google.gerrit.server.config.SitePaths site = new com.google.gerrit.server.config.SitePaths ( new java.io.File ( "." ) ) ; final com.google.gerrit.pgm.util.ConsoleUI ui = org.easymock.EasyMock.createStrictMock ( com.google.gerrit.pgm.util.ConsoleUI.class ) ; org.easymock.EasyMock.replay ( ui ) ; com.google.gerrit.pgm.init.Libraries lib = new com.google.gerrit.pgm.init.Libraries ( new com.google.inject.Provider < com.google.gerrit.pgm.init.LibraryDownloader > ( ) { @ java.lang.Override public com.google.gerrit.pgm.init.LibraryDownloader get ( ) { return new com.google.gerrit.pgm.init.LibraryDownloader ( ui , site ) ; } } ) ; org.junit.Assert.assertNotNull ( lib.bouncyCastleProvider ) ; org.junit.Assert.assertNotNull ( lib.mysqlDriver ) ; org.easymock.EasyMock.verify ( ui ) ; }
public void createEdit ( org.eclipse.jgit.lib.Repository repository , com.google.gerrit.server.project.ChangeControl changeControl ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.server.project.InvalidChangeOperationException , com.google.gwtorm.server.OrmException , java.io.IOException { ensureAuthenticatedAndPermitted ( changeControl ) ; java.util.Optional < com.google.gerrit.server.edit.ChangeEdit > changeEdit = lookupChangeEdit ( changeControl ) ; if ( changeEdit.isPresent ( ) ) { throw new com.google.gerrit.server.project.InvalidChangeOperationException ( java.lang.String.format ( "A change edit already exists for change %s" , changeControl.getId ( ) ) ) ; } com.google.gerrit.reviewdb.client.PatchSet currentPatchSet = lookupCurrentPatchSet ( changeControl ) ; org.eclipse.jgit.lib.ObjectId patchSetCommitId = com.google.gerrit.server.edit.ChangeEditModifier.getPatchSetCommitId ( currentPatchSet ) ; createEdit ( repository , changeControl , currentPatchSet , patchSetCommitId , com.google.gerrit.common.TimeUtil.nowTs ( ) ) ; }
private static org.eclipse.jgit.lib.ObjectId resolveBlob ( com.google.gitiles.GitilesView view , org.eclipse.jgit.revwalk.RevWalk rw ) throws java.io.IOException { try { org.eclipse.jgit.treewalk.TreeWalk tw = org.eclipse.jgit.treewalk.TreeWalk.forPath ( rw.getObjectReader ( ) , view.getPathPart ( ) , rw.parseTree ( view.getRevision ( ) . getId ( ) ) ) ; if ( ( ( tw.getRawMode ( 0 ) ) & ( org.eclipse.jgit.lib.FileMode.TYPE_FILE ) ) == 0 ) { return null ; } return tw.getObjectId ( 0 ) ; } catch ( org.eclipse.jgit.errors.IncorrectObjectTypeException e ) { return null ; } }
private static boolean sameUpdate ( com.google.gerrit.server.notedb.ChangeRebuilder.Event event , com.google.gerrit.server.notedb.ChangeUpdate update ) { return ( ( ( update != null ) && ( ( com.google.gerrit.server.notedb.ChangeRebuilder.round ( event.when ) ) == ( com.google.gerrit.server.notedb.ChangeRebuilder.round ( update.getWhen ( ) ) ) ) ) && ( event.who.equals ( update.getUser ( ) . getAccountId ( ) ) ) ) && ( event.psId.equals ( update.getPatchSetId ( ) ) ) ; }
private com.google.gerrit.reviewdb.server.ReviewDb unwrapDb ( ) { com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.get ( ) ; if ( db instanceof com.google.gerrit.server.schema.DisabledChangesReviewDbWrapper ) { db = ( ( com.google.gerrit.server.schema.DisabledChangesReviewDbWrapper ) ( db ) ) . unsafeGetDelegate ( ) ; } return db ; }
private com.google.inject.Injector createSshInjector ( ) { final java.util.List < com.google.inject.Module > modules = new java.util.ArrayList < com.google.inject.Module > ( ) ; modules.add ( sysInjector.getInstance ( com.google.gerrit.sshd.SshModule.class ) ) ; modules.add ( new com.google.gerrit.sshd.commands.MasterCommandModule ( ) ) ; return sysInjector.createChildInjector ( modules ) ; }
protected void applyDataRowStyle ( final int row ) { super . applyDataRowStyle ( row ) ; final com.google.gwt.user.client.ui.HTMLTable.CellFormatter fmt = table.getCellFormatter ( ) ; fmt.addStyleName ( row , com.google.gerrit.client.changes.ChangeTable.C_STAR , com.google.gerrit.client.changes.S_ICON_CELL ) ; for ( int i = com.google.gerrit.client.changes.ChangeTable.C_ID ; i < ( com.google.gerrit.client.changes.ChangeTable.COLUMNS ) ; i ++ ) { fmt.addStyleName ( row , i , com.google.gerrit.client.changes.S_DATA_CELL ) ; } fmt.addStyleName ( row , com.google.gerrit.client.changes.ChangeTable.C_ID , com.google.gerrit.client.changes.ChangeTable.S_C_ID ) ; }
public void setUp ( ) throws java.lang.Exception { repo = new org.eclipse.jgit.junit.TestRepository ( repoManager.openRepository ( project ) ) ; com.google.gerrit.server.git.ProjectConfig pc = projectCache.checkedGet ( allProjects ) . getConfig ( ) ; for ( com.google.gerrit.common.data.AccessSection sec : pc.getAccessSections ( ) ) { sec.removePermission ( Permission.READ ) ; } saveProjectConfig ( allProjects , pc ) ; }
public boolean apply ( com.google.gerrit.server.project.ListBranches.BranchInfo in ) { if ( ! ( in.ref.startsWith ( Constants.R_HEADS ) ) ) { return a.run ( in.ref ) ; } else { return a.run ( in.ref.substring ( Constants.R_HEADS.length ( ) ) ) ; } }
private static java.lang.String getLabel ( com.google.gerrit.reviewdb.client.AccountGeneralPreferences.ChangeScreen ui ) { if ( ui == null ) { return "" ; } switch ( ui ) { case OLD_UI : return Util.C.changeScreenOldUi ( ) ; case CHANGE_SCREEN2 : return Util.C.changeScreenNewUi ( ) ; default : return ui.name ( ) ; } }
public void onSuccess ( com.google.gwt.core.client.JsArray < com.google.gerrit.client.change.ReviewerSuggestOracle.SuggestReviewerInfo > result ) { final java.util.List < com.google.gerrit.client.change.ReviewerSuggestOracle.RestReviewerSuggestion > r = new java.util.ArrayList ( result.length ( ) ) ; for ( final com.google.gerrit.client.change.ReviewerSuggestOracle.SuggestReviewerInfo reviewer : com.google.gerrit.client.rpc.Natives.asList ( result ) ) { r.add ( new com.google.gerrit.client.change.ReviewerSuggestOracle.RestReviewerSuggestion ( reviewer ) ) ; } callback.onSuggestionsReady ( req , new com.google.gerrit.client.change.Response ( r ) ) ; }
private com.google.gerrit.common.data.PermissionRule grant ( com.google.gerrit.server.git.ProjectConfig project , java.lang.String permissionName , com.google.gerrit.common.data.PermissionRule rule , java.lang.String ref ) { project.getAccessSection ( ref , true ) . getPermission ( permissionName , true ) . add ( rule ) ; return rule ; }
private static void deleteLocally ( org.eclipse.jgit.transport.URIish uri ) { try { com.googlesource.gerrit.plugins.replication.ReplicationQueue.recursivelyDelete ( new java.io.File ( uri.getPath ( ) ) ) ; } catch ( java.io.IOException e ) { com.googlesource.gerrit.plugins.replication.ReplicationQueue.repLog.error ( "Error deleting local repository {}:\n" , uri.getPath ( ) , e ) ; } }
protected void configure ( ) { factory ( AbandonChange.Factory.class ) ; factory ( ChangeDetailFactory.Factory.class ) ; factory ( IncludedInDetailFactory.Factory.class ) ; factory ( PatchSetDetailFactory.Factory.class ) ; factory ( PatchSetPublishDetailFactory.Factory.class ) ; factory ( SubmitAction.Factory.class ) ; }
private void initMode ( ) { mode.addItem ( "" , "" ) ; for ( java.util.Map.Entry < java.lang.String , java.lang.String > e : com.google.gerrit.client.diff.PreferencesBox.NAME_TO_MODE.entrySet ( ) ) { mode.addItem ( e.getKey ( ) , e.getValue ( ) ) ; } }
public com.google.gerrit.extensions.registration.DynamicMap < T > get ( ) { com.google.gerrit.extensions.registration.PrivateInternals_DynamicMapImpl < T > m = new com.google.gerrit.extensions.registration.PrivateInternals_DynamicMapImpl < T > ( ) ; java.util.List < com.google.inject.Binding < T > > bindings = injector.findBindingsByType ( type ) ; if ( bindings != null ) { for ( com.google.inject.Binding < T > b : bindings ) { m.put ( "gerrit" , b.getKey ( ) , b.getProvider ( ) ) ; } } return m ; }
com.googlesource.gerrit.plugins.findowners.OwnersDb get ( com.google.gerrit.server.account.AccountCache accountCache , com.google.gerrit.server.account.Emails emails , org.eclipse.jgit.lib.Repository repository , com.google.gerrit.server.query.change.ChangeData changeData , int patchset ) throws com.google.gwtorm.server.OrmException , java.io.IOException { com.google.gerrit.reviewdb.client.Project.NameKey project = changeData.change ( ) . getProject ( ) ; java.lang.String branch = changeData.change ( ) . getDest ( ) . get ( ) ; java.lang.String dbKey = com.googlesource.gerrit.plugins.findowners.Cache.makeKey ( changeData.getId ( ) . get ( ) , patchset , branch ) ; return get ( accountCache , emails , dbKey , repository , changeData , project , branch , changeData.currentFilePaths ( ) ) ; }
public void configure ( ) { factory ( ChangeUpdate.Factory.class ) ; factory ( ChangeDraftUpdate.Factory.class ) ; factory ( DraftCommentNotes.Factory.class ) ; factory ( NoteDbUpdateManager.Factory.class ) ; }
protected void configureServlets ( ) { install ( new com.google.gerrit.server.config.FactoryModule ( ) { @ java.lang.Override protected void configure ( ) { factory ( AgreementInfoFactory.Factory.class ) ; factory ( DeleteExternalIds.Factory.class ) ; factory ( ExternalIdDetailFactory.Factory.class ) ; } } ) ; rpc ( com.google.gerrit.httpd.rpc.account.AccountSecurityImpl.class ) ; rpc ( com.google.gerrit.httpd.rpc.account.AccountServiceImpl.class ) ; }
protected void doPost ( javax.servlet.http.HttpServletRequest req , javax.servlet.http.HttpServletResponse rsp ) { try { setHealthy ( ) ; rsp.setStatus ( javax.servlet.http.HttpServletResponse.SC_NO_CONTENT ) ; } catch ( java.io.IOException e ) { com.ericsson.gerrit.plugins.highavailability.health.HealthServlet.log.error ( "Failed to set healthy" , e ) ; sendError ( rsp , javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR ) ; } }
private static void validateLabels ( java.util.Set < java.lang.String > labels ) { if ( labels == null ) { return ; } java.util.SortedSet < java.lang.String > invalidLabels = new java.util.TreeSet < > ( ) ; for ( java.lang.String label : labels ) { if ( com.google.common.base.CharMatcher.WHITESPACE.matchesAnyOf ( label ) ) { invalidLabels.add ( label ) ; } } if ( ! ( invalidLabels.isEmpty ( ) ) ) { throw com.google.gerrit.server.StarredChangesUtil.IllegalLabelException.invalidLabels ( invalidLabels ) ; } }
private void addExtensionPoint ( com.google.gerrit.client.GerritUiExtensionPoint extensionPoint , com.google.gwt.user.client.ui.Panel p , com.google.gerrit.client.info.ChangeInfo change ) { com.google.gerrit.client.api.ExtensionPanel extensionPanel = new com.google.gerrit.client.api.ExtensionPanel ( extensionPoint ) ; extensionPanel.putObject ( GerritUiExtensionPoint.Key.CHANGE_INFO , change ) ; p.add ( extensionPanel ) ; }
private boolean isParent ( java.io.File parent , java.io.File child ) throws java.io.IOException { java.io.File p = parent.getCanonicalFile ( ) ; java.io.File c = child.getCanonicalFile ( ) ; for ( ; ; ) { c = c.getParentFile ( ) ; if ( c == null ) { return false ; } if ( c.equals ( p ) ) { return true ; } } }
public java.util.List < com.google.gerrit.extensions.common.ProjectInfo > apply ( com.google.gerrit.server.project.ProjectResource rsrc ) { if ( recursive ) { return getChildProjectsRecursively ( rsrc.getNameKey ( ) , rsrc.getControl ( ) . getCurrentUser ( ) ) ; } else { return getDirectChildProjects ( rsrc.getNameKey ( ) ) ; } }
private static com.google.common.collect.ImmutableListMultimap < com.google.gerrit.reviewdb.client.Project.NameKey , com.google.gerrit.server.query.change.ChangeData > byProject ( java.lang.Iterable < com.google.gerrit.server.query.change.ChangeData > changes ) throws com.google.gwtorm.server.OrmException { com.google.common.collect.ImmutableListMultimap.Builder < com.google.gerrit.reviewdb.client.Project.NameKey , com.google.gerrit.server.query.change.ChangeData > builder = new com.google.common.collect.ImmutableListMultimap.Builder < > ( ) ; for ( com.google.gerrit.server.query.change.ChangeData cd : changes ) { builder.put ( cd.change ( ) . getProject ( ) , cd ) ; } return builder.build ( ) ; }
public static com.google.gerrit.server.index.IndexConfig create ( int maxLimit , int maxPages , int maxTerms , int maxPrefixTerms ) { return new com.google.gerrit.server.index.AutoValue_IndexConfig ( com.google.gerrit.server.index.IndexConfig.checkLimit ( maxLimit , "maxLimit" , java.lang.Integer.MAX_VALUE ) , com.google.gerrit.server.index.IndexConfig.checkLimit ( maxPages , "maxPages" , java.lang.Integer.MAX_VALUE ) , com.google.gerrit.server.index.IndexConfig.checkLimit ( maxTerms , "maxTerms" , java.lang.Integer.MAX_VALUE ) , com.google.gerrit.server.index.IndexConfig.checkLimit ( maxPrefixTerms , "maxPrefixTerms" , com.google.gerrit.server.index.IndexConfig.DEFAULT_MAX_PREFIX_TERMS ) ) ; }
public java.lang.String newToken ( final java.lang.String user , final java.lang.String resource ) throws com.google.gwtjsonrpc.server.XsrfException { final byte [ ] buf = new byte [ tokenLength ] ; com.google.gwtjsonrpc.server.XsrfUtil.encodeInt ( buf , com.google.gwtjsonrpc.server.XsrfUtil.now ( ) ) ; computeToken ( buf , user , resource ) ; return com.google.gwtjsonrpc.server.XsrfUtil.encodeBase64 ( buf ) ; }
private com.google.gerrit.sshd.SshSession newSession ( ) { final java.net.SocketAddress peer ; if ( ( peerAddress ) == null ) { peer = session.get ( ) . getRemoteAddress ( ) ; } else { peer = peerAddress ; } return new com.google.gerrit.sshd.SshSession ( session.get ( ) , peer , userFactory.create ( peer , accountId ) ) ; }
public com.google.common.collect.ImmutableSet < com.google.gerrit.reviewdb.client.Branch.NameKey > getBranchesInOrder ( ) { return sortedBranches ; }
private com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > rewriteImpl ( com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > in , com.google.gerrit.server.index.QueryOptions opts ) throws com.google.gerrit.index.query.QueryParseException { com.google.gerrit.server.index.change.ChangeIndex index = indexes.getSearchIndex ( ) ; org.eclipse.jgit.util.MutableInteger leafTerms = new org.eclipse.jgit.util.MutableInteger ( ) ; com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > out = rewriteImpl ( in , index , opts , leafTerms ) ; if ( ( in == out ) || ( out instanceof com.google.gerrit.server.index.IndexPredicate ) ) { return new com.google.gerrit.server.index.change.IndexedChangeQuery ( index , out , opts ) ; } else if ( out == null ) { return in ; } else { return out ; } }
public void onFailure ( java.lang.Throwable caught ) { }
public void testAppend_double ( ) { final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder b = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder ( ) ; assertSame ( b , b.append ( 0.0 ) ) ; assertEquals ( "0.0" , b.asString ( ) ) ; }
private org.eclipse.jgit.revwalk.RevCommit getCurrentCommit ( com.google.gerrit.acceptance.PushOneCommit.Result change ) throws java.lang.Exception { testRepo.git ( ) . fetch ( ) . setRemote ( "origin" ) . call ( ) ; com.google.gerrit.extensions.common.ChangeInfo info = get ( change.getChangeId ( ) ) ; org.eclipse.jgit.revwalk.RevCommit c = testRepo.getRevWalk ( ) . parseCommit ( org.eclipse.jgit.lib.ObjectId.fromString ( info.currentRevision ) ) ; testRepo.getRevWalk ( ) . parseBody ( c ) ; return c ; }
static com.google.gerrit.server.query.change.ChangeData createForTest ( com.google.gerrit.reviewdb.client.Change.Id id ) { return new com.google.gerrit.server.query.change.ChangeData ( null , null , null , null , null , null , null , null , id ) ; }
, @ com.google.gerrit.acceptance.GerritConfig ( name = "suggest.from" , value = "1" ) , @ com.google.gerrit.acceptance.GerritConfig ( name = "accounts.visibility" , value = "NONE" ) } ) public void suggestReviewersNoResult2 ( ) throws java.io.IOException , java.lang.Exception , org.eclipse.jgit.api.errors.GitAPIException { java.lang.String changeId = createChange ( ) . getChangeId ( ) ; java.util.List < com.google.gerrit.server.change.SuggestReviewers.SuggestedReviewerInfo > reviewers = suggestReviewers ( changeId , "u" , 6 ) ; org.junit.Assert.assertEquals ( reviewers.size ( ) , 0 ) ; }
public void display ( final java.util.List < com.google.gerrit.reviewdb.client.Project > projects ) { while ( 1 < ( table.getRowCount ( ) ) ) table.removeRow ( ( ( table.getRowCount ( ) ) - 1 ) ) ; for ( final com.google.gerrit.reviewdb.client.Project k : projects ) insert ( table.getRowCount ( ) , k ) ; finishDisplay ( ) ; }
protected void onStarClick ( final int row ) { final com.google.gerrit.client.changes.ChangeInfo c = getRowItem ( row ) ; if ( ( c != null ) && ( com.google.gerrit.client.Gerrit.isSignedIn ( ) ) ) { com.google.gerrit.client.changes.ChangeCache.get ( c.legacy_id ( ) ) . getStarCache ( ) . toggleStar ( ) ; } }
public com.google.gerrit.server.plugins.InstallPlugin create ( com.google.gerrit.extensions.restapi.TopLevelResource parent , com.google.gerrit.extensions.restapi.IdString id ) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException , com.google.gerrit.extensions.restapi.ResourceNotFoundException { if ( ! ( loader.isRemoteAdminEnabled ( ) ) ) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException ( "remote installation is disabled" ) ; } return new com.google.gerrit.server.plugins.InstallPlugin ( loader , id.get ( ) , true ) ; }
private void display ( final com.google.gerrit.reviewdb.AccountGeneralPreferences p ) { showSiteHeader.setValue ( p.isShowSiteHeader ( ) ) ; useFlashClipboard.setValue ( p.isUseFlashClipboard ( ) ) ; copySelfOnEmails.setValue ( p.isCopySelfOnEmails ( ) ) ; setListBox ( maximumPageSize , com.google.gerrit.reviewdb.AccountGeneralPreferences.DEFAULT_PAGESIZE , p.getMaximumPageSize ( ) ) ; setListBox ( dateFormat , AccountGeneralPreferences.DateFormat.STD , p.getDateFormat ( ) ) ; setListBox ( timeFormat , AccountGeneralPreferences.TimeFormat.HHMM_12 , p.getTimeFormat ( ) ) ; }
protected com.google.gerrit.prettify.client.SparseHtmlFile getSparseHtmlFileA ( com.google.gerrit.common.data.PatchScript s ) { com.google.gerrit.reviewdb.client.AccountDiffPreference dp = new com.google.gerrit.reviewdb.client.AccountDiffPreference ( s.getDiffPrefs ( ) ) ; dp.setShowWhitespaceErrors ( false ) ; com.google.gerrit.prettify.client.PrettyFormatter f = ClientSideFormatter.FACTORY.get ( ) ; f.setDiffPrefs ( dp ) ; f.setFileName ( s.getA ( ) . getPath ( ) ) ; f.setEditFilter ( PrettyFormatter.A ) ; f.setEditList ( s.getEdits ( ) ) ; f.format ( s.getA ( ) ) ; return f ; }
public java.util.List < com.google.gerrit.server.notedb.ChangeNotes > scan ( org.eclipse.jgit.lib.Repository repo , com.google.gerrit.reviewdb.server.ReviewDb db , com.google.gerrit.reviewdb.client.Project.NameKey project ) throws com.google.gwtorm.server.OrmException , java.io.IOException { if ( ! ( migration.readChanges ( ) ) ) { return scanDb ( repo , db ) ; } return scanNotedb ( repo , db , project ) ; }
void onSave ( com.google.gwt.event.dom.client.ClickEvent e ) { com.google.gerrit.client.changes.ChangeFileApi.putContent ( id , file , message.getText ( ) . trim ( ) , new com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.client.VoidResult > ( ) { @ java.lang.Override public void onSuccess ( com.google.gerrit.client.VoidResult result ) { com.google.gerrit.client.Gerrit.display ( com.google.gerrit.common.PageLinks.toChange ( id.getParentKey ( ) ) ) ; hide ( ) ; } @ java.lang.Override public void onFailure ( java.lang.Throwable caught ) { } } ) ; }
public void testNonIndexPredicates ( ) throws java.lang.Exception { com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > in = parse ( "foo:a OR foo:b" ) ; com.google.common.truth.Truth.assertThat ( in ) . isEqualTo ( rewrite ( in ) ) ; }
private boolean authLogin ( java.lang.String smtpUser , java.lang.String smtpPass ) throws java.io.IOException , java.io.UnsupportedEncodingException { if ( ( sendCommand ( "AUTH" , "LOGIN" ) ) != 334 ) { return false ; } java.lang.String cmd = org.apache.commons.net.smtp.AuthSMTPClient.encodeBase64 ( smtpUser.getBytes ( org.apache.commons.net.smtp.AuthSMTPClient.UTF_8 ) ) ; if ( ( sendCommand ( cmd ) ) != 334 ) { return false ; } cmd = org.apache.commons.net.smtp.AuthSMTPClient.encodeBase64 ( smtpPass.getBytes ( org.apache.commons.net.smtp.AuthSMTPClient.UTF_8 ) ) ; return org.apache.commons.net.smtp.SMTPReply.isPositiveCompletion ( sendCommand ( cmd ) ) ; }
protected void configure ( ) { com.google.gerrit.extensions.registration.DynamicSet.bind ( binder ( ) , com.google.gerrit.server.validators.ProjectCreationValidationListener.class ) . to ( com.googlesource.gerrit.plugins.quota.MaxRepositoriesQuotaValidator.class ) ; com.google.gerrit.extensions.registration.DynamicSet.bind ( binder ( ) , com.google.gerrit.server.git.ReceivePackInitializer.class ) . to ( com.googlesource.gerrit.plugins.quota.MaxRepositorySizeQuota.class ) ; com.google.gerrit.extensions.registration.DynamicSet.bind ( binder ( ) , org.eclipse.jgit.transport.PostReceiveHook.class ) . to ( com.googlesource.gerrit.plugins.quota.MaxRepositorySizeQuota.class ) ; install ( com.googlesource.gerrit.plugins.quota.MaxRepositorySizeQuota.module ( ) ) ; }
com.googlesource.gerrit.plugins.cfoauth.AccessToken parseAccessTokenResponse ( java.lang.String tokenResponse ) throws com.googlesource.gerrit.plugins.cfoauth.UAAClientException { if ( com.google.common.base.Strings.isNullOrEmpty ( tokenResponse ) ) { throw new com.googlesource.gerrit.plugins.cfoauth.UAAClientException ( "Can't extract a token from an empty string" ) ; } com.google.gson.JsonObject json = getAsJsonObject ( tokenResponse ) ; java.lang.String accessToken = getAttribute ( json , com.googlesource.gerrit.plugins.cfoauth.UAAClient.ACCESS_TOKEN_ATTRIBUTE ) ; if ( accessToken == null ) { throw new com.googlesource.gerrit.plugins.cfoauth.UAAClientException ( "Can't extract a token: missing or invalid 'access_token' attribute" ) ; } return toAccessToken ( accessToken ) ; }
public void createEmptyEditRest ( ) throws java.lang.Exception { com.google.common.truth.Truth.assertThat ( adminSession.post ( urlEdit ( ) ) . getStatusCode ( ) ) . isEqualTo ( org.apache.http.HttpStatus.SC_NO_CONTENT ) ; com.google.common.base.Optional < com.google.gerrit.server.edit.ChangeEdit > edit = editUtil.byChange ( change ) ; com.google.gerrit.acceptance.edit.ChangeEditIT.assertByteArray ( fileUtil.getContent ( projectCache.get ( edit.get ( ) . getChange ( ) . getProject ( ) ) , org.eclipse.jgit.lib.ObjectId.fromString ( edit.get ( ) . getRevision ( ) . get ( ) ) , com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME ) , com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_OLD ) ; }
public final com.google.gerrit.gpg.CheckResult check ( org.bouncycastle.openpgp.PGPPublicKey key , com.google.gerrit.gpg.PublicKeyStore store ) { if ( ( trusted ) == null ) { return check ( key ) ; } else if ( store == null ) { throw new java.lang.IllegalArgumentException ( "PublicKeyStore required for web of trust checks" ) ; } return check ( key , store , 0 , true , new java.util.HashSet < com.google.gerrit.gpg.Fingerprint > ( ) ) ; }
public void run ( ) { for ( int i = 0 ; i < ( ( group.size ( ) ) - 1 ) ; i ++ ) { group.get ( i ) . setValue ( false , false ) ; } group.get ( ( ( group.size ( ) ) - 1 ) ) . setValue ( true , true ) ; }
private void merge ( com.google.gerrit.acceptance.PushOneCommit.Result r ) throws java.lang.Exception { revision ( r ) . review ( com.google.gerrit.extensions.api.changes.ReviewInput.approve ( ) ) ; revision ( r ) . submit ( ) ; try ( org.eclipse.jgit.lib.Repository repo = repoManager.openRepository ( project ) ) { com.google.common.truth.Truth.assertThat ( repo.exactRef ( "refs/heads/master" ) . getObjectId ( ) ) . isEqualTo ( r.getCommitId ( ) ) ; } }
public void run ( ) throws com.google.gerrit.sshd.commands.Failure { parseCommandLine ( ) ; boolean ok = true ; for ( com.google.gerrit.reviewdb.client.Change.Id changeId : changes ) { try { ok &= modifyOne ( changeId ) ; } catch ( java.lang.Exception err ) { ok = false ; com.google.gerrit.sshd.commands.SetReviewersCommand.log.error ( ( "Error updating reviewers on change " + changeId ) , err ) ; writeError ( "fatal" , ( "internal error while updating " + changeId ) ) ; } } if ( ! ok ) { throw com.google.gerrit.sshd.commands.SetReviewersCommand.error ( "fatal: one or more updates failed; review output above" ) ; } }
public void parseBranch ( ) throws java.lang.Exception { assertParseSucceeds ( ( "Update change\n" + ( ( ( "\n" + "Branch: refs/heads/master\n" ) + "Patch-Set: 1\n" ) + "Subject: This is a test change\n" ) ) ) ; assertParseSucceeds ( ( "Update change\n" + ( ( ( "\n" + "Branch: master\n" ) + "Patch-Set: 1\n" ) + "Subject: This is a test change\n" ) ) ) ; assertParseFails ( ( "Update change\n" + ( ( ( "\n" + "Patch-Set: 1\n" ) + "Branch: refs/heads/master\n" ) + "Branch: refs/heads/stable" ) ) ) ; }
public com.googlecode.prolog_cafe.lang.Operation exec ( com.googlecode.prolog_cafe.lang.Prolog engine ) throws com.googlecode.prolog_cafe.lang.PrologException { engine.cont = cont ; engine.setB0 ( ) ; com.vmware.gerrit.owners.common.PathOwners owners = OwnersStoredValues.PATH_OWNERS.get ( engine ) ; engine.areg1 = arg1 ; engine.areg2 = new com.googlecode.prolog_cafe.lang.JavaObjectTerm ( owners.get ( ) . keys ( ) . iterator ( ) ) ; return engine.jtry2 ( gerrit_owners.PRED_owner_path_1.OWNER_PATH_CHECK , gerrit_owners.PRED_owner_path_1.OWNER_PATH_NEXT ) ; }
private void configurePeerInfoSection ( ) { ui.header ( "PeerInfo section" ) ; promptAndSetString ( "Peer URL" , com.ericsson.gerrit.plugins.highavailability.PEER_INFO_SECTION , com.ericsson.gerrit.plugins.highavailability.URL_KEY , null ) ; }
private com.google.gerrit.server.git.TagSet rebuild ( org.eclipse.jgit.lib.Repository db , com.google.gerrit.server.git.TagSet old , com.google.gerrit.server.git.TagMatcher m ) { synchronized ( buildLock ) { com.google.gerrit.server.git.TagSet cur = this . tags ; if ( cur == old ) { cur = new com.google.gerrit.server.git.TagSet ( projectName ) ; cur.build ( db , old , m ) ; this . tags = cur ; } return cur ; } }
void display ( final java.util.List < com.google.gerrit.client.reviewdb.Project > result ) { while ( 1 < ( table.getRowCount ( ) ) ) table.removeRow ( ( ( table.getRowCount ( ) ) - 1 ) ) ; for ( final com.google.gerrit.client.reviewdb.Project k : result ) { final int row = table.getRowCount ( ) ; table.insertRow ( row ) ; populate ( row , k ) ; } }
private com.google.gwt.user.client.Element getRow ( com.google.gwt.user.client.Element e ) { for ( com.google.gwt.user.client.Element prev = e ; e != null ; prev = e ) { if ( ( e = com.google.gwt.user.client.DOM.getParent ( e ) ) == ( body ) ) { return prev ; } } return null ; }
private void padLineNumber ( final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder m , boolean isForTableHeader , boolean isForSideA ) { m.openTd ( ) ; m.setStyleName ( Gerrit.RESOURCES.css ( ) . lineNumber ( ) ) ; if ( isForTableHeader ) { m.addStyleName ( Gerrit.RESOURCES.css ( ) . fileColumnHeader ( ) ) ; } if ( isForSideA ) { m.addStyleName ( Gerrit.RESOURCES.css ( ) . rightBorder ( ) ) ; } m.closeTd ( ) ; }
public void setUp ( ) throws java.lang.Exception { index = new com.google.gerrit.server.index.change.FakeChangeIndex ( FakeChangeIndex.V2 ) ; indexes = new com.google.gerrit.server.index.change.ChangeIndexCollection ( ) ; indexes.setSearchIndex ( index ) ; queryBuilder = new com.google.gerrit.server.index.change.FakeQueryBuilder ( indexes ) ; rewrite = new com.google.gerrit.server.index.change.ChangeIndexRewriter ( indexes , com.google.gerrit.server.index.IndexConfig.create ( 0 , 0 , 3 ) ) ; }
public void addAllReviewers ( com.google.gerrit.server.data.ChangeAttribute a , com.google.gerrit.reviewdb.client.Change change ) throws com.google.gwtorm.server.OrmException { java.util.Collection < com.google.gerrit.reviewdb.client.Account.Id > reviewers = approvalsUtil.getReviewers ( db.get ( ) , change.getId ( ) ) . values ( ) ; if ( ! ( reviewers.isEmpty ( ) ) ) { a.allReviewers = com.google.common.collect.Lists.newArrayListWithCapacity ( reviewers.size ( ) ) ; for ( com.google.gerrit.reviewdb.client.Account.Id id : reviewers ) { a.allReviewers.add ( asAccountAttribute ( id ) ) ; } } }
public void setUp ( ) { listenerMock = createMock ( com.google.gerrit.common.EventListener.class ) ; com.google.gerrit.extensions.registration.DynamicSet < com.google.gerrit.common.EventListener > listeners = com.google.gerrit.extensions.registration.DynamicSet.emptySet ( ) ; listeners.add ( listenerMock ) ; broker = new com.ericsson.gerrit.plugins.syncevents.SyncEventBroker ( null , listeners , null , null , null ) ; }
private com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DownloadScheme getSelectedScheme ( ) { java.lang.String id = scheme.getValue ( scheme.getSelectedIndex ( ) ) ; if ( "git" . equals ( id ) ) { return com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DownloadScheme.ANON_GIT ; } else if ( "http" . equals ( id ) ) { return com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DownloadScheme.HTTP ; } else if ( "ssh" . equals ( id ) ) { return com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DownloadScheme.SSH ; } return null ; }
private com.google.common.collect.SetMultimap < org.eclipse.jgit.lib.ObjectId , org.eclipse.jgit.lib.Ref > changeRefsById ( ) { if ( ( refsById ) == null ) { refsById = com.google.common.collect.HashMultimap.create ( ) ; for ( org.eclipse.jgit.lib.Ref r : refsByChange ( ) . values ( ) ) { refsById.put ( r.getObjectId ( ) , r ) ; } } return refsById ; }
private static java.util.Set < com.google.gerrit.client.reviewdb.AccountGroup.Id > ids ( final java.util.Collection < com.google.gerrit.client.reviewdb.AccountGroup > groupList ) { final java.util.HashSet < com.google.gerrit.client.reviewdb.AccountGroup.Id > r = new java.util.HashSet < com.google.gerrit.client.reviewdb.AccountGroup.Id > ( ) ; for ( final com.google.gerrit.client.reviewdb.AccountGroup group : groupList ) { r.add ( group.getId ( ) ) ; } return r ; }
public java.util.Collection < com.google.gerrit.common.data.AccessSection > getAllAccessSections ( ) { java.util.List < com.google.gerrit.common.data.AccessSection > all = new java.util.ArrayList < com.google.gerrit.common.data.AccessSection > ( ) ; all.addAll ( getLocalAccessSections ( ) ) ; all.addAll ( getInheritedAccessSections ( ) ) ; return all ; }
public static void assertProjectOwners ( java.util.Set < com.google.gerrit.reviewdb.client.AccountGroup.UUID > expectedOwners , com.google.gerrit.server.project.ProjectState state ) { for ( com.google.gerrit.reviewdb.client.AccountGroup.UUID g : state.getOwners ( ) ) { com.google.common.truth.Truth.assertThat ( expectedOwners.remove ( g ) ) . isTrue ( ) ; } com.google.common.truth.Truth.assertThat ( expectedOwners ) . isEmpty ( ) ; }
public com.google.gerrit.server.project.ChildProjectResource parse ( com.google.gerrit.server.project.ProjectResource parent , com.google.gerrit.extensions.restapi.IdString id ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.permissions.PermissionBackendException , java.io.IOException { com.google.gerrit.server.project.ProjectResource p = projectsCollection.parse ( TopLevelResource.INSTANCE , id ) ; for ( com.google.gerrit.server.project.ProjectState pp : p.getProjectState ( ) . parents ( ) ) { if ( parent.getNameKey ( ) . equals ( pp.getProject ( ) . getNameKey ( ) ) ) { return new com.google.gerrit.server.project.ChildProjectResource ( parent , p.getProjectState ( ) ) ; } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException ( id ) ; }
public java.lang.Iterable < com.google.gerrit.extensions.common.WebLinkInfo > getFileLinks ( java.lang.String project , java.lang.String revision , java.lang.String file ) { java.util.List < com.google.gerrit.extensions.common.WebLinkInfo > links = com.google.common.collect.Lists.newArrayList ( ) ; for ( com.google.gerrit.extensions.webui.FileWebLink webLink : fileLinks ) { links.add ( new com.google.gerrit.extensions.common.WebLinkInfo ( webLink.getLinkName ( ) , webLink.getImageUrl ( ) , webLink.getFileUrl ( project , revision , file ) , webLink.getTarget ( ) ) ) ; } return links ; }
public void testAppend_String ( ) { final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder b = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder ( ) ; org.junit.Assert.assertSame ( b , b.append ( ( ( java.lang.String ) ( null ) ) ) ) ; org.junit.Assert.assertEquals ( "" , b.asString ( ) ) ; org.junit.Assert.assertSame ( b , b.append ( "foo" ) ) ; org.junit.Assert.assertSame ( b , b.append ( "bar" ) ) ; org.junit.Assert.assertEquals ( "foobar" , b.asString ( ) ) ; }
public com.google.gerrit.server.change.Description getDescription ( com.google.gerrit.server.change.ChangeResource rsrc ) { com.google.gerrit.reviewdb.client.Change change = rsrc.getChange ( ) ; return new com.google.gerrit.extensions.webui.UiAction.Description ( ) . setLabel ( "Mark private" ) . setTitle ( "Mark change as private" ) . setVisible ( ( ( ( ! ( change.isPrivate ( ) ) ) && ( ( change.getStatus ( ) ) != ( Change.Status.MERGED ) ) ) && ( canSetPrivate ( rsrc ) ) ) ) ; }
public void setUp ( ) throws java.lang.Exception { admin2 = accounts.admin2 ( ) ; com.google.gerrit.extensions.api.groups.GroupInput gi = new com.google.gerrit.extensions.api.groups.GroupInput ( ) ; gi.name = name ( "New-Group" ) ; gi.members = com.google.common.collect.ImmutableList.of ( user.id.toString ( ) ) ; newGroup = gApi.groups ( ) . create ( gi ) . get ( ) ; }
private void initProviderBouncyCastle ( org.eclipse.jgit.lib.Config cfg ) { setKeyExchangeFactories ( java.util.Arrays.< org.apache.sshd.common.NamedFactory < org.apache.sshd.common.KeyExchange > > asList ( new org.apache.sshd.server.kex.DHG14.Factory ( ) , new org.apache.sshd.server.kex.DHG1.Factory ( ) ) ) ; org.apache.sshd.common.NamedFactory < org.apache.sshd.common.Random > factory ; if ( cfg.getBoolean ( "sshd" , null , "testUseInsecureRandom" , false ) ) { factory = new com.google.gerrit.sshd.SshDaemon.InsecureBouncyCastleRandom.Factory ( ) ; } else { factory = new org.apache.sshd.common.random.BouncyCastleRandom.Factory ( ) ; } setRandomFactory ( new org.apache.sshd.common.random.SingletonRandomFactory ( factory ) ) ; }
public void testThreeLevelTreeWithSomeIndexPredicates ( ) throws java.lang.Exception { com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > in = parse ( "-foo:a (file:b OR file:c)" ) ; com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > out = rewrite ( in ) ; com.google.common.truth.Truth.assertThat ( out.getClass ( ) ) . isSameAs ( com.google.gerrit.server.query.change.AndSource.class ) ; com.google.common.truth.Truth.assertThat ( out.getChildren ( ) ) . containsExactly ( query ( in.getChild ( 1 ) ) , in.getChild ( 0 ) ) . inOrder ( ) ; }
public com.google.gerrit.common.data.Capable canPushToAtLeastOneRef ( ) { if ( ( ! ( canPerformOnAnyRef ( Permission.PUSH ) ) ) && ( ! ( canPerformOnAnyRef ( Permission.CREATE_TAG ) ) ) ) { java.lang.String pName = state.getProject ( ) . getName ( ) ; return new com.google.gerrit.common.data.Capable ( ( ( "Upload denied for project '" + pName ) + "'" ) ) ; } if ( state.isUseContributorAgreements ( ) ) { return verifyActiveContributorAgreement ( ) ; } return com.google.gerrit.common.data.Capable.OK ; }
public void onShowView ( ) { super . onShowView ( ) ; java.lang.String prior = com.google.gerrit.client.Gerrit.getPriorView ( ) ; if ( ( prior != null ) && ( prior.startsWith ( "/c/" ) ) ) { scrollToPath ( prior.substring ( 3 ) ) ; } }
public boolean get ( ) { com.google.gerrit.common.data.ChangeDetail detail = cache.getChangeDetailCache ( ) . get ( ) ; if ( detail != null ) { return detail.isStarred ( ) ; } return false ; }
public void add ( com.google.gerrit.lifecycle.LifecycleListener listener ) { manager.add ( listener ) ; }
private java.util.Set < com.google.gerrit.reviewdb.client.Account > listAccounts ( final com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID , final com.google.gerrit.reviewdb.client.Project.NameKey project , final java.util.Set < com.google.gerrit.reviewdb.client.AccountGroup.UUID > seen ) throws com.google.gerrit.common.errors.NoSuchGroupException , com.google.gerrit.server.project.NoSuchProjectException , com.google.gwtorm.server.OrmException , java.io.IOException { if ( AccountGroup.PROJECT_OWNERS.equals ( groupUUID ) ) { return getProjectOwners ( project , seen ) ; } else { com.google.gerrit.reviewdb.client.AccountGroup group = groupCache.get ( groupUUID ) ; if ( group != null ) { return getGroupMembers ( group , project , seen ) ; } else { return java.util.Collections.emptySet ( ) ; } } }
public java.util.List < com.google.gerrit.extensions.common.ProjectInfo > list ( com.google.gerrit.reviewdb.client.Project.NameKey parent ) throws com.google.gerrit.server.permissions.PermissionBackendException { java.util.Map < com.google.gerrit.reviewdb.client.Project.NameKey , com.google.gerrit.reviewdb.client.Project > projects = readAllProjects ( ) ; com.google.common.collect.Multimap < com.google.gerrit.reviewdb.client.Project.NameKey , com.google.gerrit.reviewdb.client.Project.NameKey > children = parentToChildren ( projects ) ; com.google.gerrit.server.permissions.PermissionBackend.WithUser perm = permissionBackend.currentUser ( ) ; java.util.List < com.google.gerrit.extensions.common.ProjectInfo > results = new java.util.ArrayList < > ( ) ; depthFirstFormat ( results , perm , projects , children , parent ) ; return results ; }
public static java.util.Set < com.google.gerrit.client.reviewdb.Change.Id > starredBy ( final com.google.gerrit.client.reviewdb.ReviewDb db , final com.google.gerrit.client.reviewdb.Account.Id me ) throws com.google.gwtorm.client.OrmException { final java.util.Set < com.google.gerrit.client.reviewdb.Change.Id > existing = new java.util.HashSet < com.google.gerrit.client.reviewdb.Change.Id > ( ) ; if ( me != null ) { for ( final com.google.gerrit.client.reviewdb.StarredChange sc : db.starredChanges ( ) . byAccount ( me ) ) { existing.add ( sc.getChangeId ( ) ) ; } } return existing ; }
private com.google.gerrit.client.diff.DraftBox newRangeDraft ( net.codemirror.lib.CodeMirror cm , int line , net.codemirror.lib.TextMarker.FromTo fromTo ) { com.google.gerrit.client.diff.DisplaySide side = cm.side ( ) ; return addDraftBox ( com.google.gerrit.client.changes.CommentInfo.createRange ( path , getStoredSideFromDisplaySide ( side ) , ( line + 1 ) , null , null , com.google.gerrit.client.diff.CommentRange.create ( fromTo ) ) , side ) ; }
public void setExisting_Conflict ( ) throws java.lang.Exception { com.google.gerrit.server.account.PutUsername.Input in = new com.google.gerrit.server.account.PutUsername.Input ( ) ; in.username = admin.username ; adminRestSession.put ( ( ( "/accounts/" + ( accountCreator.create ( ) . id.get ( ) ) ) + "/username" ) , in ) . assertConflict ( ) ; }
boolean match ( final java.security.PublicKey inkey ) { return publicKey.equals ( inkey ) ; }
void schedule ( final com.google.gerrit.client.reviewdb.Project.NameKey project , final java.lang.String ref , final org.spearce.jgit.transport.URIish uri ) { synchronized ( pending ) { com.google.gerrit.git.PushOp e = pending.get ( uri ) ; if ( e == null ) { e = new com.google.gerrit.git.PushOp ( this , project.get ( ) , remote , uri ) ; injector.injectMembers ( e ) ; pool.schedule ( e , delay , java.util.concurrent.TimeUnit.SECONDS ) ; pending.put ( uri , e ) ; } e.addRef ( ref ) ; } }
public void defaultMessage ( ) throws java.lang.Exception { java.lang.String changeId = createChange ( ) . getChangeId ( ) ; com.google.gerrit.extensions.common.ChangeInfo c = get ( changeId ) ; org.junit.Assert.assertNotNull ( c.messages ) ; org.junit.Assert.assertEquals ( 1 , c.messages.size ( ) ) ; org.junit.Assert.assertEquals ( "Uploaded patch set 1." , c.messages.iterator ( ) . next ( ) . message ) ; }
public com.google.gerrit.server.group.GroupJson.GroupInfo format ( com.google.gerrit.common.data.GroupDescription.Basic group ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.group.GroupJson.GroupInfo info = init ( group ) ; if ( ( options.contains ( com.google.gerrit.common.groups.ListGroupsOption.MEMBERS ) ) || ( options.contains ( com.google.gerrit.common.groups.ListGroupsOption.INCLUDES ) ) ) { com.google.gerrit.server.group.GroupResource rsrc = new com.google.gerrit.server.group.GroupResource ( groupControlFactory.controlFor ( group ) ) ; initMembersAndIncludes ( rsrc , info ) ; } return info ; }
public void withValidGroupName ( ) throws java.lang.Exception { java.lang.String newGroupName = "newGroup" ; adminRestSession.put ( ( "/groups/" + newGroupName ) ) ; java.lang.String newProjectName = "newProject" ; adminSshSession.exec ( ( ( ( "gerrit create-project --branch master --owner " + newGroupName ) + " " ) + newProjectName ) ) ; com.google.common.truth.Truth.assert_ ( ) . withFailureMessage ( adminSshSession.getError ( ) ) . that ( adminSshSession.hasError ( ) ) . isFalse ( ) ; com.google.gerrit.server.project.ProjectState projectState = projectCache.get ( new com.google.gerrit.reviewdb.client.Project.NameKey ( newProjectName ) ) ; com.google.common.truth.Truth.assertThat ( projectState ) . isNotNull ( ) ; }
com.ericsson.gerrit.plugins.eventslog.sql.SQLClient provideLocalSqlClient ( com.ericsson.gerrit.plugins.eventslog.EventsLogConfig cfg ) { com.ericsson.gerrit.plugins.eventslog.sql.SQLClient sqlClient ; }
public void parseAuthor ( ) throws java.lang.Exception { assertParseSucceeds ( ( "Update change\n" + ( ( ( ( "\n" + "Branch: refs/heads/master\n" ) + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" ) + "Patch-Set: 1\n" ) + "Subject: This is a test change\n" ) ) ) ; assertParseFails ( writeCommit ( ( "Update change\n" + ( "\n" + "Patch-Set: 1\n" ) ) , new org.eclipse.jgit.lib.PersonIdent ( "Change Owner" , "owner@example.com" , serverIdent.getWhen ( ) , serverIdent.getTimeZone ( ) ) ) ) ; assertParseFails ( writeCommit ( ( "Update change\n" + ( "\n" + "Patch-Set: 1\n" ) ) , new org.eclipse.jgit.lib.PersonIdent ( "Change Owner" , "x@gerrit" , serverIdent.getWhen ( ) , serverIdent.getTimeZone ( ) ) ) ) ; }
protected void configure ( ) { install ( new com.google.inject.assistedinject.FactoryModuleBuilder ( ) . implement ( com.google.gerrit.server.index.group.GroupIndex.class , com.google.gerrit.lucene.LuceneGroupIndex.class ) . build ( GroupIndex.Factory.class ) ) ; install ( new com.google.gerrit.pgm.init.index.IndexModuleOnInit ( ) ) ; }
public void testUnblockForce ( ) { com.google.gerrit.common.data.PermissionRule r = com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/heads/*" ) ; r.setBlock ( ) ; r.setForce ( true ) ; com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.Util.DEVS , "refs/heads/*" ) . setForce ( true ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.project.Util.DEVS ) ; org.junit.Assert.assertTrue ( "u can force push" , u.controlForRef ( "refs/heads/master" ) . canForceUpdate ( ) ) ; }
public void setUp ( ) throws java.lang.Exception { super . setUp ( ) ; schemaFactory = org.easymock.EasyMock.createStrictMock ( com.google.gwtorm.server.SchemaFactory.class ) ; schema = org.easymock.EasyMock.createStrictMock ( com.google.gerrit.reviewdb.server.ReviewDb.class ) ; subscriptions = org.easymock.EasyMock.createStrictMock ( com.google.gerrit.reviewdb.server.SubmoduleSubscriptionAccess.class ) ; urlProvider = org.easymock.EasyMock.createStrictMock ( com.google.inject.Provider.class ) ; repoManager = org.easymock.EasyMock.createStrictMock ( com.google.gerrit.server.git.GitRepositoryManager.class ) ; replication = org.easymock.EasyMock.createStrictMock ( com.google.gerrit.server.git.ReplicationQueue.class ) ; }
public void testPostResponseOK ( ) throws java.lang.Exception { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.wireMockRule.givenThat ( com.github.tomakehurst.wiremock.client.WireMock.post ( com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo ( com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.ENDPOINT ) ) . willReturn ( com.github.tomakehurst.wiremock.client.WireMock.aResponse ( ) . withStatus ( com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.OK ) ) ) ; com.google.common.truth.Truth.assertThat ( httpSession.post ( com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.ENDPOINT ) . isSuccessful ( ) ) . isTrue ( ) ; }
private java.lang.String createServiceUserNote ( java.lang.String branch , com.googlesource.gerrit.plugins.serviceuser.GetServiceUser.ServiceUserInfo serviceUser ) throws com.google.gwtorm.server.OrmException { com.googlesource.gerrit.plugins.serviceuser.HeaderFormatter fmt = new com.googlesource.gerrit.plugins.serviceuser.HeaderFormatter ( gerritServerIdent.getTimeZone ( ) , anonymousCowardName ) ; fmt.appendDate ( ) ; fmt.append ( "Project" , project.get ( ) ) ; fmt.append ( "Branch" , branch ) ; fmt.appendUser ( com.googlesource.gerrit.plugins.serviceuser.CreateServiceUser.KEY_CREATED_BY , serviceUser.createdBy ) ; for ( com.google.gerrit.server.account.AccountInfo owner : listOwners ( serviceUser ) ) { fmt.appendUser ( com.googlesource.gerrit.plugins.serviceuser.CreateServiceUser.KEY_OWNER , owner ) ; } return fmt.toString ( ) ; }
protected void configure ( ) { com.google.gerrit.extensions.registration.DynamicSet.bind ( binder ( ) , com.google.gerrit.common.ChangeListener.class ) . to ( com.googlesource.gerrit.plugins.reviewers.ChangeEventListener.class ) ; factory ( DefaultReviewers.Factory.class ) ; bind ( com.google.gerrit.server.config.ProjectConfigEntry.class ) . annotatedWith ( com.google.gerrit.extensions.annotations.Exports.named ( "reviewer" ) ) . toInstance ( new com.google.gerrit.server.config.ProjectConfigEntry ( "Reviewers" , null , ProjectConfigEntry.Type.ARRAY , null , false , "Users or groups can be provided as reviewers" ) ) ; }
private static void sendError ( javax.servlet.http.HttpServletResponse rsp , int statusCode , java.lang.String message ) { try { rsp.sendError ( statusCode , message ) ; } catch ( java.io.IOException e ) { com.ericsson.gerrit.plugins.syncevents.SyncEventsRestApiServlet.logger.error ( ( "Failed to send error messsage: " + ( e.getMessage ( ) ) ) , e ) ; } }
protected void rcptToAuthors ( final com.google.gerrit.server.mail.RecipientType rt ) { add ( rt , change.getOwner ( ) ) ; if ( ( patchSet ) != null ) { add ( rt , patchSet.getUploader ( ) ) ; } if ( ( patchSetInfo ) != null ) { add ( rt , patchSetInfo.getAuthor ( ) ) ; add ( rt , patchSetInfo.getCommitter ( ) ) ; } }
public void testUnblockForceWithAllowNoForce_NotPossible ( ) { com.google.gerrit.common.data.PermissionRule r = com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.Util.ANONYMOUS , "refs/heads/*" ) ; r.setBlock ( ) ; r.setForce ( true ) ; com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.Util.DEVS , "refs/heads/*" ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.project.Util.DEVS ) ; org.junit.Assert.assertFalse ( "u can't force push" , u.controlForRef ( "refs/heads/master" ) . canForceUpdate ( ) ) ; }
public void onSuccess ( com.google.gerrit.client.changes.ChangeInfo info ) { info.revisions ( ) . copyKeysIntoChildren ( "name" ) ; com.google.gwt.core.client.JsArray < com.google.gerrit.client.changes.ChangeInfo.RevisionInfo > list = info.revisions ( ) . values ( ) ; com.google.gerrit.client.changes.ChangeInfo.RevisionInfo.sortRevisionInfoByNumber ( list ) ; diffTable.setUpPatchSetNav ( list , diff ) ; header.set ( info ) ; }
public void keyRevokedByExpiredKeyAfterExpirationIsNotRevoked ( ) throws java.lang.Exception { com.google.gerrit.gpg.testutil.TestKey k = add ( com.google.gerrit.gpg.testutil.TestKeys.keyRevokedByExpiredKeyAfterExpiration ( ) ) ; add ( com.google.gerrit.gpg.testutil.TestKeys.expiredKey ( ) ) ; save ( ) ; com.google.gerrit.gpg.PublicKeyChecker checker = new com.google.gerrit.gpg.PublicKeyChecker ( ) . setStore ( store ) ; assertNoProblems ( checker , k ) ; }
public void inheritRead_AppendWithDenyOfRef ( ) { com.google.gerrit.server.project.Util.allow ( parent , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS , "refs/*" ) ; com.google.gerrit.server.project.Util.deny ( local , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS , "refs/heads/*" ) ; com.google.gerrit.server.project.ProjectControl u = user ( local ) ; assertCanRead ( u ) ; assertCanRead ( "refs/master" , u ) ; assertCanRead ( "refs/tags/foobar" , u ) ; assertCanRead ( "refs/heads/master" , u ) ; }
private com.google.gerrit.server.mail.Address toAddress ( final com.google.gerrit.client.reviewdb.Account.Id id ) { final com.google.gerrit.client.reviewdb.Account a = com.google.gerrit.client.rpc.Common.getAccountCache ( ) . get ( id ) ; if ( a == null ) { return null ; } final java.lang.String e = a.getPreferredEmail ( ) ; if ( e == null ) { return null ; } return new com.google.gerrit.server.mail.Address ( a.getFullName ( ) , e ) ; }
public int weigh ( com.google.gerrit.server.patch.PatchListKey key , com.google.gerrit.server.patch.PatchList value ) { int size = ( ( ( ( ( ( 16 + ( 4 * 8 ) ) + ( 2 * 36 ) ) + 8 ) + 16 ) + ( 3 * 8 ) ) + ( 3 * 4 ) ) + 20 ; for ( com.google.gerrit.server.patch.PatchListEntry e : value.getPatches ( ) ) { size += e.weigh ( ) ; } return size ; }
private com.google.gerrit.reviewdb.client.Change newChange ( ) { com.google.gerrit.reviewdb.client.Change.Id changeId = new com.google.gerrit.reviewdb.client.Change.Id ( 1 ) ; com.google.gerrit.reviewdb.client.Change c = new com.google.gerrit.reviewdb.client.Change ( new com.google.gerrit.reviewdb.client.Change.Key ( "Iabcd1234abcd1234abcd1234abcd1234abcd1234" ) , changeId , changeOwner.getAccount ( ) . getId ( ) , new com.google.gerrit.reviewdb.client.Branch.NameKey ( project , "master" ) , com.google.gerrit.server.util.TimeUtil.nowTs ( ) ) ; com.google.gerrit.server.notedb.ChangeNotesTest.incrementPatchSet ( c ) ; return c ; }
private void appendHunkHeader ( final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder m , final com.google.gerrit.common.data.EditList.Hunk hunk ) { openLine ( m ) ; padLineNumber ( m ) ; padLineNumber ( m ) ; m.openTd ( ) ; m.addStyleName ( "DiffText" ) ; m.addStyleName ( "DiffText-HUNK_HEADER" ) ; m.append ( "@@ -" ) ; appendRange ( m , ( ( hunk.getCurA ( ) ) + 1 ) , ( ( hunk.getEndA ( ) ) - ( hunk.getCurA ( ) ) ) ) ; m.append ( " +" ) ; appendRange ( m , ( ( hunk.getCurB ( ) ) + 1 ) , ( ( hunk.getEndB ( ) ) - ( hunk.getCurB ( ) ) ) ) ; m.append ( " @@" ) ; m.closeTd ( ) ; closeLine ( m ) ; }
public com.googlesource.gerrit.plugins.hooks.its.ItsIssue getIssue ( final java.lang.String bugId ) throws java.io.IOException { return execute ( new java.util.concurrent.Callable < com.googlesource.gerrit.plugins.hooks.its.ItsIssue > ( ) { @ java.lang.Override public com.googlesource.gerrit.plugins.hooks.its.ItsIssue call ( ) throws java.lang.Exception { com.j2bugzilla.base.Bug bug = client ( ) . getBug ( bugId ) ; com.googlesource.gerrit.plugins.hooks.its.ItsIssue result = ( bug == null ) ? null : new com.googlesource.gerrit.plugins.hooks.its.ItsIssue ( bugId , bug ) ; log.debug ( ( ( ( "Got issue " + bugId ) + ", " ) + result ) ) ; return result ; } } ) ; }
private static void initLogSystem ( java.io.File logdir ) { org.apache.log4j.Logger gcLogger = org.apache.log4j.LogManager.getLogger ( GarbageCollection.LOG_NAME ) ; gcLogger.removeAllAppenders ( ) ; gcLogger.addAppender ( com.google.gerrit.server.util.SystemLog.createAppender ( logdir , GarbageCollection.LOG_NAME , new org.apache.log4j.PatternLayout ( "[%d] %-5p %x: %m%n" ) ) ) ; gcLogger.setAdditivity ( false ) ; }
private void login ( javax.servlet.ServletRequest request , javax.servlet.http.HttpServletRequest httpRequest , javax.servlet.http.HttpServletResponse httpResponse , com.googlesource.gerrit.plugins.github.oauth.GitHubLogin ghLogin ) throws java.io.IOException { if ( ghLogin.login ( httpRequest , httpResponse ) ) { org.kohsuke.github.GHMyself myself = ghLogin.getMyself ( ) ; java.lang.String user = myself.getLogin ( ) ; updateSecureConfigWithRetry ( ghLogin.hub.getMyOrganizations ( ) . keySet ( ) , user , ghLogin.token.accessToken ) ; } }
public static synchronized int getSshdPort ( ) { return ( com.google.gerrit.server.ssh.GerritSshDaemon.sshd ) != null ? com.google.gerrit.server.ssh.GerritSshDaemon.sshd.getPort ( ) : 0 ; }
public void setUp ( ) throws java.lang.Exception { index = new com.google.gerrit.server.index.change.FakeChangeIndex ( FakeChangeIndex.V2 ) ; indexes = new com.google.gerrit.server.index.change.ChangeIndexCollection ( ) ; indexes.setSearchIndex ( index ) ; queryBuilder = new com.google.gerrit.server.index.change.FakeQueryBuilder ( indexes ) ; rewrite = new com.google.gerrit.server.index.change.ChangeIndexRewriter ( indexes , com.google.gerrit.server.index.IndexConfig.builder ( ) . maxTerms ( 3 ) . build ( ) ) ; }
public com.google.gerrit.server.group.GroupJson.GroupInfo format ( com.google.gerrit.common.data.GroupDescription.Basic group ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.group.GroupJson.GroupInfo info = init ( group ) ; if ( ( options.contains ( com.google.gerrit.common.groups.ListGroupsOption.MEMBERS ) ) || ( options.contains ( com.google.gerrit.common.groups.ListGroupsOption.INCLUDES ) ) ) { com.google.gerrit.server.group.GroupResource rsrc = new com.google.gerrit.server.group.GroupResource ( groupControlFactory.controlFor ( group ) ) ; initMembersAndIncludes ( rsrc , info ) ; } return info ; }
private org.eclipse.jgit.revwalk.RevCommit commit ( com.google.gerrit.server.notedb.ChangeUpdate update ) throws java.io.IOException { com.google.gerrit.server.git.MetaDataUpdate md = new com.google.gerrit.server.git.MetaDataUpdate ( com.google.gerrit.server.extensions.events.GitReferenceUpdated.DISABLED , project , repo ) ; md.getCommitBuilder ( ) . setAuthor ( update.getUser ( ) . newCommitterIdent ( update.getWhen ( ) , com.google.gerrit.server.notedb.ChangeNotesTest.TZ ) ) ; return update.commit ( md ) ; }
public void createdOnIsPopulatedForGroupsCreatedAfterAudit ( ) throws java.lang.Exception { java.sql.Timestamp testStartTime = com.google.gerrit.common.TimeUtil.nowTs ( ) ; com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = createGroup ( "Group for schema migration" ) ; setCreatedOnToVeryOldTimestamp ( groupId ) ; schema151.migrateData ( db , new com.google.gerrit.testutil.TestUpdateUI ( ) ) ; com.google.gerrit.reviewdb.client.AccountGroup group = db.accountGroups ( ) . get ( groupId ) ; com.google.common.truth.Truth.assertThat ( group.getCreatedOn ( ) ) . isAtLeast ( testStartTime ) ; }
public com.google.gerrit.server.account.GroupControl controlFor ( final com.google.gerrit.reviewdb.client.AccountGroup.Id groupId ) throws com.google.gerrit.common.errors.NoSuchGroupException { final com.google.gerrit.reviewdb.client.AccountGroup group = groupCache.get ( groupId ) ; if ( group == null ) { throw new com.google.gerrit.common.errors.NoSuchGroupException ( groupId ) ; } return new com.google.gerrit.server.account.GroupControl ( user.get ( ) , group ) ; }
java.util.List < com.google.gerrit.server.account.AccountInfo > listActiveOwners ( com.googlesource.gerrit.plugins.serviceuser.GetServiceUser.ServiceUserInfo serviceUser ) throws com.google.gwtorm.server.OrmException { java.util.List < com.google.gerrit.server.account.AccountInfo > activeOwners = new java.util.ArrayList < > ( ) ; for ( com.google.gerrit.server.account.AccountInfo owner : listOwners ( serviceUser ) ) { com.google.gerrit.server.account.AccountState accountState = accountCache.get ( owner._id ) ; if ( ( accountState != null ) && ( accountState.getAccount ( ) . isActive ( ) ) ) { activeOwners.add ( owner ) ; } } return activeOwners ; }
protected void insertTitleWidget ( final com.google.gwt.user.client.ui.Widget w ) { header.insert ( w , 0 ) ; }
public void testInheritRead_OverrideWithDeny ( ) { grant ( parent , com.google.gerrit.reviewdb.ApprovalCategory.READ , registered , "refs/*" , 1 ) ; grant ( local , com.google.gerrit.reviewdb.ApprovalCategory.READ , registered , "refs/*" , 0 ) ; com.google.gerrit.server.project.ProjectControl u = user ( ) ; assertFalse ( "can't read" , u.isVisible ( ) ) ; }
private void fireEvent ( com.google.gerrit.common.Event event , com.google.gerrit.reviewdb.server.ReviewDb db ) throws com.google.gwtorm.server.OrmException { for ( com.google.gerrit.common.ChangeHookRunner.EventListenerHolder holder : listeners.values ( ) ) { if ( isVisibleTo ( event , holder.user , db ) ) { holder.listener.onEvent ( event ) ; } } fireEventForUnrestrictedListeners ( event ) ; }
public com.googlesource.gerrit.plugins.verifystatus.server.GetConfig.ConfigInfo apply ( com.google.gerrit.server.config.ConfigResource resource ) { com.googlesource.gerrit.plugins.verifystatus.server.GetConfig.ConfigInfo info = new com.googlesource.gerrit.plugins.verifystatus.server.GetConfig.ConfigInfo ( ) ; info.showJobsPanel = cfg.getBoolean ( "showJobsPanel" , true ) ; info.showJobsDropDownPanel = cfg.getBoolean ( "showJobsDropDownPanel" , true ) ; info.showJobsSummaryPanel = cfg.getBoolean ( "showJobsSummaryPanel" , true ) ; return info ; }
void onCancel ( com.google.gwt.event.dom.client.ClickEvent e ) { e.stopPropagation ( ) ; if ( ( isNew ( ) ) && ( ! ( isDirty ( ) ) ) ) { removeUI ( ) ; } else { setEdit ( false ) ; if ( autoClosed ) { setOpen ( false ) ; } getCm ( ) . focus ( ) ; } }
private void appendNoLF ( final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder m ) { openLine ( m , false ) ; padLineNumber ( m , false , true ) ; padLineNumber ( m , false , false ) ; m.openTd ( ) ; m.addStyleName ( Gerrit.RESOURCES.css ( ) . diffText ( ) ) ; m.addStyleName ( Gerrit.RESOURCES.css ( ) . diffTextNoLF ( ) ) ; m.append ( "\\ No newline at end of file" ) ; m.closeTd ( ) ; closeLine ( m ) ; }
protected void insertRow ( final int row ) { super . insertRow ( row ) ; final com.google.gwt.user.client.ui.HTMLTable.CellFormatter fmt = table.getCellFormatter ( ) ; fmt.addStyleName ( row , ( ( com.google.gerrit.client.patches.UnifiedDiffTable.PC ) - 2 ) , "LineNumber" ) ; fmt.addStyleName ( row , ( ( com.google.gerrit.client.patches.UnifiedDiffTable.PC ) - 1 ) , "LineNumber" ) ; fmt.addStyleName ( row , com.google.gerrit.client.patches.UnifiedDiffTable.PC , "DiffText" ) ; }
void display ( final java.util.Map < com.google.gerrit.reviewdb.AccountGroup.Id , com.google.gerrit.reviewdb.AccountGroup > groups , final java.util.List < com.google.gerrit.reviewdb.RefRight > refRights ) { while ( 1 < ( table.getRowCount ( ) ) ) table.removeRow ( ( ( table.getRowCount ( ) ) - 1 ) ) ; for ( final com.google.gerrit.reviewdb.RefRight r : refRights ) { final int row = table.getRowCount ( ) ; table.insertRow ( row ) ; applyDataRowStyle ( row ) ; populate ( row , groups , r ) ; } }
void cleanup ( ) { try { jarFile.close ( ) ; } catch ( java.io.IOException err ) { } if ( ( ! ( tmpFile.delete ( ) ) ) && ( tmpFile.exists ( ) ) ) { PluginLoader.log.warn ( ( "Cannot delete " + ( tmpFile.getAbsolutePath ( ) ) ) ) ; } }
public void updateSchema ( final com.google.gwtorm.client.StatementExecutor e ) throws com.google.gwtorm.client.OrmException { try { createSequences ( e ) ; createRelations ( e ) ; for ( final com.google.gwtorm.schema.RelationModel rel : dbDef.getSchemaModel ( ) . getRelations ( ) ) { addColumns ( e , rel ) ; } } catch ( java.sql.SQLException err ) { throw new com.google.gwtorm.client.OrmException ( "Cannot update schema" , err ) ; } }
public void execute ( ) { if ( ( cmA ) != null ) { cmA.setOption ( "viewportMargin" , 10 ) ; } if ( ( cmB ) != null ) { cmB.setOption ( "viewportMargin" , 10 ) ; } }
private void populateCommentAction ( ) { final com.google.gwt.user.client.ui.Button b = new com.google.gwt.user.client.ui.Button ( Util.C.buttonPublishCommentsBegin ( ) ) ; b.addClickHandler ( new com.google.gwt.event.dom.client.ClickHandler ( ) { @ java.lang.Override public void onClick ( final com.google.gwt.event.dom.client.ClickEvent event ) { com.google.gerrit.client.Gerrit.display ( ( "change,publish," + ( patchSet.getId ( ) . toString ( ) ) ) , new com.google.gerrit.client.changes.PublishCommentScreen ( patchSet.getId ( ) ) ) ; } } ) ; actionsPanel.add ( b ) ; }
public com.google.gerrit.server.account.AccountInfo get ( com.google.gerrit.reviewdb.client.Account.Id id ) { if ( id == null ) { return null ; } com.google.gerrit.server.account.AccountInfo info = created.get ( id ) ; if ( info == null ) { info = new com.google.gerrit.server.account.AccountInfo ( id ) ; if ( detailed ) { info._account_id = id.get ( ) ; } created.put ( id , info ) ; } return info ; }
public com.google.gwtorm.server.ResultSet < com.google.gerrit.server.query.change.ChangeData > read ( ) throws com.google.gwtorm.server.OrmException { if ( java.lang.Thread.interrupted ( ) ) { java.lang.Thread.currentThread ( ) . interrupt ( ) ; throw new com.google.gwtorm.server.OrmException ( "interupted" ) ; } return new com.google.gerrit.lucene.LuceneChangeIndex.ChangeDataResults ( executor.submit ( new java.util.concurrent.Callable < java.util.List < org.apache.lucene.document.Document > > ( ) { @ java.lang.Override public java.util.List < org.apache.lucene.document.Document > call ( ) throws com.google.gwtorm.server.OrmException { return doRead ( ) ; } } ) ) ; }
protected void deny ( java.lang.String permission , com.google.gerrit.reviewdb.client.AccountGroup.UUID id , java.lang.String ref ) throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet ( project ) . getConfig ( ) ; com.google.gerrit.server.project.Util.deny ( cfg , permission , id , ref ) ; saveProjectConfig ( project , cfg ) ; }
public void rescan ( boolean forceCleanup ) { if ( ( rescanImp ( ) ) || forceCleanup ) { java.lang.System.gc ( ) ; processPendingCleanups ( ) ; } }
private void assertParseFails ( org.eclipse.jgit.revwalk.RevCommit commit ) throws java.lang.Exception { try ( com.google.gerrit.server.notedb.ChangeNotesParser parser = newParser ( commit ) ) { exception.expect ( org.eclipse.jgit.errors.ConfigInvalidException.class ) ; parser.parseAll ( ) ; } }
void set ( com.google.gerrit.client.info.ChangeInfo info ) { this . changeId = info.legacyId ( ) ; display ( info ) ; reviewerSuggestOracle.setChange ( changeId ) ; addReviewerIcon.setVisible ( com.google.gerrit.client.Gerrit.isSignedIn ( ) ) ; }
public void setUp ( ) throws java.lang.Exception { super . setUp ( ) ; final com.google.gerrit.common.data.ApprovalTypes types = new com.google.gerrit.common.data.ApprovalTypes ( java.util.Arrays.asList ( com.google.gerrit.rules.GerritCommonTest.codeReviewCategory ( ) , com.google.gerrit.rules.GerritCommonTest.verifiedCategory ( ) ) ) ; load ( "gerrit_common_test.pl" , new com.google.inject.AbstractModule ( ) { @ java.lang.Override protected void configure ( ) { bind ( com.google.gerrit.common.data.ApprovalTypes.class ) . toInstance ( types ) ; } } ) ; }
public java.util.Collection < com.google.gerrit.reviewdb.PatchSetApproval > currentApprovals ( com.google.inject.Provider < com.google.gerrit.reviewdb.ReviewDb > db ) throws com.google.gwtorm.client.OrmException { com.google.gerrit.reviewdb.Change c = change ( db ) ; if ( c == null ) { return java.util.Collections.emptyList ( ) ; } return approvalsFor ( db , c.currentPatchSetId ( ) ) ; }
protected void onRequestSuggestions ( com.google.gerrit.client.ui.Request req , com.google.gerrit.client.ui.Callback cb ) { if ( ( req.getQuery ( ) . length ( ) ) >= ( com.google.gerrit.client.Gerrit.getConfig ( ) . getSuggestFrom ( ) ) ) { _onRequestSuggestions ( req , cb ) ; } else { java.util.List < com.google.gerrit.client.ui.Suggestion > none = java.util.Collections.emptyList ( ) ; cb.onSuggestionsReady ( req , new com.google.gerrit.client.ui.Response ( none ) ) ; } }
private void addPermission ( final java.lang.String permissionName , final java.util.List < java.lang.String > permissionList ) { if ( ( value.getPermission ( permissionName ) ) != null ) { return ; } if ( ( com.google.gerrit.client.Gerrit.getConfig ( ) . getWildProject ( ) . equals ( projectAccess.getProjectName ( ) ) ) && ( ! ( com.google.gerrit.common.data.Permission.canBeOnAllProjects ( value.getName ( ) , permissionName ) ) ) ) { return ; } permissionList.add ( permissionName ) ; }
public void setParent_Forbidden ( ) throws com.jcraft.jsch.JSchException , java.io.IOException { java.lang.String parent = "parent" ; com.google.gerrit.acceptance.git.GitUtil.createProject ( sshSession , parent , null , true ) ; com.google.gerrit.acceptance.RestResponse r = userSession.put ( ( ( "/projects/" + ( project ) ) + "/parent" ) , new com.google.gerrit.acceptance.rest.project.SetParentIT.ParentInput ( parent ) ) ; org.junit.Assert.assertEquals ( HttpStatus.SC_FORBIDDEN , r.getStatusCode ( ) ) ; r.consume ( ) ; }
void setCmdLineParser ( com.google.gerrit.util.cli.CmdLineParser clp ) { this . clp = clp ; }
private void initIgnoreWhitespace ( com.google.gwt.user.client.ui.ListBox ws ) { ws.addItem ( PatchUtil.C.whitespaceIGNORE_NONE ( ) , Whitespace.IGNORE_NONE.name ( ) ) ; ws.addItem ( PatchUtil.C.whitespaceIGNORE_SPACE_AT_EOL ( ) , Whitespace.IGNORE_SPACE_AT_EOL.name ( ) ) ; ws.addItem ( PatchUtil.C.whitespaceIGNORE_SPACE_CHANGE ( ) , Whitespace.IGNORE_SPACE_CHANGE.name ( ) ) ; ws.addItem ( PatchUtil.C.whitespaceIGNORE_ALL_SPACE ( ) , Whitespace.IGNORE_ALL_SPACE.name ( ) ) ; }
private com.google.gerrit.extensions.api.changes.AddReviewerResult putAccount ( java.lang.String reviewer , com.google.gerrit.server.change.ReviewerResource rsrc ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.git.UpdateException , com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Account member = rsrc.getReviewerUser ( ) . getAccount ( ) ; com.google.gerrit.server.project.ChangeControl control = rsrc.getReviewerControl ( ) ; com.google.gerrit.extensions.api.changes.AddReviewerResult result = new com.google.gerrit.extensions.api.changes.AddReviewerResult ( reviewer ) ; if ( isValidReviewer ( member , control ) ) { addReviewers ( rsrc.getChangeResource ( ) , result , com.google.common.collect.ImmutableMap.of ( member.getId ( ) , control ) ) ; } return result ; }
static com.google.gerrit.reviewdb.server.ReviewDb unwrap ( com.google.gerrit.reviewdb.server.ReviewDb db ) { if ( db instanceof com.google.gerrit.server.git.BatchUpdateReviewDb ) { db = ( ( com.google.gerrit.server.git.BatchUpdateReviewDb ) ( db ) ) . unsafeGetDelegate ( ) ; } if ( db instanceof com.google.gerrit.server.schema.DisabledChangesReviewDbWrapper ) { db = ( ( com.google.gerrit.server.schema.DisabledChangesReviewDbWrapper ) ( db ) ) . unsafeGetDelegate ( ) ; } return db ; }
public java.lang.Boolean call ( ) throws com.google.gerrit.server.permissions.PermissionBackendException , com.google.gerrit.server.project.NoSuchProjectException { com.google.gerrit.server.project.ProjectControl projectControl = controlFor ( project ) ; return ( shouldReplicate ( projectControl ) ) && ( ( PushOne.ALL_REFS.equals ( ref ) ) || ( projectControl.controlForRef ( ref ) . isVisible ( ) ) ) ; }
private synchronized void runHook ( com.google.gerrit.reviewdb.client.Project.NameKey project , java.nio.file.Path hook , java.util.List < java.lang.String > args ) { if ( ( project != null ) && ( java.nio.file.Files.exists ( hook ) ) ) { hookQueue.execute ( new com.google.gerrit.common.ChangeHookRunner.AsyncHookTask ( project , hook , args ) ) ; } }
void select ( ) { com.google.gerrit.client.download.DownloadCommandPanel parent = ( ( com.google.gerrit.client.download.DownloadCommandPanel ) ( getParent ( ) ) ) ; for ( com.google.gwt.user.client.ui.Widget w : parent ) { if ( ( w != ( this ) ) && ( w instanceof com.google.gerrit.client.download.DownloadCommandLink ) ) { w.removeStyleName ( Gerrit.RESOURCES.css ( ) . downloadLink_Active ( ) ) ; } } parent.setCurrentCommand ( this ) ; addStyleName ( Gerrit.RESOURCES.css ( ) . downloadLink_Active ( ) ) ; }
public void missingGroupNameRef ( ) throws java.lang.Exception { try ( org.eclipse.jgit.lib.Repository repo = repoManager.openRepository ( allUsers ) ) { org.eclipse.jgit.lib.RefUpdate ru = repo.updateRef ( RefNames.REFS_GROUPNAMES ) ; ru.setForceUpdate ( true ) ; org.eclipse.jgit.lib.RefUpdate.Result result = ru.delete ( ) ; com.google.common.truth.Truth.assertThat ( result ) . isEqualTo ( Result.FORCED ) ; } assertConsistency ( "refs/meta/group-names does not exist" , ( groupsMigration.readFromNoteDb ( ) ? ConsistencyProblemInfo.Status.ERROR : ConsistencyProblemInfo.Status.WARNING ) ) ; }
private void addSuggestion ( java.util.Map map , com.google.gerrit.reviewdb.Account account , com.google.gerrit.common.data.AccountInfo info , java.lang.Boolean active ) { if ( ( active == null ) || ( active == ( account.isActive ( ) ) ) ) { map.put ( account.getId ( ) , info ) ; } }
public java.util.Collection < com.google.gwtorm.schema.ColumnModel > getDependentFields ( ) { final java.util.ArrayList < com.google.gwtorm.schema.ColumnModel > r = new java.util.ArrayList < com.google.gwtorm.schema.ColumnModel > ( ) ; for ( final com.google.gwtorm.schema.ColumnModel c : fieldsByFieldName.values ( ) ) { if ( ( ( primaryKey ) == null ) || ( ( primaryKey.getField ( ) ) != c ) ) { r.add ( c ) ; } } return r ; }
public void testParseWComments ( ) throws java.lang.Exception { com.google.gerrit.server.git.DestinationList dl = new com.google.gerrit.server.git.DestinationList ( ) ; dl.parseLabel ( com.google.gerrit.server.git.DestinationListTest.LABEL , ( ( ( com.google.gerrit.server.git.DestinationListTest.C1 ) + ( com.google.gerrit.server.git.DestinationListTest.F_SIMPLE ) ) + ( com.google.gerrit.server.git.DestinationListTest.C2 ) ) , null ) ; java.util.Set < com.google.gerrit.reviewdb.client.Branch.NameKey > branches = dl.getDestinations ( com.google.gerrit.server.git.DestinationListTest.LABEL ) ; com.google.common.truth.Truth.assertThat ( branches ) . containsExactlyElementsIn ( com.google.gerrit.server.git.DestinationListTest.D_SIMPLE ) ; }
public void putComment ( com.google.gerrit.reviewdb.client.PatchLineComment comment ) { com.google.common.base.Preconditions.checkArgument ( ( ( psId ) != null ) , "setPatchSetId must be called before putComment" ) ; com.google.common.base.Preconditions.checkArgument ( com.google.gerrit.server.notedb.CommentsInNotesUtil.getCommentPsId ( comment ) . equals ( psId ) , "Comment on %s doesn't match previous patch set %s" , com.google.gerrit.server.notedb.CommentsInNotesUtil.getCommentPsId ( comment ) , psId ) ; com.google.common.base.Preconditions.checkArgument ( ( ( comment.getRevId ( ) ) != null ) ) ; if ( ( comment.getSide ( ) ) == 0 ) { commentsForBase.add ( comment ) ; } else { commentsForPs.add ( comment ) ; } }
protected void run ( java.lang.String [ ] args ) throws com.google.gerrit.server.ssh.Failure { final com.google.gerrit.client.data.GroupCache gc = com.google.gerrit.client.rpc.Common.getGroupCache ( ) ; if ( gc.isAdministrator ( getAccountId ( ) ) ) { gc.flush ( ) ; } else { throw new com.google.gerrit.server.ssh.Failure ( 1 , "fatal: Not a Gerrit administrator" ) ; } }
public void run ( ) { net.codemirror.lib.CodeMirror.LineHandle handle = cm.extras ( ) . activeLine ( ) ; int line = ( cm.getLineNumber ( handle ) ) + 1 ; java.lang.String token = com.google.gerrit.client.Dispatcher.toEditScreen ( revision , path , line ) ; if ( ! ( com.google.gerrit.client.Gerrit.isSignedIn ( ) ) ) { com.google.gerrit.client.Gerrit.doSignIn ( token ) ; } else { com.google.gerrit.client.Gerrit.display ( token ) ; } }
void onReplyDone ( com.google.gwt.event.dom.client.ClickEvent e ) { if ( ( replyBox ) == null ) { com.google.gerrit.client.diff.DraftBox box = getDiffView ( ) . addReply ( getOriginal ( ) , "Done" , true ) ; registerReplyBox ( box ) ; } else { openReplyBox ( ) ; } }
public static synchronized java.nio.file.FileSystem getZipFileSystem ( java.nio.file.Path zip ) throws java.io.IOException { zip = zip.toRealPath ( ) ; java.nio.file.FileSystem zipFs = com.google.gerrit.launcher.GerritLauncher.zipFileSystems.get ( zip ) ; if ( zipFs == null ) { zipFs = java.nio.file.FileSystems.newFileSystem ( java.net.URI.create ( ( "jar:" + ( zip.toUri ( ) ) ) ) , java.util.Collections.< java.lang.String , java.lang.String > emptyMap ( ) ) ; com.google.gerrit.launcher.GerritLauncher.zipFileSystems.put ( zip , zipFs ) ; } return zipFs ; }
public void createNewChangeSignedOffByFooter ( ) throws java.lang.Exception { setSignedOffByFooter ( ) ; com.google.gerrit.extensions.common.ChangeInfo info = assertCreateSucceeds ( newChangeInput ( ChangeStatus.NEW ) ) ; java.lang.String message = info.revisions.get ( info.currentRevision ) . commit.message ; com.google.common.truth.Truth.assertThat ( message ) . contains ( java.lang.String.format ( "%sAdministrator <%s>" , org.eclipse.jgit.lib.Constants.SIGNED_OFF_BY_TAG , admin.getIdent ( ) . getEmailAddress ( ) ) ) ; }
public UiAction.Description getDescription ( com.google.gerrit.server.change.ChangeResource rsrc ) { try { return new com.google.gerrit.extensions.webui.UiAction.Description ( ) . setTitle ( java.lang.String.format ( "Delete Draft Change %d" , rsrc.getChange ( ) . getChangeId ( ) ) ) . setVisible ( ( ( ( rsrc.getChange ( ) . getStatus ( ) ) == ( com.google.gerrit.reviewdb.client.Change.Status.DRAFT ) ) && ( rsrc.getControl ( ) . canDeleteDraft ( dbProvider.get ( ) ) ) ) ) ; } catch ( com.google.gwtorm.server.OrmException e ) { throw new java.lang.IllegalStateException ( e ) ; } }
void updateMeter ( ) { if ( ( meter ) != null ) { meter.setValue ( ( ( 100 * ( row ) ) / ( list.size ( ) ) ) ) ; } }
private java.lang.String buildJsonRaw ( java.lang.String path ) throws java.lang.Exception { com.google.gitiles.FakeHttpServletResponse res = buildResponse ( path , "format=json" , javax.servlet.http.HttpServletResponse.SC_OK ) ; org.junit.Assert.assertEquals ( "application/json" , res.getHeader ( com.google.common.net.HttpHeaders.CONTENT_TYPE ) ) ; java.lang.String body = res.getActualBodyString ( ) ; java.lang.String magic = ")]}\'\n" ; org.junit.Assert.assertEquals ( magic , body.substring ( 0 , magic.length ( ) ) ) ; return body.substring ( magic.length ( ) ) ; }
private boolean match ( org.eclipse.jgit.lib.Repository repo , java.util.Set < com.google.gerrit.server.index.change.StalenessChecker.RefState > expected ) throws java.io.IOException { for ( org.eclipse.jgit.lib.Ref r : repo.getRefDatabase ( ) . getRefs ( prefix ( ) ) . values ( ) ) { if ( ! ( match ( r.getName ( ) ) ) ) { continue ; } if ( ! ( expected.contains ( com.google.gerrit.server.index.change.StalenessChecker.RefState.of ( r ) ) ) ) { return false ; } } return true ; }
public void commentOnReviewableChangeByOwner ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS ) ; review ( sc.owner , sc.changeId , com.google.gerrit.extensions.client.GeneralPreferencesInfo.EmailStrategy.ENABLED ) ; assertThat ( sender ) . sent ( "comment" , sc ) . notTo ( sc.owner ) . cc ( sc.reviewer , sc.ccer ) . cc ( sc.reviewerByEmail , sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS ) ; }
protected void configure ( ) { itsConfig = createMock ( com.googlesource.gerrit.plugins.its.base.its.ItsConfig.class ) ; bind ( com.googlesource.gerrit.plugins.its.base.its.ItsConfig.class ) . toInstance ( itsConfig ) ; commitMessageFetcher = createMock ( com.googlesource.gerrit.plugins.its.base.util.CommitMessageFetcher.class ) ; bind ( com.googlesource.gerrit.plugins.its.base.util.CommitMessageFetcher.class ) . toInstance ( commitMessageFetcher ) ; db = createMock ( com.google.gerrit.reviewdb.server.ReviewDb.class ) ; bind ( com.google.gerrit.reviewdb.server.ReviewDb.class ) . toInstance ( db ) ; }
public java.util.Set < com.google.gerrit.reviewdb.client.AccountGroup.UUID > guessRelevantGroupUUIDs ( ) { java.util.Set < com.google.gerrit.reviewdb.client.AccountGroup.UUID > groups = com.google.common.collect.Sets.newHashSet ( ) ; for ( com.google.gerrit.reviewdb.client.Project.NameKey n : all ( ) ) { com.google.gerrit.server.project.ProjectState p = byName.getIfPresent ( n.get ( ) ) ; if ( p != null ) { groups.addAll ( p.getConfig ( ) . getAllGroupUUIDs ( ) ) ; } } return groups ; }
private boolean isChangeReviewed ( com.google.gerrit.reviewdb.client.Account.Id self , com.google.gerrit.server.query.change.ChangeData cd , java.util.List < com.google.gerrit.reviewdb.client.ChangeMessage > msgs ) throws com.google.gwtorm.server.OrmException { msgs = ChangeNotes.MESSAGE_BY_TIME.sortedCopy ( msgs ) ; java.util.Collections.reverse ( msgs ) ; com.google.gerrit.reviewdb.client.Account.Id changeOwnerId = cd.change ( ) . getOwner ( ) ; for ( com.google.gerrit.reviewdb.client.ChangeMessage cm : msgs ) { if ( self.equals ( cm.getAuthor ( ) ) ) { return true ; } else if ( changeOwnerId.equals ( cm.getAuthor ( ) ) ) { return false ; } } return false ; }
private static boolean sameUpdate ( com.google.gerrit.server.notedb.ChangeRebuilder.Event event , com.google.gerrit.server.notedb.ChangeUpdate update ) { return ( ( ( ( update != null ) && ( ( com.google.gerrit.server.notedb.ChangeRebuilder.round ( event.when ) ) == ( com.google.gerrit.server.notedb.ChangeRebuilder.round ( update.getWhen ( ) ) ) ) ) && ( event.who.equals ( update.getUser ( ) . getAccountId ( ) ) ) ) && ( event.psId.equals ( update.getPatchSetId ( ) ) ) ) && ( ! ( event instanceof com.google.gerrit.server.notedb.ChangeRebuilder.FinalUpdatesEvent ) ) ; }
public void addMultipleIncludes ( ) throws java.lang.Exception { java.lang.String p = group ( "parent" ) ; java.lang.String g1 = group ( "newGroup1" ) ; java.lang.String g2 = group ( "newGroup2" ) ; java.util.List < java.lang.String > groups = com.google.common.collect.Lists.newLinkedList ( ) ; groups.add ( g1 ) ; groups.add ( g2 ) ; gApi.groups ( ) . id ( p ) . addGroups ( g1 , g2 ) ; assertIncludes ( p , g1 , g2 ) ; }
void onRefReplicatedToOneNode ( java.lang.String project , java.lang.String ref , org.eclipse.jgit.transport.URIish uri , com.googlesource.gerrit.plugins.replication.ReplicationState.RefPushResult status ) { com.googlesource.gerrit.plugins.replication.RefReplicatedEvent event = new com.googlesource.gerrit.plugins.replication.RefReplicatedEvent ( project , ref , com.googlesource.gerrit.plugins.replication.PushResultProcessing.resolveNodeName ( uri ) , status ) ; postEvent ( project , ref , event ) ; }
public void mergeByOtherCcingSelfNotifyNone ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS , com.google.gerrit.server.account.WatchConfig.NotifyType.SUBMITTED_CHANGES ) ; setEmailStrategy ( other , EmailStrategy.CC_ON_OWN_COMMENTS ) ; merge ( sc.changeId , other , com.google.gerrit.extensions.api.changes.NotifyHandling.NONE ) ; assertThat ( sender ) . notSent ( ) ; }
public java.lang.String getTargetOAuthFinal ( javax.servlet.http.HttpServletRequest httpRequest ) { java.lang.String targetUrl = getTargetUrl ( httpRequest ) ; java.lang.String code = getURLEncoded ( httpRequest.getParameter ( "code" ) ) ; java.lang.String state = getURLEncoded ( httpRequest.getParameter ( "state" ) ) ; return ( ( ( ( targetUrl + ( ( targetUrl.indexOf ( '?' ) ) < 0 ? '?' : '&' ) ) + "code=" ) + code ) + "&state=" ) + state ; }
public boolean canUpload ( ) { for ( com.google.gerrit.server.project.SectionMatcher matcher : access ( ) ) { com.google.gerrit.common.data.AccessSection section = matcher.section ; if ( section.getName ( ) . startsWith ( "refs/for/" ) ) { com.google.gerrit.common.data.Permission permission = section.getPermission ( Permission.PUSH ) ; if ( ( permission != null ) && ( controlForRef ( section.getName ( ) ) . canPerform ( Permission.PUSH ) ) ) { return true ; } } } return false ; }
private java.util.List < com.google.gerrit.reviewdb.RefRight > filter ( java.util.Collection < com.google.gerrit.reviewdb.RefRight > all ) { java.util.List < com.google.gerrit.reviewdb.RefRight > mine = new java.util.ArrayList < com.google.gerrit.reviewdb.RefRight > ( all.size ( ) ) ; for ( com.google.gerrit.reviewdb.RefRight right : all ) { if ( matches ( right.getRefPattern ( ) ) ) { mine.add ( right ) ; } } return mine ; }
public void queryChangesOwnerWithDifferentUsers ( ) throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange ( ) ; org.junit.Assert.assertEquals ( r.getChangeId ( ) , com.google.common.collect.Iterables.getOnlyElement ( query ( "owner:self" ) ) . changeId ) ; setApiUser ( user ) ; org.junit.Assert.assertTrue ( query ( "owner:self" ) . isEmpty ( ) ) ; }
public T decode ( java.nio.ByteBuffer buf ) { if ( buf.hasArray ( ) ) { return decode ( com.google.protobuf.CodedInputStream.newInstance ( buf.array ( ) , buf.position ( ) , buf.remaining ( ) ) ) ; } else { return decode ( com.google.protobuf.ByteString.copyFrom ( buf ) ) ; } }
protected void init ( ) throws com.google.gerrit.common.errors.EmailException { super . init ( ) ; if ( ( fromId ) != null ) { reviewers.remove ( fromId ) ; } add ( RecipientType.TO , reviewers ) ; add ( RecipientType.CC , extraCC ) ; rcptToAuthors ( RecipientType.CC ) ; bccStarredBy ( ) ; includeWatchers ( NotifyType.NEW_PATCHSETS , ( ! ( patchSet.isDraft ( ) ) ) ) ; }
private void setLineNumber ( com.google.gerrit.client.diff.DisplaySide side , int cmLine , java.lang.String html , java.lang.String styleName ) { com.google.gwt.user.client.ui.InlineHTML gutter = new com.google.gwt.user.client.ui.InlineHTML ( html ) ; diffTable.add ( gutter ) ; gutter.setStyleName ( styleName ) ; cm.setGutterMarker ( cmLine , ( side == ( DisplaySide.A ) ? UnifiedTable.style.lineNumbersLeft ( ) : UnifiedTable.style.lineNumbersRight ( ) ) , gutter.getElement ( ) ) ; }
public com.google.gitiles.GitilesView.Builder setPathPart ( java.lang.String path ) { switch ( type ) { case PATH : case DIFF : this . path = com.google.gitiles.GitilesView.maybeTrimLeadingAndTrailingSlash ( com.google.common.base.Preconditions.checkNotNull ( path ) ) ; return this ; case DESCRIBE : case REFS : case LOG : this . path = ( path != null ) ? com.google.gitiles.GitilesView.maybeTrimLeadingAndTrailingSlash ( path ) : null ; return this ; default : throw new java.lang.IllegalStateException ( java.lang.String.format ( "cannot set path on %s view" , type ) ) ; } }
private synchronized com.google.gerrit.testutil.InMemoryRepositoryManager.Repo get ( com.google.gerrit.reviewdb.client.Project.NameKey name ) throws org.eclipse.jgit.errors.RepositoryNotFoundException { com.google.gerrit.testutil.InMemoryRepositoryManager.Repo repo = repos.get ( name.get ( ) . toLowerCase ( ) ) ; if ( repo != null ) { return repo ; } throw new org.eclipse.jgit.errors.RepositoryNotFoundException ( name.get ( ) ) ; }
net.codemirror.lib.LineWidget addLineWidget ( net.codemirror.lib.CodeMirror cm , int line , final com.google.gwt.user.client.ui.Widget widget , net.codemirror.lib.Configuration options ) { widget.setVisible ( false ) ; net.codemirror.lib.LineWidget lineWidget = cm.addLineWidget ( line , widget.getElement ( ) , options ) ; lineWidget.onFirstRedraw ( new java.lang.Runnable ( ) { @ java.lang.Override public void run ( ) { widget.setVisible ( true ) ; } } ) ; return lineWidget ; }
public void testCopy ( ) { final com.google.gerrit.server.query.OperatorPredicate < java.lang.String > f = f ( "author" , "alice" ) ; org.junit.Assert.assertSame ( f , f.copy ( java.util.Collections.< com.google.gerrit.server.query.Predicate < java.lang.String > > emptyList ( ) ) ) ; org.junit.Assert.assertSame ( f , f.copy ( f.getChildren ( ) ) ) ; try { f.copy ( java.util.Collections.singleton ( f ( "owner" , "bob" ) ) ) ; } catch ( java.lang.IllegalArgumentException e ) { org.junit.Assert.assertEquals ( "Expected 0 children" , e.getMessage ( ) ) ; } }
public com.google.gerrit.server.patch.IntraLineDiff getIntraLineDiff ( com.google.gerrit.server.patch.IntraLineDiffKey key ) { if ( computeIntraline ) { try { return intraCache.get ( key ) ; } catch ( java.util.concurrent.ExecutionException e ) { IntraLineLoader.log.warn ( ( "Error computing " + key ) , e ) ; return new com.google.gerrit.server.patch.IntraLineDiff ( IntraLineDiff.Status.ERROR ) ; } } else { return new com.google.gerrit.server.patch.IntraLineDiff ( IntraLineDiff.Status.DISABLED ) ; } }
public void start ( ) { long interval = scheduleConfig.getInterval ( ) ; long delay = scheduleConfig.getInitialDelay ( ) ; if ( ( delay == ( com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG ) ) && ( interval == ( com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG ) ) ) { com.googlesource.gerrit.plugins.quota.PublisherScheduler.log.info ( "Ignoring missing schedule configuration" ) ; } else if ( ( delay < 0 ) || ( interval <= 0 ) ) { com.googlesource.gerrit.plugins.quota.PublisherScheduler.log.warn ( "Ignoring invalid schedule configuration" ) ; } else { workQueue.getDefaultQueue ( ) . scheduleWithFixedDelay ( publisher , delay , interval , java.util.concurrent.TimeUnit.MILLISECONDS ) ; } }
private java.lang.String getCommand ( java.lang.String command , com.google.gitiles.RevisionParser.Result result , java.lang.String path ) { if ( ! ( com.google.gitiles.ViewFilter.CMD_AUTO.equals ( command ) ) ) { return command ; } else if ( ( result.getOldRevision ( ) ) != null ) { return com.google.gitiles.ViewFilter.CMD_DIFF ; } else { return com.google.gitiles.ViewFilter.CMD_SHOW ; } }
protected void resetHtml ( final java.lang.String body ) { com.google.gwt.user.client.DOM.setInnerHTML ( table.getBodyElement ( ) , body ) ; }
public void onClick ( final com.google.gwt.event.dom.client.ClickEvent event ) { com.google.gerrit.client.Gerrit.display ( com.google.gerrit.client.Dispatcher.toPublish ( patchSet.getId ( ) ) ) ; }
public static com.google.gerrit.extensions.client.EditPreferencesInfo defaults ( ) { com.google.gerrit.extensions.client.EditPreferencesInfo i = new com.google.gerrit.extensions.client.EditPreferencesInfo ( ) ; i.tabSize = 8 ; i.lineLength = 100 ; i.hideTopMenu = false ; i.showTabs = true ; i.showWhitespaceErrors = false ; i.syntaxHighlighting = true ; i.hideLineNumbers = false ; i.theme = com.google.gerrit.extensions.client.Theme.DEFAULT ; return i ; }
public void addPatchSets ( com.google.gerrit.reviewdb.server.ReviewDb db , com.google.gerrit.server.data.ChangeAttribute ca , java.util.Collection < com.google.gerrit.reviewdb.client.PatchSet > ps , java.util.Map < com.google.gerrit.reviewdb.client.PatchSet.Id , java.util.Collection < com.google.gerrit.reviewdb.client.PatchSetApproval > > approvals , com.google.gerrit.common.data.LabelTypes labelTypes ) { addPatchSets ( db , ca , ps , approvals , false , null , labelTypes ) ; }
protected java.util.List < com.google.gerrit.reviewdb.client.Change > impl ( com.google.gerrit.server.util.RequestContext ctx ) throws com.google.gwtorm.server.OrmException { java.lang.String ref = event.getRefName ( ) ; com.google.gerrit.reviewdb.client.Project.NameKey project = new com.google.gerrit.reviewdb.client.Project.NameKey ( event.getProjectName ( ) ) ; if ( ref.equals ( RefNames.REFS_CONFIG ) ) { return com.google.gerrit.server.query.change.ChangeData.asChanges ( queryProvider.get ( ) . byProjectOpen ( project ) ) ; } return com.google.gerrit.server.query.change.ChangeData.asChanges ( queryProvider.get ( ) . byBranchOpen ( new com.google.gerrit.reviewdb.client.Branch.NameKey ( project , ref ) ) ) ; }
protected void configure ( ) { bind ( com.google.gerrit.server.index.account.AccountIndexRewriter.class ) ; bind ( com.google.gerrit.server.index.account.AccountIndexCollection.class ) ; listener ( ) . to ( com.google.gerrit.server.index.account.AccountIndexCollection.class ) ; bind ( com.google.gerrit.server.index.change.ChangeIndexRewriter.class ) ; bind ( com.google.gerrit.server.index.change.ChangeIndexCollection.class ) ; listener ( ) . to ( com.google.gerrit.server.index.change.ChangeIndexCollection.class ) ; factory ( ChangeIndexer.Factory.class ) ; }
protected void doGet ( final javax.servlet.http.HttpServletRequest req , final javax.servlet.http.HttpServletResponse rsp ) throws java.io.IOException { toGerrit ( com.google.gerrit.common.PageLinks.toChangeQuery ( req.getPathInfo ( ) ) , req , rsp ) ; }
private void writeObject ( final java.io.ObjectOutputStream out ) throws java.io.IOException { out.writeUTF ( projectKey.get ( ) ) ; org.spearce.jgit.lib.ObjectIdSerialization.write ( out , oldId ) ; org.spearce.jgit.lib.ObjectIdSerialization.write ( out , newId ) ; com.google.gerrit.server.patch.DiffCacheKey.writeString ( out , fileName ) ; com.google.gerrit.server.patch.DiffCacheKey.writeString ( out , sourceFileName ) ; }
void onRestore ( int idx ) { java.lang.String path = list.get ( idx ) . path ( ) ; com.google.gerrit.client.changes.ChangeEditApi.restore ( curr.getParentKey ( ) . get ( ) , path , new com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.client.VoidResult > ( ) { @ java.lang.Override public void onSuccess ( com.google.gerrit.client.VoidResult result ) { com.google.gerrit.client.Gerrit.display ( com.google.gerrit.common.PageLinks.toChangeInEditMode ( curr.getParentKey ( ) ) ) ; } @ java.lang.Override public void onFailure ( java.lang.Throwable caught ) { } } ) ; }
public com.google.gerrit.server.account.AccountState createEntry ( final com.google.gerrit.reviewdb.Account.Id key ) throws java.lang.Exception { final com.google.gerrit.reviewdb.ReviewDb db = schema.open ( ) ; try { final com.google.gerrit.server.account.AccountState state = load ( db , key ) ; if ( ( state.getUserName ( ) ) != null ) { byName.put ( state.getUserName ( ) , state.getAccount ( ) . getId ( ) ) ; } return state ; } finally { db.close ( ) ; } }
public java.lang.Object apply ( com.google.gerrit.server.change.PatchResource resource , com.google.gerrit.server.change.Reviewed.Input input ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.get ( ) ; com.google.gerrit.reviewdb.client.AccountPatchReview apr = com.google.gerrit.server.change.Reviewed.getExisting ( db , resource ) ; if ( apr == null ) { db.accountPatchReviews ( ) . insert ( java.util.Collections.singleton ( new com.google.gerrit.reviewdb.client.AccountPatchReview ( resource.getPatchKey ( ) , resource.getAccountId ( ) ) ) ) ; return com.google.gerrit.extensions.restapi.Response.created ( "" ) ; } else { return com.google.gerrit.extensions.restapi.Response.ok ( "" ) ; } }
private static java.lang.String duration ( double ns ) { if ( ns < 0.5 ) { return null ; } java.lang.String suffix = "ns" ; if ( ns >= 1000.0 ) { ns /= 1000.0 ; suffix = "us" ; } if ( ns >= 1000.0 ) { ns /= 1000.0 ; suffix = "ms" ; } if ( ns >= 1000.0 ) { ns /= 1000.0 ; suffix = "s " ; } return java.lang.String.format ( "%4.1f%s" , ns , suffix ) . trim ( ) ; }
private void appendLineNumber ( final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder m , final int idx , boolean isForSideA ) { m.openTd ( ) ; m.setStyleName ( Gerrit.RESOURCES.css ( ) . lineNumber ( ) ) ; if ( isForSideA ) { m.addStyleName ( Gerrit.RESOURCES.css ( ) . rightBorder ( ) ) ; } m.append ( com.google.gwtexpui.safehtml.client.SafeHtml.asis ( ( ( "<a href=\"javascript:void(0)\">" + ( idx + 1 ) ) + "</a>" ) ) ) ; m.closeTd ( ) ; }
private static com.google.gerrit.client.change.RelatedChangesTab.MyTable getMyTable ( com.google.gwt.dom.client.NativeEvent event ) { com.google.gerrit.client.change.Element e = event.getEventTarget ( ) . cast ( ) ; for ( e = com.google.gwt.user.client.DOM.getParent ( e ) ; e != null ; e = com.google.gwt.user.client.DOM.getParent ( e ) ) { com.google.gwt.user.client.EventListener l = com.google.gwt.user.client.DOM.getEventListener ( e ) ; if ( l instanceof com.google.gerrit.client.change.RelatedChangesTab.MyTable ) { return ( ( com.google.gerrit.client.change.RelatedChangesTab.MyTable ) ( l ) ) ; } } return null ; }
boolean matches ( org.eclipse.jgit.lib.Repository git ) throws java.io.IOException { org.eclipse.jgit.lib.Ref head = git.getRef ( Constants.HEAD ) ; return ( ( head != null ) && ( head.isSymbolic ( ) ) ) && ( GitRepositoryManager.REF_CONFIG.equals ( head.getLeaf ( ) . getName ( ) ) ) ; }
private static com.google.gerrit.server.git.CodeReviewCommit failed ( final org.eclipse.jgit.revwalk.RevWalk rw , final org.eclipse.jgit.revwalk.RevFlag canMergeFlag , final com.google.gerrit.server.git.CodeReviewCommit mergeTip , final com.google.gerrit.server.git.CodeReviewCommit n , final com.google.gerrit.server.git.CommitMergeStatus failure ) throws java.io.IOException , org.eclipse.jgit.errors.IncorrectObjectTypeException , org.eclipse.jgit.errors.MissingObjectException { rw.resetRetain ( canMergeFlag ) ; rw.markStart ( n ) ; rw.markUninteresting ( mergeTip ) ; com.google.gerrit.server.git.CodeReviewCommit failed ; while ( ( failed = ( ( com.google.gerrit.server.git.CodeReviewCommit ) ( rw.next ( ) ) ) ) != null ) { failed.statusCode = failure ; } return failed ; }
static void postSignIn ( final boolean success ) { final com.google.gerrit.client.SignInDialog d = com.google.gerrit.client.SignInDialog.current ; assert d != null ; if ( success ) { com.google.gerrit.client.Gerrit.postSignIn ( ) ; d.hide ( ) ; if ( ( d.callback ) != null ) { com.google.gwt.user.client.DeferredCommand.addCommand ( new com.google.gwt.user.client.Command ( ) { public void execute ( ) { d.callback.onSuccess ( null ) ; } } ) ; } } else { d.hide ( ) ; } }
protected void onInitUI ( ) { final com.google.gwt.user.client.ui.FlowPanel me = ( ( com.google.gwt.user.client.ui.FlowPanel ) ( getWidget ( ) ) ) ; me.add ( ( header = new com.google.gwt.user.client.ui.FlowPanel ( ) ) ) ; me.add ( ( body = new com.google.gwt.user.client.ui.FlowPanel ( ) ) ) ; header.setStyleName ( "gerrit-ScreenHeader" ) ; header.add ( ( headerText = new com.google.gwt.user.client.ui.InlineLabel ( ) ) ) ; }
private void setDoubleClickHandler ( ) { if ( ( messageClick ) == null ) { messageClick = contentPanelMessage.addDomHandler ( new com.google.gwt.event.dom.client.DoubleClickHandler ( ) { @ java.lang.Override public void onDoubleClick ( com.google.gwt.event.dom.client.DoubleClickEvent arg0 ) { editArea.setText ( contentPanelMessage.getText ( ) ) ; setEdit ( ( ! ( isEdit ( ) ) ) ) ; runClickCallback ( ) ; } } , com.google.gwt.event.dom.client.DoubleClickEvent.getType ( ) ) ; } }
public java.lang.String getUrl ( ) { java.lang.StringBuilder b = new java.lang.StringBuilder ( ) ; b.append ( "ssh://" ) ; b.append ( session.getUserName ( ) ) ; b.append ( "@" ) ; b.append ( session.getHost ( ) ) ; b.append ( ":" ) ; b.append ( session.getPort ( ) ) ; return b.toString ( ) ; }
private void assertBranches ( java.util.List < java.lang.String > branches ) throws java.lang.Exception { java.util.List < java.lang.String > expected = com.google.common.collect.Lists.newArrayList ( "HEAD" , "refs/meta/config" , "refs/heads/master" ) ; expected.addAll ( branches ) ; com.google.gerrit.acceptance.rest.project.BranchAssert.assertRefNames ( expected , project ( ) . branches ( ) . get ( ) ) ; }
private void initMessage ( final com.google.gwt.user.client.ui.Panel body ) { body.add ( new com.google.gerrit.client.ui.SmallHeading ( Util.C.headingCoverMessage ( ) ) ) ; final com.google.gwt.user.client.ui.VerticalPanel mwrap = new com.google.gwt.user.client.ui.VerticalPanel ( ) ; mwrap.setStyleName ( "gerrit-CoverMessage" ) ; body.add ( mwrap ) ; message = new com.google.gwt.user.client.ui.TextArea ( ) ; message.setCharacterWidth ( 60 ) ; message.setVisibleLines ( 10 ) ; com.google.gwt.user.client.DOM.setElementPropertyBoolean ( message.getElement ( ) , "spellcheck" , true ) ; mwrap.add ( message ) ; }
public int compare ( com.google.gerrit.server.notedb.ChangeRebuilderImpl.Event a , com.google.gerrit.server.notedb.ChangeRebuilderImpl.Event b ) { return com.google.common.collect.ComparisonChain.start ( ) . compareTrueFirst ( a.predatesChange , b.predatesChange ) . compare ( a.when , b.when ) . compare ( a.who.get ( ) , b.who.get ( ) ) . compare ( a.psId.get ( ) , b.psId.get ( ) ) . result ( ) ; }
com.googlesource.gerrit.plugins.replication.ReplicationState [ ] getStatesAsArray ( ) { java.util.Set < com.googlesource.gerrit.plugins.replication.ReplicationState > statesSet = new java.util.HashSet < > ( ) ; statesSet.addAll ( stateMap.values ( ) ) ; return statesSet.toArray ( new com.googlesource.gerrit.plugins.replication.ReplicationState [ statesSet.size ( ) ] ) ; }
public void show ( ) { super . show ( ) ; if ( ( regWindowResize ) == null ) { regWindowResize = com.google.gwt.user.client.Window.addResizeHandler ( this ) ; } com.google.gwtexpui.globalkey.client.GlobalKey.dialog ( this ) ; if ( fileList.isLoaded ( ) ) { installFileList ( ) ; } else { fileList.onTableLoaded ( new com.google.gwt.user.client.Command ( ) { @ java.lang.Override public void execute ( ) { sp.setHeight ( "" ) ; setPosition ( getOffsetWidth ( ) , getOffsetHeight ( ) ) ; installFileList ( ) ; } } ) ; } }
public void requestReceived ( com.github.tomakehurst.wiremock.http.Request request , com.github.tomakehurst.wiremock.http.Response response ) { if ( request.getAbsoluteUrl ( ) . contains ( flushRequest ) ) { try { checkPoint.await ( ) ; } catch ( java.lang.InterruptedException | java.util.concurrent.BrokenBarrierException e ) { com.google.common.base.Throwables.propagateIfPossible ( e ) ; } } }
public void restoreFile ( java.lang.String filePath ) throws com.google.gerrit.extensions.restapi.RestApiException { try { com.google.gerrit.server.change.ChangeEdits.Post.Input restoreInput = new com.google.gerrit.server.change.ChangeEdits.Post.Input ( ) ; restoreInput.restorePath = filePath ; changeEditsPost.apply ( changeResource , restoreInput ) ; } catch ( java.lang.Exception e ) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException ( "Cannot restore file of change edit" , e ) ; } }
private com.google.gerrit.server.git.ProjectConfig parseConfig ( com.google.gerrit.reviewdb.client.Project.NameKey p , java.lang.String idStr ) throws java.io.IOException , org.eclipse.jgit.errors.ConfigInvalidException , org.eclipse.jgit.errors.RepositoryNotFoundException { org.eclipse.jgit.lib.ObjectId id = org.eclipse.jgit.lib.ObjectId.fromString ( idStr ) ; if ( org.eclipse.jgit.lib.ObjectId.zeroId ( ) . equals ( id ) ) { return null ; } try ( org.eclipse.jgit.lib.Repository repo = repoManager.openRepository ( p ) ) { com.google.gerrit.server.git.ProjectConfig pc = new com.google.gerrit.server.git.ProjectConfig ( p ) ; pc.load ( repo , id ) ; return pc ; } }
public boolean isOwner ( ) { return ( canPerform ( com.google.gerrit.reviewdb.ApprovalCategory.OWN , ( ( short ) ( 1 ) ) ) ) || ( getProjectControl ( ) . isOwner ( ) ) ; }
private java.lang.String parseError ( com.google.gerrit.common.data.ReviewResult.Error.Type type ) { switch ( type ) { case ABANDON_NOT_PERMITTED : return "not permitted to abandon change" ; case RESTORE_NOT_PERMITTED : return "not permitted to restore change" ; case SUBMIT_NOT_PERMITTED : return "not permitted to submit change" ; case SUBMIT_NOT_READY : return "approvals or dependencies lacking" ; case CHANGE_IS_CLOSED : return "change is closed" ; case CHANGE_NOT_ABANDONED : return "change is not abandoned" ; case PUBLISH_NOT_PERMITTED : return "not permitted to publish change" ; case DELETE_NOT_PERMITTED : return "not permitted to delete change/patch set" ; case RULE_ERROR : return "rule error" ; case NOT_A_DRAFT : return "change/patch set is not a draft" ; case GIT_ERROR : return "error writing change to git repository" ; case DEST_BRANCH_NOT_FOUND : return "destination branch not found" ; default : return "failure in review" ; } }
private void insertDummyApproval ( final com.google.gerrit.reviewdb.Change change , final com.google.gerrit.reviewdb.PatchSet.Id psId , final com.google.gerrit.reviewdb.Account.Id forAccount , final com.google.gerrit.reviewdb.ApprovalCategory.Id catId , final com.google.gerrit.reviewdb.ReviewDb db ) throws com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.PatchSetApproval ca = new com.google.gerrit.reviewdb.PatchSetApproval ( new com.google.gerrit.reviewdb.PatchSetApproval.Key ( psId , forAccount , catId ) , ( ( short ) ( 0 ) ) ) ; ca.cache ( change ) ; db.patchSetApprovals ( ) . insert ( java.util.Collections.singleton ( ca ) ) ; }
public void testAppend_SafeHtml ( ) { final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder b = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder ( ) ; assertSame ( b , b.append ( ( ( com.google.gwtexpui.safehtml.client.SafeHtml ) ( null ) ) ) ) ; assertEquals ( "" , b.asString ( ) ) ; assertSame ( b , b.append ( new com.google.gwtexpui.safehtml.client.SafeHtmlString ( "foo" ) ) ) ; assertSame ( b , b.append ( new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder ( ) . append ( "bar" ) ) ) ; assertEquals ( "foobar" , b.asString ( ) ) ; }
private byte [ ] dataRowKey ( T obj ) { com.google.gwtorm.nosql.IndexKeyBuilder b = new com.google.gwtorm.nosql.IndexKeyBuilder ( ) ; b.add ( com.google.gwtorm.nosql.generic.GenericAccess.getRelationName ( ) ) ; b.delimiter ( ) ; com.google.gwtorm.nosql.generic.GenericAccess.getKeyIndex ( ) . encode ( b , obj ) ; return b.toByteArray ( ) ; }
public void emptyServletPath ( ) { com.google.common.truth.Truth.assertThat ( com.google.gerrit.util.http.RequestUtil.getEncodedPathInfo ( mockRequest ( "/c/foo/bar" , "" , "/c" ) ) ) . isEqualTo ( "/foo/bar" ) ; com.google.common.truth.Truth.assertThat ( com.google.gerrit.util.http.RequestUtil.getEncodedPathInfo ( mockRequest ( "/c/foo%2Fbar" , "" , "/c" ) ) ) . isEqualTo ( "/foo%2Fbar" ) ; }
private java.util.List < com.google.gerrit.reviewdb.Account > byPreferredEmail ( final javax.servlet.http.HttpServletResponse rsp , final java.lang.String email ) { try { final com.google.gerrit.reviewdb.ReviewDb db = schema.open ( ) ; try { return db.accounts ( ) . byPreferredEmail ( email ) . toList ( ) ; } finally { db.close ( ) ; } } catch ( com.google.gwtorm.client.OrmException e ) { getServletContext ( ) . log ( "cannot query database" , e ) ; return java.util.Collections.< com.google.gerrit.reviewdb.Account > emptyList ( ) ; } }
protected void configure ( ) { if ( ! ( com.google.gerrit.server.util.BouncyCastleUtil.havePGP ( ) ) ) { com.google.gerrit.server.git.gpg.SignedPushModule.log.info ( ( "BouncyCastle PGP not installed; signed push verification is" + " disabled" ) ) ; return ; } bind ( com.google.gerrit.server.git.gpg.PublicKeyChecker.class ) . to ( com.google.gerrit.server.git.gpg.GerritPublicKeyChecker.class ) ; com.google.gerrit.extensions.registration.DynamicSet.bind ( binder ( ) , com.google.gerrit.server.git.ReceivePackInitializer.class ) . to ( com.google.gerrit.server.git.gpg.SignedPushModule.Initializer.class ) ; }
protected void configure ( ) { bind ( com.google.gerrit.pgm.util.ConsoleUI.class ) . toInstance ( ui ) ; bind ( java.io.File.class ) . annotatedWith ( com.google.gerrit.server.config.SitePath.class ) . toInstance ( sitePath ) ; java.util.List < java.lang.String > plugins = com.google.common.base.Objects.firstNonNull ( getInstallPlugins ( ) , com.google.common.collect.Lists.< java.lang.String > newArrayList ( ) ) ; bind ( new com.google.inject.TypeLiteral < java.util.List < java.lang.String > > ( ) { } ) . annotatedWith ( com.google.gerrit.pgm.init.InstallPlugins.class ) . toInstance ( plugins ) ; bind ( com.google.gerrit.pgm.init.PluginsDistribution.class ) . toInstance ( pluginsDistribution ) ; }
public com.google.gerrit.reviewdb.client.PatchSet currentPatchSet ( com.google.inject.Provider < com.google.gerrit.reviewdb.server.ReviewDb > db ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change c = change ( db ) ; if ( c == null ) { return null ; } for ( com.google.gerrit.reviewdb.client.PatchSet p : patches ( db ) ) { if ( p.getId ( ) . equals ( c.currentPatchSetId ( ) ) ) { return p ; } } return null ; }
public void testIsEnabledRefParentNoBranchEnabled ( ) { java.lang.String [ ] branches = new java.lang.String [ ] { } ; setupIsEnabled ( "false" , "true" , branches ) ; com.googlesource.gerrit.plugins.its.base.its.ItsConfig itsConfig = createItsConfig ( ) ; replayMocks ( ) ; assertFalse ( itsConfig.isEnabled ( "testProject" , "refs/heads/testBranch" ) ) ; }
public com.google.gerrit.client.reviewdb.AccountGroup lookup ( final java.lang.String groupName ) throws com.google.gwtorm.client.OrmException { final com.google.gerrit.client.reviewdb.ReviewDb db = schema.open ( ) ; try { final com.google.gerrit.client.reviewdb.AccountGroup.NameKey nameKey = new com.google.gerrit.client.reviewdb.AccountGroup.NameKey ( groupName ) ; final com.google.gerrit.client.reviewdb.AccountGroup group = db.accountGroups ( ) . get ( nameKey ) ; if ( group != null ) { return group ; } else { return null ; } } finally { db.close ( ) ; } }
public void updateSchema ( ) throws com.google.gwtorm.client.OrmException { try { createSequences ( ) ; createRelations ( ) ; for ( final com.google.gwtorm.schema.RelationModel rel : dbDef.getSchemaModel ( ) . getRelations ( ) ) { addColumns ( rel ) ; } } catch ( java.sql.SQLException e ) { throw new com.google.gwtorm.client.OrmException ( "Schema update failure" , e ) ; } }
public void createDraftChangeNotAllowed ( ) throws java.lang.Exception { com.google.common.truth.TruthJUnit.assume ( ) . that ( isAllowDrafts ( ) ) . isFalse ( ) ; com.google.gerrit.extensions.common.ChangeInfo ci = newChangeInfo ( ChangeStatus.DRAFT ) ; com.google.gerrit.acceptance.RestResponse r = adminSession.post ( "/changes/" , ci ) ; com.google.common.truth.Truth.assertThat ( r.getStatusCode ( ) ) . isEqualTo ( HttpStatus.SC_METHOD_NOT_ALLOWED ) ; com.google.common.truth.Truth.assertThat ( r.getEntityContent ( ) ) . contains ( "draft workflow is disabled" ) ; }
public void testInsertOneDBException ( ) throws com.google.gwtorm.server.OrmException , java.sql.SQLException { java.sql.SQLException exception = new java.sql.BatchUpdateException ( ) ; java.sql.PreparedStatement insert = stubStatementThrowExceptionOnExecute ( com.google.gwtorm.jdbc.TestJdbcAccess.INSERT , exception ) ; com.google.gwtorm.jdbc.JdbcAccess < com.google.gwtorm.jdbc.TestJdbcAccess.Data , com.google.gwtorm.jdbc.TestJdbcAccess.Data.DataKey > classUnderTest = createClassUnderTest ( ) ; try { classUnderTest.insert ( oneRow ) ; org.junit.Assert.fail ( "missingException" ) ; } catch ( com.google.gwtorm.server.OrmException e ) { org.junit.Assert.assertSame ( e.getCause ( ) , exception ) ; } com.google.gwtorm.jdbc.TestJdbcAccess.assertUsedBatchingOnly ( insert ) ; }
public boolean canUpdate ( ) { if ( ( RefNames.REFS_CONFIG.equals ( refName ) ) && ( ! ( projectControl.isOwner ( ) ) ) ) { if ( ! ( ( projectControl.getProjectState ( ) . isAllProjects ( ) ) && ( getCurrentUser ( ) . getCapabilities ( ) . canAdministrateServer ( ) ) ) ) { return false ; } } return ( canPerform ( Permission.PUSH ) ) && ( canWrite ( ) ) ; }
public void setParent_Forbidden ( ) throws java.lang.Exception { java.lang.String parent = createProject ( "parent" , null , true ) . get ( ) ; com.google.gerrit.acceptance.RestResponse r = userSession.put ( ( ( "/projects/" + ( project.get ( ) ) ) + "/parent" ) , newParentInput ( parent ) ) ; com.google.common.truth.Truth.assertThat ( r.getStatusCode ( ) ) . isEqualTo ( HttpStatus.SC_FORBIDDEN ) ; r.consume ( ) ; }
private static boolean hasUserName ( ) { return ( ( com.google.gerrit.client.Gerrit.isSignedIn ( ) ) && ( ( com.google.gerrit.client.Gerrit.getUserAccount ( ) . getUserName ( ) ) != null ) ) && ( ( com.google.gerrit.client.Gerrit.getUserAccount ( ) . getUserName ( ) . length ( ) ) > 0 ) ; }
void setOpen ( boolean open ) { com.google.gwt.user.client.ui.UIObject.setVisible ( summary , ( ! open ) ) ; com.google.gwt.user.client.ui.UIObject.setVisible ( message , open ) ; com.google.gwt.user.client.ui.UIObject.setVisible ( buttons , open ) ; if ( open ) { removeStyleName ( style.closed ( ) ) ; } else { addStyleName ( style.closed ( ) ) ; } super . setOpen ( open ) ; }
public java.lang.String render ( java.lang.String varName ) { if ( com.google.gerrit.common.data.Permission.isLabel ( varName ) ) { return Util.M.label ( new com.google.gerrit.common.data.Permission ( varName ) . getLabel ( ) ) ; } java.lang.String desc = com.google.gerrit.client.admin.PermissionNameRenderer.all.get ( varName ) ; if ( desc == null ) { desc = com.google.gerrit.client.admin.PermissionNameRenderer.all.get ( varName.toLowerCase ( ) ) ; } return desc != null ? desc : varName ; }
public void go ( ) { if ( ( com.google.gerrit.client.Gerrit.patchScreen ) != null ) { com.google.gerrit.client.Gerrit.patchScreen.setTopView ( tv ) ; } com.google.gwt.dom.client.AnchorElement.as ( getElement ( ) ) . blur ( ) ; }
private void initTcpIpForwardFilter ( ) { setTcpIpForwardFilter ( new org.apache.sshd.server.TcpIpForwardFilter ( ) { @ java.lang.Override public boolean canConnect ( java.net.InetSocketAddress address , org.apache.sshd.server.session.ServerSession session ) { return false ; } @ java.lang.Override public boolean canListen ( java.net.InetSocketAddress address , org.apache.sshd.server.session.ServerSession session ) { return false ; } } ) ; }
private com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection newReviewerFilterSection ( java.lang.String filter ) { com.google.common.collect.ImmutableSet.Builder < java.lang.String > b = com.google.common.collect.ImmutableSet.builder ( ) ; for ( java.lang.String reviewer : cfg.getStringList ( com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FILTER , filter , "reviewer" ) ) { b.add ( reviewer ) ; } return new com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection ( filter , b.build ( ) ) ; }
public void testGetIssuePatternNullMatch ( ) { com.googlesource.gerrit.plugins.its.base.its.ItsConfig itsConfig = createItsConfig ( ) ; org.easymock.EasyMock.expect ( serverConfig.getString ( "ItsTestName" , null , "commentlink" ) ) . andReturn ( null ) . atLeastOnce ( ) ; org.easymock.EasyMock.expect ( serverConfig.getString ( "commentlink" , "ItsTestName" , "match" ) ) . andReturn ( null ) . atLeastOnce ( ) ; replayMocks ( ) ; assertNull ( "Pattern for null match is not null" , itsConfig.getIssuePattern ( ) ) ; }
private java.util.List < org.kohsuke.github.GHRepository > getRepositories ( com.googlesource.gerrit.plugins.github.oauth.GitHubLogin hubLogin , java.lang.String organisation ) throws java.io.IOException { if ( organisation.equals ( hubLogin.getMyself ( ) . getLogin ( ) ) ) { return hubLogin.getMyself ( ) . listRepositories ( com.googlesource.gerrit.plugins.github.wizard.RepositoriesListController.PAGE_SIZE ) . asList ( ) ; } else { org.kohsuke.github.GHOrganization ghOrganisation = hubLogin.getMyself ( ) . getOrganizations ( ) . byLogin ( organisation ) ; return ghOrganisation.listRepositories ( com.googlesource.gerrit.plugins.github.wizard.RepositoriesListController.PAGE_SIZE ) . asList ( ) ; } }
public void onEvent ( com.google.gerrit.server.events.Event event ) { if ( event instanceof com.google.gerrit.server.events.ChangeMergedEvent ) { com.google.gerrit.server.events.ChangeMergedEvent changeMergedEvent = ( ( com.google.gerrit.server.events.ChangeMergedEvent ) ( event ) ) ; mergeResults.put ( changeMergedEvent.change.get ( ) . number , changeMergedEvent.newRev ) ; } }
public void run ( ) { if ( ( prefs.context ( ) ) == ( com.google.gerrit.reviewdb.client.AccountDiffPreference.WHOLE_FILE_CONTEXT ) ) { contextEntireFile.setValue ( true ) ; } if ( view.canEnableRenderEntireFile ( prefs ) ) { renderEntireFile.setEnabled ( true ) ; } else { if ( prefs.renderEntireFile ( ) ) { prefs.renderEntireFile ( false ) ; renderEntireFile.setValue ( false ) ; view.updateRenderEntireFile ( ) ; } renderEntireFile.setEnabled ( false ) ; } view.setContext ( prefs.context ( ) ) ; }
public void stop ( ) { try { eventsDb.close ( ) ; } catch ( java.sql.SQLException e ) { com.ericsson.gerrit.plugins.eventslog.SQLStore.log.warn ( "Cannot close datasource " , e ) ; } try { localEventsDb.close ( ) ; } catch ( java.sql.SQLException e ) { com.ericsson.gerrit.plugins.eventslog.SQLStore.log.warn ( "Cannot close datasource " , e ) ; } }
public java.util.Collection < com.google.gerrit.server.index.ChangeIndex > getWriteIndexes ( ) { return java.util.Collections.unmodifiableCollection ( writeIndexes.values ( ) ) ; }
public void index ( com.google.gerrit.reviewdb.server.ReviewDb db , com.google.gerrit.reviewdb.client.Project.NameKey project , com.google.gerrit.reviewdb.client.Change.Id changeId ) throws java.io.IOException { index ( changeDataFactory.create ( db , project , changeId ) ) ; }
private void addPriority ( java.util.Map < java.lang.String , java.lang.Object > have , com.google.gerrit.server.account.CapabilityControl cc ) { com.google.gerrit.server.git.QueueProvider.QueueType queue = cc.getQueueType ( ) ; if ( ( queue != ( QueueProvider.QueueType.INTERACTIVE ) ) || ( ( ( query ) != null ) && ( query.contains ( com.google.gerrit.common.data.GlobalCapability.PRIORITY ) ) ) ) { have.put ( com.google.gerrit.common.data.GlobalCapability.PRIORITY , queue ) ; } }
private void registerCmEvents ( final net.codemirror.lib.CodeMirror cm ) { cm.on ( "beforeSelectionChange" , onSelectionChange ( cm ) ) ; cm.on ( "cursorActivity" , updateActiveLine ( cm ) ) ; cm.on ( "gutterClick" , onGutterClick ( cm ) ) ; cm.on ( "focus" , updateActiveLine ( cm ) ) ; }
private com.amd.gerrit.plugins.manifestsubscription.VersionedManifests parseManifests ( com.google.gerrit.reviewdb.client.Project.NameKey p , java.lang.String refName ) throws java.io.IOException , javax.xml.bind.JAXBException , org.eclipse.jgit.errors.ConfigInvalidException { com.google.gerrit.server.git.MetaDataUpdate update = metaDataUpdateFactory.create ( p ) ; com.amd.gerrit.plugins.manifestsubscription.VersionedManifests vManifests = new com.amd.gerrit.plugins.manifestsubscription.VersionedManifests ( refName ) ; vManifests.load ( update ) ; return vManifests ; }
public boolean deleteChangeFromIndex ( int changeId ) { try { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpResponseHandler.HttpResult result = httpSession.delete ( buildIndexEndpoint ( changeId ) ) ; if ( result.isSuccessful ( ) ) { return true ; } com.ericsson.gerrit.plugins.highavailability.forwarder.rest.RestForwarder.log.error ( "Unable to delete from index change {}. Cause: {}" , changeId , result.getMessage ( ) ) ; } catch ( java.io.IOException e ) { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.RestForwarder.log.error ( ( "Error trying to delete from index change " + changeId ) , e ) ; } return false ; }
boolean hasDynamicItem ( com.google.inject.TypeLiteral < ? > type ) { return sysItems.containsKey ( type ) ; }
public com.google.gerrit.reviewdb.client.Change abandon ( com.google.gerrit.server.project.ChangeControl control ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.git.UpdateException { return abandon ( control , "" , NotifyHandling.ALL ) ; }
public void onClick ( com.google.gwt.event.dom.client.ClickEvent event ) { final com.google.gwt.user.client.ui.HTMLTable.Cell cell = table.getCellForEvent ( event ) ; if ( ( ( cell != null ) && ( ( cell.getCellIndex ( ) ) != 1 ) ) && ( ( getRowItem ( cell.getRowIndex ( ) ) ) != null ) ) { movePointerTo ( cell.getRowIndex ( ) ) ; } }
public com.google.gerrit.server.events.PatchSetCommentAttribute asPatchSetLineAttribute ( com.google.gerrit.reviewdb.PatchLineComment c ) { com.google.gerrit.server.events.PatchSetCommentAttribute a = new com.google.gerrit.server.events.PatchSetCommentAttribute ( ) ; a.reviewer = asAccountAttribute ( c.getAuthor ( ) ) ; a.file = c.getKey ( ) . getParentKey ( ) . get ( ) ; a.line = c.getLine ( ) ; a.message = c.getMessage ( ) ; return a ; }
void onWhitespaceErrors ( com.google.gwt.event.logical.shared.ValueChangeEvent < java.lang.Boolean > e ) { prefs.showWhitespaceErrors ( e.getValue ( ) ) ; if ( ( view ) != null ) { view.operation ( new java.lang.Runnable ( ) { @ java.lang.Override public void run ( ) { boolean s = prefs.showWhitespaceErrors ( ) ; view.getCmFromSide ( DisplaySide.A ) . setOption ( "showTrailingSpace" , s ) ; view.getCmFromSide ( DisplaySide.B ) . setOption ( "showTrailingSpace" , s ) ; } } ) ; } }
public void addPatchSets ( com.google.gerrit.server.data.ChangeAttribute a , java.util.Collection < com.google.gerrit.reviewdb.client.PatchSet > ps , com.google.gerrit.common.data.LabelTypes labelTypes ) { addPatchSets ( a , ps , null , false , null , labelTypes ) ; }
private com.google.gerrit.reviewdb.client.PatchSet updateDraftPatchSet ( com.google.gerrit.server.change.RevisionResource rsrc ) throws com.google.gwtorm.server.OrmException { return dbProvider.get ( ) . patchSets ( ) . atomicUpdate ( rsrc.getPatchSet ( ) . getId ( ) , new com.google.gwtorm.server.AtomicUpdate < com.google.gerrit.reviewdb.client.PatchSet > ( ) { @ java.lang.Override public com.google.gerrit.reviewdb.client.PatchSet update ( com.google.gerrit.reviewdb.client.PatchSet patchset ) { patchset.setDraft ( false ) ; return patchset ; } } ) ; }
public void deleteReviewerFromReviewableWipChange ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableWipChange ( ) ; removeReviewer ( sc , extraReviewer ) ; assertThat ( sender ) . notSent ( ) ; }
public com.google.gerrit.extensions.restapi.Response < com.google.gerrit.server.change.CommentInfo > apply ( com.google.gerrit.server.change.DraftResource rsrc , com.google.gerrit.server.change.DeleteDraft.Input input ) throws com.google.gwtorm.server.OrmException { db.get ( ) . patchComments ( ) . delete ( java.util.Collections.singleton ( rsrc.getComment ( ) ) ) ; return com.google.gerrit.extensions.restapi.Response.none ( ) ; }
void onCancel ( com.google.gwt.event.dom.client.ClickEvent e ) { setEdit ( false ) ; getCm ( ) . focus ( ) ; }
protected void doPost ( javax.servlet.http.HttpServletRequest req , javax.servlet.http.HttpServletResponse rsp ) { if ( ! ( currentUserProvider.get ( ) . getCapabilities ( ) . canAdministrateServer ( ) ) ) { sendError ( rsp , javax.servlet.http.HttpServletResponse.SC_FORBIDDEN ) ; return ; } this . healthy = true ; rsp.setStatus ( javax.servlet.http.HttpServletResponse.SC_NO_CONTENT ) ; }
public com.google.gerrit.reviewdb.client.Change update ( com.google.gerrit.reviewdb.client.Change change ) { if ( ( change.getStatus ( ) ) == ( Change.Status.DRAFT ) ) { change.setStatus ( Change.Status.NEW ) ; com.google.gerrit.server.ChangeUtil.updated ( change ) ; } return change ; }
public void onShowView ( ) { super . onShowView ( ) ; com.google.gwt.user.client.Window.enableScrolling ( false ) ; final int height = getCodeMirrorHeight ( ) ; cmA.setHeight ( height ) ; cmB.setHeight ( height ) ; diffTable.sidePanel.adjustGutters ( cmB ) ; cmB.setCursor ( net.codemirror.lib.LineCharacter.create ( 0 ) ) ; cmB.focus ( ) ; prefetchNextFile ( ) ; }
public void testPatternNullMatch ( ) { com.googlesource.gerrit.plugins.hooks.its.ItsConfig itsConfig = createItsConfig ( ) ; org.easymock.EasyMock.expect ( serverConfig.getString ( "commentLink" , "ItsTestName" , "match" ) ) . andReturn ( null ) . atLeastOnce ( ) ; replayMocks ( ) ; assertNull ( "Pattern for null match is not null" , itsConfig.getIssuePattern ( ) ) ; }
public com.googlecode.prolog_cafe.lang.Operation switch_on_term ( com.googlecode.prolog_cafe.lang.Operation var , com.googlecode.prolog_cafe.lang.Operation Int , com.googlecode.prolog_cafe.lang.Operation flo , com.googlecode.prolog_cafe.lang.Operation con , com.googlecode.prolog_cafe.lang.Operation str , com.googlecode.prolog_cafe.lang.Operation lis ) { com.googlecode.prolog_cafe.lang.Term arg1 = r1.dereference ( ) ; if ( arg1 instanceof com.googlecode.prolog_cafe.lang.VariableTerm ) return var ; if ( arg1 instanceof com.googlecode.prolog_cafe.lang.IntegerTerm ) return Int ; if ( arg1 instanceof com.googlecode.prolog_cafe.lang.DoubleTerm ) return flo ; if ( arg1 instanceof com.googlecode.prolog_cafe.lang.SymbolTerm ) return con ; if ( arg1 instanceof com.googlecode.prolog_cafe.lang.StructureTerm ) return str ; if ( arg1 instanceof com.googlecode.prolog_cafe.lang.ListTerm ) return lis ; return var ; }
private static void mergeTestConfig ( org.eclipse.jgit.lib.Config cfg ) { java.lang.String forceEphemeralPort = java.lang.String.format ( "%s:0" , com.google.gerrit.acceptance.GerritServer.getLocalHost ( ) . getHostName ( ) ) ; java.lang.String url = ( "http://" + forceEphemeralPort ) + "/" ; cfg.setString ( "gerrit" , null , "canonicalWebUrl" , url ) ; cfg.setString ( "httpd" , null , "listenUrl" , url ) ; cfg.setString ( "sshd" , null , "listenAddress" , forceEphemeralPort ) ; cfg.setString ( "cache" , null , "directory" , null ) ; cfg.setString ( "gerrit" , null , "basePath" , "git" ) ; cfg.setBoolean ( "sendemail" , null , "enable" , false ) ; cfg.setInt ( "cache" , "projects" , "checkFrequency" , 0 ) ; cfg.setInt ( "plugins" , null , "checkFrequency" , 0 ) ; }
public void start ( ) { }
public void clearReviewed ( com.google.gerrit.reviewdb.client.PatchSet.Id psId ) throws com.google.gwtorm.server.OrmException { try ( java.sql.Connection con = ds.getConnection ( ) ; java.sql.PreparedStatement stmt = con.prepareStatement ( ( "DELETE FROM ACCOUNT_PATCH_REVIEWS " + "WHERE CHANGE_ID + ? AND PATCH_SET_ID = ?" ) ) ) { stmt.setInt ( 1 , psId.getParentKey ( ) . get ( ) ) ; stmt.setInt ( 2 , psId.get ( ) ) ; stmt.executeUpdate ( ) ; } catch ( java.sql.SQLException e ) { throw com.google.gerrit.server.schema.H2AccountPatchReviewStore.convertError ( "delete" , e ) ; } }
protected void configure ( ) { final com.google.inject.TypeLiteral < com.google.gerrit.server.cache.Cache < java.lang.String , java.util.Set < com.google.gerrit.reviewdb.Account.Id > > > type = new com.google.inject.TypeLiteral < com.google.gerrit.server.cache.Cache < java.lang.String , java.util.Set < com.google.gerrit.reviewdb.Account.Id > > > ( ) { } ; core ( type , com.google.gerrit.server.account.AccountByEmailCacheImpl.CACHE_NAME ) ; bind ( com.google.gerrit.server.account.AccountByEmailCacheImpl.class ) ; bind ( com.google.gerrit.server.account.AccountByEmailCache.class ) . to ( com.google.gerrit.server.account.AccountByEmailCacheImpl.class ) ; }
public com.google.gerrit.server.project.ProjectState get ( final com.google.gerrit.reviewdb.Project.NameKey projectName ) { return byName.get ( projectName ) ; }
public java.lang.String toString ( ) { final java.lang.StringBuffer r = new java.lang.StringBuffer ( ) ; r.append ( getClass ( ) . getName ( ) ) ; r.append ( '[' ) ; if ( ( getParentKey ( ) ) != null ) { r.append ( getParentKey ( ) . toString ( ) ) ; r.append ( ", " ) ; } r.append ( get ( ) ) ; r.append ( ']' ) ; return r.toString ( ) ; }
private boolean canPerformOnAllRefs ( com.google.gerrit.reviewdb.ApprovalCategory.Id actionId , short requireValue ) { return canPerform ( actionId , requireValue , "refs/*" ) ; }
public void testUnblockInLocalVisibilityByRegisteredUsers_Fails ( ) { com.google.gerrit.server.project.Util.block ( util.getParentConfig ( ) , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/heads/*" ) ; com.google.gerrit.server.project.Util.allow ( local , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS , "refs/heads/*" ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS ) ; org.junit.Assert.assertFalse ( "u can't read" , u.controlForRef ( "refs/heads/master" ) . isVisibleByRegisteredUsers ( ) ) ; }
private void mapMessages ( com.google.gerrit.server.change.ChangeJson.ChangeInfo i , com.google.gerrit.extensions.common.ChangeInfo o ) { java.util.List < com.google.gerrit.extensions.common.ChangeMessageInfo > r = com.google.common.collect.Lists.newArrayListWithCapacity ( i.messages.size ( ) ) ; for ( com.google.gerrit.server.change.ChangeJson.ChangeMessageInfo m : i.messages ) { com.google.gerrit.extensions.common.ChangeMessageInfo cmi = new com.google.gerrit.extensions.common.ChangeMessageInfo ( ) ; cmi.id = m.id ; cmi.author = com.google.gerrit.server.api.changes.ChangeInfoMapper.fromAcountInfo ( m.author ) ; cmi.date = m.date ; cmi.message = m.message ; cmi._revisionNumber = m._revisionNumber ; r.add ( cmi ) ; } o.messages = r ; }
public void parseBranch ( ) throws java.lang.Exception { assertParseSucceeds ( ( "Update change\n" + ( ( ( "\n" + "Branch: refs/heads/master\n" ) + "Patch-Set: 1\n" ) + "Subject: This is a test change\n" ) ) ) ; assertParseSucceeds ( ( "Update change\n" + ( ( ( "\n" + "Branch: master\n" ) + "Patch-Set: 1\n" ) + "Subject: This is a test change\n" ) ) ) ; assertParseFails ( ( "Update change\n" + ( ( ( "\n" + "Patch-Set: 1\n" ) + "Branch: refs/heads/master\n" ) + "Branch: refs/heads/stable" ) ) ) ; }
public void testDeleteResponseOK ( ) throws java.lang.Exception { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.wireMockRule.givenThat ( com.github.tomakehurst.wiremock.client.WireMock.delete ( com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo ( com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.ENDPOINT ) ) . willReturn ( com.github.tomakehurst.wiremock.client.WireMock.aResponse ( ) . withStatus ( com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.NO_CONTENT ) ) ) ; com.google.common.truth.Truth.assertThat ( httpSession.delete ( com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.ENDPOINT ) . isSuccessful ( ) ) . isTrue ( ) ; }
private static synchronized void fill ( byte [ ] raw , com.google.gerrit.reviewdb.server.ReviewDb db ) throws com.google.gwtorm.server.OrmException { if ( ( com.google.gerrit.server.ChangeUtil.uuidSeq ) == 0 ) { com.google.gerrit.server.ChangeUtil.uuidPrefix = db.nextChangeMessageId ( ) ; com.google.gerrit.server.ChangeUtil.uuidSeq = java.lang.Integer.MAX_VALUE ; } org.eclipse.jgit.util.NB.encodeInt32 ( raw , 0 , com.google.gerrit.server.ChangeUtil.uuidPrefix ) ; org.eclipse.jgit.util.NB.encodeInt32 ( raw , 4 , com.google.gerrit.server.util.IdGenerator.mix ( com.google.gerrit.server.ChangeUtil.uuidPrefix , ( ( com.google.gerrit.server.ChangeUtil.uuidSeq ) -- ) ) ) ; }
public void setUpMocks ( ) { changeId = Change.Id.parse ( java.lang.Integer.toString ( com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandlerTest.CHANGE_ID ) ) ; accountId = Account.Id.parse ( java.lang.Integer.toString ( com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandlerTest.ACCOUNT_ID ) ) ; accountGroupUUID = AccountGroup.UUID.parse ( com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandlerTest.UUID ) ; indexEventHandler = new com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandler ( com.google.common.util.concurrent.MoreExecutors.directExecutor ( ) , com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandlerTest.PLUGIN_NAME , forwarder ) ; }
protected void configure ( ) { bind ( java.lang.String.class ) . annotatedWith ( com.googlesource.gerrit.plugins.hooks.its.ItsName.class ) . toInstance ( "ItsTestName" ) ; serverConfig = createMock ( org.eclipse.jgit.lib.Config.class ) ; bind ( org.eclipse.jgit.lib.Config.class ) . annotatedWith ( com.google.gerrit.server.config.GerritServerConfig.class ) . toInstance ( serverConfig ) ; issueExtractor = createMock ( com.googlesource.gerrit.plugins.hooks.util.IssueExtractor.class ) ; bind ( com.googlesource.gerrit.plugins.hooks.util.IssueExtractor.class ) . toInstance ( issueExtractor ) ; itsFacade = createMock ( com.googlesource.gerrit.plugins.hooks.its.ItsFacade.class ) ; bind ( com.googlesource.gerrit.plugins.hooks.its.ItsFacade.class ) . toInstance ( itsFacade ) ; }
private static void whoAmI ( ) { final java.lang.String name = com.google.gerrit.client.FormatUtil.nameEmail ( com.google.gerrit.client.Gerrit.getUserAccount ( ) ) ; final com.google.gwt.user.client.ui.InlineLabel l = new com.google.gwt.user.client.ui.InlineLabel ( name ) ; l.setStyleName ( com.google.gerrit.client.Gerrit.RESOURCES.css ( ) . menuBarUserName ( ) ) ; com.google.gerrit.client.Gerrit.menuRight.add ( l ) ; }
private static java.lang.String nameOf ( java.io.File jar ) { java.lang.String name = jar.getName ( ) ; int ext = name.lastIndexOf ( '.' ) ; return 0 < ext ? name.substring ( 0 , ext ) : name ; }
public void configureServlets ( ) { serveRegex ( "^/gerrit_ui/(?!rpc/)(.*)$" ) . with ( com.google.inject.Key.get ( javax.servlet.http.HttpServlet.class , com.google.inject.name.Names.named ( com.google.gerrit.httpd.raw.StaticModule.GWT_UI_SERVLET ) ) ) ; com.google.gerrit.httpd.raw.StaticModule.Paths p = getPaths ( ) ; if ( p.isDev ( ) ) { filter ( "/" ) . through ( new com.google.gerrit.httpd.raw.RecompileGwtUiFilter ( p.buckOut , p.unpackedWar ) ) ; } }
private void listen ( com.google.gerrit.server.plugins.AutoRegisterModules.ClassData def ) throws com.google.gerrit.server.plugins.InvalidPluginException { java.lang.Class < ? > clazz ; try { clazz = java.lang.Class.forName ( def.className , false , classLoader ) ; } catch ( java.lang.ClassNotFoundException err ) { throw new com.google.gerrit.server.plugins.InvalidPluginException ( java.lang.String.format ( "Cannot load %s with @Listen" , def.className ) , err ) ; } com.google.gerrit.extensions.annotations.Listen listen = clazz.getAnnotation ( com.google.gerrit.extensions.annotations.Listen.class ) ; if ( listen != null ) { listen ( clazz , clazz ) ; } else { PluginLoader.log.warn ( java.lang.String.format ( "In plugin %s asm incorrectly parsed %s with @Listen" , pluginName , clazz.getName ( ) ) ) ; } }
public void postUpdate ( com.google.gerrit.server.git.BatchUpdate.Context ctx ) throws com.google.gwtorm.server.OrmException { if ( ( updated ( ) ) && ( runHooks ) ) { hooks.doHashtagsChangedHook ( change , ctx.getUser ( ) . asIdentifiedUser ( ) . getAccount ( ) , toAdd , toRemove , updatedHashtags , ctx.getDb ( ) ) ; } }
java.nio.file.Path getSharedDirectory ( com.google.gerrit.server.config.PluginConfigFactory cfg , @ com.google.gerrit.extensions.annotations.PluginName java.lang.String pluginName ) throws java.io.IOException { java.lang.String sharedDirectory = com.google.common.base.Strings.emptyToNull ( cfg.getFromGerritConfig ( pluginName , true ) . getString ( "sharedDirectory" ) ) ; if ( sharedDirectory == null ) { throw new com.google.inject.ProvisionException ( "sharedDirectory must be configured" ) ; } java.nio.file.Path sharedDirectoryPath = java.nio.file.Paths.get ( sharedDirectory ) ; java.nio.file.Files.createDirectories ( sharedDirectoryPath ) ; return sharedDirectoryPath ; }
public void isDisabledForInvalidRef ( ) throws java.lang.Exception { com.googlesource.gerrit.plugins.uploadvalidator.ValidatorConfig config = getConfig ( ( "[plugin \"uploadvalidator\"]\n" + ( " ref = anInvalidRef\n" + " blockedFileExtension = jar" ) ) ) ; com.google.common.truth.Truth.assertThat ( config.isEnabledForRef ( projectName , "refs/heads/anyref" , "blockedFileExtension" ) ) . isFalse ( ) ; }
protected com.google.gerrit.client.reviewdb.Project getProject ( ) { final com.google.gerrit.server.project.ProjectState r ; r = projectCache.get ( change.getDest ( ) . getParentKey ( ) ) ; return r != null ? r.getProject ( ) : null ; }
private void migrateData ( java.util.List < com.google.gerrit.server.schema.SchemaVersion > pending , com.google.gerrit.server.schema.UpdateUI ui , com.google.gerrit.reviewdb.client.CurrentSchemaVersion curr , com.google.gerrit.reviewdb.server.ReviewDb db ) throws com.google.gwtorm.server.OrmException , java.sql.SQLException { for ( com.google.gerrit.server.schema.SchemaVersion v : pending ) { ui.message ( java.lang.String.format ( "Migrating data to schema %d ..." , v.getVersionNbr ( ) ) ) ; v.migrateData ( db , ui ) ; v.finish ( curr , db ) ; } }
private static void checkTimerDescription ( com.google.gerrit.metrics.Description desc ) { com.google.common.base.Preconditions.checkArgument ( ( ! ( desc.isGauge ( ) ) ) , "timer must not be a gauge" ) ; com.google.common.base.Preconditions.checkArgument ( ( ! ( desc.isRate ( ) ) ) , "timer must not be a rate" ) ; com.google.common.base.Preconditions.checkArgument ( desc.isCumulative ( ) , "timer must be cumulative" ) ; com.google.common.base.Preconditions.checkArgument ( ( ( desc.getTimeUnit ( ) ) != null ) , "timer must have a unit" ) ; }
private static java.lang.String authorName ( com.google.gerrit.client.changes.CommentInfo info ) { if ( ( info.author ( ) ) != null ) { if ( ( info.author ( ) . name ( ) ) != null ) { return info.author ( ) . name ( ) ; } return com.google.gerrit.client.Gerrit.getConfig ( ) . getAnonymousCowardName ( ) ; } return Util.C.messageNoAuthor ( ) ; }
public void withDuplicateSystemGroupCaseSensitiveName_Conflict ( ) throws java.lang.Exception { java.lang.String newGroupName = "Registered Users" ; adminSshSession.exec ( ( "gerrit create-group " + newGroupName ) ) ; com.google.common.truth.Truth.assert_ ( ) . withFailureMessage ( adminSshSession.getError ( ) ) . that ( adminSshSession.hasError ( ) ) . isTrue ( ) ; }
com.googlesource.gerrit.plugins.findowners.OwnersDb get ( com.google.gerrit.server.account.AccountCache accountCache , com.google.gerrit.server.account.Accounts accounts , org.eclipse.jgit.lib.Repository repository , com.google.gerrit.server.query.change.ChangeData changeData , int patchset ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Project.NameKey project = changeData.change ( ) . getProject ( ) ; java.lang.String branch = changeData.change ( ) . getDest ( ) . get ( ) ; java.lang.String dbKey = com.googlesource.gerrit.plugins.findowners.Cache.makeKey ( changeData.getId ( ) . get ( ) , patchset , branch ) ; return get ( accountCache , accounts , dbKey , repository , project , branch , changeData.currentFilePaths ( ) ) ; }
public void modifyCommitMessage ( java.lang.String newCommitMessage ) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.change.ChangeEdits.EditMessage.Input input = new com.google.gerrit.server.change.ChangeEdits.EditMessage.Input ( ) ; input.message = newCommitMessage ; try { modifyChangeEditCommitMessage.apply ( changeResource , input ) ; } catch ( java.io.IOException | com.google.gwtorm.server.OrmException e ) { throw new com.google.gerrit.extensions.restapi.RestApiException ( "Cannot modify commit message of change edit" , e ) ; } }
public void commitWhoseParentIsUninterestingGetsNewGroup ( ) throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit branchTip = tr.commit ( ) . create ( ) ; org.eclipse.jgit.revwalk.RevCommit a = tr.commit ( ) . parent ( branchTip ) . create ( ) ; com.google.common.collect.Multimap < org.eclipse.jgit.lib.ObjectId , java.lang.String > groups = com.google.gerrit.server.git.GroupCollectorTest.collectGroups ( newWalk ( a , branchTip ) , com.google.gerrit.server.git.GroupCollectorTest.patchSets ( ) , com.google.gerrit.server.git.GroupCollectorTest.groups ( ) ) ; com.google.common.truth.Truth.assertThat ( groups ) . containsEntry ( a , a.name ( ) ) ; }
private java.util.List < com.google.gerrit.reviewdb.client.AccountGroupById > loadIncludes ( ) throws com.google.gwtorm.server.OrmException { java.util.List < com.google.gerrit.reviewdb.client.AccountGroupById > groups = new java.util.ArrayList < > ( ) ; for ( com.google.gerrit.reviewdb.client.AccountGroupById m : db.accountGroupById ( ) . byGroup ( groupId ) ) { if ( control.canSeeGroup ( ) ) { groups.add ( m ) ; } } return groups ; }
public static java.lang.String toProject ( final com.google.gerrit.reviewdb.Project.NameKey proj , com.google.gerrit.reviewdb.Change.Status status ) { switch ( status ) { case ABANDONED : return ( "project,abandoned," + ( proj.toString ( ) ) ) + ",n,z" ; case MERGED : return ( "project,merged," + ( proj.toString ( ) ) ) + ",n,z" ; case NEW : case SUBMITTED : default : return ( "project,open," + ( proj.toString ( ) ) ) + ",n,z" ; } }
private org.eclipse.jgit.lib.Repository getRepo ( final com.google.gerrit.reviewdb.Change change ) { try { return repoManager.openRepository ( change.getProject ( ) . get ( ) ) ; } catch ( java.lang.Exception ex ) { return null ; } }
private void reindexChanges ( ) throws java.io.IOException { com.google.gerrit.server.index.ChangeIndexer.allAsList ( indexFutures ) . checkedGet ( ) ; }
public static synchronized com.google.gerrit.server.GerritServer getInstance ( ) throws com.google.gwtjsonrpc.server.XsrfException , com.google.gwtorm.client.OrmException { if ( ( com.google.gerrit.server.GerritServer.impl ) == null ) { try { com.google.gerrit.server.GerritServer.impl = new com.google.gerrit.server.GerritServer ( ) ; } catch ( com.google.gwtorm.client.OrmException e ) { e.printStackTrace ( ) ; throw e ; } } return com.google.gerrit.server.GerritServer.impl ; }
void set ( com.google.gerrit.client.info.ChangeInfo info ) { this . changeId = info.legacyId ( ) ; this . project = info.projectNameKey ( ) ; this . canEdit = ( info.hasActions ( ) ) && ( info.actions ( ) . containsKey ( "assignee" ) ) ; setAssignee ( info.assignee ( ) ) ; editAssigneeIcon.setVisible ( canEdit ) ; if ( ! ( canEdit ) ) { show.setTitle ( null ) ; } }
private java.lang.String configurationToString ( ) { java.lang.StringBuilder b = new java.lang.StringBuilder ( ) ; b.append ( "Supermanifest config (" ) . append ( config.size ( ) ) . append ( ") {\n" ) ; for ( com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.ConfigEntry c : config ) { b.append ( " " ) . append ( c ) . append ( "\n" ) ; } b.append ( "}\n" ) ; return b.toString ( ) ; }
public org.kohsuke.github.GitHub login ( com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.AccessToken authToken ) throws java.io.IOException { this . token = authToken ; this . hub = org.kohsuke.github.GitHub.connectUsingOAuth ( authToken.access_token ) ; this . myself = hub.getMyself ( ) ; return this . hub ; }
org.eclipse.jgit.lib.ObjectId getTestAgainst ( ) throws com.google.gwtorm.server.OrmException { if ( ( testAgainst ) == null ) { testAgainst = org.eclipse.jgit.lib.ObjectId.fromString ( new com.google.gerrit.server.query.change.ChangeData ( change ) . currentPatchSet ( db ) . getRevision ( ) . get ( ) ) ; } return testAgainst ; }
public static com.google.gerrit.server.notedb.ChangeBundle fromNotes ( com.google.gerrit.server.PatchLineCommentsUtil plcUtil , com.google.gerrit.server.notedb.ChangeNotes notes ) throws com.google.gwtorm.server.OrmException { return new com.google.gerrit.server.notedb.ChangeBundle ( notes.getChange ( ) , notes.getChangeMessages ( ) , notes.getPatchSets ( ) . values ( ) , notes.getApprovals ( ) . values ( ) , com.google.common.collect.Iterables.concat ( plcUtil.draftByChange ( null , notes ) , plcUtil.publishedByChange ( null , notes ) ) ) ; }
protected byte [ ] indexRowData ( T obj ) { final long now = java.lang.System.currentTimeMillis ( ) ; final com.google.gwtorm.nosql.IndexKeyBuilder b = new com.google.gwtorm.nosql.IndexKeyBuilder ( ) ; encodePrimaryKey ( b , com.google.gwtorm.nosql.generic.GenericAccess.primaryKey ( obj ) ) ; final byte [ ] key = b.toByteArray ( ) ; return IndexRow.CODEC.encodeToByteString ( com.google.gwtorm.nosql.IndexRow.forKey ( now , key ) ) . toByteArray ( ) ; }
com.google.gerrit.server.account.externalids.ExternalId get ( com.google.gerrit.server.account.externalids.ExternalId.Key key , org.eclipse.jgit.lib.ObjectId rev ) throws java.io.IOException , org.eclipse.jgit.errors.ConfigInvalidException { if ( rev.equals ( org.eclipse.jgit.lib.ObjectId.zeroId ( ) ) ) { return null ; } try ( org.eclipse.jgit.lib.Repository repo = repoManager.openRepository ( allUsersName ) ; org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk ( repo ) ) { return com.google.gerrit.server.account.externalids.ExternalIdReader.parse ( key , rw , rev ) ; } }
public void execute ( ) { assert ( selfWidget ) != null ; assert ( widgetManager ) != null ; selfWidget.changed ( ) ; widgetManager.resizePaddingWidget ( ) ; }
private void display ( com.google.gerrit.reviewdb.client.AccountExternalId id ) { java.lang.String user ; java.lang.String pass ; if ( id != null ) { user = id.getSchemeRest ( ) ; pass = id.getPassword ( ) ; } else { user = null ; pass = null ; } this . id = id ; com.google.gerrit.client.Gerrit.getUserAccount ( ) . setUserName ( user ) ; password.setText ( ( pass != null ? pass : "" ) ) ; password.setVisible ( ( pass != null ) ) ; enableUI ( true ) ; }
public static boolean isSqlPrimitive ( final java.lang.Class < ? > type ) { if ( ( type == null ) || ( type == ( java.lang.Void.TYPE ) ) ) { return false ; } if ( type.isPrimitive ( ) ) { return true ; } if ( type == ( java.lang.String.class ) ) { return true ; } return false ; }
void onRestore ( int idx ) { java.lang.String path = list.get ( idx ) . path ( ) ; com.google.gerrit.client.changes.ChangeFileApi.restoreContent ( curr , path , new com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.client.VoidResult > ( ) { @ java.lang.Override public void onSuccess ( com.google.gerrit.client.VoidResult result ) { com.google.gerrit.client.Gerrit.display ( com.google.gerrit.common.PageLinks.toChangeInEditMode ( curr.getParentKey ( ) ) ) ; } @ java.lang.Override public void onFailure ( java.lang.Throwable caught ) { } } ) ; }
private com.google.gerrit.server.account.AccountState missing ( com.google.gerrit.reviewdb.client.Account.Id accountId ) { com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account ( accountId , com.google.gerrit.common.TimeUtil.nowTs ( ) ) ; account.setActive ( false ) ; return new com.google.gerrit.server.account.AccountState ( allUsersName , account , com.google.common.collect.ImmutableSet.of ( ) , com.google.common.base.Suppliers.ofInstance ( com.google.common.collect.ImmutableMap.of ( ) ) , com.google.common.base.Suppliers.ofInstance ( com.google.gerrit.extensions.client.GeneralPreferencesInfo.defaults ( ) ) ) ; }
public void onSuccess ( final java.util.List < com.google.gerrit.reviewdb.AccountSshKey > result ) { keys.display ( result ) ; if ( ( result.isEmpty ( ) ) && ( keys.isVisible ( ) ) ) { showAddKeyBlock ( true ) ; } if ( ( ++ ( loadCount ) ) == 2 ) { display ( ) ; } }
private void initChangeAction ( com.google.gerrit.client.changes.ChangeInfo info , com.google.gerrit.client.rpc.NativeMap < com.google.gerrit.client.actions.ActionInfo > actions ) { if ( ( info.status ( ) ) == ( com.google.gerrit.reviewdb.client.Change.Status.DRAFT ) ) { actions.copyKeysIntoChildren ( "id" ) ; if ( actions.containsKey ( "/" ) ) { deleteChange.setVisible ( true ) ; deleteChange.setTitle ( actions.get ( "/" ) . title ( ) ) ; } } }
private com.google.gerrit.acceptance.server.mail.StagedChange stageChange ( com.google.gerrit.acceptance.server.mail.DeleteReviewerSenderIT.Stager stager ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stager.stage ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS ) ; com.google.gerrit.extensions.api.changes.ReviewInput in = com.google.gerrit.extensions.api.changes.ReviewInput.noScore ( ) . reviewer ( extraReviewer.email ) . reviewer ( extraCcer.email , ReviewerState.CC , false ) ; gApi.changes ( ) . id ( sc.changeId ) . revision ( "current" ) . review ( in ) ; return sc ; }
java.lang.Iterable < com.google.gerrit.reviewdb.client.PatchSetApproval > getForPatchSet ( com.google.gerrit.reviewdb.server.ReviewDb db , com.google.gerrit.server.project.ChangeControl ctl , com.google.gerrit.reviewdb.client.PatchSet.Id psId , java.lang.Iterable < com.google.gerrit.reviewdb.client.PatchSetApproval > dontCopy ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.PatchSet ps = psUtil.get ( db , ctl.getNotes ( ) , psId ) ; if ( ps == null ) { return java.util.Collections.emptyList ( ) ; } return getForPatchSet ( db , ctl , ps , dontCopy ) ; }
protected void assertBadQuery ( com.google.gerrit.extensions.api.changes.Changes.QueryRequest query ) throws java.lang.Exception { try { query.get ( ) ; org.junit.Assert.fail ( ( "expected BadRequestException for query: " + query ) ) ; } catch ( com.google.gerrit.extensions.restapi.BadRequestException e ) { } }
public void delete ( com.google.gerrit.server.query.change.ChangeData cd ) throws java.io.IOException { org.apache.lucene.index.Term id = idTerm ( cd ) ; if ( cd.getChange ( ) . getStatus ( ) . isOpen ( ) ) { openIndex.delete ( id ) ; } else { closedIndex.delete ( id ) ; } }
public int getIssuePatternGroupIndex ( ) { java.util.regex.Pattern pattern = getIssuePattern ( ) ; int groupCount = pattern.matcher ( "" ) . groupCount ( ) ; int index = gerritConfig.getInt ( pluginName , "commentlinkGroupIndex" , 1 ) ; if ( ( index < 0 ) || ( index > groupCount ) ) { index = ( groupCount == 0 ) ? 0 : 1 ; } return index ; }
private java.util.Set < com.google.gerrit.server.change.PostReview.CommentSetEntry > readExistingComments ( com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx ) throws com.google.gwtorm.server.OrmException { java.util.Set < com.google.gerrit.server.change.PostReview.CommentSetEntry > r = new java.util.HashSet < > ( ) ; for ( com.google.gerrit.reviewdb.client.PatchLineComment c : plcUtil.publishedByChange ( ctx.getDb ( ) , ctx.getChangeNotes ( ) ) ) { r.add ( com.google.gerrit.server.change.PostReview.CommentSetEntry.create ( c ) ) ; } return r ; }
protected com.google.gerrit.common.data.PermissionRule block ( java.lang.String permission , com.google.gerrit.reviewdb.client.AccountGroup.UUID id , java.lang.String ref ) throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet ( project ) . getConfig ( ) ; com.google.gerrit.common.data.PermissionRule rule = com.google.gerrit.server.project.Util.block ( cfg , permission , id , ref ) ; saveProjectConfig ( project , cfg ) ; return rule ; }
protected void configure ( ) { com.google.gerrit.extensions.registration.DynamicSet.bind ( binder ( ) , com.google.gerrit.server.git.validators.CommitValidationListener.class ) . to ( com.googlesource.gerrit.plugins.uploadvalidator.SymlinkValidator.class ) ; bind ( com.google.gerrit.server.config.ProjectConfigEntry.class ) . annotatedWith ( com.google.gerrit.extensions.annotations.Exports.named ( com.googlesource.gerrit.plugins.uploadvalidator.SymlinkValidator.KEY_CHECK_SYMLINK ) ) . toInstance ( new com.google.gerrit.server.config.ProjectConfigEntry ( "Reject Symbolic Links" , "false" , ProjectConfigEntry.Type.BOOLEAN , null , false , ( "Symbolic Links. Pushes of commits that include symbolic " + "links will be rejected." ) ) ) ; }
public void changeMessageWithTrailingDoubleNewline ( ) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange ( ) ; com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate ( c , changeOwner ) ; update.setChangeMessage ( ( "Testing trailing double newline\n" + "\n" ) ) ; update.commit ( ) ; assertBodyEquals ( ( "Update patch set 1\n" + ( ( ( ( ( "\n" + "Testing trailing double newline\n" ) + "\n" ) + "\n" ) + "\n" ) + "Patch-set: 1\n" ) ) , update.getResult ( ) ) ; }
public com.google.gerrit.extensions.registration.DynamicSet < T > . ReloadableHandle replace ( com.google.inject.Key < T > newKey , T newItem ) { if ( ref.compareAndSet ( item , newItem ) ) { return new ReloadableHandle ( ref , newKey , newItem ) ; } return null ; }
private java.util.Set < com.google.gerrit.reviewdb.client.AccountGroup.UUID > groupsOf ( com.google.gerrit.reviewdb.client.Account.Id account ) { return userFactory.create ( account ) . getEffectiveGroups ( ) . getKnownGroups ( ) ; }
public void listTasksWithoutViewQueueCapability ( ) throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = userSession.get ( "/config/server/tasks/" ) ; com.google.common.truth.Truth.assertThat ( r.getStatusCode ( ) ) . isEqualTo ( HttpStatus.SC_OK ) ; java.util.List < com.google.gerrit.server.config.ListTasks.TaskInfo > result = newGson ( ) . fromJson ( r.getReader ( ) , new com.google.gson.reflect.TypeToken < java.util.List < com.google.gerrit.server.config.ListTasks.TaskInfo > > ( ) { } . getType ( ) ) ; com.google.common.truth.Truth.assertThat ( result ) . isEmpty ( ) ; }
protected void doUpdate ( final java.lang.Iterable < T > instances , final com.google.gwtorm.jdbc.JdbcTransaction txn ) throws com.google.gwtorm.client.OrmException { try { if ( schema.getDialect ( ) . canDetermineIndividualBatchUpdateCounts ( ) ) { updateAsBatch ( instances ) ; } else { updateIndividually ( instances ) ; } } catch ( java.sql.SQLException e ) { throw convertError ( "update" , e ) ; } }
protected void preDisplay ( com.google.gerrit.client.projects.ConfigInfoCache.Entry result ) { commentManager = new com.google.gerrit.client.diff.UnifiedCommentManager ( this , base , revision , path , result.getCommentLinkProcessor ( ) , getChangeStatus ( ) . isOpen ( ) ) ; setTheme ( result.getTheme ( ) ) ; display ( comments ) ; }
public void onEvent ( com.google.gerrit.server.events.Event event ) { if ( event instanceof com.google.gerrit.server.events.ChangeMergedEvent ) { com.google.gerrit.server.events.ChangeMergedEvent changeMergedEvent = ( ( com.google.gerrit.server.events.ChangeMergedEvent ) ( event ) ) ; mergeResults.put ( changeMergedEvent.change.number , changeMergedEvent.newRev ) ; } }
public void pathOfFixReplacementIsMandatory ( ) throws java.lang.Exception { com.google.common.truth.TruthJUnit.assume ( ) . that ( notesMigration.enabled ( ) ) . isTrue ( ) ; fixReplacementInfo.path = null ; exception.expect ( com.google.gerrit.extensions.restapi.BadRequestException.class ) ; exception.expectMessage ( java.lang.String.format ( ( "A file path must be given for the " + "replacement of the robot comment on %s" ) , withFixRobotCommentInput.path ) ) ; addRobotComment ( changeId , withFixRobotCommentInput ) ; }
com.google.common.hash.Funnel < K > funnel ( ) { return new com.google.common.hash.Funnel < K > ( ) { @ java.lang.Override public void funnel ( K from , com.google.common.hash.PrimitiveSink into ) { try { java.io.ObjectOutputStream ser = new java.io.ObjectOutputStream ( new com.google.gerrit.server.cache.h2.H2CacheImpl.SinkOutputStream ( into ) ) ; ser.writeObject ( from ) ; ser.flush ( ) ; } catch ( java.io.IOException err ) { throw new java.lang.RuntimeException ( "Cannot hash as Serializable" , err ) ; } } } ; }
public boolean execute ( ) { if ( ( prefs.syntaxHighlighting ( ) ) && ( isAttached ( ) ) ) { setSyntaxHighlighting ( prefs.syntaxHighlighting ( ) ) ; } return false ; }
private synchronized com.google.gerrit.testutil.InMemoryRepositoryManager.Repo get ( com.google.gerrit.reviewdb.client.Project.NameKey name ) throws org.eclipse.jgit.errors.RepositoryNotFoundException { com.google.gerrit.testutil.InMemoryRepositoryManager.Repo repo = repos.get ( name.get ( ) . toLowerCase ( ) ) ; if ( repo != null ) { return repo ; } throw new org.eclipse.jgit.errors.RepositoryNotFoundException ( name.get ( ) ) ; }
public org.parboiled.Rule typeOfNote ( ) { return firstOf ( sequence ( string ( "note" ) , push ( DivNode.Style.NOTE ) ) , sequence ( string ( "promo" ) , push ( DivNode.Style.PROMO ) ) , sequence ( string ( "aside" ) , push ( DivNode.Style.ASIDE ) ) ) ; }
public void listOneIncludeMember ( ) throws java.lang.Exception { java.lang.String gx = group ( "gx" , "Administrators" ) ; java.lang.String gy = group ( "gy" , "Administrators" ) ; PUT ( ( ( ( "/groups/" + gx ) + "/groups/" ) + gy ) ) ; com.google.common.truth.Truth.assertThat ( GET_ONE ( ( ( ( "/groups/" + gx ) + "/groups/" ) + gy ) ) . name ) . isEqualTo ( gy ) ; }
public java.lang.String get ( ) { java.lang.String canonicalUrl = super . get ( ) ; if ( canonicalUrl != null ) { return canonicalUrl ; } if ( ( requestProvider ) != null ) { final javax.servlet.http.HttpServletRequest req ; try { req = requestProvider.get ( ) ; } catch ( com.google.inject.ProvisionException noWeb ) { if ( ( noWeb.getCause ( ) ) instanceof com.google.inject.OutOfScopeException ) { return null ; } throw noWeb ; } return com.google.gerrit.httpd.CanonicalWebUrl.computeFromRequest ( req ) ; } return null ; }
public java.lang.Object apply ( com.google.gerrit.server.group.GroupResource resource , com.google.gerrit.server.group.PutMembers.PutMember.Input input ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.extensions.restapi.BadRequestException , com.google.gerrit.extensions.restapi.MethodNotAllowedException , com.google.gwtorm.server.OrmException { com.google.gerrit.server.group.PutMembers.Input in = new com.google.gerrit.server.group.PutMembers.Input ( ) ; in._oneMember = id ; java.util.List < com.google.gerrit.server.group.MembersCollection.MemberInfo > list = put.get ( ) . apply ( resource , in ) ; if ( list.isEmpty ( ) ) { return com.google.gerrit.extensions.restapi.Response.none ( ) ; } else if ( ( list.size ( ) ) == 1 ) { return list.get ( 0 ) ; } else { throw new java.lang.IllegalStateException ( ) ; } }
public com.google.gitiles.doc.html.HtmlBuilder close ( java.lang.String tag ) { com.google.common.base.Preconditions.checkArgument ( ( ( com.google.gitiles.doc.html.HtmlBuilder.ALLOWED_TAGS.contains ( tag ) ) && ( ! ( com.google.gitiles.doc.html.HtmlBuilder.SELF_CLOSING_TAGS.contains ( tag ) ) ) ) , "invalid HTML tag %s" , tag ) ; finishActiveTag ( ) ; htmlBuf.append ( "</" ) . append ( tag ) . append ( '>' ) ; return this ; }
private static com.google.gerrit.client.reviewdb.AccountExternalId lookupGoogleAccount ( final com.google.gerrit.client.reviewdb.AccountExternalIdAccess extAccess , final java.lang.String email ) throws com.google.gwtorm.client.OrmException { final java.util.List < com.google.gerrit.client.reviewdb.AccountExternalId > m = new java.util.ArrayList < com.google.gerrit.client.reviewdb.AccountExternalId > ( ) ; for ( final com.google.gerrit.client.reviewdb.AccountExternalId e : extAccess.byEmailAddress ( email ) ) { if ( e.getExternalId ( ) . equals ( OpenIdUtil.URL_GOOGLE ) ) { m.add ( e ) ; } } return ( m.size ( ) ) == 1 ? m.get ( 0 ) : null ; }
protected void configure ( ) { bind ( com.google.gerrit.server.cache.h2.DefaultCacheFactory.class ) ; bind ( com.google.gerrit.server.cache.MemoryCacheFactory.class ) . to ( com.google.gerrit.server.cache.h2.DefaultCacheFactory.class ) ; bind ( com.google.gerrit.server.cache.PersistentCacheFactory.class ) . to ( com.google.gerrit.server.cache.h2.H2CacheFactory.class ) ; listener ( ) . to ( com.google.gerrit.server.cache.h2.H2CacheFactory.class ) ; }
public boolean isReviewer ( com.google.gerrit.reviewdb.server.ReviewDb db , @ com.google.gerrit.common.Nullable com.google.gerrit.server.query.change.ChangeData cd ) throws com.google.gwtorm.server.OrmException { if ( getCurrentUser ( ) . isIdentifiedUser ( ) ) { java.util.Collection < com.google.gerrit.reviewdb.client.Account.Id > results = ( cd != null ) ? cd.reviewers ( ) . values ( ) : approvalsUtil.getReviewers ( db , change.getId ( ) ) . values ( ) ; com.google.gerrit.server.IdentifiedUser user = ( ( com.google.gerrit.server.IdentifiedUser ) ( getCurrentUser ( ) ) ) ; return results.contains ( user.getAccountId ( ) ) ; } return false ; }
private static java.util.List < java.lang.reflect.Method > getConfigs ( java.lang.Class < ? > clazz ) { java.util.List < java.lang.reflect.Method > result = com.google.common.collect.Lists.newArrayListWithExpectedSize ( 3 ) ; for ( java.lang.reflect.Method m : clazz.getMethods ( ) ) { com.google.gerrit.testutil.ConfigSuite.Config ann = m.getAnnotation ( com.google.gerrit.testutil.ConfigSuite.Config.class ) ; if ( ann != null ) { com.google.common.base.Preconditions.checkArgument ( ( ! ( m.getName ( ) . equals ( com.google.gerrit.testutil.ConfigSuite.DEFAULT ) ) ) , "@ConfigSuite.Config cannot be named %s" , com.google.gerrit.testutil.ConfigSuite.DEFAULT ) ; result.add ( m ) ; } } return result ; }
protected java.lang.String getNameFor ( final com.google.gerrit.reviewdb.client.Account.Id accountId ) { if ( accountId == null ) { return args.anonymousCowardName ; } final com.google.gerrit.reviewdb.client.Account userAccount = args.accountCache.get ( accountId ) . getAccount ( ) ; java.lang.String name = userAccount.getFullName ( ) ; if ( name == null ) { name = userAccount.getPreferredEmail ( ) ; } if ( name == null ) { name = ( ( args.anonymousCowardName ) + " #" ) + accountId ; } return name ; }
private org.apache.lucene.index.Term idTerm ( com.google.gerrit.server.query.change.ChangeData cd ) { return intTerm ( com.google.gerrit.server.query.change.ChangeQueryBuilder.FIELD_CHANGE , cd.getId ( ) . get ( ) ) ; }
private org.kohsuke.args4j.spi.OptionHandler findHandler ( java.lang.String name ) { for ( org.kohsuke.args4j.spi.OptionHandler handler : parser.options ) { if ( ( handler.option ) instanceof org.kohsuke.args4j.NamedOptionDef ) { org.kohsuke.args4j.NamedOptionDef def = ( ( org.kohsuke.args4j.NamedOptionDef ) ( handler.option ) ) ; if ( name.equals ( def.name ( ) ) ) { return handler ; } for ( java.lang.String alias : def.aliases ( ) ) { if ( name.equals ( alias ) ) { return handler ; } } } } return null ; }
java.util.List < java.lang.String > getValues ( int row ) { java.util.List < java.lang.String > v = new java.util.ArrayList < > ( ) ; for ( int i = 0 ; i < ( inputs.size ( ) ) ; i ++ ) { v.add ( table.getText ( row , ( i + 1 ) ) ) ; } return v ; }
public final java.util.List < com.google.gerrit.reviewdb.client.Account.FieldName > editableAccountFields ( ) { java.util.List < com.google.gerrit.reviewdb.client.Account.FieldName > fields = new java.util.ArrayList < > ( ) ; for ( com.google.gerrit.client.config.AuthInfo.AccountFieldNameInfo f : com.google.gerrit.client.rpc.Natives.asList ( _editableAccountFields ( ) ) ) { fields.add ( f.get ( ) ) ; } return fields ; }
private void insertNoneRow ( final int row ) { insertRow ( row ) ; table.setText ( row , 0 , Util.C.changeTableNone ( ) ) ; final com.google.gwt.user.client.ui.FlexTable.FlexCellFormatter fmt = table.getFlexCellFormatter ( ) ; fmt.setColSpan ( row , 0 , com.google.gerrit.client.changes.ChangeTable.COLUMNS ) ; fmt.setStyleName ( row , 0 , com.google.gerrit.client.changes.ChangeTable.S_EMPTY_SECTION ) ; }
public com.google.gerrit.extensions.registration.RegistrationHandle put ( java.lang.String pluginName , java.lang.String exportName , final T item ) { final com.google.gerrit.extensions.registration.NamePair key = new com.google.gerrit.extensions.registration.NamePair ( pluginName , exportName ) ; items.put ( key , item ) ; return new com.google.gerrit.extensions.registration.RegistrationHandle ( ) { @ java.lang.Override public void remove ( ) { items.remove ( key , item ) ; } } ; }
public java.util.List < com.google.gerrit.server.update.BatchUpdate > batchUpdates ( com.google.gerrit.server.update.BatchUpdate.Factory batchUpdateFactory , java.util.Collection < com.google.gerrit.reviewdb.client.Project.NameKey > projects ) throws com.google.gerrit.server.project.NoSuchProjectException , java.io.IOException { java.util.List < com.google.gerrit.server.update.BatchUpdate > updates = new java.util.ArrayList ( projects.size ( ) ) ; for ( com.google.gerrit.reviewdb.client.Project.NameKey project : projects ) { updates.add ( getRepo ( project ) . getUpdate ( batchUpdateFactory ) ) ; } return updates ; }
public void commentOnReviewableChangeByReviewer ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS ) ; review ( sc.reviewer , sc.changeId , com.google.gerrit.extensions.client.GeneralPreferencesInfo.EmailStrategy.ENABLED ) ; assertThat ( sender ) . sent ( "comment" , sc ) . notTo ( sc.reviewer ) . to ( sc.owner ) . cc ( sc.ccer ) . cc ( sc.reviewerByEmail , sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS ) ; }
public void testUpsertOneNotExisting ( ) throws com.google.gwtorm.client.OrmException , java.sql.SQLException { stubExecuteBatchOK ( com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE ) ; java.sql.PreparedStatement insert = stubExecuteBatchOK ( com.google.gwtorm.jdbc.TestJdbcAccess.INSERT , 1 ) ; createClassUnderTest ( ) . upsert ( com.google.gwtorm.jdbc.TestJdbcAccess.ONE_ROW ) ; verifyIds ( insert , 1 ) ; }
private com.google.gerrit.common.data.LabelTypes getLabelTypes ( ) throws java.lang.Exception { db.create ( ) ; com.google.gerrit.server.config.AllProjectsName allProjects = db.getInstance ( com.google.gerrit.server.config.AllProjectsName.class ) ; com.google.gerrit.server.git.ProjectConfig c = new com.google.gerrit.server.git.ProjectConfig ( allProjects ) ; org.eclipse.jgit.lib.Repository repo = db.getInstance ( com.google.gerrit.server.git.GitRepositoryManager.class ) . openRepository ( allProjects ) ; try { c.load ( repo ) ; return new com.google.gerrit.common.data.LabelTypes ( com.google.common.collect.ImmutableList.copyOf ( c.getLabelSections ( ) . values ( ) ) ) ; } finally { repo.close ( ) ; } }
public com.google.gerrit.extensions.restapi.Response < java.lang.String > apply ( com.google.gerrit.server.config.CacheResource rsrc , com.google.gerrit.server.config.FlushCache.Input input ) throws com.google.gerrit.extensions.restapi.AuthException { if ( ( com.google.gerrit.server.config.FlushCache.WEB_SESSIONS.equals ( rsrc.getName ( ) ) ) && ( ! ( self.get ( ) . getCapabilities ( ) . canMaintainServer ( ) ) ) ) { throw new com.google.gerrit.extensions.restapi.AuthException ( java.lang.String.format ( "only site maintainers can flush %s" , com.google.gerrit.server.config.FlushCache.WEB_SESSIONS ) ) ; } rsrc.getCache ( ) . invalidateAll ( ) ; return com.google.gerrit.extensions.restapi.Response.ok ( "" ) ; }
private org.eclipse.jgit.revwalk.RevCommit makeCommit ( ) throws java.io.IOException , org.eclipse.jgit.api.errors.GitAPIException , org.eclipse.jgit.api.errors.NoFilepatternException { java.util.Map < java.io.File , byte [ ] > files = new java.util.HashMap < > ( ) ; java.lang.String content = "http://foo.bar.tld/?pw=myp4ssw0rdTefoobarstline2\n" ; files.put ( new java.io.File ( repo.getDirectory ( ) . getParent ( ) , "foo.txt" ) , content.getBytes ( java.nio.charset.StandardCharsets.UTF_8 ) ) ; content = "$Id$\n" + ( ( ( "$Header$\n" + "$Author$\n" ) + "processXFile($File::Find::name, $Config{$type});\n" ) + "$Id: bla bla bla$\n" ) ; files.put ( new java.io.File ( repo.getDirectory ( ) . getParent ( ) , "bar.txt" ) , content.getBytes ( java.nio.charset.StandardCharsets.UTF_8 ) ) ; content = "Testline1\n" + ( ( "Testline2\n" + "Testline3\n" ) + "Testline4" ) ; files.put ( new java.io.File ( repo.getDirectory ( ) . getParent ( ) , "foobar.txt" ) , content.getBytes ( java.nio.charset.StandardCharsets.UTF_8 ) ) ; return com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.makeCommit ( repo , "Commit with test files." , files ) ; }
private void approve ( java.lang.String changeId ) throws java.io.IOException { com.google.gerrit.acceptance.RestResponse r = adminSession.post ( ( ( "/changes/" + changeId ) + "/revisions/current/review" ) , new com.google.gerrit.extensions.api.changes.ReviewInput ( ) . label ( "Code-Review" , 2 ) ) ; com.google.common.truth.Truth.assertThat ( r.getStatusCode ( ) ) . isEqualTo ( HttpStatus.SC_OK ) ; r.consume ( ) ; }
private static java.util.Collection < com.google.gerrit.reviewdb.client.AccountSshKey > toAccountSshKey ( com.google.gerrit.server.account.AccountState a , java.util.List < com.google.gerrit.extensions.common.SshKeyInfo > sshKeys ) { java.util.Collection < com.google.gerrit.reviewdb.client.AccountSshKey > result = new java.util.HashSet < > ( ) ; int index = 1 ; for ( com.google.gerrit.extensions.common.SshKeyInfo sshKeyInfo : sshKeys ) { result.add ( new com.google.gerrit.reviewdb.client.AccountSshKey ( new com.google.gerrit.reviewdb.client.AccountSshKey.Id ( a.getAccount ( ) . getId ( ) , ( index ++ ) ) , sshKeyInfo.sshPublicKey ) ) ; } return result ; }
public com.google.gerrit.extensions.common.ChangeInfo apply ( com.google.gerrit.server.change.ChangeResource req , com.google.gerrit.extensions.api.changes.AbandonInput input ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.git.UpdateException , com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl control = req.getControl ( ) ; if ( ! ( control.canAbandon ( dbProvider.get ( ) ) ) ) { throw new com.google.gerrit.extensions.restapi.AuthException ( "abandon not permitted" ) ; } com.google.gerrit.reviewdb.client.Change change = abandon ( control , input.message , input.notify ) ; return json.create ( ChangeJson.NO_OPTIONS ) . format ( change ) ; }
public void mergeByReviewer ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS , com.google.gerrit.server.account.WatchConfig.NotifyType.SUBMITTED_CHANGES ) ; merge ( sc.changeId , sc.reviewer ) ; assertThat ( sender ) . sent ( "merged" , sc ) . notTo ( sc.reviewer ) . to ( sc.owner ) . cc ( sc.ccer ) . cc ( sc.reviewerByEmail , sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS , com.google.gerrit.server.account.WatchConfig.NotifyType.SUBMITTED_CHANGES ) ; }
private java.lang.String getPullUrl ( ) { final java.util.List < com.jcraft.jsch.HostKey > hostKeys = sshInfo.getHostKeys ( ) ; if ( hostKeys.isEmpty ( ) ) { return "" ; } final java.lang.String host = hostKeys.get ( 0 ) . getHost ( ) ; final java.lang.StringBuilder r = new java.lang.StringBuilder ( ) ; r.append ( "git pull ssh://" ) ; if ( host.startsWith ( "*:" ) ) { r.append ( getGerritHost ( ) ) ; r.append ( host.substring ( 1 ) ) ; } else { r.append ( host ) ; } r.append ( "/" ) ; r.append ( projectName ) ; r.append ( " " ) ; r.append ( patchSet.getRefName ( ) ) ; return r.toString ( ) ; }
private void openlink ( final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder m , final int colspan ) { m.openTd ( ) ; m.addStyleName ( com.google.gerrit.client.changes.S_DATA_CELL ) ; m.addStyleName ( "DiffLinkCell" ) ; m.setAttribute ( "colspan" , colspan ) ; }
private java.lang.String deserializerFor ( com.google.gwt.core.ext.typeinfo.JArrayType targetType ) { final com.google.gwt.core.ext.typeinfo.JType componentType = targetType.getComponentType ( ) ; if ( com.google.gwtjsonrpc.rebind.SerializerCreator.isBoxedPrimitive ( componentType ) ) return ( ( ( com.google.gwtjsonrpc.client.PrimitiveArrayResultDeserializers.class . getCanonicalName ( ) ) + "." ) + ( componentType.getSimpleSourceName ( ) . toUpperCase ( ) ) ) + "_INSTANCE" ; final java.lang.String name = generatedDeserializers.get ( targetType.getQualifiedSourceName ( ) ) ; return name == null ? null : name + ".INSTANCE" ; }
private < K , V > java.util.Map < K , V > limitToExistingPatchSets ( java.util.Map < K , V > in , final com.google.common.base.Function < K , com.google.gerrit.reviewdb.client.PatchSet.Id > func ) { return com.google.common.collect.Maps.filterKeys ( in , new com.google.common.base.Predicate < K > ( ) { @ java.lang.Override public boolean apply ( K in ) { return patchSets.containsKey ( func.apply ( in ) ) ; } } ) ; }
public void groupNameNoteIsMissing ( ) throws java.lang.Exception { updateGroupNamesRef ( "g-2" , "[group]\n\tuuid = uuid-2\n\tname = g-2\n" ) ; java.util.List < com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo > problems = com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.checkWithGroupNameNotes ( allUsersRepo , "g-1" , new com.google.gerrit.reviewdb.client.AccountGroup.UUID ( "uuid-1" ) ) ; com.google.common.truth.Truth.assertThat ( problems ) . containsExactly ( com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo.warning ( "Group with name 'g-1' doesn't exist in the list of all names" ) ) ; }
private boolean canEditTopicName ( ) { if ( getChange ( ) . getStatus ( ) . isOpen ( ) ) { return ( ( ( ( isOwner ( ) ) || ( getRefControl ( ) . isOwner ( ) ) ) || ( getProjectControl ( ) . isOwner ( ) ) ) || ( getRefControl ( ) . canEditTopicName ( ) ) ) || ( getProjectControl ( ) . isAdmin ( ) ) ; } return getRefControl ( ) . canForceEditTopicName ( ) ; }
public void newPatchSetByOtherOnReviewableChangeNotifyOwnerInReviewDb ( ) throws java.lang.Exception { com.google.common.truth.TruthJUnit.assume ( ) . that ( notesMigration.readChanges ( ) ) . isFalse ( ) ; com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.NEW_PATCHSETS ) ; pushTo ( sc , "refs/for/master%notify=OWNER" , other ) ; assertThat ( sender ) . sent ( "newpatchset" , sc ) . to ( sc.reviewer , sc.ccer ) . notTo ( sc.owner , sc.starrer , other ) . notTo ( sc.reviewerByEmail , sc.ccerByEmail ) . notTo ( com.google.gerrit.server.account.WatchConfig.NotifyType.NEW_PATCHSETS ) ; }
private void grantApproveToChangeOwner ( ) throws java.lang.Exception { grantLabel ( ( ( com.google.gerrit.common.data.Permission.LABEL ) + "Code-Review" ) , ( - 2 ) , 2 , project , "refs/heads/*" , false , SystemGroupBackend.CHANGE_OWNER ) ; }
public void testExecuteItem ( ) throws java.io.IOException { com.googlesource.gerrit.plugins.hooks.workflow.ActionRequest actionRequest = createMock ( com.googlesource.gerrit.plugins.hooks.workflow.ActionRequest.class ) ; org.easymock.EasyMock.expect ( actionRequest.getUnparsed ( ) ) . andReturn ( "unparsed action 1" ) ; its.performAction ( "4711" , "unparsed action 1" ) ; replayMocks ( ) ; com.googlesource.gerrit.plugins.hooks.workflow.ActionExecutor actionExecutor = createActionExecutor ( ) ; actionExecutor.execute ( "4711" , actionRequest ) ; }
public com.google.gerrit.acceptance.RestResponse post ( java.lang.String endPoint , java.lang.Object content ) throws java.io.IOException { org.apache.http.client.fluent.Request post = org.apache.http.client.fluent.Request.Post ( ( ( ( url ) + "/a" ) + endPoint ) ) ; if ( content != null ) { post.addHeader ( new org.apache.http.message.BasicHeader ( "Content-Type" , "application/json" ) ) ; post.body ( new org.apache.http.entity.StringEntity ( OutputFormat.JSON_COMPACT.newGson ( ) . toJson ( content ) , java.nio.charset.StandardCharsets.UTF_8 ) ) ; } return execute ( post ) ; }
protected com.google.gerrit.acceptance.PushOneCommit.Result pushTo ( java.lang.String ref ) throws com.google.gerrit.acceptance.GitAPIException , java.io.IOException { com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create ( db , admin.getIdent ( ) ) ; return push.to ( git , ref ) ; BRANCH ( 4 ) ; com.google.gerrit.acceptance.bc067 Show ; com.google.gerrit.acceptance.change status ; draft ( sets ) ; }
public void shouldFailWithFilesWithoutPatchSetsOrCurrentPatchSetsOption ( ) throws java.lang.Exception { java.lang.String changeId = createChange ( ) . getChangeId ( ) ; sshSession.exec ( ( "gerrit query --files " + changeId ) ) ; com.google.common.truth.Truth.assertThat ( sshSession.hasError ( ) ) . isTrue ( ) ; com.google.common.truth.Truth.assertThat ( sshSession.getError ( ) ) . contains ( "needs --patch-sets or --current-patch-set" ) ; }
public void testUnblockRangeForNotChangeOwner ( ) { com.google.gerrit.server.project.Util.grant ( local , ( ( com.google.gerrit.common.data.Permission.LABEL ) + "Code-Review" ) , ( - 2 ) , ( + 2 ) , com.google.gerrit.server.project.Util.CHANGE_OWNER , "refs/heads/*" ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.project.Util.DEVS ) ; com.google.gerrit.common.data.PermissionRange range = u.controlForRef ( "refs/heads/master" ) . getRange ( ( ( com.google.gerrit.common.data.Permission.LABEL ) + "Code-Review" ) ) ; org.junit.Assert.assertFalse ( "u can vote -2" , range.contains ( ( - 2 ) ) ) ; org.junit.Assert.assertFalse ( "u can vote +2" , range.contains ( 2 ) ) ; }
void onKeyDownInput ( com.google.gwt.event.dom.client.KeyDownEvent e ) { if ( ( e.getNativeKeyCode ( ) ) == ( com.google.gwt.event.dom.client.KeyCodes.KEY_ESCAPE ) ) { onCancel ( null ) ; } else if ( ( e.getNativeKeyCode ( ) ) == ( com.google.gwt.event.dom.client.KeyCodes.KEY_ENTER ) ) { onSave ( null ) ; } }
public static org.eclipse.jgit.transport.PushResult deleteRef ( org.eclipse.jgit.junit.TestRepository < ? > testRepo , java.lang.String ref ) throws org.eclipse.jgit.api.errors.GitAPIException { return com.google.gerrit.acceptance.GitUtil.pushOne ( testRepo , "" , ref , false , true , null ) ; }
public static java.lang.String shortestExample ( java.lang.String pattern ) { if ( pattern.startsWith ( RefRight.REGEX_PREFIX ) ) { return com.google.gerrit.server.project.RefControl.toRegExp ( pattern ) . toAutomaton ( ) . getShortestExample ( true ) ; } else if ( pattern.endsWith ( "/*" ) ) { return ( pattern.substring ( 0 , ( ( pattern.length ( ) ) - 1 ) ) ) + '1' ; } else { return pattern ; } }
void onDiscard ( com.google.gwt.event.dom.client.ClickEvent e ) { e.stopPropagation ( ) ; if ( isNew ( ) ) { removeUI ( ) ; } else { setEdit ( false ) ; com.google.gerrit.client.changes.CommentApi.deleteDraft ( psId , comment.id ( ) , new com.google.gerrit.client.rpc.GerritCallback < com.google.gwt.core.client.JavaScriptObject > ( ) { @ java.lang.Override public void onSuccess ( com.google.gwt.core.client.JavaScriptObject result ) { removeUI ( ) ; } } ) ; } }
public void tearDown ( ) { if ( ( repo ) != null ) { repo.getRepository ( ) . close ( ) ; } if ( ( lifecycle ) != null ) { lifecycle.stop ( ) ; } requestContext.setContext ( null ) ; if ( ( db ) != null ) { db.close ( ) ; } com.google.gerrit.testutil.InMemoryDatabase.drop ( schemaFactory ) ; }
public com.google.gerrit.server.plugins.ListPlugins.PluginInfo apply ( com.google.gerrit.server.plugins.PluginResource resource , com.google.gerrit.server.plugins.DisablePlugin.Input input ) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException { if ( ! ( loader.isRemoteAdminEnabled ( ) ) ) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException ( "remote plugin administration is disabled" ) ; } java.lang.String name = resource.getName ( ) ; loader.disablePlugins ( com.google.common.collect.ImmutableSet.of ( name ) ) ; return new com.google.gerrit.server.plugins.ListPlugins.PluginInfo ( loader.get ( name ) ) ; }
public void parseMultipleValue ( ) throws java.lang.Exception { java.lang.String in = "a.b=c,d,e" ; java.util.Map < java.lang.String , java.util.Map < java.lang.String , com.google.gerrit.extensions.api.projects.ProjectInput.ConfigValue > > r = cmd.parsePluginConfigValues ( java.util.Collections.singletonList ( in ) ) ; com.google.gerrit.extensions.api.projects.ProjectInput.ConfigValue configValue = r.get ( "a" ) . get ( "b" ) ; org.junit.Assert.assertArrayEquals ( new java.lang.String [ ] { "c" , "d" , "e" } , configValue.values.toArray ( ) ) ; org.junit.Assert.assertNull ( configValue.value ) ; }
public void topic ( java.lang.String topic ) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.change.PutTopic.Input in = new com.google.gerrit.server.change.PutTopic.Input ( ) ; in.topic = topic ; try { putTopic.apply ( change , in ) ; } catch ( com.google.gerrit.server.git.UpdateException | com.google.gerrit.server.permissions.PermissionBackendException e ) { throw new com.google.gerrit.extensions.restapi.RestApiException ( "Cannot set topic" , e ) ; } }
private org.eclipse.jgit.transport.PushResult pushVia ( final org.eclipse.jgit.transport.Transport tn ) throws java.io.IOException , org.eclipse.jgit.errors.NotSupportedException , org.eclipse.jgit.errors.TransportException { tn.applyConfig ( config ) ; final java.util.List < org.eclipse.jgit.transport.RemoteRefUpdate > todo = generateUpdates ( tn ) ; if ( todo.isEmpty ( ) ) { return new org.eclipse.jgit.transport.PushResult ( ) ; } return tn.push ( NullProgressMonitor.INSTANCE , todo ) ; }
boolean inCharacter ( com.googlecode.prolog_cafe.builtin.Term t ) { if ( ! ( t instanceof com.googlecode.prolog_cafe.builtin.SymbolTerm ) ) return false ; if ( t.equals ( com.googlecode.prolog_cafe.builtin.PRED_get_char_2.SYM_EOF ) ) return true ; return ( ( ( com.googlecode.prolog_cafe.builtin.SymbolTerm ) ( t ) ) . name ( ) . length ( ) ) == 1 ; }
public static < T > java.util.LinkedHashSet < T > topoSort ( com.google.common.collect.Multimap < T , T > graph ) throws com.google.gerrit.server.git.SubmoduleException { java.util.LinkedHashSet < T > sorted = new java.util.LinkedHashSet < > ( ) ; for ( T p : graph.keySet ( ) ) { if ( ! ( sorted.contains ( p ) ) ) { com.google.gerrit.server.git.SubmoduleOp.topoSortHelper ( p , new java.util.HashSet < T > ( ) , sorted , graph ) ; } } return sorted ; }
public void testUnblockForce ( ) { com.google.gerrit.common.data.PermissionRule r = com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/heads/*" ) ; r.setBlock ( ) ; r.setForce ( true ) ; com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.Util.DEVS , "refs/heads/*" ) . setForce ( true ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.project.Util.DEVS ) ; org.junit.Assert.assertTrue ( "u can force push" , u.controlForRef ( "refs/heads/master" ) . canForceUpdate ( ) ) ; }
public java.util.Set < com.google.gerrit.reviewdb.client.AccountGroup.UUID > getOwners ( ) { com.google.gerrit.reviewdb.client.Project.NameKey parentName = getProject ( ) . getParent ( ) ; if ( ( ( ! ( localOwners.isEmpty ( ) ) ) || ( parentName == null ) ) || ( isAllProjects ) ) { return localOwners ; } com.google.gerrit.server.project.ProjectState parent = projectCache.get ( parentName ) ; if ( parent != null ) { return parent.getOwners ( ) ; } return java.util.Collections.emptySet ( ) ; }
public void content ( ) throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange ( ) ; com.google.gerrit.extensions.restapi.BinaryResult bin = gApi.changes ( ) . id ( r.getChangeId ( ) ) . revision ( r.getCommit ( ) . name ( ) ) . file ( com.google.gerrit.acceptance.PushOneCommit.FILE_NAME ) . content ( ) ; java.io.ByteArrayOutputStream os = new java.io.ByteArrayOutputStream ( ) ; bin.writeTo ( os ) ; java.lang.String res = new java.lang.String ( os.toByteArray ( ) , java.nio.charset.StandardCharsets.UTF_8 ) ; com.google.common.truth.Truth.assertThat ( res ) . isEqualTo ( com.google.gerrit.acceptance.PushOneCommit.FILE_CONTENT ) ; }
public void generatesExpectedMessage ( ) throws java.lang.Exception { mockEvent.change = mockChange ; mockEvent.author = mockAccount ; mockEvent.comment = "This is the first line\nAnd the second line." ; mockChange.project = "testproject" ; mockChange.branch = "master" ; mockChange.url = "https://change/" ; mockAccount.name = "Unit Tester" ; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator ; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance ( mockEvent , config ) ; java.lang.String expectedResult ; expectedResult = "{\"text\": \"Unit Tester commented\\n>>>" + ( ( "testproject (master): This is the first line\n" + "And the second line. (https://change/)\"," ) + "\"channel\": \"#testchannel\",\"username\": \"testuser\"}\n" ) ; java.lang.String actualResult ; actualResult = messageGenerator.generate ( ) ; org.junit.Assert.assertThat ( actualResult , org.hamcrest.core.Is.is ( org.hamcrest.CoreMatchers.equalTo ( expectedResult ) ) ) ; }
private boolean isLive ( final java.io.File entry ) { final java.lang.String name = entry.getName ( ) ; return ( ( ( ErrorLogFile.LOG_NAME.equals ( name ) ) || ( "sshd_log" . equals ( name ) ) ) || ( "httpd_log" . equals ( name ) ) ) || ( name.endsWith ( ".pid" ) ) ; }
public void testIsEnabledCommentAddedEvent ( ) { java.lang.String [ ] branches = new java.lang.String [ ] { } ; setupIsEnabled ( "true" , null , branches ) ; com.google.gerrit.server.events.CommentAddedEvent event = new com.google.gerrit.server.events.CommentAddedEvent ( ) ; event.change = new com.google.gerrit.server.data.ChangeAttribute ( ) ; event.change.project = "testProject" ; event.change.branch = "testBranch" ; com.googlesource.gerrit.plugins.its.base.its.ItsConfig itsConfig = createItsConfig ( ) ; replayMocks ( ) ; assertTrue ( itsConfig.isEnabled ( event ) ) ; }
private Account.Id parseIdent ( org.eclipse.jgit.revwalk.RevCommit commit ) throws org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String email = commit.getCommitterIdent ( ) . getEmailAddress ( ) ; int at = email.indexOf ( '@' ) ; if ( at >= 0 ) { java.lang.String host = email.substring ( ( at + 1 ) , email.length ( ) ) ; java.lang.Integer id = com.google.common.primitives.Ints.tryParse ( email.substring ( 0 , at ) ) ; if ( ( id != null ) && ( host.equals ( com.google.gerrit.server.notedb.ChangeNoteUtil.GERRIT_PLACEHOLDER_HOST ) ) ) { return new com.google.gerrit.reviewdb.client.Account.Id ( id ) ; } } throw parseException ( "invalid committer, expected <id>@%s: %s" , com.google.gerrit.server.notedb.ChangeNoteUtil.GERRIT_PLACEHOLDER_HOST , email ) ; }
private java.util.Map < java.lang.String , com.google.gerrit.reviewdb.client.PatchLineComment > patchSetDrafts ( com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx ) throws com.google.gwtorm.server.OrmException { java.util.Map < java.lang.String , com.google.gerrit.reviewdb.client.PatchLineComment > drafts = com.google.common.collect.Maps.newHashMap ( ) ; for ( com.google.gerrit.reviewdb.client.PatchLineComment c : plcUtil.draftByPatchSetAuthor ( ctx.getDb ( ) , psId , user.getAccountId ( ) , ctx.getChangeNotes ( ) ) ) { drafts.put ( c.getKey ( ) . get ( ) , c ) ; } return drafts ; }
public com.google.gerrit.server.git.InsertException apply ( java.lang.Exception input ) { if ( input instanceof com.google.gwtorm.server.OrmException ) { return new com.google.gerrit.server.git.InsertException ( "ORM error" , input ) ; } if ( input instanceof java.io.IOException ) { return new com.google.gerrit.server.git.InsertException ( "IO error" , input ) ; } return new com.google.gerrit.server.git.InsertException ( "Error inserting change/patchset" , input ) ; }
public com.google.gerrit.extensions.client.ChangeKind getChangeKind ( com.google.gerrit.reviewdb.client.Project.NameKey project , @ com.google.gerrit.common.Nullable org.eclipse.jgit.lib.Repository repo , @ com.google.gerrit.common.Nullable org.eclipse.jgit.revwalk.RevWalk rw , org.eclipse.jgit.lib.ObjectId prior , org.eclipse.jgit.lib.ObjectId next ) { try { com.google.gerrit.server.change.ChangeKindCacheImpl.Key key = new com.google.gerrit.server.change.ChangeKindCacheImpl.Key ( prior , next , useRecursiveMerge ) ; return cache.get ( key , new com.google.gerrit.server.change.ChangeKindCacheImpl.Loader ( key , repoManager , project , repo , rw ) ) ; } catch ( java.util.concurrent.ExecutionException e ) { com.google.gerrit.server.change.ChangeKindCacheImpl.log.warn ( ( ( ( "Cannot check trivial rebase of new patch set " + ( next.name ( ) ) ) + " in " ) + project ) , e ) ; return com.google.gerrit.extensions.client.ChangeKind.REWORK ; } }
public void createProject ( ) throws java.lang.Exception { java.lang.String name = name ( "foo" ) ; com.google.common.truth.Truth.assertThat ( gApi.projects ( ) . create ( name ) . get ( ) . name ) . isEqualTo ( name ) ; org.eclipse.jgit.revwalk.RevCommit head = getRemoteHead ( name , RefNames.REFS_CONFIG ) ; eventRecorder.assertRefUpdatedEvents ( name , RefNames.REFS_CONFIG , null , head ) ; eventRecorder.assertRefUpdatedEvents ( name , "refs/heads/master" , new java.lang.String [ ] { } ) ; }
public void abandonWipChangeNotifyAll ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageWipChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.ABANDONED_CHANGES ) ; abandon ( sc.changeId , sc.owner , com.google.gerrit.extensions.api.changes.NotifyHandling.ALL ) ; assertThat ( sender ) . sent ( "abandon" , sc ) . notTo ( sc.owner ) . cc ( sc.reviewer , sc.ccer ) . cc ( sc.reviewerByEmail , sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.ABANDONED_CHANGES ) ; }
void audit ( com.google.gerrit.sshd.SshScope.Context ctx , java.lang.Object result , java.lang.String commandName , java.lang.String [ ] args ) { final java.lang.String sid = extractSessionId ( ctx ) ; final long created = extractCreated ( ctx ) ; final java.lang.String what = extractWhat ( commandName , args ) ; auditService.dispatch ( new com.google.gerrit.audit.AuditEvent ( sid , extractCurrentUser ( ctx ) , ( "ssh:" + what ) , created , java.util.Arrays.asList ( args ) , result ) ) ; }
protected void configure ( ) { install ( new com.google.gerrit.server.index.IndexModule ( threads ) ) ; bind ( ChangeIndex.Manager.class ) . to ( com.google.gerrit.lucene.LuceneChangeIndexManager.class ) ; listener ( ) . to ( com.google.gerrit.lucene.LuceneChangeIndexManager.class ) ; if ( checkVersion ) { listener ( ) . to ( com.google.gerrit.lucene.IndexVersionCheck.class ) ; } }
private boolean isMuteable ( com.google.gerrit.server.change.ChangeResource rsrc ) { try { return ( ! ( isMuted ( rsrc ) ) ) && ( ! ( stars.isIgnored ( rsrc ) ) ) ; } catch ( com.google.gwtorm.server.OrmException e ) { com.google.gerrit.server.change.Mute.log.error ( "failed to check ignored star" , e ) ; } return false ; }
public void testParseFooComment ( ) throws java.lang.Exception { com.google.gerrit.server.git.QueryList ql = com.google.gerrit.server.git.QueryList.parse ( ( ( "#" + ( com.google.gerrit.server.git.QueryListTest.L_FOO ) ) + ( com.google.gerrit.server.git.QueryListTest.L_BAR ) ) , null ) ; com.google.common.truth.Truth.assertThat ( ql.getQuery ( com.google.gerrit.server.git.QueryListTest.N_FOO ) ) . isNull ( ) ; com.google.common.truth.Truth.assertThat ( ql.getQuery ( com.google.gerrit.server.git.QueryListTest.N_BAR ) ) . isEqualTo ( com.google.gerrit.server.git.QueryListTest.Q_B ) ; }
public void onlyResetMatchingRefs ( ) throws java.lang.Exception { org.eclipse.jgit.lib.Ref matchingRef = createRef ( "refs/match/test" ) ; org.eclipse.jgit.lib.Ref anotherMatchingRef = createRef ( "refs/another-match/test" ) ; org.eclipse.jgit.lib.Ref nonMatchingRef = createRef ( "refs/no-match/test" ) ; org.eclipse.jgit.lib.Ref updatedNonMatchingRef ; try ( com.google.gerrit.acceptance.ProjectResetter resetProject = builder ( ) . reset ( project , "refs/match/*" , "refs/another-match/*" ) . build ( ) ) { updateRef ( matchingRef ) ; updateRef ( anotherMatchingRef ) ; updatedNonMatchingRef = updateRef ( nonMatchingRef ) ; } assertRef ( matchingRef ) ; assertRef ( anotherMatchingRef ) ; assertRef ( updatedNonMatchingRef ) ; }
public java.lang.Iterable < com.google.gerrit.server.WebLinks.Link > getPatchSetLinks ( java.lang.String project , java.lang.String commit ) { java.util.List < com.google.gerrit.server.WebLinks.Link > links = com.google.common.collect.Lists.newArrayList ( ) ; for ( com.google.gerrit.extensions.webui.PatchSetWebLink webLink : patchSetLinks ) { links.add ( new com.google.gerrit.server.WebLinks.Link ( webLink.getLinkName ( ) , webLink.getPatchSetUrl ( project , commit ) ) ) ; } return links ; }
private java.lang.String resolveImageUrl ( java.lang.String url ) { if ( ( ( ( ( imageLoader ) == null ) || ( url.startsWith ( "https://" ) ) ) || ( url.startsWith ( "http://" ) ) ) || ( url.startsWith ( "data:" ) ) ) { return url ; } return imageLoader.loadImage ( url ) ; }
public java.lang.String getLabel ( com.google.gerrit.server.change.RevisionResource resource ) { return java.lang.String.format ( "Submit Patch Set %d" , resource.getPatchSet ( ) . getPatchSetId ( ) ) ; }
private void display ( com.google.gwt.core.client.JsArray < com.google.gerrit.client.extensions.TopMenuItem > items ) { java.util.List < java.util.List < java.lang.String > > values = new java.util.ArrayList < > ( ) ; for ( com.google.gerrit.client.extensions.TopMenuItem item : com.google.gerrit.client.rpc.Natives.asList ( items ) ) { values.add ( java.util.Arrays.asList ( item.getName ( ) , item.getUrl ( ) ) ) ; } myMenus.display ( values ) ; }
public void changeToIndexDoNotExist ( ) throws java.lang.Exception { setupPostMocks ( com.ericsson.gerrit.plugins.syncindex.SyncIndexRestApiServletTest.CHANGE_DOES_NOT_EXIST ) ; verifyPost ( ) ; }
private void assertDeleteSucceeds ( ) throws java.lang.Exception { java.lang.String branchRev = branch ( ) . get ( ) . revision ; branch ( ) . delete ( ) ; eventRecorder.assertRefUpdatedEvents ( project.get ( ) , branch.get ( ) , null , branchRev , branchRev , null ) ; exception.expect ( com.google.gerrit.extensions.restapi.ResourceNotFoundException.class ) ; branch ( ) . get ( ) ; }
public com.google.gerrit.server.change.VoteResource parse ( com.google.gerrit.server.change.ReviewerResource reviewer , com.google.gerrit.extensions.restapi.IdString id ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.extensions.restapi.ResourceNotFoundException , com.google.gwtorm.server.OrmException { return new com.google.gerrit.server.change.VoteResource ( reviewer , id.get ( ) ) ; }
private org.eclipse.jgit.dircache.DirCacheEntry file ( final java.lang.String name ) throws java.io.IOException { final org.eclipse.jgit.dircache.DirCacheEntry e = new org.eclipse.jgit.dircache.DirCacheEntry ( name ) ; e.setFileMode ( FileMode.REGULAR_FILE ) ; e.setObjectId ( writer ( ) . writeBlob ( org.eclipse.jgit.lib.Constants.encode ( name ) ) ) ; return e ; }
public static java.lang.String toLongString ( final com.google.gerrit.extensions.client.SubmitType type ) { if ( type == null ) { return "" ; } switch ( type ) { case FAST_FORWARD_ONLY : return com.google.gerrit.client.admin.Util.C.projectSubmitType_FAST_FORWARD_ONLY ( ) ; case MERGE_IF_NECESSARY : return com.google.gerrit.client.admin.Util.C.projectSubmitType_MERGE_IF_NECESSARY ( ) ; case REBASE_IF_NECESSARY : return com.google.gerrit.client.admin.Util.C.projectSubmitType_REBASE_IF_NECESSARY ( ) ; case MERGE_ALWAYS : return com.google.gerrit.client.admin.Util.C.projectSubmitType_MERGE_ALWAYS ( ) ; case CHERRY_PICK : return com.google.gerrit.client.admin.Util.C.projectSubmitType_CHERRY_PICK ( ) ; default : return type.name ( ) ; } }
public void onSuccess ( com.googlesource.gerrit.plugins.serviceuser.client.MessagesInfo info ) { onSuccessMessage = info.getOnSuccessMessage ( ) ; java.lang.String infoMessage = info.getInfoMessage ( ) ; if ( ( infoMessage != null ) && ( ! ( "" . equals ( infoMessage ) ) ) ) { insert ( new com.google.gwt.user.client.ui.HTML ( infoMessage ) , 0 ) ; } }
public RefUpdate.Result call ( ) throws java.lang.Exception { org.eclipse.jgit.lib.Ref ref = repo.exactRef ( refName ) ; afterReadRef.run ( ) ; org.eclipse.jgit.lib.ObjectId oldId ; if ( ref == null ) { oldId = org.eclipse.jgit.lib.ObjectId.zeroId ( ) ; next = seed.get ( ) ; } else { oldId = ref.getObjectId ( ) ; next = parse ( oldId ) ; } return store ( repo , rw , oldId , ( ( next ) + ( count ) ) ) ; }
public void onResize ( com.google.gwt.event.logical.shared.ResizeEvent event ) { if ( ( cmA ) != null ) { cmA.setHeight ( ( ( event.getHeight ( ) ) - ( com.google.gerrit.client.diff.SideBySide2.HEADER_FOOTER ) ) ) ; cmA.refresh ( ) ; } if ( ( cmB ) != null ) { cmB.setHeight ( ( ( event.getHeight ( ) ) - ( com.google.gerrit.client.diff.SideBySide2.HEADER_FOOTER ) ) ) ; cmB.refresh ( ) ; } resizeBoxPaddings ( ) ; }
public void createdOnIsPopulatedForGroupsCreatedAfterAudit ( ) throws java.lang.Exception { java.sql.Timestamp testStartTime = com.google.gerrit.common.TimeUtil.nowTs ( ) ; com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = createGroup ( "Group for schema migration" ) ; setCreatedOnToVeryOldTimestamp ( groupId ) ; schema151.migrateData ( db , new com.google.gerrit.server.schema.Schema_150_to_151_Test.TestUpdateUI ( ) ) ; com.google.gerrit.reviewdb.client.AccountGroup group = db.accountGroups ( ) . get ( groupId ) ; com.google.common.truth.Truth.assertThat ( group.getCreatedOn ( ) ) . isAtLeast ( testStartTime ) ; }
private static org.bouncycastle.openpgp.PGPPublicKeyRingCollection readPubRing ( final java.io.File pub ) { try { java.io.InputStream in = new java.io.FileInputStream ( pub ) ; try { in = org.bouncycastle.openpgp.PGPUtil.getDecoderStream ( in ) ; return new org.bouncycastle.openpgp.PGPPublicKeyRingCollection ( in ) ; } finally { in.close ( ) ; } } catch ( java.io.IOException e ) { throw new com.google.inject.ProvisionException ( ( "Cannot read " + pub ) , e ) ; } catch ( org.bouncycastle.openpgp.PGPException e ) { throw new com.google.inject.ProvisionException ( ( "Cannot read " + pub ) , e ) ; } }
public void init ( javax.servlet.FilterConfig config ) throws javax.servlet.ServletException { if ( isPropertyUndefined ( config , com.googlesource.gerrit.plugins.javamelody.GerritMonitoringFilter.JavamelodyFilter.HTTP_TRANSFORM_PATTERN , com.googlesource.gerrit.plugins.javamelody.GerritMonitoringFilter.JavamelodyFilter.GLOBAL_HTTP_TRANSFORM_PATTERN ) ) { java.lang.System.setProperty ( com.googlesource.gerrit.plugins.javamelody.GerritMonitoringFilter.JavamelodyFilter.GLOBAL_HTTP_TRANSFORM_PATTERN , com.googlesource.gerrit.plugins.javamelody.GerritMonitoringFilter.JavamelodyFilter.GERRIT_GROUPING ) ; } if ( isPropertyUndefined ( config , com.googlesource.gerrit.plugins.javamelody.GerritMonitoringFilter.JavamelodyFilter.STORAGE_DIR , com.googlesource.gerrit.plugins.javamelody.GerritMonitoringFilter.JavamelodyFilter.GLOBAL_STORAGE_DIR ) ) { java.lang.System.setProperty ( com.googlesource.gerrit.plugins.javamelody.GerritMonitoringFilter.JavamelodyFilter.GLOBAL_STORAGE_DIR , getStorageDir ( ) ) ; } super . init ( config ) ; }
private static org.eclipse.jgit.dircache.DirCache readTree ( final org.eclipse.jgit.lib.Repository pdb , final org.eclipse.jgit.lib.Ref branch ) throws java.io.IOException , org.eclipse.jgit.errors.IncorrectObjectTypeException , org.eclipse.jgit.errors.MissingObjectException { try ( org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk ( pdb ) ) { final org.eclipse.jgit.dircache.DirCache dc = org.eclipse.jgit.dircache.DirCache.newInCore ( ) ; final org.eclipse.jgit.dircache.DirCacheBuilder b = dc.builder ( ) ; b.addTree ( new byte [ 0 ] , DirCacheEntry.STAGE_0 , pdb.newObjectReader ( ) , rw.parseTree ( branch.getObjectId ( ) ) ) ; b.finish ( ) ; return dc ; } }
public void onSuccess ( java.lang.Void result ) { goUpToChange ( openReplyBox ) ; }
private org.eclipse.jgit.treewalk.TreeWalk find ( final org.eclipse.jgit.lib.ObjectId within ) throws java.io.IOException , org.eclipse.jgit.errors.CorruptObjectException , org.eclipse.jgit.errors.IncorrectObjectTypeException , org.eclipse.jgit.errors.MissingObjectException { if ( ( path ) == null ) { return null ; } final org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk ( db ) ; final org.eclipse.jgit.revwalk.RevTree tree = rw.parseTree ( within ) ; return org.eclipse.jgit.treewalk.TreeWalk.forPath ( db , path , tree ) ; }
public boolean updateChange ( com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.PatchSet ps = psUtil.get ( ctx.getDb ( ) , ctx.getNotes ( ) , psId ) ; psUtil.setGroups ( ctx.getDb ( ) , ctx.getUpdate ( psId ) , ps , com.google.common.collect.ImmutableList.< java.lang.String > of ( ) ) ; return true ; }
protected void display ( com.googlesource.gerrit.plugins.xdocs.client.ChangeInfo change ) { java.lang.String frameId = "xdoc_unified_diff_iframe" ; com.google.gwt.user.client.ui.Frame frame = new com.google.gwt.user.client.ui.Frame ( com.googlesource.gerrit.plugins.xdocs.client.XDocScreen.getUrl ( change.project ( ) , getRevision ( ) , getFile ( ) ) ) ; frame.getElement ( ) . setId ( frameId ) ; com.googlesource.gerrit.plugins.xdocs.client.XDocScreen.resize ( frame , frameId ) ; add ( frame ) ; }
void initMeter ( ) { if ( ( meter ) == null ) { final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder b = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder ( ) ; b.openTr ( ) ; b.openTd ( ) ; b.closeTd ( ) ; b.closeTr ( ) ; resetHtml ( b ) ; meter = new com.google.gwtexpui.progress.client.ProgressBar ( Util.M.loadingPatchSet ( psid.get ( ) ) ) ; table.setWidget ( 0 , 0 , meter ) ; } updateMeter ( ) ; }
public void parseOptionMap ( java.util.Map < java.lang.String , java.lang.String [ ] > parameters ) throws org.kohsuke.args4j.CmdLineException { com.google.common.collect.ListMultimap < java.lang.String , java.lang.String > map = com.google.common.collect.ArrayListMultimap.create ( ) ; for ( java.util.Map.Entry < java.lang.String , java.lang.String [ ] > ent : parameters.entrySet ( ) ) { for ( java.lang.String val : ent.getValue ( ) ) { map.put ( ent.getKey ( ) , val ) ; } } parseOptionMap ( map ) ; }
private com.google.inject.Injector createSshInjector ( ) { final java.util.List < com.google.inject.Module > modules = new java.util.ArrayList < com.google.inject.Module > ( ) ; if ( sshd ) { modules.add ( new com.google.gerrit.sshd.SshModule ( ) ) ; if ( slave ) { modules.add ( new com.google.gerrit.sshd.commands.SlaveCommandModule ( ) ) ; } else { modules.add ( new com.google.gerrit.sshd.commands.MasterCommandModule ( ) ) ; modules.add ( cfgInjector.getInstance ( com.google.gerrit.sshd.commands.MasterPluginsModule.class ) ) ; } } else { modules.add ( new com.google.gerrit.server.ssh.NoSshModule ( ) ) ; } return sysInjector.createChildInjector ( modules ) ; }
protected java.net.SocketAddress getRemoteAddress ( ) { return session.getAttribute ( SshUtil.REMOTE_PEER ) ; }
private java.io.File copyToTempFile ( org.eclipse.jgit.lib.ObjectId blobId , java.io.File tempDir ) throws java.io.FileNotFoundException , java.io.IOException , org.eclipse.jgit.errors.MissingObjectException { java.io.File tmp = java.io.File.createTempFile ( "rules" , ".pl" , tempDir ) ; try ( java.io.FileOutputStream out = new java.io.FileOutputStream ( tmp ) ) { git.open ( blobId ) . copyTo ( out ) ; } return tmp ; }
public void index ( com.google.gerrit.reviewdb.client.Account.Id id ) throws java.io.IOException { for ( com.google.gerrit.index.Index < com.google.gerrit.reviewdb.client.Account.Id , com.google.gerrit.server.account.AccountState > i : getWriteIndexes ( ) ) { com.google.gerrit.server.account.AccountState accountState = byIdCache.getOrNull ( id ) ; if ( accountState != null ) { i.replace ( accountState ) ; } else { i.delete ( id ) ; } } fireAccountIndexedEvent ( id.get ( ) ) ; com.google.gerrit.server.index.account.AccountIndexerImpl.autoReindexIfStale ( id ) ; }
void setText ( final java.lang.String query ) { if ( ( query == null ) || ( query.equals ( "" ) ) ) { searchBox.setText ( Gerrit.C.searchHint ( ) ) ; searchBox.addStyleName ( "gerrit-InputFieldTypeHint" ) ; } else { searchBox.setText ( query ) ; searchBox.removeStyleName ( "gerrit-InputFieldTypeHint" ) ; } }
private static void unified ( final java.lang.String token , final com.google.gerrit.reviewdb.client.PatchSet.Id baseId , final com.google.gerrit.reviewdb.client.Patch.Key id , final int line ) { com.google.gwt.core.client.GWT.runAsync ( new com.google.gerrit.client.Dispatcher.AsyncSplit ( token ) { @ java.lang.Override public void onSuccess ( ) { com.google.gerrit.client.Gerrit.display ( token , new com.google.gerrit.client.diff.Unified ( baseId , id.getParentKey ( ) , id.get ( ) , line ) ) ; } } ) ; }
private void streamFile ( javax.servlet.http.HttpServletRequest req , javax.servlet.http.HttpServletResponse res ) throws java.io.IOException { java.io.File f = configFile ( req ) ; res.setStatus ( HttpServletResponse.SC_OK ) ; res.setContentType ( "application/octet-stream" ) ; res.setContentLength ( ( ( int ) ( f.length ( ) ) ) ) ; java.io.OutputStream out = res.getOutputStream ( ) ; try ( java.io.InputStream in = new java.io.FileInputStream ( f ) ) { com.google.common.io.ByteStreams.copy ( in , out ) ; } }
public void testGetIssuePatternWCommentLink ( ) { com.googlesource.gerrit.plugins.its.base.its.ItsConfig itsConfig = createItsConfig ( ) ; org.easymock.EasyMock.expect ( serverConfig.getString ( "ItsTestName" , null , "commentlink" ) ) . andReturn ( "foo" ) . atLeastOnce ( ) ; org.easymock.EasyMock.expect ( serverConfig.getString ( "commentlink" , "foo" , "match" ) ) . andReturn ( "TestPattern" ) . atLeastOnce ( ) ; replayMocks ( ) ; assertEquals ( "Expected and generated pattern are not equal" , "TestPattern" , itsConfig.getIssuePattern ( ) . pattern ( ) ) ; }
private java.lang.String errorMessageForBranches ( java.util.List < java.lang.String > branches ) { java.lang.StringBuilder message = new java.lang.StringBuilder ( ) ; for ( java.lang.String branch : branches ) { message.append ( "Cannot delete " ) . append ( branch ) . append ( ": it doesn't exist or you do not have permission " ) . append ( "to delete it\n" ) ; } return message.toString ( ) ; }
private void mergeImpl ( final com.google.gerrit.client.reviewdb.Branch.NameKey branch ) { try { new com.google.gerrit.git.MergeOp ( server , schema , replication , emailSender , branch ) . merge ( ) ; } catch ( java.lang.Throwable e ) { com.google.gerrit.git.ChangeMergeQueue.log.error ( ( ( "Merge attempt for " + branch ) + " failed" ) , e ) ; } }
private java.lang.String buildJsonRaw ( java.lang.String path ) throws java.lang.Exception { com.google.gitiles.FakeHttpServletResponse res = buildResponse ( path , "format=json" , javax.servlet.http.HttpServletResponse.SC_OK ) ; com.google.common.truth.Truth.assertThat ( res.getHeader ( com.google.common.net.HttpHeaders.CONTENT_TYPE ) ) . isEqualTo ( "application/json" ) ; java.lang.String body = res.getActualBodyString ( ) ; java.lang.String magic = ")]}\'\n" ; com.google.common.truth.Truth.assertThat ( body ) . startsWith ( magic ) ; return body.substring ( magic.length ( ) ) ; }
public java.util.SortedMap < java.lang.String , com.google.gerrit.extensions.common.GroupInfo > apply ( com.google.gerrit.extensions.restapi.TopLevelResource resource ) throws com.google.gerrit.extensions.restapi.BadRequestException , com.google.gwtorm.server.OrmException { java.util.SortedMap < java.lang.String , com.google.gerrit.extensions.common.GroupInfo > output = com.google.common.collect.Maps.newTreeMap ( ) ; for ( com.google.gerrit.extensions.common.GroupInfo info : get ( ) ) { output.put ( com.google.common.base.MoreObjects.firstNonNull ( info.name , ( "Group " + ( com.google.gerrit.extensions.restapi.Url.decode ( info.id ) ) ) ) , info ) ; info.name = null ; } return output ; }
public java.util.SortedMap < java.lang.String , com.google.gerrit.extensions.common.PluginInfo > getAsMap ( ) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.plugins.ListPlugins list = listProvider.get ( ) ; list.setAll ( this . getAll ( ) ) ; list.setStart ( this . getStart ( ) ) ; list.setLimit ( this . getLimit ( ) ) ; return list.apply ( ) ; }
public void testPushForMasterWithTopic ( ) throws com.google.gwtorm.server.OrmException , java.io.IOException , org.eclipse.jgit.api.errors.GitAPIException { java.lang.String topic = "my/topic" ; com.google.gerrit.acceptance.git.PushOneCommit.Result r = pushTo ( ( "refs/for/master/" + topic ) ) ; r.assertOkStatus ( ) ; r.assertChange ( Change.Status.NEW , topic ) ; r = pushTo ( ( "refs/for/master%topic=" + topic ) ) ; r.assertOkStatus ( ) ; r.assertChange ( Change.Status.NEW , topic ) ; }
public void newPatchSetByOwnerOnReviewableChangeToWipInReviewDb ( ) throws java.lang.Exception { com.google.common.truth.TruthJUnit.assume ( ) . that ( notesMigration.readChanges ( ) ) . isFalse ( ) ; com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.NEW_PATCHSETS ) ; pushTo ( sc , "refs/for/master%wip" , sc.owner ) ; assertThat ( sender ) . sent ( "newpatchset" , sc ) . notTo ( sc.owner ) . notTo ( sc.reviewerByEmail , sc.ccerByEmail ) . to ( sc.reviewer , sc.ccer ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.NEW_PATCHSETS ) ; }
private java.util.Collection < com.google.gerrit.reviewdb.client.ChangeMessage > filterChangeMessages ( ) { return com.google.common.collect.Collections2.filter ( changeMessages , new com.google.common.base.Predicate < com.google.gerrit.reviewdb.client.ChangeMessage > ( ) { @ java.lang.Override public boolean apply ( com.google.gerrit.reviewdb.client.ChangeMessage in ) { com.google.gerrit.reviewdb.client.PatchSet.Id psId = in.getPatchSetId ( ) ; return ( psId == null ) || ( patchSets.containsKey ( psId ) ) ; } } ) ; }
protected < T > void doInvoke ( final java.lang.String requestData , final com.google.gwtjsonrpc.client.JsonSerializer < T > resultSerializer , final com.google.gwt.user.client.rpc.AsyncCallback < T > callback ) throws com.google.gwt.user.client.rpc.InvocationException { if ( ( url ) == null ) { throw new com.google.gwtjsonrpc.client.NoServiceEntryPointSpecifiedException ( ) ; } new com.google.gwtjsonrpc.client.JsonCall < T > ( this , requestData , resultSerializer , callback ) . send ( ) ; }
public void topic ( java.lang.String topic ) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.change.PutTopic.Input in = new com.google.gerrit.server.change.PutTopic.Input ( ) ; in.topic = topic ; try { putTopic.apply ( change , in ) ; } catch ( com.google.gwtorm.server.OrmException | java.io.IOException e ) { throw new com.google.gerrit.extensions.restapi.RestApiException ( "Cannot set topic" , e ) ; } }
private static void populateBottomMenu ( ) { final com.google.gwt.user.client.ui.RootPanel btmmenu = com.google.gwt.user.client.ui.RootPanel.get ( "gerrit_btmmenu" ) ; final java.lang.String vs ; if ( com.google.gwt.core.client.GWT.isScript ( ) ) { final com.google.gerrit.client.GerritVersion v = com.google.gwt.core.client.GWT.create ( com.google.gerrit.client.GerritVersion.class ) ; vs = v.version ( ) ; } else { vs = "dev" ; } final com.google.gwt.user.client.ui.HTML version = new com.google.gwt.user.client.ui.HTML ( com.google.gerrit.client.Gerrit.M.poweredBy ( vs ) ) ; version.setStyleName ( "gerrit-version" ) ; btmmenu.add ( version ) ; }
private static org.bouncycastle.openpgp.PGPPublicKeyRingCollection readPubRing ( final java.io.File pub ) { try ( java.io.InputStream fin = new java.io.FileInputStream ( pub ) ; java.io.InputStream in = org.bouncycastle.openpgp.PGPUtil.getDecoderStream ( fin ) ) { return new org.bouncycastle.openpgp.PGPPublicKeyRingCollection ( in ) ; } catch ( java.io.IOException e ) { throw new com.google.inject.ProvisionException ( ( "Cannot read " + pub ) , e ) ; } catch ( org.bouncycastle.openpgp.PGPException e ) { throw new com.google.inject.ProvisionException ( ( "Cannot read " + pub ) , e ) ; } }
private java.lang.String percent ( final long value , final long total ) { if ( total <= 0 ) { return "" ; } final long pcent = ( 100 * value ) / total ; return java.lang.String.format ( "%3d%%" , ( ( int ) ( pcent ) ) ) ; }
protected com.google.gerrit.reviewdb.client.PatchLineComment newPublishedPatchLineComment ( com.google.gerrit.reviewdb.client.PatchSet.Id psId , java.lang.String filename , java.lang.String UUID , com.google.gerrit.reviewdb.client.CommentRange range , int line , com.google.gerrit.server.IdentifiedUser commenter , java.lang.String parentUUID , java.sql.Timestamp t , java.lang.String message , short side , java.lang.String commitSHA1 ) { return newPatchLineComment ( psId , filename , UUID , range , line , commenter , parentUUID , t , message , side , commitSHA1 , PatchLineComment.Status.PUBLISHED ) ; }
protected void setUp ( ) throws java.lang.Exception { if ( com.google.gerrit.server.util.HostPlatform.isWin32 ( ) ) { throw new com.google.gerrit.server.tools.hooks.CommitMsgHookTest.SkipTestOnThisPlatform ( ) ; } super . setUp ( ) ; final java.util.Date when = author.getWhen ( ) ; final java.util.TimeZone tz = author.getTimeZone ( ) ; author = new org.eclipse.jgit.lib.PersonIdent ( "J. Author" , "ja@example.com" ) ; author = new org.eclipse.jgit.lib.PersonIdent ( author , when , tz ) ; committer = new org.eclipse.jgit.lib.PersonIdent ( "J. Committer" , "jc@example.com" ) ; committer = new org.eclipse.jgit.lib.PersonIdent ( committer , when , tz ) ; }
private static org.eclipse.jgit.lib.AnyObjectId aFor ( final com.google.gerrit.server.patch.PatchListKey key , final org.eclipse.jgit.lib.Repository repo , final org.eclipse.jgit.revwalk.RevCommit b ) throws java.io.IOException { if ( ( key.getOldId ( ) ) != null ) { return key.getOldId ( ) ; } switch ( b.getParentCount ( ) ) { case 0 : return com.google.gerrit.server.patch.PatchListCacheImpl.emptyTree ( repo ) ; case 1 : return b.getParent ( 0 ) ; default : return null ; } }
public com.google.gson.JsonObject getChangeData ( int change , com.googlesource.gerrit.plugins.findowners.Util.String2String params ) { return apply ( null , new com.googlesource.gerrit.plugins.findowners.Action.Input ( change , params ) ) ; }
public void run ( ) { renderSkips ( context ) ; }
public static void doSignIn ( ) { new com.google.gerrit.client.SignInDialog ( ) . center ( ) ; }
public com.googlecode.prolog_cafe.lang.Operation exec ( com.googlecode.prolog_cafe.lang.Prolog engine ) throws com.googlecode.prolog_cafe.lang.PrologException { engine.setB0 ( ) ; com.googlecode.prolog_cafe.lang.Term a1 = arg1.dereference ( ) ; com.google.gerrit.reviewdb.client.Change change = StoredValues.CHANGE_DATA.get ( engine ) . getChange ( ) ; com.google.gerrit.reviewdb.client.Project.NameKey name = change.getProject ( ) ; if ( ! ( a1.unify ( com.googlecode.prolog_cafe.lang.SymbolTerm.create ( name.get ( ) ) , engine.trail ) ) ) { return engine.fail ( ) ; } return cont ; }
public void onFailure ( java.lang.Throwable caught ) { }
public void createEmptyEditRest ( ) throws java.lang.Exception { org.junit.Assert.assertEquals ( org.apache.http.HttpStatus.SC_NO_CONTENT , adminSession.post ( urlEdit ( ) ) . getStatusCode ( ) ) ; com.google.common.base.Optional < com.google.gerrit.server.edit.ChangeEdit > edit = editUtil.byChange ( change ) ; org.junit.Assert.assertArrayEquals ( com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_OLD , com.google.gerrit.acceptance.edit.ChangeEditIT.toBytes ( fileUtil.getContent ( edit.get ( ) . getChange ( ) . getProject ( ) , edit.get ( ) . getRevision ( ) . get ( ) , com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME ) ) ) ; }
public void run ( ) { net.codemirror.lib.CodeMirror.LineHandle handle = cm.extras ( ) . activeLine ( ) ; int line = ( cm.getLineNumber ( handle ) ) + 1 ; if ( Patch.COMMIT_MSG.equals ( path ) ) { line = adjustCommitMessageLine ( line ) ; } java.lang.String token = com.google.gerrit.client.Dispatcher.toEditScreen ( revision , path , line ) ; if ( ! ( com.google.gerrit.client.Gerrit.isSignedIn ( ) ) ) { com.google.gerrit.client.Gerrit.doSignIn ( token ) ; } else { com.google.gerrit.client.Gerrit.display ( token ) ; } }
public java.util.Map < java.lang.String , com.google.gitiles.RepositoryDescription > listRepositories ( java.util.Set < java.lang.String > branches ) throws java.io.IOException { java.util.Map < java.lang.String , com.google.gitiles.RepositoryDescription > repos = com.google.common.collect.Maps.newTreeMap ( ) ; for ( org.eclipse.jgit.lib.Repository repo : scanRepositories ( basePath , req ) ) { repos.put ( getRepositoryName ( repo ) , buildDescription ( repo , branches ) ) ; repo.close ( ) ; } return repos ; }
private java.lang.String addressList ( ) { final java.lang.StringBuilder r = new java.lang.StringBuilder ( ) ; for ( java.util.Iterator < java.net.SocketAddress > i = listen.iterator ( ) ; i.hasNext ( ) ; ) { r.append ( com.google.gerrit.sshd.SshDaemon.format ( i.next ( ) ) ) ; if ( i.hasNext ( ) ) { r.append ( ", " ) ; } } return r.toString ( ) ; }
private org.eclipse.jetty.util.resource.Resource getBaseResource ( ) throws java.io.IOException { if ( ( baseResource ) == null ) { try { baseResource = unpackWar ( ) ; } catch ( java.io.FileNotFoundException err ) { throw err ; } } return baseResource ; }
public static com.google.gerrit.git.WorkQueue.Task < ? > [ ] getTasks ( ) { final java.util.List < com.google.gerrit.git.WorkQueue.Task < ? > > r = new java.util.ArrayList < com.google.gerrit.git.WorkQueue.Task < ? > > ( ) ; for ( final com.google.gerrit.git.WorkQueue.Executor e : com.google.gerrit.git.WorkQueue.queues ) { e.addAllTo ( r ) ; } return r.toArray ( new com.google.gerrit.git.WorkQueue.Task [ r.size ( ) ] ) ; }
com.googlesource.gerrit.plugins.cfoauth.AccessToken parseAccessTokenResponse ( java.lang.String tokenResponse ) throws com.googlesource.gerrit.plugins.cfoauth.UAAClientException { if ( com.google.common.base.Strings.isNullOrEmpty ( tokenResponse ) ) { throw new com.googlesource.gerrit.plugins.cfoauth.UAAClientException ( "Can't extract a token from an empty string" ) ; } com.google.gson.JsonObject json = getAsJsonObject ( tokenResponse ) ; java.lang.String accessToken = getAttribute ( json , com.googlesource.gerrit.plugins.cfoauth.UAAClient.ACCESS_TOKEN_ATTRIBUTE ) ; if ( accessToken == null ) { throw new com.googlesource.gerrit.plugins.cfoauth.UAAClientException ( "Can't extract a token: missing or invalid 'access_token' attribute" ) ; } return toAccessToken ( accessToken ) ; }
protected void run ( ) { loader.rescan ( true ) ; }
public void onResize ( com.google.gwt.event.logical.shared.ResizeEvent event ) { int h = ( com.google.gerrit.client.Gerrit.getHeaderFooterHeight ( ) ) + ( reviewed.getOffsetHeight ( ) ) ; if ( ( cmA ) != null ) { cmA.setHeight ( ( ( event.getHeight ( ) ) - h ) ) ; cmA.refresh ( ) ; } if ( ( cmB ) != null ) { cmB.setHeight ( ( ( event.getHeight ( ) ) - h ) ) ; cmB.refresh ( ) ; } resizeBoxPaddings ( ) ; }
private java.lang.String getPullUrl ( ) { final java.util.List < com.jcraft.jsch.HostKey > hostKeys = sshInfo.getHostKeys ( ) ; if ( hostKeys.isEmpty ( ) ) { return "" ; } final java.lang.String host = hostKeys.get ( 0 ) . getHost ( ) ; final java.lang.StringBuilder r = new java.lang.StringBuilder ( ) ; r.append ( "git pull ssh://" ) ; if ( host.startsWith ( "*:" ) ) { r.append ( getGerritHost ( ) ) ; r.append ( host.substring ( 1 ) ) ; } else { r.append ( host ) ; } r.append ( "/" ) ; r.append ( projectName ) ; r.append ( " " ) ; r.append ( patchSet.getRefName ( ) ) ; return r.toString ( ) ; }
void set ( com.google.gerrit.client.changes.ChangeInfo info ) { canEdit = ( info.hasActions ( ) ) && ( info.actions ( ) . containsKey ( "hashtags" ) ) ; this . changeId = info.legacyId ( ) ; display ( info ) ; openForm.setVisible ( canEdit ) ; }
public void onClick ( final com.google.gwt.event.dom.client.ClickEvent event ) { showAddKeyBlock ( false ) ; }
private static java.lang.String url ( com.google.gerrit.reviewdb.client.PatchSet.Id ps , com.google.gerrit.client.changes.CommentInfo info ) { return com.google.gerrit.client.Dispatcher.toSideBySide ( null , ps , info.path ( ) , ( ( info.side ( ) ) == ( com.google.gerrit.extensions.client.Side.PARENT ) ? com.google.gerrit.client.diff.DisplaySide.A : com.google.gerrit.client.diff.DisplaySide.B ) , info.line ( ) ) ; }
public void run ( ) { if ( ( active ) == null ) { active = this ; fixup.scheduleRepeating ( 20 ) ; } if ( ( active ) == ( this ) ) { net.codemirror.lib.ScrollInfo si = src.getScrollInfo ( ) ; updateScreenHeader ( si ) ; dst.scrollTo ( si.getLeft ( ) , align ( si.getTop ( ) ) ) ; state = 0 ; } }
public void deleteComment ( com.google.gerrit.reviewdb.client.PatchLineComment c ) { verifyComment ( c ) ; if ( ( c.getStatus ( ) ) == ( PatchLineComment.Status.DRAFT ) ) { createDraftUpdateIfNull ( ) . deleteComment ( c ) ; } else { throw new java.lang.IllegalArgumentException ( ( "Cannot delete published comment " + c ) ) ; } }
protected com.google.gerrit.reviewdb.AccountGroup missing ( final com.google.gerrit.reviewdb.AccountGroup.Id key ) { return missingGroup ( key ) ; }
private boolean isMergeable ( com.google.gerrit.reviewdb.client.Change c ) { final com.google.gerrit.server.git.CodeReviewCommit commit = commits.get ( c.getId ( ) ) ; final com.google.gerrit.server.git.CommitMergeStatus s = ( commit != null ) ? commit.statusCode : null ; boolean isMergeable = false ; if ( ( s != null ) && ( ( ( s.equals ( CommitMergeStatus.CLEAN_MERGE ) ) || ( s.equals ( CommitMergeStatus.CLEAN_PICK ) ) ) || ( s.equals ( CommitMergeStatus.ALREADY_MERGED ) ) ) ) { isMergeable = true ; } return isMergeable ; }
private static com.google.gerrit.server.git.CodeReviewCommit failed ( com.google.gerrit.server.git.CodeReviewCommit.CodeReviewRevWalk rw , org.eclipse.jgit.revwalk.RevFlag canMergeFlag , com.google.gerrit.server.git.CodeReviewCommit mergeTip , com.google.gerrit.server.git.CodeReviewCommit n , com.google.gerrit.server.git.strategy.CommitMergeStatus failure ) throws java.io.IOException , org.eclipse.jgit.errors.IncorrectObjectTypeException , org.eclipse.jgit.errors.MissingObjectException { rw.resetRetain ( canMergeFlag ) ; rw.markStart ( n ) ; rw.markUninteresting ( mergeTip ) ; com.google.gerrit.server.git.CodeReviewCommit failed ; while ( ( failed = rw.next ( ) ) != null ) { failed.setStatusCode ( failure ) ; } return failed ; }
public void restoreExternalIds ( ) throws java.lang.Exception { db.accountExternalIds ( ) . delete ( getExternalIds ( admin ) ) ; db.accountExternalIds ( ) . delete ( getExternalIds ( user ) ) ; db.accountExternalIds ( ) . insert ( savedExternalIds ) ; }
public void onSuccess ( final com.google.gwtjsonrpc.client.VoidResult result ) { for ( int row = 1 ; row < ( table.getRowCount ( ) ) ; ) { com.google.gerrit.reviewdb.RefRight r = getRowItem ( row ) ; if ( ( r != null ) && ( refRightIds.contains ( r.getKey ( ) ) ) ) { table.removeRow ( row ) ; } else { row ++ ; } } }
public void skipOnlyOnSpecificRef ( ) throws java.lang.Exception { java.lang.String config = "[plugin \"uploadvalidator\"]\n" + ( ( "skipValidation=testOp\n" + "skipRef=refs/heads/myref\n" ) + "skipGroup=testGroup" ) ; com.googlesource.gerrit.plugins.uploadvalidator.ValidatorConfig validatorConfig = new com.googlesource.gerrit.plugins.uploadvalidator.ValidatorConfig ( new com.googlesource.gerrit.plugins.uploadvalidator.FakeConfigFactory ( projectName , config ) , new com.googlesource.gerrit.plugins.uploadvalidator.FakeGroupCacheUUIDByName ( ) ) ; com.google.common.truth.Truth.assertThat ( validatorConfig.isEnabledForRef ( anyUser , projectName , "refs/heads/myref" , "testOp" ) ) . isFalse ( ) ; }
private static void set ( org.eclipse.jgit.lib.Config cfg , java.lang.String section , java.lang.String key , java.lang.String val ) { if ( com.google.common.base.Strings.isNullOrEmpty ( val ) ) { cfg.unset ( com.google.gerrit.server.account.GetPreferences.MY , section , key ) ; } else { cfg.setString ( com.google.gerrit.server.account.GetPreferences.MY , section , key , val ) ; } }
public static com.google.gerrit.server.index.IndexConfig fromConfig ( org.eclipse.jgit.lib.Config cfg ) { return com.google.gerrit.server.index.IndexConfig.create ( cfg.getInt ( "index" , null , "maxLimit" , 0 ) , cfg.getInt ( "index" , null , "maxPages" , 0 ) , cfg.getInt ( "index" , null , "maxTerms" , 0 ) ) ; }
void onRenderEntireFile ( com.google.gwt.event.logical.shared.ValueChangeEvent < java.lang.Boolean > e ) { prefs.renderEntireFile ( e.getValue ( ) ) ; view.updateRenderEntireFile ( ) ; }
public void deleteVoteFromReviewableWipChange ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableWipChange ( ) ; deleteVote ( sc , voter ) ; assertThat ( sender ) . sent ( "deleteVote" , sc ) . notTo ( voter ) . to ( sc.owner ) . cc ( sc.reviewer , sc.ccer ) . cc ( sc.reviewerByEmail , sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS ) ; }
public boolean dryRun ( final com.google.gerrit.server.git.CodeReviewCommit mergeTip , final com.google.gerrit.server.git.CodeReviewCommit toMerge ) throws com.google.gerrit.server.git.MergeException { return ( ! ( com.google.gerrit.server.git.MergeUtil.hasMissingDependencies ( args.mergeSorter , toMerge ) ) ) && ( com.google.gerrit.server.git.MergeUtil.canCherryPick ( args.mergeSorter , args.repo , args.useContentMerge , mergeTip , args.rw , toMerge ) ) ; }
public static com.google.gerrit.reviewdb.client.AccountDiffPreference createDefault ( com.google.gerrit.reviewdb.client.Account.Id accountId ) { com.google.gerrit.reviewdb.client.AccountDiffPreference p = new com.google.gerrit.reviewdb.client.AccountDiffPreference ( accountId ) ; p.setIgnoreWhitespace ( com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace.IGNORE_NONE ) ; p.setTabSize ( 8 ) ; p.setLineLength ( 100 ) ; p.setSyntaxHighlighting ( true ) ; p.setShowWhitespaceErrors ( true ) ; p.setIntralineDifference ( true ) ; p.setShowTabs ( true ) ; p.setContext ( com.google.gerrit.reviewdb.client.AccountDiffPreference.DEFAULT_CONTEXT ) ; p.setManualReview ( false ) ; return p ; }
public void setOriginalSubject ( java.lang.String originalSubject ) { this . originalSubject = originalSubject ; }
public static com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > closed ( ) { java.util.List < com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > > r = new java.util.ArrayList < > ( 4 ) ; for ( final com.google.gerrit.reviewdb.client.Change.Status e : Change.Status.values ( ) ) { if ( e.isClosed ( ) ) { r.add ( new com.google.gerrit.server.query.change.ChangeStatusPredicate ( e ) ) ; } } return ( r.size ( ) ) == 1 ? r.get ( 0 ) : or ( r ) ; }
public static void addMember ( com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID , java.lang.String member , com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.client.groups.MemberInfo > cb ) { java.lang.String n = com.google.gwt.http.client.URL.encodePathSegment ( member ) ; new com.google.gerrit.client.rpc.RestApi ( ( ( ( com.google.gerrit.client.groups.GroupApi.membersBase ( groupUUID ) ) + "/" ) + n ) ) . put ( cb ) ; }
private Account.Id parseIdent ( org.eclipse.jgit.revwalk.RevCommit commit ) throws org.eclipse.jgit.errors.ConfigInvalidException { return parseIdent ( commit.getAuthorIdent ( ) ) ; }
private void expandSideBefore ( int cnt ) { net.codemirror.lib.TextMarker.FromTo range = textMarker.find ( ) ; int oldStart = range.getFrom ( ) . getLine ( ) ; int newStart = oldStart + cnt ; int end = range.getTo ( ) . getLine ( ) ; clearMarkerAndWidget ( ) ; collapse ( newStart , end , true ) ; updateSelection ( ) ; }
public com.google.gerrit.client.ui.InlineHyperlink getNextPatchLink ( int index , com.google.gerrit.client.patches.PatchScreen.Type patchType ) { for ( index ++ ; index < ( patchList.size ( ) ) ; index ++ ) { com.google.gerrit.client.ui.InlineHyperlink link = createLink ( index , patchType , null , com.google.gwtexpui.safehtml.client.SafeHtml.asis ( Util.C.nextPatchLinkIcon ( ) ) ) ; if ( link != null ) { return link ; } } return null ; }
public com.google.gwtjsonrpc.client.VoidResult run ( final com.google.gerrit.client.reviewdb.ReviewDb db ) throws com.google.gwtorm.client.OrmException { final com.google.gerrit.client.reviewdb.Account a = db.accounts ( ) . get ( com.google.gerrit.client.rpc.Common.getAccountId ( ) ) ; a.setShowSiteHeader ( newSetting ) ; db.accounts ( ) . update ( java.util.Collections.singleton ( a ) ) ; com.google.gerrit.client.rpc.Common.getAccountCache ( ) . invalidate ( a.getId ( ) ) ; return com.google.gwtjsonrpc.client.VoidResult.INSTANCE ; }
public static java.lang.String projectQuery ( com.google.gerrit.reviewdb.client.Project.NameKey proj , com.google.gerrit.reviewdb.client.Change.Status status ) { switch ( status ) { case ABANDONED : return "status:abandoned " + ( com.google.gerrit.common.PageLinks.op ( "project" , proj.get ( ) ) ) ; case MERGED : return "status:merged " + ( com.google.gerrit.common.PageLinks.op ( "project" , proj.get ( ) ) ) ; case NEW : case SUBMITTED : default : return "status:open " + ( com.google.gerrit.common.PageLinks.op ( "project" , proj.get ( ) ) ) ; } }
public void commentOnReviewableChangeByOtherCcingSelf ( ) throws java.lang.Exception { com.google.gerrit.acceptance.TestAccount other = accounts.create ( "other" , "other@example.com" , "other" ) ; com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS ) ; setApiUser ( other ) ; review ( sc.changeId , com.google.gerrit.extensions.client.GeneralPreferencesInfo.EmailStrategy.CC_ON_OWN_COMMENTS ) ; assertThat ( sender ) . sent ( "comment" , sc ) . to ( sc.owner ) . to ( sc.reviewerByEmail ) . cc ( sc.reviewer , sc.ccer , other ) . cc ( sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS ) ; }
private void afterTest ( ) throws java.lang.Exception { db.close ( ) ; sshSession.close ( ) ; if ( ( server ) != ( com.google.gerrit.acceptance.AbstractDaemonTest.commonServer ) ) { server.stop ( ) ; } }
public com.google.gerrit.extensions.client.DiffPreferencesInfo apply ( com.google.gerrit.server.account.AccountResource rsrc ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.permissions.PermissionBackendException , java.io.IOException , org.eclipse.jgit.errors.ConfigInvalidException { if ( ( self.get ( ) ) != ( rsrc.getUser ( ) ) ) { permissionBackend.user ( self ) . check ( GlobalPermission.ADMINISTRATE_SERVER ) ; } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser ( ) . getAccountId ( ) ; return accountCache.get ( id ) . map ( AccountState :: getDiffPreferences ) . orElseThrow ( ( ) -> new com.google.gerrit.extensions.restapi.ResourceNotFoundException ( com.google.gerrit.extensions.restapi.IdString.fromDecoded ( id.toString ( ) ) ) ) ; }
public boolean isIdentityTrustable ( final java.util.Collection < com.google.gerrit.client.reviewdb.AccountExternalId > ids ) { switch ( getLoginType ( ) ) { case DEVELOPMENT_BECOME_ANY_ACCOUNT : case HTTP : return true ; case OPENID : for ( final com.google.gerrit.client.reviewdb.AccountExternalId e : ids ) { if ( ! ( isTrusted ( e ) ) ) { return false ; } } return true ; default : return false ; } }
public java.util.List < com.google.gerrit.reviewdb.client.PatchSetApproval > addReviewers ( com.google.gerrit.reviewdb.server.ReviewDb db , com.google.gerrit.common.data.LabelTypes labelTypes , com.google.gerrit.reviewdb.client.Change change , com.google.gerrit.reviewdb.client.PatchSet ps , com.google.gerrit.reviewdb.client.PatchSetInfo info , java.lang.Iterable < com.google.gerrit.reviewdb.client.Account.Id > wantReviewers , java.util.Set < com.google.gerrit.reviewdb.client.Account.Id > existingReviewers ) throws com.google.gwtorm.server.OrmException { return addReviewers ( db , labelTypes , change , ps.getId ( ) , ps.isDraft ( ) , info.getAuthor ( ) . getAccount ( ) , info.getCommitter ( ) . getAccount ( ) , wantReviewers , existingReviewers ) ; }
public java.util.Map < K , V > getAll ( java.lang.Iterable < K > keys ) { java.util.HashMap < K , V > map = new java.util.HashMap < K , V > ( ) ; for ( K k : keys ) { if ( ! ( map.containsKey ( k ) ) ) { V v = get ( k ) ; if ( v != null ) { map.put ( k , v ) ; } } } return map ; }
public java.lang.Object apply ( com.google.gerrit.server.change.PatchResource resource , com.google.gerrit.server.change.Reviewed.Input input ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.get ( ) ; com.google.gerrit.reviewdb.client.AccountPatchReview apr = com.google.gerrit.server.change.Reviewed.getExisting ( db , resource ) ; if ( apr != null ) { db.accountPatchReviews ( ) . delete ( java.util.Collections.singleton ( apr ) ) ; } return com.google.gerrit.extensions.restapi.Response.none ( ) ; }
public void getGrandChildProject_NotFound ( ) throws java.lang.Exception { com.google.gerrit.acceptance.SshSession sshSession = new com.google.gerrit.acceptance.SshSession ( server , admin ) ; com.google.gerrit.reviewdb.client.Project.NameKey child = new com.google.gerrit.reviewdb.client.Project.NameKey ( "p1" ) ; createProject ( child.get ( ) ) ; com.google.gerrit.reviewdb.client.Project.NameKey grandChild = new com.google.gerrit.reviewdb.client.Project.NameKey ( "p1.1" ) ; createProject ( grandChild.get ( ) , child ) ; sshSession.close ( ) ; assertChildNotFound ( allProjects , grandChild.get ( ) ) ; }
public void setUp ( ) throws java.lang.Exception { group1 = group ( "users1" ) ; group ( "users2" ) ; group ( "users3" ) ; user1 = accounts.create ( "user1" , "user1@example.com" , "User1" , "users1" ) ; user2 = accounts.create ( "user2" , "user2@example.com" , "User2" , "users2" ) ; user3 = accounts.create ( "user3" , "user3@example.com" , "User3" , "users1" , "users2" ) ; }
public static void sortRevisionInfoByNumber ( com.google.gwt.core.client.JsArray < com.google.gerrit.client.changes.ChangeInfo.RevisionInfo > list ) { java.util.Collections.sort ( com.google.gerrit.client.rpc.Natives.asList ( list ) , new java.util.Comparator < com.google.gerrit.client.changes.ChangeInfo.RevisionInfo > ( ) { @ java.lang.Override public int compare ( com.google.gerrit.client.changes.ChangeInfo.RevisionInfo a , com.google.gerrit.client.changes.ChangeInfo.RevisionInfo b ) { return ( a._number ( ) ) - ( b._number ( ) ) ; } } ) ; }
public boolean canDeleteRef ( final java.lang.String refname ) { switch ( user.getAccessPath ( ) ) { case WEB : if ( isOwner ( ) ) { return true ; } if ( ( com.google.gerrit.server.project.ProjectControl.isHead ( refname ) ) && ( canPerform ( com.google.gerrit.reviewdb.ApprovalCategory.PUSH_HEAD , com.google.gerrit.reviewdb.ApprovalCategory.PUSH_HEAD_REPLACE ) ) ) { return true ; } return false ; case SSH : if ( ( com.google.gerrit.server.project.ProjectControl.isHead ( refname ) ) && ( canPerform ( com.google.gerrit.reviewdb.ApprovalCategory.PUSH_HEAD , com.google.gerrit.reviewdb.ApprovalCategory.PUSH_HEAD_REPLACE ) ) ) { return true ; } return false ; default : return false ; } }
public com.google.common.collect.ImmutableListMultimap < com.google.gerrit.reviewdb.client.PatchSet.Id , com.google.gerrit.reviewdb.client.PatchSetApproval > getApprovals ( ) { return state.approvals ( ) ; }
void removeCommentBox ( com.google.gerrit.common.changes.Side side , int line ) { getLineBoxMapFromSide ( side ) . remove ( line ) ; }
private com.google.gerrit.server.account.AccountState toChangeData ( com.google.gson.JsonElement json ) { com.google.gson.JsonElement source = json.getAsJsonObject ( ) . get ( "_source" ) ; if ( source == null ) { source = json.getAsJsonObject ( ) . get ( "fields" ) ; } return toAccountState ( source ) ; }
public void onKeyPress ( final com.google.gwt.event.dom.client.KeyPressEvent event ) { if ( ( event.isControlKeyDown ( ) ) || ( event.isMetaKeyDown ( ) ) ) { switch ( event.getCharCode ( ) ) { case 'c' : case 'x' : com.google.gwt.core.client.Scheduler.get ( ) . scheduleDeferred ( new com.google.gwt.user.client.Command ( ) { public void execute ( ) { hideTextBox ( ) ; } } ) ; break ; } } }
private static java.lang.String targetForBrowser ( java.lang.String browser ) { if ( ( browser == null ) || ( browser.isEmpty ( ) ) ) { return "ui_dbg" ; } else if ( browser.startsWith ( "ui_" ) ) { return browser ; } else { return "ui_" + browser ; } }
public void onFailure ( final java.lang.Throwable caught ) { userNameTxt.setEnabled ( true ) ; changeUserName.setEnabled ( true ) ; super . onFailure ( caught ) ; }
private boolean isRepo ( java.nio.file.Path p ) { java.lang.String name = p.getFileName ( ) . toString ( ) ; return ( ! ( name.equals ( Constants.DOT_GIT ) ) ) && ( name.endsWith ( Constants.DOT_GIT_EXT ) ) ; }
public com.google.common.collect.ImmutableList < com.google.gerrit.reviewdb.client.AccountGroup.UUID > load ( java.lang.String key ) throws java.lang.Exception { try ( com.google.gerrit.reviewdb.server.ReviewDb db = schema.open ( ) ) { java.util.Set < com.google.gerrit.reviewdb.client.AccountGroup.UUID > ids = new java.util.HashSet < > ( ) ; for ( com.google.gerrit.reviewdb.client.AccountGroupById agi : db.accountGroupById ( ) . all ( ) ) { if ( ! ( com.google.gerrit.reviewdb.client.AccountGroup.isInternalGroup ( agi.getIncludeUUID ( ) ) ) ) { ids.add ( agi.getIncludeUUID ( ) ) ; } } return com.google.common.collect.ImmutableList.copyOf ( ids ) ; } }
private void throwUnsupported ( final org.objectweb.asm.MethodVisitor mv , final java.lang.String message ) { final org.objectweb.asm.Type eType = org.objectweb.asm.Type.getType ( java.lang.UnsupportedOperationException.class ) ; mv.visitTypeInsn ( com.google.gwtorm.jdbc.gen.NEW , eType.getInternalName ( ) ) ; mv.visitInsn ( com.google.gwtorm.jdbc.gen.DUP ) ; mv.visitLdcInsn ( message ) ; mv.visitMethodInsn ( com.google.gwtorm.jdbc.gen.INVOKESPECIAL , eType.getInternalName ( ) , "<init>" , org.objectweb.asm.Type.getMethodDescriptor ( Type.VOID_TYPE , new org.objectweb.asm.Type [ ] { org.objectweb.asm.Type.getType ( java.lang.String.class ) } ) ) ; mv.visitInsn ( com.google.gwtorm.jdbc.gen.ATHROW ) ; }
private void assertReviewers ( com.google.gerrit.reviewdb.client.Change c , com.google.gerrit.acceptance.TestAccount ... expectedReviewers ) throws com.google.gwtorm.server.OrmException { java.lang.Iterable < com.google.gerrit.reviewdb.client.Account.Id > actualIds = approvalsUtil.getReviewers ( db , notesFactory.create ( db , c.getProject ( ) , c.getId ( ) ) ) . values ( ) ; com.google.common.truth.Truth.assertThat ( actualIds ) . containsExactlyElementsIn ( com.google.common.collect.Sets.newHashSet ( com.google.gerrit.acceptance.TestAccount.ids ( expectedReviewers ) ) ) ; }
public static void toggleStar ( final com.google.gerrit.reviewdb.client.Change.Id changeId , final boolean newValue ) { if ( ( com.google.gerrit.client.changes.StarredChanges.next ) == null ) { com.google.gerrit.client.changes.StarredChanges.next = new com.google.gerrit.common.data.ToggleStarRequest ( ) ; } com.google.gerrit.client.changes.StarredChanges.next.toggle ( changeId , newValue ) ; com.google.gerrit.client.changes.StarredChanges.fireChangeStarEvent ( changeId , newValue ) ; if ( ! ( com.google.gerrit.client.changes.StarredChanges.busy ) ) { com.google.gerrit.client.changes.StarredChanges.start ( ) ; } }
private static boolean getBoolean ( org.eclipse.jgit.lib.Config cfg , java.lang.String section , java.lang.String name , boolean defaultValue ) { try { return cfg.getBoolean ( section , name , defaultValue ) ; } catch ( java.lang.IllegalArgumentException e ) { com.ericsson.gerrit.plugins.highavailability.Configuration.log.error ( java.lang.String.format ( "invalid value for %s; using default value %s" , name , defaultValue ) ) ; com.ericsson.gerrit.plugins.highavailability.Configuration.log.debug ( ( "Failed to retrieve boolean value: " + ( e.getMessage ( ) ) ) , e ) ; return defaultValue ; } }
public void onOk ( ) { send ( ) ; }
private boolean isActionAllowed ( com.google.gerrit.server.project.ChangeControl changeControl , com.google.gerrit.reviewdb.client.Change.Status status ) { return ( ( status != ( com.google.gerrit.reviewdb.client.Change.Status.DRAFT ) ) || ( allowDrafts ) ) || ( changeControl.isAdmin ( ) ) ; }
public static java.util.Set < java.lang.String > accountFields ( com.google.gerrit.server.index.QueryOptions opts ) { java.util.Set < java.lang.String > fs = opts.fields ( ) ; return fs.contains ( com.google.gerrit.server.index.account.AccountField.ID.getName ( ) ) ? fs : com.google.common.collect.Sets.union ( fs , com.google.common.collect.ImmutableSet.of ( com.google.gerrit.server.index.account.AccountField.ID.getName ( ) ) ) ; }
private void index ( com.google.gerrit.reviewdb.client.Account.Id id ) throws java.io.IOException { java.util.concurrent.atomic.AtomicInteger accountIdLock = getAndIncrementAccountIdLock ( id ) ; synchronized ( accountIdLock ) { indexer.index ( id ) ; com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexAccountRestApiServlet.logger.debug ( "Account {} successfully indexed" , id ) ; } if ( ( accountIdLock.decrementAndGet ( ) ) == 0 ) { removeAccountIdLock ( id ) ; } }
private com.google.gerrit.httpd.resources.Resource getMarkdownAsHtmlResource ( com.googlesource.gerrit.plugins.xdocs.XDocGlobalConfig cfg , com.google.gerrit.reviewdb.client.Project.NameKey project , java.lang.String md , int lastModified ) throws java.io.IOException { com.google.gerrit.server.documentation.MarkdownFormatter f = new com.google.gerrit.server.documentation.MarkdownFormatter ( ) ; if ( ! ( cfg.isHtmlAllowed ( Formatter.MARKDOWN ) ) ) { f.suppressHtml ( ) ; } byte [ ] html = f.markdownToDocHtml ( replaceMacros ( project , md ) , java.nio.charset.StandardCharsets.UTF_8.name ( ) ) ; return new com.google.gerrit.httpd.resources.SmallResource ( html ) . setContentType ( "text/html" ) . setCharacterEncoding ( java.nio.charset.StandardCharsets.UTF_8.name ( ) ) . setLastModified ( lastModified ) ; }
protected void configure ( ) { bind ( java.util.concurrent.Executor.class ) . annotatedWith ( com.googlesource.gerrit.plugins.webhooks.WebHooksExecutor.class ) . toProvider ( com.googlesource.gerrit.plugins.webhooks.ExecutorProvider.class ) ; bind ( com.googlesource.gerrit.plugins.webhooks.Configuration.class ) . in ( Scopes.SINGLETON ) ; bind ( org.apache.http.impl.client.CloseableHttpClient.class ) . toProvider ( com.googlesource.gerrit.plugins.webhooks.HttpClientProvider.class ) . in ( Scopes.SINGLETON ) ; factory ( PostEventTask.Factory.class ) ; com.google.gerrit.extensions.registration.DynamicSet.bind ( binder ( ) , com.google.gerrit.common.EventListener.class ) . to ( com.googlesource.gerrit.plugins.webhooks.EventHandler.class ) ; }
public final boolean has_skip ( ) { com.google.gwt.core.client.JsArray < com.google.gerrit.client.diff.DiffInfo.Region > c = content ( ) ; for ( int i = 0 ; i < ( c.length ( ) ) ; i ++ ) { if ( ( c.get ( i ) . skip ( ) ) != 0 ) { return true ; } } return false ; }
public com.google.gerrit.extensions.restapi.Response < com.google.gerrit.extensions.common.ChangeInfo > apply ( com.google.gerrit.server.change.ChangeResource rsrc , com.google.gerrit.extensions.api.changes.FixInput input ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.permissions.PermissionBackendException , com.google.gwtorm.server.OrmException { if ( ( ! ( rsrc.isUserOwner ( ) ) ) && ( ! ( rsrc.getControl ( ) . getProjectControl ( ) . isOwner ( ) ) ) ) { permissionBackend.user ( user ) . check ( GlobalPermission.MAINTAIN_SERVER ) ; } return com.google.gerrit.extensions.restapi.Response.withMustRevalidate ( newChangeJson ( ) . fix ( input ) . format ( rsrc ) ) ; }
private org.eclipse.jgit.revwalk.RevObject resolve ( java.lang.String name , org.eclipse.jgit.revwalk.RevWalk walk ) throws java.io.IOException { try { org.eclipse.jgit.lib.ObjectId id = repo.resolve ( name ) ; return id != null ? walk.parseAny ( id ) : null ; } catch ( org.eclipse.jgit.errors.RevisionSyntaxException e ) { return null ; } catch ( org.eclipse.jgit.errors.MissingObjectException e ) { return null ; } }
private com.google.gerrit.server.notedb.RevisionNoteData parseJson ( com.google.gerrit.server.notedb.ChangeNoteUtil noteUtil , int offset ) throws java.io.IOException { com.google.gerrit.server.notedb.RevisionNoteData data ; try ( java.io.InputStream is = new java.io.ByteArrayInputStream ( raw , offset , ( ( raw.length ) - offset ) ) ; java.io.Reader r = new java.io.InputStreamReader ( is ) ) { data = noteUtil.getGson ( ) . fromJson ( r , com.google.gerrit.server.notedb.RevisionNoteData.class ) ; } return data ; }
public void missingRepo ( ) throws java.lang.Exception { assumeNoteDbDisabled ( ) ; com.google.gerrit.server.project.ChangeControl ctl = insertChange ( ) ; com.google.gerrit.reviewdb.client.Project.NameKey name = ctl.getProject ( ) . getNameKey ( ) ; ( ( com.google.gerrit.testutil.InMemoryRepositoryManager ) ( repoManager ) ) . deleteRepository ( name ) ; assertProblems ( ctl , null , com.google.gerrit.acceptance.server.change.ConsistencyCheckerIT.problem ( ( "Destination repository not found: " + name ) ) ) ; }
public void parseRef ( ) throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit master = repo.branch ( "refs/heads/master" ) . commit ( ) . create ( ) ; org.junit.Assert.assertEquals ( new com.google.gitiles.RevisionParser.Result ( com.google.gitiles.Revision.peeled ( "master" , master ) ) , parser.parse ( "master" ) ) ; org.junit.Assert.assertEquals ( new com.google.gitiles.RevisionParser.Result ( com.google.gitiles.Revision.peeled ( "refs/heads/master" , master ) ) , parser.parse ( "refs/heads/master" ) ) ; org.junit.Assert.assertNull ( parser.parse ( "refs//heads//master" ) ) ; org.junit.Assert.assertNull ( parser.parse ( "refs heads master" ) ) ; }
public com.google.gerrit.server.change.ChangeJson.ChangeInfo format ( com.google.gerrit.server.change.RevisionResource rsrc ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData cd = new com.google.gerrit.server.query.change.ChangeData ( rsrc.getControl ( ) ) ; cd.limitToPatchSets ( com.google.common.collect.ImmutableList.of ( rsrc.getPatchSet ( ) . getId ( ) ) ) ; return format ( cd ) ; }
public void newPatchSetByOtherOnReviewableChangeOwnerSelfCcInNoteDb ( ) throws java.lang.Exception { com.google.common.truth.TruthJUnit.assume ( ) . that ( notesMigration.readChanges ( ) ) . isTrue ( ) ; com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.NEW_PATCHSETS ) ; pushTo ( sc , "refs/for/master" , other , EmailStrategy.CC_ON_OWN_COMMENTS ) ; assertThat ( sender ) . sent ( "newpatchset" , sc ) . to ( sc.owner , sc.reviewer , other ) . cc ( sc.ccer ) . cc ( sc.reviewerByEmail , sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.NEW_PATCHSETS ) ; }
public static org.eclipse.jgit.lib.Config allEnabledConfig ( ) { org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config ( ) ; for ( com.google.gerrit.server.notedb.ConfigNotesMigration.Table t : com.google.gerrit.server.notedb.ConfigNotesMigration.Table.values ( ) ) { cfg.setBoolean ( com.google.gerrit.server.notedb.ConfigNotesMigration.NOTEDB , t.key ( ) , com.google.gerrit.server.notedb.ConfigNotesMigration.WRITE , true ) ; cfg.setBoolean ( com.google.gerrit.server.notedb.ConfigNotesMigration.NOTEDB , t.key ( ) , com.google.gerrit.server.notedb.ConfigNotesMigration.READ , true ) ; } return cfg ; }
private void testPushWithInvalidChangeIdFromEgit ( ) throws java.lang.Exception { com.google.gerrit.acceptance.git.AbstractPushForReview.createCommit ( testRepo , ( "Message with invalid Change-Id\n" + ( "\n" + "Change-Id: I0000000000000000000000000000000000000000\n" ) ) ) ; com.google.gerrit.acceptance.git.AbstractPushForReview.pushForReviewRejected ( testRepo , "invalid Change-Id line format in commit message footer" ) ; com.google.gerrit.server.git.ProjectConfig config = projectCache.checkedGet ( project ) . getConfig ( ) ; config.getProject ( ) . setRequireChangeID ( InheritableBoolean.FALSE ) ; saveProjectConfig ( project , config ) ; com.google.gerrit.acceptance.git.AbstractPushForReview.pushForReviewRejected ( testRepo , "invalid Change-Id line format in commit message footer" ) ; }
public void run ( ) { getSkipManager ( ) . removeAll ( ) ; getChunkManager ( ) . reset ( ) ; getDiffTable ( ) . scrollbar.removeDiffAnnotations ( ) ; setShowIntraline ( prefs.intralineDifference ( ) ) ; render ( diff ) ; getSkipManager ( ) . render ( prefs.context ( ) , diff ) ; }
private static boolean isDateField ( java.lang.String name ) { return ( ( "lastUpdated" . equals ( name ) ) || ( "grantedOn" . equals ( name ) ) ) || ( "timestamp" . equals ( name ) ) ; }
private com.google.gerrit.extensions.client.SubmitType getSubmitType ( com.google.gerrit.server.query.change.ChangeData cd , com.google.gerrit.reviewdb.client.PatchSet patchSet ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.SubmitTypeRecord rec = submitRuleEvaluatorFactory.create ( cd ) . setPatchSet ( patchSet ) . getSubmitType ( ) ; if ( ( rec.status ) != ( SubmitTypeRecord.Status.OK ) ) { throw new com.google.gwtorm.server.OrmException ( ( "Submit type rule failed: " + rec ) ) ; } return rec.type ; }
static void addHistoryHook ( final com.google.gwt.core.client.JavaScriptObject hook ) { if ( ( com.google.gerrit.client.Gerrit.historyHooks ) == null ) { com.google.gerrit.client.Gerrit.historyHooks = new java.util.ArrayList < com.google.gwt.core.client.JavaScriptObject > ( ) ; com.google.gwt.user.client.History.addHistoryListener ( new com.google.gwt.user.client.HistoryListener ( ) { public void onHistoryChanged ( final java.lang.String historyToken ) { com.google.gerrit.client.Gerrit.dispatchHistoryHooks ( historyToken ) ; } } ) ; } com.google.gerrit.client.Gerrit.historyHooks.add ( hook ) ; }
private java.lang.String anchorHref ( java.lang.String val ) { if ( com.google.gitiles.doc.html.HtmlBuilder.URI.getValueFilter ( ) . matcher ( val ) . find ( ) ) { return com.google.gitiles.doc.html.HtmlBuilder.URI.escape ( val ) ; } return com.google.gitiles.doc.html.HtmlBuilder.URI.getInnocuousOutput ( ) ; }
private void readObject ( final java.io.ObjectInputStream in ) throws java.io.IOException { projectKey = new com.google.gerrit.client.reviewdb.Project.NameKey ( in.readUTF ( ) ) ; oldId = org.spearce.jgit.lib.ObjectIdSerialization.read ( in ) ; newId = org.spearce.jgit.lib.ObjectIdSerialization.read ( in ) ; fileName = com.google.gerrit.server.patch.DiffCacheKey.readString ( in ) ; sourceFileName = com.google.gerrit.server.patch.DiffCacheKey.readString ( in ) ; }
private boolean canPushWithForce ( ) { if ( ( GitRepositoryManager.REF_CONFIG.equals ( refName ) ) && ( ! ( projectControl.isOwner ( ) ) ) ) { return false ; } boolean result = false ; for ( com.google.gerrit.common.data.PermissionRule rule : access ( Permission.PUSH ) ) { if ( rule.isBlock ( ) ) { return false ; } if ( rule.getForce ( ) ) { result = true ; } } return result ; }
public void testCarriageReturn ( ) throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = makeCommit ( ) ; com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator validator = new com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator ( null , new com.googlesource.gerrit.plugins.uploadvalidator.ContentTypeUtil ( com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.PATTERN_CACHE ) , null , null , null ) ; java.util.List < com.google.gerrit.server.git.validators.CommitValidationMessage > m = validator.performValidation ( repo , c , com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.EMPTY_PLUGIN_CONFIG ) ; com.google.common.truth.Truth.assertThat ( com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.transformMessages ( m ) ) . containsExactlyElementsIn ( com.google.common.collect.ImmutableSet.of ( "ERROR: found carriage return (CR) character in file: foo.txt" ) ) ; }
public com.google.gerrit.extensions.client.GeneralPreferencesInfo apply ( com.google.gerrit.server.config.ConfigResource rsrc , com.google.gerrit.extensions.client.GeneralPreferencesInfo input ) throws com.google.gerrit.extensions.restapi.BadRequestException , java.io.IOException , org.eclipse.jgit.errors.ConfigInvalidException { if ( ! ( com.google.gerrit.server.restapi.config.SetPreferences.hasSetFields ( input ) ) ) { throw new com.google.gerrit.extensions.restapi.BadRequestException ( "unsupported option" ) ; } com.google.gerrit.server.account.Preferences.validateMy ( input.my ) ; try ( com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.get ( ) . create ( allUsersName ) ) { com.google.gerrit.extensions.client.GeneralPreferencesInfo updatedPrefs = com.google.gerrit.server.account.Preferences.updateDefaultGeneralPreferences ( md , input ) ; accountCache.evictAllNoReindex ( ) ; return updatedPrefs ; } }
public void onSuccess ( final com.google.gerrit.client.reviewdb.AccountSshKey result ) { addNew.setEnabled ( true ) ; addTxt.setText ( "" ) ; keys.addOneKey ( result ) ; }
public com.google.gerrit.extensions.common.GroupInfo format ( com.google.gerrit.common.data.GroupDescription.Basic group ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.extensions.common.GroupInfo info = init ( group ) ; if ( ( options.contains ( com.google.gerrit.extensions.client.ListGroupsOption.MEMBERS ) ) || ( options.contains ( com.google.gerrit.extensions.client.ListGroupsOption.INCLUDES ) ) ) { com.google.gerrit.server.group.GroupResource rsrc = new com.google.gerrit.server.group.GroupResource ( groupControlFactory.controlFor ( group ) ) ; initMembersAndSubgroups ( rsrc , info ) ; } return info ; }
public static java.lang.String toLongString ( final com.google.gerrit.extensions.api.projects.ProjectState type ) { if ( type == null ) { return "" ; } switch ( type ) { case ACTIVE : return com.google.gerrit.client.admin.Util.C.projectState_ACTIVE ( ) ; case READ_ONLY : return com.google.gerrit.client.admin.Util.C.projectState_READ_ONLY ( ) ; case HIDDEN : return com.google.gerrit.client.admin.Util.C.projectState_HIDDEN ( ) ; default : return type.name ( ) ; } }
public static void doSignOut ( ) { com.google.gerrit.client.Gerrit.myAccount = null ; com.google.gwt.user.client.Cookies.removeCookie ( com.google.gerrit.client.Gerrit.ACCOUNT_COOKIE ) ; com.google.gerrit.client.Gerrit.globalHandlers.fireEvent ( new com.google.gerrit.client.SignOutEvent ( ) ) ; com.google.gwtexpui.globalkey.client.GlobalKey.filter ( new com.google.gwtexpui.globalkey.client.KeyCommandFilter ( ) { public boolean include ( final com.google.gwtexpui.globalkey.client.KeyCommand key ) { return ! ( key instanceof com.google.gerrit.client.ui.NeedsSignInKeyCommand ) ; } } ) ; com.google.gerrit.client.Gerrit.refreshMenuBar ( ) ; final com.google.gerrit.client.ui.Screen cs = com.google.gerrit.client.Gerrit.body.getView ( ) ; if ( cs != null ) { cs.onSignOut ( ) ; } }
void resizeCodeMirror ( ) { int rest = ( ( ( com.google.gerrit.client.Gerrit.getHeaderFooterHeight ( ) ) + ( header.getOffsetHeight ( ) ) ) + ( diffTable.getHeaderHeight ( ) ) ) + 10 ; int h = ( com.google.gwt.user.client.Window.getClientHeight ( ) ) - rest ; cmA.setHeight ( h ) ; cmB.setHeight ( h ) ; cmA.refresh ( ) ; cmB.refresh ( ) ; diffTable.sidePanel.adjustGutters ( cmB ) ; }
public void listBranchesOfNonExistingProject_NotFound ( ) throws java.lang.Exception { com.google.common.truth.Truth.assertThat ( GET ( "/projects/non-existing/branches" ) . getStatusCode ( ) ) . isEqualTo ( HttpStatus.SC_NOT_FOUND ) ; }
public static boolean branchExists ( final com.google.gerrit.server.git.GitRepositoryManager repoManager , final com.google.gerrit.reviewdb.client.Branch.NameKey branch ) throws java.io.IOException , org.eclipse.jgit.errors.RepositoryNotFoundException { final org.eclipse.jgit.lib.Repository repo = repoManager.openRepository ( branch.getParentKey ( ) ) ; try { boolean exists = ( repo.getRef ( branch.get ( ) ) ) != null ; if ( ! exists ) { exists = repo.getFullBranch ( ) . equals ( branch.get ( ) ) ; } return exists ; } finally { repo.close ( ) ; } }
private void parseReviewer ( com.google.gerrit.server.notedb.ReviewerState state , java.lang.String line ) throws org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.PersonIdent ident = org.eclipse.jgit.util.RawParseUtils.parsePersonIdent ( line ) ; if ( ident == null ) { throw invalidFooter ( state.getFooterKey ( ) , line ) ; } com.google.gerrit.reviewdb.client.Account.Id accountId = parseIdent ( ident ) ; if ( ! ( reviewers.containsKey ( accountId ) ) ) { reviewers.put ( accountId , state ) ; } }
public java.lang.String apply ( java.lang.String s ) { try { return java.net.URLEncoder.encode ( s , java.nio.charset.StandardCharsets.UTF_8.name ( ) ) . replace ( "%2F" , "/" ) . replace ( "%2f" , "/" ) . replace ( "+" , "%20" ) . replace ( "%2B" , "+" ) . replace ( "%2b" , "+" ) ; } catch ( java.io.UnsupportedEncodingException e ) { throw new java.lang.IllegalStateException ( e ) ; } }
public void newPatchSetOnWipChangeSettingReadyInNoteDb ( ) throws java.lang.Exception { com.google.common.truth.TruthJUnit.assume ( ) . that ( notesMigration.readChanges ( ) ) . isTrue ( ) ; com.google.gerrit.acceptance.server.mail.StagedChange sc = stageWipChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.NEW_PATCHSETS ) ; pushTo ( sc , "refs/for/master%ready" , sc.owner ) ; assertThat ( sender ) . sent ( "newpatchset" , sc ) . notTo ( sc.owner ) . to ( sc.reviewer ) . cc ( sc.ccer ) . cc ( sc.reviewerByEmail , sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.NEW_PATCHSETS ) ; assertThat ( sender ) . notSent ( ) ; }
private void expandAfter ( ) { net.codemirror.lib.TextMarker.FromTo range = textMarker.find ( ) ; int start = range.getFrom ( ) . getLine ( ) ; int oldEnd = range.getTo ( ) . getLine ( ) ; int newEnd = oldEnd - ( com.google.gerrit.client.diff.SkipBar.NUM_ROWS_TO_EXPAND ) ; boolean attach = start == 0 ; if ( attach ) { clearMarkerAndWidget ( ) ; } else { textMarker.clear ( ) ; } collapse ( start , newEnd , attach ) ; updateSelection ( ) ; }
public static com.google.gerrit.server.patch.DiffSummaryKey fromPatchListKey ( com.google.gerrit.server.patch.PatchListKey plk ) { return new com.google.gerrit.server.patch.DiffSummaryKey ( plk.getOldId ( ) , plk.getParentNum ( ) , plk.getNewId ( ) , plk.getWhitespace ( ) ) ; }
void operation ( final java.lang.Runnable apply ) { cmA.operation ( new java.lang.Runnable ( ) { @ java.lang.Override public void run ( ) { cmB.operation ( new java.lang.Runnable ( ) { @ java.lang.Override public void run ( ) { apply.run ( ) ; } } ) ; } } ) ; }
private static java.nio.file.Path popdir ( java.net.URL u , java.nio.file.Path dir , java.lang.String name ) throws java.io.FileNotFoundException { if ( com.google.gerrit.launcher.GerritLauncher.last ( dir ) . equals ( name ) ) { return dir.getParent ( ) ; } throw new java.io.FileNotFoundException ( ( "Cannot find buck-out from " + u ) ) ; }
public java.lang.String format ( ) { if ( ( value ( ) ) == ( ( short ) ( 0 ) ) ) { return '-' + ( label ( ) ) ; } else if ( ( value ( ) ) < 0 ) { return ( label ( ) ) + ( value ( ) ) ; } else { return ( ( label ( ) ) + '+' ) + ( value ( ) ) ; } }
protected boolean canDelete ( com.google.gerrit.server.project.ProjectResource rsrc ) { com.google.gerrit.server.permissions.PermissionBackend.WithUser userPermission = permissionBackend.user ( userProvider ) ; com.google.gerrit.server.permissions.PermissionBackend.ForProject projectPermission = userPermission.project ( rsrc.getNameKey ( ) ) ; return ( ( userPermission.testOrFalse ( GlobalPermission.ADMINISTRATE_SERVER ) ) || ( userPermission.testOrFalse ( new com.google.gerrit.extensions.api.access.PluginPermission ( pluginName , com.googlesource.gerrit.plugins.deleteproject.DeleteProjectCapability.DELETE_PROJECT ) ) ) ) || ( ( userPermission.testOrFalse ( new com.google.gerrit.extensions.api.access.PluginPermission ( pluginName , com.googlesource.gerrit.plugins.deleteproject.DeleteOwnProjectCapability.DELETE_OWN_PROJECT ) ) ) && ( projectPermission.testOrFalse ( ProjectPermission.WRITE_CONFIG ) ) ) ; }
private boolean canRead ( org.eclipse.jgit.lib.ObjectId revId ) throws java.io.IOException { try ( org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk ( repo ) ) { org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit ( revId ) ; return projectControl.canReadCommit ( db , repo , commit ) ; } }
public void run ( ) { java.lang.String t = prefs.theme ( ) . name ( ) . toLowerCase ( ) ; view.getCmFromSide ( DisplaySide.A ) . setOption ( "theme" , t ) ; view.getCmFromSide ( DisplaySide.B ) . setOption ( "theme" , t ) ; }
void openAll ( ) { if ( ( table ) != null ) { java.lang.String self = com.google.gerrit.client.Gerrit.selfRedirect ( null ) ; for ( com.google.gerrit.client.diff.FileInfo info : com.google.gerrit.client.rpc.Natives.asList ( table.list ) ) { com.google.gwt.user.client.Window.open ( ( ( self + "#" ) + ( url ( info ) ) ) , "_blank" , null ) ; } } }
public boolean match ( com.google.gerrit.server.query.change.ChangeData cd ) throws com.google.gwtorm.client.OrmException { com.google.gerrit.reviewdb.Change change = cd.change ( dbProvider ) ; return ( change != null ) && ( ( change.getSortKey ( ) . compareTo ( getValue ( ) ) ) < 0 ) ; }
public void testUnblockForce ( ) { com.google.gerrit.common.data.PermissionRule r = com.google.gerrit.server.project.Util.block ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/heads/*" ) ; r.setForce ( true ) ; com.google.gerrit.server.project.Util.allow ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.Util.DEVS , "refs/heads/*" ) . setForce ( true ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.project.Util.DEVS ) ; org.junit.Assert.assertTrue ( "u can force push" , u.controlForRef ( "refs/heads/master" ) . canForceUpdate ( ) ) ; }
public void createNewChangeSignedOffByFooter ( ) throws java.lang.Exception { setSignedOffByFooter ( ) ; com.google.gerrit.extensions.common.ChangeInfo info = assertCreateSucceeds ( newChangeInput ( ChangeStatus.NEW ) ) ; java.lang.String message = info.revisions.get ( info.currentRevision ) . commit.message ; com.google.common.truth.Truth.assertThat ( message ) . contains ( java.lang.String.format ( "%sAdministrator <%s>" , org.eclipse.jgit.lib.Constants.SIGNED_OFF_BY_TAG , admin.getIdent ( ) . getEmailAddress ( ) ) ) ; }
private org.eclipse.jgit.lib.ObjectId pushChangeTo ( org.eclipse.jgit.junit.TestRepository < ? > repo , java.lang.String branch ) throws java.lang.Exception { return pushChangeTo ( repo , branch , "some change" ) ; }
public void onKeyPress ( com.google.gwt.event.dom.client.KeyPressEvent event ) { if ( com.google.gerrit.client.Gerrit.isSignedIn ( ) ) { if ( ( event.getNativeEvent ( ) . getCharCode ( ) ) == 0 ) { Window.Location.reload ( ) ; return ; } if ( topic.canEdit ( ) ) { topic.onEdit ( ) ; } } else { com.google.gerrit.client.Gerrit.doSignIn ( getToken ( ) ) ; } }
private void initRepository ( ) throws java.io.IOException { if ( ( repo ) == null ) { this . repo = repoManager.openRepository ( project ) ; closeRepo = true ; inserter = repo.newObjectInserter ( ) ; revWalk = new org.eclipse.jgit.revwalk.RevWalk ( inserter.newReader ( ) ) ; } }
private com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection newReviewerFilterSection ( java.lang.String filter ) { com.google.common.collect.ImmutableSet.Builder < java.lang.String > b = com.google.common.collect.ImmutableSet.builder ( ) ; for ( java.lang.String reviewer : cfg.getStringList ( com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FILTER , filter , "reviewer" ) ) { b.add ( reviewer ) ; } return new com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection ( filter , b.build ( ) ) ; }
public boolean isOwner ( ) { if ( canPerform ( com.google.gerrit.reviewdb.ApprovalCategory.OWN , ( ( short ) ( 1 ) ) ) ) { return true ; } if ( ( ! ( RefRight.ALL.equals ( getRefName ( ) ) ) ) && ( getProjectControl ( ) . isOwner ( ) ) ) { return true ; } return false ; }
public java.lang.String getUrl ( java.lang.String project ) { if ( ! ( isEnabled ( ) ) ) { return null ; } java.lang.StringBuilder r = new java.lang.StringBuilder ( ) ; r.append ( com.googlesource.gerrit.plugins.download.scheme.SshScheme.ensureSlash ( sshdAddress ) ) ; r.append ( project ) ; return r.toString ( ) ; }
public void testUpsertOneException ( ) throws com.google.gwtorm.client.OrmException , java.sql.SQLException { stubExecuteBatchException ( com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE , new java.sql.BatchUpdateException ( ) ) ; try { createClassUnderTest ( ) . upsert ( com.google.gwtorm.jdbc.TestJdbcAccess.ONE_ROW ) ; org.junit.Assert.fail ( "missingException" ) ; } catch ( com.google.gwtorm.client.OrmException e ) { } }
private RevisionParser.Result parseRevision ( javax.servlet.http.HttpServletRequest req , java.lang.String path ) throws java.io.IOException { com.google.gitiles.RevisionParser revParser = new com.google.gitiles.RevisionParser ( org.eclipse.jgit.http.server.ServletUtils.getRepository ( req ) , accessFactory.forRequest ( req ) , visibilityCache ) ; return revParser.parse ( path ) ; }
public com.google.gerrit.server.account.AccountSshKey create ( com.google.gerrit.server.account.AccountSshKey.Id id , java.lang.String encoded ) throws com.google.gerrit.common.errors.InvalidSshKeyException { try { com.google.gerrit.server.account.AccountSshKey key = new com.google.gerrit.server.account.AccountSshKey ( id , com.google.gerrit.sshd.SshUtil.toOpenSshPublicKey ( encoded ) ) ; com.google.gerrit.sshd.SshUtil.parse ( key ) ; return key ; } catch ( java.security.NoSuchAlgorithmException | java.security.spec.InvalidKeySpecException e ) { throw new com.google.gerrit.common.errors.InvalidSshKeyException ( ) ; } catch ( java.security.NoSuchProviderException e ) { com.google.gerrit.sshd.SshKeyCreatorImpl.log.error ( "Cannot parse SSH key" , e ) ; throw new com.google.gerrit.common.errors.InvalidSshKeyException ( ) ; } }
public java.util.List < com.google.gerrit.client.data.ChangeInfo > run ( final com.google.gerrit.client.reviewdb.ReviewDb db ) throws com.google.gwtorm.client.OrmException { final com.google.gerrit.client.reviewdb.Account.Id me = com.google.gerrit.client.rpc.RpcUtil.getAccountId ( ) ; final com.google.gerrit.client.data.AccountCache ac = new com.google.gerrit.client.data.AccountCache ( db ) ; final java.util.Set < com.google.gerrit.client.reviewdb.Change.Id > starred = com.google.gerrit.client.changes.ChangeListServiceImpl.starredBy ( db , me ) ; return com.google.gerrit.client.changes.ChangeListServiceImpl.list ( db.changes ( ) . get ( starred ) , starred , ac ) ; }
public void deleteReviewerFromReviewableChangeByAdmin ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange ( ) ; setApiUser ( admin ) ; removeReviewer ( sc , extraReviewer ) ; assertThat ( sender ) . sent ( "deleteReviewer" , sc ) . to ( sc.owner , extraReviewer ) . cc ( extraCcer , sc.reviewer , sc.ccer ) . cc ( sc.reviewerByEmail , sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS ) ; }
public java.lang.String getContentType ( ) { return "plain/text" ; }
public com.google.gerrit.server.git.ReceiveCommits.Capable canUpload ( ) { if ( ! ( projectControl.canUploadToAtLeastOneRef ( ) ) ) { java.lang.String reqName = project.getName ( ) ; return new com.google.gerrit.server.git.ReceiveCommits.Capable ( ( ( "Upload denied for project '" + reqName ) + "'" ) ) ; } if ( project.isUseContributorAgreements ( ) ) { try { return verifyActiveContributorAgreement ( ) ; } catch ( com.google.gwtorm.client.OrmException e ) { com.google.gerrit.server.git.ReceiveCommits.log.error ( "Cannot query database for agreements" , e ) ; return new com.google.gerrit.server.git.ReceiveCommits.Capable ( "Cannot verify contribution agreement" ) ; } } else { return com.google.gerrit.server.git.ReceiveCommits.Capable.OK ; } }
private int limit ( com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > s ) { int n = com.google.common.base.Objects.firstNonNull ( com.google.gerrit.server.query.change.ChangeQueryBuilder.getLimit ( s ) , maxLimit ) ; return ( limit ) > 0 ? ( java.lang.Math.min ( n , limit ) ) + 1 : n + 1 ; }
public void parseApproval ( ) throws java.lang.Exception { assertParseSucceeds ( ( "Update change\n" + ( ( ( ( ( "\n" + "Patch-Set: 1\n" ) + "Label: Label1=+1\n" ) + "Label: Label2=1\n" ) + "Label: Label3=0\n" ) + "Label: Label4=-1\n" ) ) ) ; assertParseFails ( ( "Update change\n" + ( ( "\n" + "Patch-Set: 1\n" ) + "Label: Label1=X\n" ) ) ) ; assertParseFails ( ( "Update change\n" + ( ( "\n" + "Patch-Set: 1\n" ) + "Label: Label1 = 1\n" ) ) ) ; assertParseFails ( ( "Update change\n" + ( ( "\n" + "Patch-Set: 1\n" ) + "Label: X+Y\n" ) ) ) ; }
public void testUpsertOneNotExisting ( ) throws com.google.gwtorm.server.OrmException , java.sql.SQLException { java.sql.PreparedStatement update = stubStatementWithUpdateCounts ( com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE ) ; java.sql.PreparedStatement insert = stubStatementWithUpdateCounts ( com.google.gwtorm.jdbc.TestJdbcAccess.INSERT , 1 ) ; createClassUnderTest ( ) . upsert ( oneRow ) ; com.google.gwtorm.jdbc.TestJdbcAccess.assertUsedBatchingOnly ( update ) ; com.google.gwtorm.jdbc.TestJdbcAccess.assertUsedBatchingOnly ( insert ) ; com.google.gwtorm.jdbc.TestJdbcAccess.assertExpectedIdsUsed ( insert , 1 ) ; }
public void missingRepo ( ) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = com.google.gerrit.testutil.TestChanges.newChange ( new com.google.gerrit.reviewdb.client.Project.NameKey ( "otherproject" ) , adminId ) ; db.changes ( ) . insert ( java.util.Collections.singleton ( c ) ) ; insertMissingPatchSet ( c , "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" ) ; assertProblems ( c , "Destination repository not found: otherproject" ) ; }
private static boolean isRewritePossible ( com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > p ) { if ( ( ( ( p.getClass ( ) ) != ( com.google.gerrit.server.query.AndPredicate.class ) ) && ( ( p.getClass ( ) ) != ( com.google.gerrit.server.query.OrPredicate.class ) ) ) && ( ( p.getClass ( ) ) != ( com.google.gerrit.server.query.NotPredicate.class ) ) ) { return false ; } return ( p.getChildCount ( ) ) > 0 ; }
private com.google.gerrit.pgm.init.File getPath ( ) { com.google.gerrit.pgm.init.Path basePath = site.resolve ( flags.cfg.getString ( "gerrit" , null , "basePath" ) ) ; if ( basePath == null ) { throw new java.lang.IllegalStateException ( "gerrit.basePath must be configured" ) ; } return com.google.gerrit.pgm.init.FileKey.resolve ( basePath.resolve ( allUsers ) . toFile ( ) , FS.DETECTED ) ; }
private boolean isRefDeleted ( com.googlesource.gerrit.plugins.refprotection.Event event ) { if ( event.getNewObjectId ( ) . equals ( org.eclipse.jgit.lib.ObjectId.zeroId ( ) . getName ( ) ) ) { com.googlesource.gerrit.plugins.refprotection.RefUpdateListener.log.info ( java.lang.String.format ( "Ref Deleted: project [%s] refname [%s] old object id [%s]" , event.getProjectName ( ) , event.getRefName ( ) , event.getOldObjectId ( ) ) ) ; return true ; } return false ; }
public static void generateHttpPassword ( java.lang.String account , com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.client.rpc.NativeString > cb ) { com.google.gerrit.client.account.AccountApi.HttpPasswordInput in = com.google.gerrit.client.account.AccountApi.HttpPasswordInput.create ( ) ; in.generate ( true ) ; com.google.gerrit.client.account.AccountApi.accounts ( ) . id ( account ) . view ( "password.http" ) . put ( in , cb ) ; }
public void rescheduleOnError ( ) throws java.io.IOException { org.mockito.Mockito.when ( session.post ( com.googlesource.gerrit.plugins.webhooks.PostTaskTest.WEBHOOK_URL , com.googlesource.gerrit.plugins.webhooks.PostTaskTest.HEADERS , remote , com.googlesource.gerrit.plugins.webhooks.PostTaskTest.BODY ) ) . thenReturn ( com.googlesource.gerrit.plugins.webhooks.PostTaskTest.ERR_RESULT ) ; task.run ( ) ; org.mockito.Mockito.verify ( executor , org.mockito.Mockito.times ( 1 ) ) . schedule ( task , com.googlesource.gerrit.plugins.webhooks.PostTaskTest.RETRY_INTERVAL , java.util.concurrent.TimeUnit.MILLISECONDS ) ; }
private void assertExternalId ( com.google.gerrit.server.account.externalids.ExternalId.Key extIdKey , @ com.google.gerrit.common.Nullable java.lang.String expectedEmail ) throws java.lang.Exception { com.google.gerrit.server.account.externalids.ExternalId extId = externalIds.get ( extIdKey ) ; com.google.common.truth.Truth.assertThat ( extId ) . named ( extIdKey.get ( ) ) . isNotNull ( ) ; com.google.common.truth.Truth.assertThat ( extId.email ( ) ) . named ( ( "email of " + ( extIdKey.get ( ) ) ) ) . isEqualTo ( expectedEmail ) ; }
private void setDefaultBlameCache ( ) { if ( ( blameCache ) == null ) { if ( config.getSubsections ( "cache" ) . contains ( "blame" ) ) { blameCache = new com.google.gitiles.BlameCache ( com.google.gitiles.ConfigUtil.getCacheBuilder ( config , "blame" ) ) ; } else { blameCache = new com.google.gitiles.BlameCache ( ) ; } } }
public void testUnblockForceEditTopicName ( ) { com.google.gerrit.server.project.Util.block ( local , com.google.gerrit.common.data.Permission.EDIT_TOPIC_NAME , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/heads/*" ) ; com.google.gerrit.server.project.Util.allow ( local , com.google.gerrit.common.data.Permission.EDIT_TOPIC_NAME , com.google.gerrit.server.project.Util.DEVS , "refs/heads/*" ) . setForce ( true ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.project.Util.DEVS ) ; org.junit.Assert.assertTrue ( "u can edit topic name" , u.controlForRef ( "refs/heads/master" ) . canForceEditTopicName ( ) ) ; }
private synchronized void runHook ( java.io.File hook , java.util.List < java.lang.String > args ) { if ( hook.exists ( ) ) { hookQueue.execute ( new com.google.gerrit.common.ChangeHookRunner.HookTask ( null , hook , args ) ) ; } }
private com.google.gerrit.extensions.api.GerritApi connect ( com.google.reviewit.app.ServerConfig serverCfg ) { return new com.urswolfer.gerrit.client.rest.GerritRestApiFactory ( ) . create ( new com.urswolfer.gerrit.client.rest.GerritAuthData.Basic ( serverCfg.url , serverCfg.user , serverCfg.password ) ) ; }
public < F1 , V > com.google.gerrit.metrics.CallbackMetric1 < F1 , V > newCallbackMetric ( java.lang.String name , java.lang.Class < V > valueClass , com.google.gerrit.metrics.Description desc , com.google.gerrit.metrics.Field < F1 > field1 ) { com.google.gerrit.metrics.dropwizard.CallbackMetricImpl1 < F1 , V > m = new com.google.gerrit.metrics.dropwizard.CallbackMetricImpl1 ( this , registry , name , valueClass , desc , field1 ) ; define ( name , desc ) ; bucketed.put ( name , m ) ; return m.create ( ) ; }
public void setUp ( ) throws java.lang.Exception { super . setUp ( ) ; final java.util.Properties p = new java.util.Properties ( ) ; p.setProperty ( "driver" , org.h2.Driver.class . getName ( ) ) ; p.setProperty ( "url" , ( "jdbc:h2:mem:PhoneBookDb" + ( ( com.google.gwtorm.server.PhoneBookDbTestCase.runCount ) ++ ) ) ) ; db = new com.google.gwtorm.jdbc.Database < com.google.gwtorm.data.PhoneBookDb > ( p , com.google.gwtorm.data.PhoneBookDb.class ) ; openSchemas = new java.util.ArrayList < com.google.gwtorm.data.PhoneBookDb > ( ) ; }
public void indexChange ( ) throws java.lang.Exception { java.lang.String changeId = createChange ( ) . getChangeId ( ) ; com.google.gerrit.acceptance.RestResponse r = userSession.post ( ( ( "/changes/" + changeId ) + "/index/" ) ) ; com.google.common.truth.Truth.assertThat ( r.getStatusCode ( ) ) . isEqualTo ( HttpStatus.SC_NO_CONTENT ) ; }
private static java.lang.String format ( java.lang.String name , short value ) { java.lang.StringBuilder sb = new java.lang.StringBuilder ( ( ( name.length ( ) ) + 2 ) ) ; sb.append ( name ) ; if ( value >= 0 ) { sb.append ( '+' ) ; } sb.append ( value ) ; return sb.toString ( ) ; }
private final native void setStartLine ( int sl ) ;
private static boolean isUnreasonableName ( java.lang.String name ) { if ( ( name.length ( ) ) < 1 ) return true ; if ( ( name.indexOf ( '\\' ) ) >= 0 ) return true ; if ( name.startsWith ( "../" ) ) return true ; if ( name.contains ( "/../" ) ) return true ; if ( name.contains ( "/./" ) ) return true ; if ( name.contains ( "//" ) ) return true ; return false ; }
public void onFailure ( final java.lang.Throwable caught ) { com.google.gwt.core.client.GWT.log ( "Fail" , caught ) ; }
public void testReplaceInOrder1 ( ) { final com.google.gwtexpui.safehtml.client.RawFindReplace [ ] repl = new com.google.gwtexpui.safehtml.client.RawFindReplace [ ] { new com.google.gwtexpui.safehtml.client.RawFindReplace ( "(GWTEXPUI-(\\d+))" , "<a href=\"gwtexpui-bug?$2\">$1</a>" ) , new com.google.gwtexpui.safehtml.client.RawFindReplace ( "(issue\\s+(\\d+))" , "<a href=\"generic-bug?$2\">$1</a>" ) } ; final com.google.gwtexpui.safehtml.client.SafeHtml o = com.google.gwtexpui.safehtml.client.SafeHtml_ReplaceTest.html ( "A\nissue 42\nReally GWTEXPUI-9918 is better\nB" ) ; final com.google.gwtexpui.safehtml.client.SafeHtml n = o.replaceAll ( java.util.Arrays.asList ( repl ) ) ; assertNotSame ( o , n ) ; assertEquals ( ( "A\n" + ( ( "<a href=\"generic-bug?42\">issue 42</a>\n" + "Really <a href=\"gwtexpui-bug?9918\">GWTEXPUI-9918</a> is better\n" ) + "B" ) ) , n.asString ( ) ) ; }
public boolean indexChange ( int changeId ) { try { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpResponseHandler.HttpResult result = httpSession.post ( buildEndpoint ( changeId ) ) ; if ( result.isSuccessful ( ) ) { return true ; } com.ericsson.gerrit.plugins.highavailability.forwarder.rest.RestForwarder.log.error ( "Unable to index change {}. Cause: {}" , changeId , result.getMessage ( ) ) ; } catch ( java.io.IOException e ) { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.RestForwarder.log.error ( ( "Error trying to index change " + changeId ) , e ) ; } return false ; }
public java.util.Set < java.lang.String > getMyOrganisationsLogins ( ) throws java.io.IOException { if ( isLoggedIn ( ) ) { try { return getMyOrganisationsLoginsViaApi ( ) ; } catch ( java.io.IOException e ) { com.googlesource.gerrit.plugins.github.oauth.GitHubLogin.log.error ( ( ( "Cannot retrieve " + ( getMyself ( ) . getLogin ( ) ) ) + "'s organisations via REST API => falling back to Web HTML profile" ) , e ) ; return getMyOrganisationsLoginsViaWeb ( ) ; } } return java.util.Collections.emptySet ( ) ; }
protected boolean isVisibleTo ( com.google.gerrit.reviewdb.client.Branch.NameKey branchName , com.google.gerrit.server.CurrentUser user ) { com.google.gerrit.server.project.ProjectState pe = projectCache.get ( branchName.getParentKey ( ) ) ; if ( pe == null ) { return false ; } com.google.gerrit.server.project.ProjectControl pc = pe.controlFor ( user ) ; return pc.controlForRef ( branchName ) . isVisible ( ) ; }
public void testInsertOneDBException ( ) throws com.google.gwtorm.server.OrmException , java.sql.SQLException { java.sql.SQLException exception = new java.sql.BatchUpdateException ( ) ; java.sql.PreparedStatement insert = stubStatementThrowExceptionOnExecute ( com.google.gwtorm.jdbc.TestJdbcAccess.INSERT , exception ) ; com.google.gwtorm.jdbc.JdbcAccess < com.google.gwtorm.jdbc.TestJdbcAccess.Data , com.google.gwtorm.jdbc.TestJdbcAccess.Data.DataKey > classUnderTest = createClassUnderTest ( ) ; try { classUnderTest.insert ( oneRow ) ; org.junit.Assert.fail ( "missingException" ) ; } catch ( com.google.gwtorm.server.OrmException e ) { org.junit.Assert.assertSame ( e.getCause ( ) , exception ) ; } com.google.gwtorm.jdbc.TestJdbcAccess.assertUsedBatchingOnly ( insert ) ; }
private PushOneCommit.Result createCommitAndPush ( org.eclipse.jgit.junit.TestRepository < org.eclipse.jgit.internal.storage.dfs.InMemoryRepository > repo , java.lang.String ref , java.lang.String commitMsg , java.lang.String fileName , java.lang.String content ) throws java.lang.Exception { return pushFactory.create ( db , admin.getIdent ( ) , repo , commitMsg , fileName , content ) . to ( ref ) ; }
public void testUnblockForce ( ) { com.google.gerrit.common.data.PermissionRule r = com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.Util.ANONYMOUS , "refs/heads/*" ) ; r.setBlock ( ) ; r.setForce ( true ) ; com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.Util.DEVS , "refs/heads/*" ) . setForce ( true ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.project.Util.DEVS ) ; assertTrue ( "u can force push" , u.controlForRef ( "refs/heads/master" ) . canForceUpdate ( ) ) ; }
public com.google.gerrit.reviewdb.client.AccountSshKey addKey ( java.lang.String pub ) { com.google.common.base.Preconditions.checkState ( ( ( keys ) != null ) , "SSH keys not loaded yet" ) ; int seq = ( keys.isEmpty ( ) ) ? 1 : ( keys.size ( ) ) + 1 ; com.google.gerrit.reviewdb.client.AccountSshKey.Id keyId = new com.google.gerrit.reviewdb.client.AccountSshKey.Id ( accountId , seq ) ; com.google.gerrit.reviewdb.client.AccountSshKey key = new com.google.gerrit.server.account.VersionedAuthorizedKeys.SimpleSshKeyCreator ( ) . create ( keyId , pub ) ; keys.add ( com.google.common.base.Optional.of ( key ) ) ; return key ; }
public void suggestReviewersChange ( ) throws java.io.IOException , java.lang.Exception , org.eclipse.jgit.api.errors.GitAPIException { java.lang.String changeId = createChange ( ) . getChangeId ( ) ; java.util.List < com.google.gerrit.server.change.SuggestReviewers.SuggestedReviewerInfo > reviewers = suggestReviewers ( changeId , "u" , 6 ) ; org.junit.Assert.assertEquals ( reviewers.size ( ) , 6 ) ; reviewers = suggestReviewers ( changeId , "u" , 5 ) ; org.junit.Assert.assertEquals ( reviewers.size ( ) , 5 ) ; reviewers = suggestReviewers ( changeId , "users3" , 10 ) ; org.junit.Assert.assertEquals ( reviewers.size ( ) , 1 ) ; }
com.google.gerrit.server.account.externalids.ExternalId get ( com.google.gerrit.server.account.externalids.ExternalId.Key key ) throws java.io.IOException , org.eclipse.jgit.errors.ConfigInvalidException { checkReadEnabled ( ) ; try ( org.eclipse.jgit.lib.Repository repo = repoManager.openRepository ( allUsersName ) ; org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk ( repo ) ) { org.eclipse.jgit.lib.ObjectId rev = com.google.gerrit.server.account.externalids.ExternalIdReader.readRevision ( repo ) ; if ( rev.equals ( org.eclipse.jgit.lib.ObjectId.zeroId ( ) ) ) { return null ; } return com.google.gerrit.server.account.externalids.ExternalIdReader.parse ( key , rw , rev ) ; } }
private synchronized void define ( java.lang.String name , com.google.gerrit.metrics.Description desc ) { if ( descriptions.containsKey ( name ) ) { throw new java.lang.IllegalStateException ( java.lang.String.format ( "metric %s already defined" , name ) ) ; } descriptions.put ( name , desc.getAnnotations ( ) ) ; }
public com.google.gerrit.client.ui.InlineHyperlink getNextPatchLink ( int index , com.google.gerrit.client.patches.PatchScreen.Type patchType ) { if ( index < ( ( patchList.size ( ) ) - 1 ) ) return createLink ( ( index + 1 ) , patchType , null , com.google.gwtexpui.safehtml.client.SafeHtml.asis ( Util.C.nextPatchLinkIcon ( ) ) ) ; return null ; }
public void testNonIndexPredicate ( ) throws java.lang.Exception { com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > in = parse ( "foo:a" ) ; com.google.common.truth.Truth.assertThat ( in ) . isSameAs ( rewrite ( in ) ) ; }
private void display ( final com.google.gerrit.client.reviewdb.AccountGeneralPreferences p ) { showSiteHeader.setValue ( p.isShowSiteHeader ( ) ) ; useFlashClipboard.setValue ( p.isUseFlashClipboard ( ) ) ; displayDefaultContext ( p.getDefaultContext ( ) ) ; }
private static com.googlecode.prolog_cafe.lang.BufferingPrologControl newEmptyMachine ( java.lang.ClassLoader cl ) { com.googlecode.prolog_cafe.lang.BufferingPrologControl ctl = new com.googlecode.prolog_cafe.lang.BufferingPrologControl ( ) ; ctl.setMaxArity ( PrologEnvironment.MAX_ARITY ) ; ctl.setMaxDatabaseSize ( com.google.gerrit.rules.RulesCache.DB_MAX ) ; ctl.setPrologClassLoader ( new com.googlecode.prolog_cafe.lang.PrologClassLoader ( cl ) ) ; ctl.setEnabled ( java.util.EnumSet.allOf ( Prolog.Feature.class ) , false ) ; return ctl ; }
public void unblockForceEditTopicName ( ) { com.google.gerrit.server.project.Util.block ( local , com.google.gerrit.common.data.Permission.EDIT_TOPIC_NAME , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/heads/*" ) ; com.google.gerrit.server.project.Util.allow ( local , com.google.gerrit.common.data.Permission.EDIT_TOPIC_NAME , com.google.gerrit.server.project.Util.DEVS , "refs/heads/*" ) . setForce ( true ) ; com.google.gerrit.server.project.ProjectControl u = user ( local , com.google.gerrit.server.project.Util.DEVS ) ; com.google.common.truth.Truth.assertThat ( u.controlForRef ( "refs/heads/master" ) . canForceEditTopicName ( ) ) . named ( "u can edit topic name" ) . isTrue ( ) ; }
public com.google.gerrit.server.patch.PatchList get ( final com.google.gerrit.server.patch.PatchListKey key ) { return self.get ( key ) ; }
protected void migrateData ( final com.google.gerrit.reviewdb.server.ReviewDb db , final com.google.gerrit.server.schema.UpdateUI ui ) throws java.sql.SQLException { final java.sql.Statement stmt = ( ( com.google.gwtorm.jdbc.JdbcSchema ) ( db ) ) . getConnection ( ) . createStatement ( ) ; try { stmt.executeUpdate ( "UPDATE account_diff_preferences SET show_line_endings='Y'" ) ; } finally { stmt.close ( ) ; } }
private com.google.common.collect.SetMultimap < org.eclipse.jgit.lib.ObjectId , org.eclipse.jgit.lib.Ref > changeRefsById ( ) throws java.io.IOException { if ( ( refsById ) == null ) { refsById = com.google.common.collect.HashMultimap.create ( ) ; for ( org.eclipse.jgit.lib.Ref r : repo.getRefDatabase ( ) . getRefs ( "refs/changes/" ) . values ( ) ) { if ( com.google.gerrit.reviewdb.client.PatchSet.isRef ( r.getName ( ) ) ) { refsById.put ( r.getObjectId ( ) , r ) ; } } } return refsById ; }
public com.google.gerrit.server.events.RefUpdatedEvent getOneRefUpdate ( java.lang.String project , java.lang.String refName ) { java.lang.String key = com.google.gerrit.acceptance.EventRecorder.key ( RefUpdatedEvent.TYPE , project , refName ) ; com.google.common.truth.Truth.assertThat ( recordedEvents ) . containsKey ( key ) ; java.util.Collection < com.google.gerrit.server.events.RefEvent > events = recordedEvents.get ( key ) ; com.google.common.truth.Truth.assertThat ( events ) . hasSize ( 1 ) ; com.google.gerrit.server.events.Event e = events.iterator ( ) . next ( ) ; com.google.common.truth.Truth.assertThat ( e ) . isInstanceOf ( com.google.gerrit.server.events.RefUpdatedEvent.class ) ; return ( ( com.google.gerrit.server.events.RefUpdatedEvent ) ( e ) ) ; }
public void requestReceived ( com.github.tomakehurst.wiremock.http.Request request , com.github.tomakehurst.wiremock.http.Response response ) { if ( request.getAbsoluteUrl ( ) . contains ( expectedRequest ) ) { try { checkPoint.await ( ) ; } catch ( java.lang.InterruptedException | java.util.concurrent.BrokenBarrierException e ) { org.junit.Assert.fail ( ) ; } } }
public void missingRepo ( ) throws java.lang.Exception { com.google.common.truth.TruthJUnit.assume ( ) . that ( notesMigration.readChanges ( ) ) . isFalse ( ) ; com.google.gerrit.server.project.ChangeControl ctl = insertChange ( ) ; com.google.gerrit.reviewdb.client.Project.NameKey name = ctl.getProject ( ) . getNameKey ( ) ; ( ( com.google.gerrit.testutil.InMemoryRepositoryManager ) ( repoManager ) ) . deleteRepository ( name ) ; assertProblems ( ctl , null , com.google.gerrit.acceptance.server.change.ConsistencyCheckerIT.problem ( ( "Destination repository not found: " + name ) ) ) ; }
public void testUnblockInLocalVisibilityByRegisteredUsers_Fails ( ) { com.google.gerrit.server.project.Util.block ( parent , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/heads/*" ) ; com.google.gerrit.server.project.Util.allow ( local , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS , "refs/heads/*" ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS ) ; org.junit.Assert.assertFalse ( "u can't read" , u.controlForRef ( "refs/heads/master" ) . isVisibleByRegisteredUsers ( ) ) ; }
public void onSuccess ( com.google.gerrit.common.data.PatchSetDetail result ) { patchSetDetail = result ; if ( ( fileList ) == null ) { fileList = new com.google.gerrit.client.changes.PatchTable ( prefs ) ; fileList.display ( idSideA , result ) ; patchIndex = fileList.indexOf ( patchKey ) ; } refresh ( true ) ; }
public final AccountGroup.Id getAdministrators ( ) { return administrators ; }
private static java.lang.String KD ( java.lang.String secret , java.lang.String data ) { try { java.security.MessageDigest md = com.google.gerrit.httpd.ProjectDigestFilter.newMD5 ( ) ; md.update ( secret.getBytes ( "UTF-8" ) ) ; md.update ( ( ( byte ) ( ':' ) ) ) ; md.update ( data.getBytes ( "UTF-8" ) ) ; return com.google.gerrit.httpd.ProjectDigestFilter.LHEX ( md.digest ( ) ) ; } catch ( java.io.UnsupportedEncodingException e ) { throw new java.lang.RuntimeException ( "UTF-8 encoding not available" , e ) ; } }
protected void setUp ( ) throws java.lang.Exception { repo = new org.eclipse.jgit.junit.TestRepository < org.eclipse.jgit.storage.dfs.DfsRepository > ( new org.eclipse.jgit.storage.dfs.InMemoryRepository ( new org.eclipse.jgit.storage.dfs.DfsRepositoryDescription ( "test" ) ) ) ; servlet = new com.google.gitiles.RepositoryIndexServlet ( new com.google.gitiles.DefaultRenderer ( ) , new com.google.gitiles.TestGitilesAccess ( repo.getRepository ( ) ) , new com.google.gitiles.TimeCache ( ) ) ; }
void addReplyBox ( ) { getCommentManager ( ) . addDraftBox ( getCm ( ) . side ( ) , com.google.gerrit.client.changes.CommentInfo.createReply ( comment ) ) . setEdit ( true ) ; }
public com.google.gerrit.extensions.restapi.Response < ? > apply ( com.google.gerrit.server.project.ChangeControl changeControl , java.lang.String filePath ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.extensions.restapi.ResourceConflictException , com.google.gerrit.server.permissions.PermissionBackendException , com.google.gwtorm.server.OrmException , java.io.IOException { com.google.gerrit.reviewdb.client.Project.NameKey project = changeControl.getChange ( ) . getProject ( ) ; try ( org.eclipse.jgit.lib.Repository repository = repositoryManager.openRepository ( project ) ) { editModifier.deleteFile ( repository , changeControl , filePath ) ; } catch ( com.google.gerrit.server.project.InvalidChangeOperationException e ) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException ( e.getMessage ( ) ) ; } return com.google.gerrit.extensions.restapi.Response.none ( ) ; }
protected com.google.gwtorm.data.PhoneBookDb openAndCreate ( ) throws com.google.gwtorm.client.OrmException { final com.google.gwtorm.data.PhoneBookDb schema = open ( ) ; schema.updateSchema ( ) ; return schema ; }
public boolean isVisible ( ) { return ( ( ( ( ( user ) instanceof com.google.gerrit.server.InternalUser ) || ( groupBackend.isVisibleToAll ( group.getGroupUUID ( ) ) ) ) || ( user.getEffectiveGroups ( ) . contains ( group.getGroupUUID ( ) ) ) ) || ( user.getCapabilities ( ) . canAdministrateServer ( ) ) ) || ( isOwner ( ) ) ; }
private void insertChangeRow ( final int row ) { insertRow ( row ) ; setStyleName ( row , com.google.gerrit.client.changes.ChangeTable.C_ID , "gerrit-ChangeTable-ColumnID" ) ; final com.google.gwt.user.client.ui.FlexTable.FlexCellFormatter fmt = table.getFlexCellFormatter ( ) ; for ( int i = com.google.gerrit.client.changes.ChangeTable.C_ID ; i < ( com.google.gerrit.client.changes.ChangeTable.COLUMNS ) ; i ++ ) { fmt.addStyleName ( row , i , "gerrit-ChangeTable-Cell" ) ; } }
private static void addFooter ( java.lang.StringBuilder sb , org.eclipse.jgit.revwalk.FooterKey footer , java.lang.Object ... values ) { com.google.gerrit.server.notedb.ChangeUpdate.addFooter ( sb , footer ) ; for ( java.lang.Object value : values ) { sb.append ( value ) ; } sb.append ( '\n' ) ; }
java.lang.Runnable toggleOpenBox ( final net.codemirror.lib.CodeMirror cm ) { return new java.lang.Runnable ( ) { @ java.lang.Override public void run ( ) { if ( cm.extras ( ) . hasActiveLine ( ) ) { com.google.gerrit.client.diff.UnifiedCommentGroup w = map ( cm.side ( ) ) . get ( ( ( cm.getLineNumber ( cm.extras ( ) . activeLine ( ) ) ) + 1 ) ) ; if ( w != null ) { w.openCloseLast ( ) ; } } } } ; }
public void postEvent ( com.google.gerrit.reviewdb.client.Branch.NameKey branchName , com.google.gerrit.server.events.Event event ) { fireEvent ( branchName , event ) ; }
protected com.google.gerrit.common.data.PermissionRule block ( java.lang.String permission , com.google.gerrit.reviewdb.client.AccountGroup.UUID id , java.lang.String ref ) throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet ( project ) . getConfig ( ) ; com.google.gerrit.common.data.PermissionRule rule = com.google.gerrit.server.project.Util.block ( cfg , permission , id , ref ) ; saveProjectConfig ( project , cfg ) ; return rule ; }
public void testUpsertTwoSecondExistsing ( ) throws com.google.gwtorm.client.OrmException , java.sql.SQLException { stubExecuteBatchOK ( com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE , 0 , 1 ) ; java.sql.PreparedStatement insert = stubExecuteBatchOK ( com.google.gwtorm.jdbc.TestJdbcAccess.INSERT , 1 ) ; createClassUnderTest ( ) . upsert ( com.google.gwtorm.jdbc.TestJdbcAccess.TWO_ROWS ) ; verifyIds ( insert , 1 ) ; }
public void basicGroupProperties ( ) throws java.lang.Exception { com.google.gerrit.extensions.common.GroupInfo createdGroup = gApi.groups ( ) . create ( name ( "group" ) ) . get ( ) ; com.google.gerrit.server.group.InternalGroup reviewDbGroup = groups.getGroup ( db , new com.google.gerrit.reviewdb.client.AccountGroup.UUID ( createdGroup.id ) ) . get ( ) ; deleteGroupRefs ( reviewDbGroup ) ; com.google.common.truth.Truth.assertThat ( rebuild ( reviewDbGroup ) ) . isEqualTo ( roundToSecond ( reviewDbGroup ) ) ; }
private boolean matchGroup ( com.google.gerrit.reviewdb.AccountGroup.UUID uuid ) { java.util.Set < com.google.gerrit.reviewdb.AccountGroup.UUID > userGroups = getCurrentUser ( ) . getEffectiveGroups ( ) ; if ( AccountGroup.PROJECT_OWNERS.equals ( uuid ) ) { com.google.gerrit.server.project.ProjectState state = projectControl.getProjectState ( ) ; return com.google.gerrit.common.CollectionsUtil.isAnyIncludedIn ( state.getOwners ( ) , userGroups ) ; } else { return userGroups.contains ( uuid ) ; } }
public static com.google.gerrit.gpg.testutil.TestKey keyRevokedByExpiredKeyAfterExpiration ( ) throws java.lang.Exception { return new com.google.gerrit.gpg.testutil.TestKey ( ( "-----BEGIN PGP PUBLIC KEY BLOCK-----\n" + ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( "Version: GnuPG v1\n" + "\n" ) + "mQENBELuRwABCAC56yhFKybBtuKT4nyb7RdLE98pZR54aGjcDcKH3VKVyBF8Z4Kx\n" ) + "ptd7Sre0mLPCQiNWVOmCT+JG7GKVE6YeFmyXDUnhX9w4+HAeDEh23S4u9JvwWaF+\n" ) + "wlJ6jLq/oe5gdT1F6Y2yqNpQ6CztOw52Ko9KSYz7/1zBMPcCkl/4k15ee4iebVdq\n" ) + "c7qT5Qt49Poiozh0DI5prPQ624uckHkz2mXshjWQVuHWwrkIkCJZ2I/KQN2kBjKw\n" ) + "/ALxumaWmiB9lQ0nIwLuGzHCh0Xg5RxuCrK8fJp47Aza3ikVuYlNzSxhJVav3OtK\n" ) + "gftBihQXUlY3Uy/4QTCeH/BdVs5OALtXL3VhABEBAAGJAS0EIAECABcFAlYmr4kQ\n" ) + "HQN0ZXN0OCBub3QgdXNlZAAKCRA87HgbF94azQJ5B/0TeQk7TSChNp+NqCKPTuw0\n" ) + "wpflDyc+5ru/Gcs4r358cWzgiLUb3M0Q1+M8CF13BFQdrxT05vjheI9o5PCn3b//\n" ) + "AHV8m+QFSnRi2J3QslbvuOqOnipz7vc7lyZ7q1sWNC33YN+ZcGZiMuu5HJi9iadf\n" ) + "ZL7AdInpUb4Zb+XKphbMokDcN3yw7rqSMMcx+rKytUAqUnt9qvaSLrIH/zeazxlp\n" ) + "YG4jaN53WPfLCcGG+Rw56mW+eCQD2rmzaNHCw8Qr+19sokXLB7OML+rd1wNwZT4q\n" ) + "stWnL+nOj8ZkbFV0w3zClDYaARr7H+vTckwVStyDVRbnpRitSAtJwbRDzZBaS4Vx\n" ) + "iQE3BB8BAgAhBQJC7lUQFwyAAR2e63ndOLBJk52crzzseBsX3hrNAgcAAAoJEAAa\n" ) + "34t4v31+AS4H/0x3Y9E3q9DR5FCuYTXG4BHyrALo2WKoP0CfUWL98Fw9Txl0hF+9\n" ) + "5wriNlnmd2zvM0quHs78x4/xehQO88cw0lqPx3RARq/ju5/VbOjoNlcHvfGYZiEd\n" ) + "yWOwHu7O8sZrenFDjeDglD6NArrjncOcC51XIPSSTLvVQpSauQ1FS4tan5Q4aWMb\n" ) + "s4DzE+Vqu2xMkO/X9toYAZKzyWP29OckpouMbt3GUnS6/o0A8Z7jVX+XOIk3XolP\n" ) + "Li9tzTQB12Xl23mgFvearDoguR2Bu2SbmTJtdiXz8L3S54kGvxVqak5uOP2dagzU\n" ) + "vBiqR4SVoAdGoXt6TI6mpA+qdYmPMG8v21S0IlRlc3R1c2VyIEVpZ2h0IDx0ZXN0\n" ) + "OEBleGFtcGxlLmNvbT6JATgEEwECACIFAkLuRwACGwMGCwkIBwMCBhUIAgkKCwQW\n" ) + "AgMBAh4BAheAAAoJEAAa34t4v31+8/sIAIuqd+dU8k9c5VQ12k7IfZGGYQHF2Mk/\n" ) + "8FNuP7hFP/VOXBK3QIxIfGEOHbDX6uIxudYMaDmn2UJbdIqJd8NuQByh1gqXdX/x\n" ) + "nteUa+4e7U6uTjkp/Ij5UzRed8suINA3NzVOy6qwCu3DTOXIZcjiOZtOA5GTqG6Z\n" ) + "naDP0hwDssJp+LXIYTJgsvneJQFGSdQhhJSv19oV0JPSbb6Zc7gEIHtPcaJHjuZQ\n" ) + "Ev+TRcRrI9HPTF0MvgOYgIDo2sbcSFV+8moKsHMC+j1Hmuuqgm/1yKGIZrt0V75s\n" ) + "D9HYu0tiS3+Wlsry3y1hg/2XBQbwgh6sT/jWkpWar7+uzNxO5GdFYrC5AQ0EQu5H\n" ) + "AAEIALPFTedbfyK+9B35Uo9cPsmFa3mT3qp/bAQtnOjiTTTiIO3tu0ALnaBjf6On\n" ) + "fAV1HmGz6hRMRK4LGyHkNTaGDNNPoXO7+t9DWycSHmsCL5d5zp7VevQE8MPR8zHK\n" ) + "Il2YQlCzdy5TWSUhunKd4guDNZ9GiOS6NQ9feYZ9DQ1kzC8nnu7jLkR2zNT02sYU\n" ) + "kuOCZUktQhVNszUlavdIFjvToZo3RPcdb/E3kTTy2R9xi89AXjWZf3lSAZe3igkL\n" ) + "jhwsd+u3RRx0ptOJym7zYl5ZdUZk4QrS7FPI6zEBpjawbS4/r6uEW89P3QAkanDI\n" ) + "ridIAZP8awLZU3uSPtMwPIJpao0AEQEAAYkBHwQYAQIACQUCQu5HAAIbDAAKCRAA\n" ) + "Gt+LeL99fqpHB/wOXhdMNtgeVW38bLk8YhcEB23FW6fDjFjBJb9m/yqRTh5CIeG2\n" ) + "bm29ofT4PTamPb8Gt+YuDLnQQ3K2jURakxNDcYwiurvR/oHVdxsBRU7Px7UPeZk3\n" ) + "BG5VnIJRT198dF7MWFJ+x5wHbNXwM8DDvUwTjXLH/TlGl1XIheSTHCYd9Pra4ejE\n" ) + "ockkrDaZlPCQdTwY+P7K2ieb5tsqNpJkQeBrglF2bemY/CtQHnM9qwa6ZJqkyYNR\n" ) + "F1nkSYn36BPuNpytYw1CaQV9GbePugPHtshECLwA160QzqISQUcJlKXttUqUGnoO\n" ) + "0d0PyzZT3676mQwmFoebMR9vACAeHjvDxD4F\n" ) + "=ihWb\n" ) + "-----END PGP PUBLIC KEY BLOCK-----\n" ) ) , ( "-----BEGIN PGP PRIVATE KEY BLOCK-----\n" + ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( "Version: GnuPG v1\n" + "\n" ) + "lQOYBELuRwABCAC56yhFKybBtuKT4nyb7RdLE98pZR54aGjcDcKH3VKVyBF8Z4Kx\n" ) + "ptd7Sre0mLPCQiNWVOmCT+JG7GKVE6YeFmyXDUnhX9w4+HAeDEh23S4u9JvwWaF+\n" ) + "wlJ6jLq/oe5gdT1F6Y2yqNpQ6CztOw52Ko9KSYz7/1zBMPcCkl/4k15ee4iebVdq\n" ) + "c7qT5Qt49Poiozh0DI5prPQ624uckHkz2mXshjWQVuHWwrkIkCJZ2I/KQN2kBjKw\n" ) + "/ALxumaWmiB9lQ0nIwLuGzHCh0Xg5RxuCrK8fJp47Aza3ikVuYlNzSxhJVav3OtK\n" ) + "gftBihQXUlY3Uy/4QTCeH/BdVs5OALtXL3VhABEBAAEAB/wLr88oGuxsoqIHRQZL\n" ) + "eGm9jc4aQGmcDMcjpwdGilhrwyfrO6f84hWbQdD+rJcnI8hsH7oOd5ZMGkWfpJyt\n" ) + "eUAh9iNB5ChYGfDVSLUg6KojqDtprj6vNMihvLkr/OI6xL/hZksikwfnLFMPpgXU\n" ) + "knwPocQ3nn+egsUSL7CR8/SLiIm4MC0brer6jhDxB5LKweExNlfTe4c0MDeYTsWt\n" ) + "0WGzNPlvRZQXRotJzqemt3wdNZXUnCKR0n7pSQ8EhZr2O6NXr+mUgp6PIOE/3un2\n" ) + "YGiBEf5uy3qEFe7FjEGIHz+Z3ySRdUDfHOk82TKAzynoJIxRUvLIYVNw4eFB3l5U\n" ) + "s1w5BADUzfciG7RVLa8UFKJfqQ/5M06QmdS1v1/hMQXg38+3vKe8RgfSSnMJ08Sc\n" ) + "eAEsmugwpNXAxgRKHcmWzN3NMBHhE3KiyiogWaMGqmSo6swFpu0+dwMvZSxMlfD+\n" ) + "ka/BWt8YsUdrqW06ow39aTgCV+icbNRV81C7NKe7u0X1JDx2CQQA36gbdo62h/Wd\n" ) + "gJI8kdz/se3xrt8x6RoWvOnWPNmsZR5XkDqAMTL1dWiEEA/dQTphMcgAe9z3WaP+\n" ) + "F1TPAfounbiurGCcS3kxJ5tY7ojyU7nYz4DA/V2OU0C/LUoLXhttG5HM+m/i3qn4\n" ) + "K9bBoWIQY1ijliS7cTSwNqd6IHaQGpkEAMnp5GwSGhY+kUuLw06hmH4xnsuf6agz\n" ) + "AfhbPylB2nf/ZaX6dt6/mFEAkvQNahcoWEskfS3LGCD8jHm8PvF8K0mciXPDweq2\n" ) + "gW3/irE0RXNwn3Oa222VSvcgUlocBm9InkfvpFXh20OYFe3dFH7uYkwUqIHJeXjw\n" ) + "TjpXUX/vC5QJQOyJATcEHwECACEFAkLuVRAXDIABHZ7red04sEmTnZyvPOx4Gxfe\n" ) + "Gs0CBwAACgkQABrfi3i/fX4BLgf/THdj0Ter0NHkUK5hNcbgEfKsAujZYqg/QJ9R\n" ) + "Yv3wXD1PGXSEX73nCuI2WeZ3bO8zSq4ezvzHj/F6FA7zxzDSWo/HdEBGr+O7n9Vs\n" ) + "6Og2Vwe98ZhmIR3JY7Ae7s7yxmt6cUON4OCUPo0CuuOdw5wLnVcg9JJMu9VClJq5\n" ) + "DUVLi1qflDhpYxuzgPMT5Wq7bEyQ79f22hgBkrPJY/b05ySmi4xu3cZSdLr+jQDx\n" ) + "nuNVf5c4iTdeiU8uL23NNAHXZeXbeaAW95qsOiC5HYG7ZJuZMm12JfPwvdLniQa/\n" ) + "FWpqTm44/Z1qDNS8GKpHhJWgB0ahe3pMjqakD6p1iY8wby/bVLQiVGVzdHVzZXIg\n" ) + "RWlnaHQgPHRlc3Q4QGV4YW1wbGUuY29tPokBOAQTAQIAIgUCQu5HAAIbAwYLCQgH\n" ) + "AwIGFQgCCQoLBBYCAwECHgECF4AACgkQABrfi3i/fX7z+wgAi6p351TyT1zlVDXa\n" ) + "Tsh9kYZhAcXYyT/wU24/uEU/9U5cErdAjEh8YQ4dsNfq4jG51gxoOafZQlt0iol3\n" ) + "w25AHKHWCpd1f/Ge15Rr7h7tTq5OOSn8iPlTNF53yy4g0Dc3NU7LqrAK7cNM5chl\n" ) + "yOI5m04DkZOobpmdoM/SHAOywmn4tchhMmCy+d4lAUZJ1CGElK/X2hXQk9Jtvplz\n" ) + "uAQge09xokeO5lAS/5NFxGsj0c9MXQy+A5iAgOjaxtxIVX7yagqwcwL6PUea66qC\n" ) + "b/XIoYhmu3RXvmwP0di7S2JLf5aWyvLfLWGD/ZcFBvCCHqxP+NaSlZqvv67M3E7k\n" ) + "Z0VisJ0DmARC7kcAAQgAs8VN51t/Ir70HflSj1w+yYVreZPeqn9sBC2c6OJNNOIg\n" ) + "7e27QAudoGN/o6d8BXUeYbPqFExErgsbIeQ1NoYM00+hc7v630NbJxIeawIvl3nO\n" ) + "ntV69ATww9HzMcoiXZhCULN3LlNZJSG6cp3iC4M1n0aI5Lo1D195hn0NDWTMLyee\n" ) + "7uMuRHbM1PTaxhSS44JlSS1CFU2zNSVq90gWO9OhmjdE9x1v8TeRNPLZH3GLz0Be\n" ) + "NZl/eVIBl7eKCQuOHCx367dFHHSm04nKbvNiXll1RmThCtLsU8jrMQGmNrBtLj+v\n" ) + "q4Rbz0/dACRqcMiuJ0gBk/xrAtlTe5I+0zA8gmlqjQARAQABAAf+JNVkZOcGYaQm\n" ) + "eI3BMMaBxuCjaMG3ec+p3iFKaR0VHKTIgneXSkQXA+nfGTUT4DpjAznN2GLYH6D+\n" ) + "6i7MCGPm9NT4C7KUcHJoltTLjrlf7vVyNHEhRCZO/pBh9+2mpO6xh799x+wj88u5\n" ) + "XAqlah50OjJFkjfk70VsrPWqWvgwLejkaQpGbE+pdL+vjy+ol5FHzidzmJvsXDR1\n" ) + "I1as0vBu5g2XPpexyVanmHJglZdZX07OPYQBhxQKuPXT/2/IRnXsXEpitk4IyJT0\n" ) + "U5D/iedEUldhBByep1lBcJnAap0CP7iuu2CYhRp6V2wVvdweNPng5Eo7f7LNyjnX\n" ) + "UMAeaeCjAQQA1A0iKtg3Grxc9+lpFl1znc2/kO3p6ixM13uUvci+yGFNJJninnxo\n" ) + "99KXEzqqVD0zerjiyyegQmzpITE/+hFIOJZInxEH08WQwZstV/KYeRSJkXf0Um48\n" ) + "E+Zrh8fpJVW1w3ZCw9Ee2yE6fEhAA4w66+50pM+vBXanWOrG1HDrkxEEANkHc2Rz\n" ) + "YJsO4v63xo/7/njLSQ31miOglb99ACKBA0Yl/jvj2KqLcomKILqvK3DKP+BHNq86\n" ) + "LUBUglyKjKuj0wkSWT0tCnfgLzysUpowcoyFhJ36KzAz8hjqIn3TQpMF21HvkZdG\n" ) + "Mtkcyhu5UDvbfOuWOBaKIeNQWCWv1rNzMme9A/9zU1+esEhKwGWEqa3/B/Te/xQh\n" ) + "alk180n74sTZid6lXD8o8cEei0CUq7zBSV0P8v6kk8PP9/XyLRl3Rqa95fESUWrL\n" ) + "xD6TBY1JlHBZS+N6rN/7Ilf5EXSELmnbDFsVxkNGp4elKxajvZxC6uEWYBu62AYy\n" ) + "wS0dj8mZR3faCEps90YXiQEfBBgBAgAJBQJC7kcAAhsMAAoJEAAa34t4v31+qkcH\n" ) + "/A5eF0w22B5VbfxsuTxiFwQHbcVbp8OMWMElv2b/KpFOHkIh4bZubb2h9Pg9NqY9\n" ) + "vwa35i4MudBDcraNRFqTE0NxjCK6u9H+gdV3GwFFTs/HtQ95mTcEblWcglFPX3x0\n" ) + "XsxYUn7HnAds1fAzwMO9TBONcsf9OUaXVciF5JMcJh30+trh6MShySSsNpmU8JB1\n" ) + "PBj4/sraJ5vm2yo2kmRB4GuCUXZt6Zj8K1Aecz2rBrpkmqTJg1EXWeRJiffoE+42\n" ) + "nK1jDUJpBX0Zt4+6A8e2yEQIvADXrRDOohJBRwmUpe21SpQaeg7R3Q/LNlPfrvqZ\n" ) + "DCYWh5sxH28AIB4eO8PEPgU=\n" ) + "=cSfw\n" ) + "-----END PGP PRIVATE KEY BLOCK-----\n" ) ) ) ; }
public void onSuccess ( com.google.gerrit.client.diff.DiffInfo info ) { new net.codemirror.lib.ModeInjector ( ) . add ( getContentType ( info.meta_a ( ) ) ) . add ( getContentType ( info.meta_b ( ) ) ) . inject ( com.google.gerrit.client.rpc.CallbackGroup.< java.lang.Void > emptyCallback ( ) ) ; }
private com.google.gerrit.server.query.change.ChangeData toChangeData ( org.apache.lucene.document.Document doc ) { org.apache.lucene.util.BytesRef cb = doc.getBinaryValue ( com.google.gerrit.lucene.LuceneChangeIndex.CHANGE_FIELD ) ; int id = doc.getField ( com.google.gerrit.lucene.ID_FIELD ) . numericValue ( ) . intValue ( ) ; return changeDataFactory.create ( db.get ( ) , new com.google.gerrit.reviewdb.client.Change.Id ( id ) ) ; BRANCH ( 87.0F ) ; }
public void run ( ) { try { for ( com.google.gerrit.reviewdb.client.Project.NameKey nameKey : projectCache.all ( ) ) { replication.scheduleFullSync ( nameKey , urlMatch ) ; } } catch ( java.lang.Exception e ) { com.googlesource.gerrit.plugins.replication.PushAll.log.error ( "Cannot enumerate known projects" , e ) ; } }
public void ignore ( com.google.gerrit.reviewdb.client.Account.Id accountId , com.google.gerrit.reviewdb.client.Project.NameKey project , com.google.gerrit.reviewdb.client.Change.Id changeId ) throws com.google.gwtorm.server.OrmException { star ( accountId , project , changeId , com.google.common.collect.ImmutableSet.of ( com.google.gerrit.server.StarredChangesUtil.IGNORE_LABEL ) , com.google.common.collect.ImmutableSet.of ( ) ) ; }
public void testErrorWhileSendingUnhealthyResponse ( ) throws java.io.IOException { javax.servlet.http.HttpServletResponse responseMock = mock ( javax.servlet.http.HttpServletResponse.class ) ; servlet.doDelete ( null , responseMock ) ; org.mockito.Mockito.verify ( responseMock ) . setStatus ( javax.servlet.http.HttpServletResponse.SC_NO_CONTENT ) ; responseMock = mock ( javax.servlet.http.HttpServletResponse.class ) ; doThrow ( new java.io.IOException ( "someError" ) ) . when ( responseMock ) . sendError ( javax.servlet.http.HttpServletResponse.SC_SERVICE_UNAVAILABLE ) ; servlet.doGet ( null , responseMock ) ; org.mockito.Mockito.verify ( responseMock ) . setStatus ( javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR ) ; }
public void testBlockPushDraftsUnblockAdmin ( ) { com.google.gerrit.server.project.Util.grant ( util.getParentConfig ( ) , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/drafts/*" ) . setBlock ( ) ; com.google.gerrit.server.project.Util.grant ( util.getParentConfig ( ) , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.Util.ADMIN , "refs/drafts/*" ) ; org.junit.Assert.assertTrue ( "push is blocked for anonymous to refs/drafts/master" , util.user ( local ) . controlForRef ( "refs/drafts/refs/heads/master" ) . isBlocked ( com.google.gerrit.common.data.Permission.PUSH ) ) ; org.junit.Assert.assertFalse ( "push is blocked for admin refs/drafts/master" , util.user ( local , "a" , com.google.gerrit.server.project.Util.ADMIN ) . controlForRef ( "refs/drafts/refs/heads/master" ) . isBlocked ( com.google.gerrit.common.data.Permission.PUSH ) ) ; }
protected java.util.List createEntry ( final java.lang.String url ) throws java.lang.Exception { try { final java.util.List < ? > list = manager.discover ( url ) ; return ( list != null ) && ( ! ( list.isEmpty ( ) ) ) ? list : null ; } catch ( org.openid4java.discovery.DiscoveryException e ) { return null ; } }
public void ignore ( boolean ignore ) throws com.google.gerrit.extensions.restapi.RestApiException { try { if ( ignore ) { this . ignore.apply ( change , new com.google.gerrit.server.change.Ignore.Input ( ) ) ; } else { unignore.apply ( change , new com.google.gerrit.server.change.Unignore.Input ( ) ) ; } } catch ( com.google.gwtorm.server.OrmException | com.google.gerrit.server.StarredChangesUtil.IllegalLabelException e ) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException ( "Cannot ignore change" , e ) ; } }
public static int limitThreads ( com.google.inject.Injector dbInjector , int threads ) { return com.google.gerrit.pgm.util.ThreadLimiter.limitThreads ( dbInjector.getInstance ( com.google.inject.Key.get ( org.eclipse.jgit.lib.Config.class , com.google.gerrit.server.config.GerritServerConfig.class ) ) , dbInjector.getInstance ( com.google.gerrit.server.schema.DataSourceType.class ) , threads ) ; }
public void close ( ) { java.util.List < com.google.common.util.concurrent.ListenableFuture < ? > > closeFutures = com.google.common.collect.Lists.newArrayListWithCapacity ( 2 ) ; closeFutures.add ( executor.submit ( new java.lang.Runnable ( ) { @ java.lang.Override public void run ( ) { openIndex.close ( ) ; } } ) ) ; closeFutures.add ( executor.submit ( new java.lang.Runnable ( ) { @ java.lang.Override public void run ( ) { closedIndex.close ( ) ; } } ) ) ; com.google.common.util.concurrent.Futures.getUnchecked ( com.google.common.util.concurrent.Futures.allAsList ( closeFutures ) ) ; }
public void reindexEmptySite ( ) throws java.lang.Exception { initSite ( ) ; org.eclipse.jgit.storage.file.FileBasedConfig cfg = gerritConfig ( ) ; cfg.load ( ) ; cfg.setBoolean ( "gerrit-test" , null , "bypassAutoRecheckMergeable" , true ) ; cfg.save ( ) ; com.google.gerrit.acceptance.pgm.ReindexIT.runGerrit ( "reindex" , "-d" , sitePath.toString ( ) , "--show-stack-trace" ) ; }
public com.google.gerrit.reviewdb.client.Change submit ( com.google.gerrit.server.change.RevisionResource rsrc , com.google.gerrit.server.IdentifiedUser caller , boolean force ) throws com.google.gerrit.extensions.restapi.ResourceConflictException , com.google.gwtorm.server.OrmException , java.io.IOException { java.lang.String topic = rsrc.getChange ( ) . getTopic ( ) ; if ( ( submitWholeTopic ) && ( ! ( com.google.common.base.Strings.isNullOrEmpty ( topic ) ) ) ) { return submitWholeTopic ( rsrc , caller , force , topic ) ; } else { return submitThisChange ( rsrc , caller , force ) ; } }
private void configureCmdLineParser ( ) { factory ( CmdLineParser.Factory.class ) ; registerOptionHandler ( Account.Id.class , com.google.gerrit.sshd.args4j.AccountIdHandler.class ) ; registerOptionHandler ( AccountGroup.Id.class , com.google.gerrit.sshd.args4j.AccountGroupIdHandler.class ) ; registerOptionHandler ( PatchSet.Id.class , com.google.gerrit.sshd.args4j.PatchSetIdHandler.class ) ; registerOptionHandler ( com.google.gerrit.server.project.ProjectControl.class , com.google.gerrit.sshd.args4j.ProjectControlHandler.class ) ; registerOptionHandler ( java.net.SocketAddress.class , com.google.gerrit.sshd.args4j.SocketAddressHandler.class ) ; }
protected PushOneCommit.Result amendChange ( java.lang.String changeId , java.lang.String ref ) throws java.lang.Exception { java.util.Collections.shuffle ( com.google.gerrit.acceptance.AbstractDaemonTest.RANDOM ) ; com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create ( db , admin.getIdent ( ) , testRepo , PushOneCommit.SUBJECT , PushOneCommit.FILE_NAME , new java.lang.String ( com.google.common.primitives.Chars.toArray ( com.google.gerrit.acceptance.AbstractDaemonTest.RANDOM ) ) , changeId ) ; return push.to ( ref ) ; }
public java.lang.Iterable < com.google.gerrit.common.data.EditList.Hunk > getHunks ( ) { return new com.google.gerrit.common.data.EditList ( edits , getContext ( ) , a.size ( ) , b.size ( ) ) . getHunks ( ) ; }
public void create_Empty ( ) throws java.io.IOException { final java.nio.file.Path root = com.google.gerrit.server.config.SitePathsTest.random ( ) ; try { java.nio.file.Files.createDirectory ( root ) ; final com.google.gerrit.server.config.SitePaths site = new com.google.gerrit.server.config.SitePaths ( root ) ; com.google.common.truth.Truth.assertThat ( site.isNew ) . isTrue ( ) ; com.google.gerrit.extensions.common.PathSubject.assertThat ( site.site_path ) . isEqualTo ( root ) ; } finally { java.nio.file.Files.delete ( root ) ; } }
protected void configure ( ) { bind ( com.google.gerrit.server.config.SitePaths.class ) ; bind ( org.eclipse.jgit.lib.Config.class ) . annotatedWith ( com.google.gerrit.server.config.GerritServerConfig.class ) . toProvider ( com.google.gerrit.server.config.GerritServerConfigProvider.class ) . in ( com.google.inject.Scopes.SINGLETON ) ; }
public void onError ( final com.google.gwt.http.client.Request request , final java.lang.Throwable exception ) { com.google.gwtjsonrpc.client.JsonUtil.fireOnCallEnd ( ) ; if ( ( ( exception.getClass ( ) ) == ( java.lang.RuntimeException.class ) ) && ( exception.getMessage ( ) . contains ( "XmlHttpRequest.status" ) ) ) { callback.onFailure ( new com.google.gwtjsonrpc.client.ServerUnavailableException ( ) ) ; } else { callback.onFailure ( exception ) ; } }
public void createEditByDeletingExistingFileRest ( ) throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = adminSession.delete ( urlEditFile ( ) ) ; org.junit.Assert.assertEquals ( org.apache.http.HttpStatus.SC_NO_CONTENT , r.getStatusCode ( ) ) ; com.google.common.base.Optional < com.google.gerrit.server.edit.ChangeEdit > edit = editUtil.byChange ( change ) ; try { fileUtil.getContent ( edit.get ( ) . getChange ( ) . getProject ( ) , edit.get ( ) . getRevision ( ) . get ( ) , com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME ) ; org.junit.Assert.fail ( "ResourceNotFoundException expected" ) ; } catch ( com.google.gerrit.extensions.restapi.ResourceNotFoundException rnfe ) { } }
public void hostIndex ( ) throws java.lang.Exception { com.google.gitiles.GitilesView view = getView ( "/" ) ; org.junit.Assert.assertEquals ( Type.HOST_INDEX , view.getType ( ) ) ; org.junit.Assert.assertEquals ( "test-host" , view.getHostName ( ) ) ; org.junit.Assert.assertNull ( view.getRepositoryName ( ) ) ; org.junit.Assert.assertEquals ( Revision.NULL , view.getRevision ( ) ) ; org.junit.Assert.assertEquals ( Revision.NULL , view.getOldRevision ( ) ) ; org.junit.Assert.assertNull ( view.getPathPart ( ) ) ; }
public void deleteBranchByRestWithoutRefsHeadsPrefix ( ) throws java.lang.Exception { grantDelete ( ) ; java.lang.String ref = branch.getShortName ( ) ; com.google.common.truth.Truth.assertThat ( ref ) . doesNotMatch ( org.eclipse.jgit.lib.Constants.R_HEADS ) ; com.google.gerrit.acceptance.RestResponse r = userRestSession.delete ( ( ( ( "/projects/" + ( project.get ( ) ) ) + "/branches/" ) + ref ) ) ; r.assertNoContent ( ) ; }
public void fooBarSubdirJson ( ) throws java.lang.Exception { java.util.Map < java.lang.String , com.google.gitiles.RepositoryDescription > res = buildJson ( "/foo/bar/" , new com.google.gson.reflect.TypeToken < java.util.Map < java.lang.String , com.google.gitiles.RepositoryDescription > > ( ) { } . getType ( ) ) ; org.junit.Assert.assertEquals ( 1 , res.size ( ) ) ; com.google.gitiles.RepositoryDescription d = res.get ( "repo" ) ; org.junit.Assert.assertNotNull ( "repo exists" , d ) ; org.junit.Assert.assertEquals ( repo.getRepository ( ) . getDescription ( ) . getRepositoryName ( ) , d.name ) ; }
java.util.List < java.util.List < java.lang.String > > getValues ( ) { java.util.List < java.util.List < java.lang.String > > values = new java.util.ArrayList < > ( ) ; for ( int row = 2 ; row < ( table.getRowCount ( ) ) ; row ++ ) { values.add ( getValues ( row ) ) ; } return values ; }
public void emptyPermissionRangeKeepsResult ( ) throws java.lang.Exception { com.google.gerrit.reviewdb.client.PatchSetApproval cr = psa ( userId , "Code-Review" , 1 ) ; com.google.gerrit.reviewdb.client.PatchSetApproval v = psa ( userId , "Verified" , 1 ) ; org.junit.Assert.assertEquals ( com.google.gerrit.server.git.LabelNormalizer.Result.create ( com.google.gerrit.server.git.LabelNormalizerTest.list ( cr , v ) , com.google.gerrit.server.git.LabelNormalizerTest.list ( ) , com.google.gerrit.server.git.LabelNormalizerTest.list ( ) ) , norm.normalize ( notes , com.google.gerrit.server.git.LabelNormalizerTest.list ( cr , v ) ) ) ; }
public java.lang.Object apply ( com.google.gerrit.server.project.ProjectResource resource , com.google.gerrit.server.project.SetDashboard.Input input ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.extensions.restapi.BadRequestException , com.google.gerrit.extensions.restapi.ResourceConflictException , java.lang.Exception { com.google.gerrit.server.project.SetDefaultDashboard set = setDefault.get ( ) ; set.inherited = inherited ; return com.google.gerrit.extensions.restapi.Response.created ( set.apply ( com.google.gerrit.server.project.DashboardResource.projectDefault ( resource.getControl ( ) ) , input ) ) ; }
private static org.apache.lucene.search.Query not ( com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > p ) throws com.google.gerrit.server.query.QueryParseException { com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > n = p.getChild ( 0 ) ; if ( n instanceof com.google.gerrit.server.index.TimestampRangePredicate ) { return com.google.gerrit.lucene.QueryBuilder.notTimestamp ( ( ( com.google.gerrit.server.index.TimestampRangePredicate < com.google.gerrit.server.query.change.ChangeData > ) ( n ) ) ) ; } org.apache.lucene.search.BooleanQuery q = new org.apache.lucene.search.BooleanQuery ( ) ; q.add ( new org.apache.lucene.search.MatchAllDocsQuery ( ) , org.apache.lucene.search.BooleanClause.Occur.MUST ) ; q.add ( com.google.gerrit.lucene.QueryBuilder.toQuery ( n ) , org.apache.lucene.search.BooleanClause.Occur.MUST_NOT ) ; return q ; }
boolean wouldPushRef ( java.lang.String ref ) { if ( ( ! ( replicatePermissions ) ) && ( GitRepositoryManager.REF_CONFIG.equals ( ref ) ) ) { return false ; } for ( org.eclipse.jgit.transport.RefSpec s : remote.getPushRefSpecs ( ) ) { if ( s.matchSource ( ref ) ) { return true ; } } return false ; }
private void testGetGroup ( java.lang.String url , com.google.gerrit.reviewdb.client.AccountGroup expectedGroup ) throws java.io.IOException { com.google.gerrit.acceptance.RestResponse r = session.get ( url ) ; com.google.gerrit.acceptance.rest.group.GroupInfo group = new com.google.gson.Gson ( ) . fromJson ( r.getReader ( ) , new com.google.gson.reflect.TypeToken < com.google.gerrit.acceptance.rest.group.GroupInfo > ( ) { } . getType ( ) ) ; com.google.gerrit.acceptance.rest.group.GroupAssert.assertGroupInfo ( expectedGroup , group ) ; }
private boolean add ( com.google.gerrit.server.mail.send.ProjectWatch.Watchers matching , com.google.gerrit.reviewdb.client.Account.Id accountId , com.google.gerrit.server.account.WatchConfig.ProjectWatchKey key , java.util.Set < com.google.gerrit.reviewdb.client.AccountProjectWatch.NotifyType > watchedTypes , com.google.gerrit.reviewdb.client.AccountProjectWatch.NotifyType type ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.IdentifiedUser user = args.identifiedUserFactory.create ( accountId ) ; try { if ( filterMatch ( user , key.filter ( ) ) ) { if ( watchedTypes.contains ( type ) ) { matching.bcc.accounts.add ( accountId ) ; } return true ; } } catch ( com.google.gerrit.server.query.QueryParseException e ) { } return false ; }
public java.lang.Iterable < com.google.gerrit.extensions.common.WebLinkInfo > getPatchSetLinks ( java.lang.String project , java.lang.String commit ) { java.util.List < com.google.gerrit.extensions.common.WebLinkInfo > links = com.google.common.collect.Lists.newArrayList ( ) ; for ( com.google.gerrit.extensions.webui.PatchSetWebLink webLink : patchSetLinks ) { links.add ( new com.google.gerrit.extensions.common.WebLinkInfo ( webLink.getLinkName ( ) , webLink.getImageUrl ( ) , webLink.getPatchSetUrl ( project , commit ) , webLink.getTarget ( ) ) ) ; } return links ; }
public void singlePeeledTagText ( ) throws java.lang.Exception { com.google.gitiles.FakeHttpServletRequest req = com.google.gitiles.FakeHttpServletRequest.newRequest ( ) ; req.setPathInfo ( "/test/+refs/tags/atag" ) ; req.setQueryString ( "format=TEXT" ) ; com.google.gitiles.FakeHttpServletResponse res = new com.google.gitiles.FakeHttpServletResponse ( ) ; servlet.service ( req , res ) ; org.junit.Assert.assertEquals ( 200 , res.getStatus ( ) ) ; org.junit.Assert.assertEquals ( ( ( ( ( id ( "refs/tags/atag" ) ) + " refs/tags/atag\n" ) + ( peeled ( "refs/tags/atag" ) ) ) + " refs/tags/atag^{}\n" ) , res.getActualBodyString ( ) ) ; }
public void serverConfigWithPlugin ( ) throws java.lang.Exception { java.nio.file.Path plugins = tempSiteDir.newFolder ( "plugins" ) . toPath ( ) ; java.nio.file.Path jsplugin = plugins.resolve ( "js-plugin-1.js" ) ; java.nio.file.Files.write ( jsplugin , "Gerrit.install(function(self){});\n" . getBytes ( java.nio.charset.StandardCharsets.UTF_8 ) ) ; adminSshSession.exec ( "gerrit plugin reload" ) ; com.google.gerrit.extensions.common.ServerInfo i = getServerConfig ( ) ; com.google.common.truth.Truth.assertThat ( i.plugin.jsResourcePaths ) . hasSize ( 1 ) ; }
protected void renderJson ( javax.servlet.http.HttpServletRequest req , javax.servlet.http.HttpServletResponse res , java.lang.Object src , java.lang.reflect.Type typeOfSrc ) throws java.io.IOException { setApiHeaders ( res , com.google.gitiles.FormatType.JSON ) ; res.setStatus ( javax.servlet.http.HttpServletResponse.SC_OK ) ; java.io.Writer writer = getWriter ( res ) ; new com.google.gson.GsonBuilder ( ) . setFieldNamingPolicy ( com.google.gson.FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES ) . setPrettyPrinting ( ) . generateNonExecutableJson ( ) . create ( ) . toJson ( src , typeOfSrc , writer ) ; writer.write ( '\n' ) ; writer.close ( ) ; }
public void configureServlets ( ) { serveRegex ( "^/gerrit_ui/(?!rpc/)(.*)$" ) . with ( com.google.inject.Key.get ( javax.servlet.http.HttpServlet.class , com.google.inject.name.Names.named ( com.google.gerrit.httpd.raw.StaticModule.GWT_UI_SERVLET ) ) ) ; com.google.gerrit.httpd.raw.StaticModule.Paths p = getPaths ( ) ; if ( ( ( p.warFs ) == null ) && ( ( p.buckOut ) != null ) ) { filter ( "/" ) . through ( new com.google.gerrit.httpd.raw.RecompileGwtUiFilter ( p.buckOut , p.unpackedWar ) ) ; } }
private static void replyUncompressed ( javax.servlet.http.HttpServletResponse res , java.io.OutputStream dst , com.google.gerrit.extensions.restapi.BinaryResult bin , long len ) throws java.io.IOException { if ( ( 0 <= len ) && ( len < ( java.lang.Integer.MAX_VALUE ) ) ) { res.setContentLength ( ( ( int ) ( len ) ) ) ; } else if ( 0 <= len ) { res.setHeader ( "Content-Length" , java.lang.Long.toString ( len ) ) ; } bin.writeTo ( dst ) ; }
public void queryChangesOwnerWithDifferentUsers ( ) throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange ( ) ; com.google.common.truth.Truth.assertThat ( com.google.common.collect.Iterables.getOnlyElement ( query ( "owner:self" ) ) . changeId ) . isEqualTo ( r.getChangeId ( ) ) ; setApiUser ( user ) ; com.google.common.truth.Truth.assertThat ( query ( "owner:self" ) ) . isEmpty ( ) ; }
public com.google.gerrit.server.change.GetRelated.RelatedInfo getRelated ( com.google.gerrit.server.change.RevisionResource rsrc ) throws com.google.gwtorm.server.OrmException , java.io.IOException , org.eclipse.jgit.errors.RepositoryNotFoundException { try ( org.eclipse.jgit.lib.Repository git = gitMgr.openRepository ( rsrc.getChange ( ) . getProject ( ) ) ; org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk ( git ) ) { org.eclipse.jgit.lib.Ref ref = git.getRef ( rsrc.getChange ( ) . getDest ( ) . get ( ) ) ; com.google.gerrit.server.change.GetRelated.RelatedInfo info = new com.google.gerrit.server.change.GetRelated.RelatedInfo ( ) ; info.changes = walk ( rsrc , rw , ref ) ; return info ; } }
private void restoreSelection ( ) { if ( ( ( getFromTo ( ) ) != null ) && ( ( comment.in_reply_to ( ) ) == null ) ) { getCm ( ) . setSelection ( getFromTo ( ) . getFrom ( ) , getFromTo ( ) . getTo ( ) ) ; } }
private com.google.gerrit.server.patch.PatchScriptBuilder newBuilder ( ) throws com.google.gerrit.client.rpc.BaseServiceImplementation.Failure { final com.google.gerrit.server.patch.PatchScriptBuilder b = new com.google.gerrit.server.patch.PatchScriptBuilder ( ) ; b.setRepository ( git ) ; b.setPatch ( patch ) ; if ( ( context ) == ( com.google.gerrit.client.reviewdb.Account.WHOLE_FILE_CONTEXT ) ) b.setContext ( PatchScriptBuilder.MAX_CONTEXT ) ; else if ( ( 0 <= ( context ) ) && ( ( context ) <= ( PatchScriptBuilder.MAX_CONTEXT ) ) ) b.setContext ( context ) ; else throw new com.google.gerrit.client.rpc.BaseServiceImplementation.Failure ( new com.google.gerrit.client.rpc.NoSuchEntityException ( ) ) ; return b ; }
protected void allowGlobalCapability ( java.lang.String capabilityName , com.google.gerrit.reviewdb.client.AccountGroup.UUID id ) throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet ( allProjects ) . getConfig ( ) ; com.google.gerrit.server.project.Util.allow ( cfg , capabilityName , id ) ; saveProjectConfig ( allProjects , cfg ) ; }
public void deleteReviewerByEmailFromWipChangeInNoteDb ( ) throws java.lang.Exception { com.google.common.truth.TruthJUnit.assume ( ) . that ( notesMigration.readChanges ( ) ) . isTrue ( ) ; com.google.gerrit.acceptance.server.mail.StagedChange sc = stageWipChange ( ) ; gApi.changes ( ) . id ( sc.changeId ) . reviewer ( sc.reviewerByEmail ) . remove ( ) ; assertThat ( sender ) . notSent ( ) ; }
protected void configure ( ) { bind ( com.googlesource.gerrit.plugins.uploadvalidator.ContentTypeUtil.class ) ; bind ( com.google.gerrit.server.config.ProjectConfigEntry.class ) . annotatedWith ( com.google.gerrit.extensions.annotations.Exports.named ( com.googlesource.gerrit.plugins.uploadvalidator.ContentTypeUtil.KEY_BINARY_TYPES ) ) . toInstance ( new com.google.gerrit.server.config.ProjectConfigEntry ( "Binary Types" , null , ProjectConfigEntry.Type.ARRAY , null , false , ( "At the moment, there is no ideal solution to detect binary " + ( ( ( "files. But some checks shouldn't run on binary files " + "(e. g. InvalidLineEndingCheck). Because of that you can " ) + "enter content types to avoid that these checks run on " ) + "files with one of the entered content types." ) ) ) ) ; }
public java.util.List < com.google.gerrit.reviewdb.client.ChangeMessage > messages ( com.google.inject.Provider < com.google.gerrit.reviewdb.server.ReviewDb > db ) throws com.google.gwtorm.server.OrmException { if ( ( messages ) == null ) { messages = db.get ( ) . changeMessages ( ) . byChange ( legacyId ) . toList ( ) ; } return messages ; }
public com.google.gerrit.extensions.client.GeneralPreferencesInfo apply ( com.google.gerrit.server.account.AccountResource rsrc ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.server.permissions.PermissionBackendException { if ( ( self.get ( ) ) != ( rsrc.getUser ( ) ) ) { permissionBackend.user ( self ) . check ( GlobalPermission.MODIFY_ACCOUNT ) ; } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser ( ) . getAccountId ( ) ; return accountCache.get ( id ) . getGeneralPreferences ( ) ; }
private java.lang.String getOwerGroupName ( com.google.gerrit.server.project.ProjectState project ) { java.util.Set < com.google.gerrit.reviewdb.client.AccountGroup.UUID > owners = project.getAllOwners ( ) ; if ( ! ( owners.isEmpty ( ) ) ) { return groupCache.get ( owners.iterator ( ) . next ( ) ) . getName ( ) ; } return java.lang.String.format ( "no owners for project %s" , project.getProject ( ) . getName ( ) ) ; }
protected void renderJson ( javax.servlet.http.HttpServletRequest req , javax.servlet.http.HttpServletResponse res , java.lang.Object src , java.lang.reflect.Type typeOfSrc ) throws java.io.IOException { setApiHeaders ( res , com.google.gitiles.FormatType.JSON ) ; res.setStatus ( javax.servlet.http.HttpServletResponse.SC_OK ) ; java.io.Writer writer = getWriter ( res ) ; new com.google.gson.GsonBuilder ( ) . setFieldNamingPolicy ( com.google.gson.FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES ) . setPrettyPrinting ( ) . generateNonExecutableJson ( ) . create ( ) . toJson ( src , typeOfSrc , writer ) ; writer.write ( '\n' ) ; writer.close ( ) ; }
public void testNotNot ( ) { final com.google.gerrit.server.query.NotPredicateTest.TestPredicate p = com.google.gerrit.server.query.NotPredicateTest.f ( "author" , "bob" ) ; final com.google.gerrit.server.query.Predicate < java.lang.String > n = com.google.gerrit.server.query.Predicate.not ( p ) ; org.junit.Assert.assertTrue ( ( n instanceof com.google.gerrit.server.query.NotPredicate ) ) ; org.junit.Assert.assertNotSame ( p , n ) ; org.junit.Assert.assertSame ( p , com.google.gerrit.server.query.Predicate.not ( n ) ) ; }
private java.lang.Iterable < com.google.gerrit.reviewdb.client.PatchSetApproval > safeGetApprovals ( com.google.gerrit.server.git.CodeReviewCommit n ) { try { return approvalsUtil.byPatchSet ( db.get ( ) , n.getControl ( ) , n.getPatchsetId ( ) ) ; } catch ( com.google.gwtorm.server.OrmException e ) { com.google.gerrit.server.git.MergeUtil.log.error ( ( "Can't read approval records for " + ( n.getPatchsetId ( ) ) ) , e ) ; return java.util.Collections.emptyList ( ) ; } }
public void testKeyObjectId ( ) throws java.lang.Exception { org.bouncycastle.openpgp.PGPPublicKey key = com.google.gerrit.server.git.gpg.TestKey.key1 ( ) . getPublicKey ( ) ; java.lang.String objId = com.google.gerrit.server.git.gpg.PublicKeyStore.keyObjectId ( key.getKeyID ( ) ) . name ( ) ; org.junit.Assert.assertEquals ( "ed0625dc46328a8c000000000000000000000000" , objId ) ; org.junit.Assert.assertEquals ( com.google.gerrit.server.git.gpg.PublicKeyStore.keyIdToString ( key.getKeyID ( ) ) . toLowerCase ( ) , objId.substring ( 8 , 16 ) ) ; }
public void duplicateCompoundIndexOnlyPredicates ( ) throws java.lang.Exception { com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > in = parse ( "(status:new OR file:a) bar:p file:b" ) ; com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > out = rewrite ( in ) ; com.google.common.truth.Truth.assertThat ( out.getClass ( ) ) . isEqualTo ( com.google.gerrit.server.query.change.AndChangeSource.class ) ; com.google.common.truth.Truth.assertThat ( out.getChildren ( ) ) . containsExactly ( query ( com.google.gerrit.server.query.Predicate.and ( in.getChild ( 0 ) , in.getChild ( 2 ) ) ) , in.getChild ( 1 ) ) . inOrder ( ) ; }
public com.google.gerrit.extensions.restapi.Response < ? > apply ( com.google.gerrit.server.change.ChangeResource rsrc , com.google.gerrit.server.change.Index.Input input ) throws com.google.gerrit.extensions.restapi.AuthException , java.io.IOException { com.google.gerrit.server.project.ChangeControl ctl = rsrc.getControl ( ) ; if ( ( ! ( ctl.isOwner ( ) ) ) && ( ! ( ctl.getCurrentUser ( ) . getCapabilities ( ) . canMaintainServer ( ) ) ) ) { throw new com.google.gerrit.extensions.restapi.AuthException ( "Only change owner or server maintainer can reindex" ) ; } indexer.index ( db.get ( ) , rsrc.getChange ( ) ) ; return com.google.gerrit.extensions.restapi.Response.none ( ) ; }
public void testSubscriptionWithoutServerSetting ( ) throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository < ? > superRepo = createProjectWithPush ( "super-project" ) ; org.eclipse.jgit.junit.TestRepository < ? > subRepo = createProjectWithPush ( "subscribed-to-project" ) ; createSubmoduleSubscription ( superRepo , "master" , "subscribed-to-project" , "master" ) ; pushChangeTo ( subRepo , "master" ) ; com.google.common.truth.Truth.assertThat ( hasSubmodule ( superRepo , "master" , "subscribed-to-project" ) ) . isFalse ( ) ; }
public com.google.gerrit.server.change.ChangeEditResource parse ( com.google.gerrit.server.change.ChangeResource change , com.google.gerrit.extensions.restapi.IdString id ) { throw new java.lang.IllegalStateException ( "not yet implemented" ) ; }
public com.google.gerrit.server.change.ReviewerJson.ReviewerInfo format ( com.google.gerrit.server.change.ReviewerJson.ReviewerInfo out , com.google.gerrit.server.project.ChangeControl ctl ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.PatchSet.Id psId = ctl.getChange ( ) . currentPatchSetId ( ) ; return format ( out , ctl , approvalsUtil.byPatchSetUser ( db.get ( ) , ctl , psId , new com.google.gerrit.reviewdb.client.Account.Id ( out._accountId ) ) ) ; }
public com.google.gerrit.acceptance.RestResponse putRaw ( java.lang.String endPoint , com.google.gerrit.extensions.restapi.RawInput stream ) throws java.io.IOException { com.google.common.base.Preconditions.checkNotNull ( stream ) ; org.apache.http.client.fluent.Request put = org.apache.http.client.fluent.Request.Put ( ( ( ( url ) + "/a" ) + endPoint ) ) ; put.addHeader ( new org.apache.http.message.BasicHeader ( "Content-Type" , stream.getContentType ( ) ) ) ; put.body ( new org.apache.http.entity.BufferedHttpEntity ( new org.apache.http.entity.InputStreamEntity ( stream.getInputStream ( ) , stream.getContentLength ( ) ) ) ) ; return execute ( put ) ; }
public com.google.gwtorm.server.ResultSet < com.google.gerrit.server.query.change.ChangeData > read ( ) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.reviewdb.client.RevId id = new com.google.gerrit.reviewdb.client.RevId ( abbreviated ( ) . name ( ) ) ; if ( id.isComplete ( ) ) { return com.google.gerrit.server.query.change.ChangeDataResultSet.patchSet ( dbProvider.get ( ) . patchSets ( ) . byRevision ( id ) ) ; } else { return com.google.gerrit.server.query.change.ChangeDataResultSet.patchSet ( dbProvider.get ( ) . patchSets ( ) . byRevisionRange ( id , id.max ( ) ) ) ; } }
public com.google.gitiles.GitilesView.Builder setPathPart ( java.lang.String path ) { switch ( type ) { case PATH : case DIFF : com.google.common.base.Preconditions.checkState ( ( path != null ) , "cannot set null path on %s view" , type ) ; break ; case ARCHIVE : case DESCRIBE : case REFS : case LOG : break ; default : com.google.common.base.Preconditions.checkState ( ( path == null ) , "cannot set path on %s view" , type ) ; break ; } this . path = ( path != null ) ? com.google.gitiles.GitilesView.maybeTrimLeadingAndTrailingSlash ( path ) : null ; return this ; }
protected org.eclipse.jgit.junit.TestRepository < ? > createProjectWithPush ( java.lang.String name , @ com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey parent , boolean createEmptyCommit , com.google.gerrit.extensions.client.SubmitType submitType ) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey project = createProject ( name , parent , createEmptyCommit , submitType ) ; HEAD ( 26 ) ; a551 ( "More horizontal space for patch set descriptions" ) ; grant ( Permission.PUSH , project , "refs/heads/*" ) ; grant ( Permission.SUBMIT , project , "refs/for/refs/heads/*" ) ; }
private void createLuceneIndex ( ) throws java.io.IOException { com.google.inject.Injector injector = com.google.inject.Guice.createInjector ( new com.google.gerrit.lucene.LuceneIndexModule ( com.google.gerrit.server.index.ChangeSchemas.getLatest ( ) . getVersion ( ) , 0 , null ) , new com.google.gerrit.pgm.init.InitIndex.MockIndexSupportModule ( ) ) ; com.google.gerrit.server.index.ChangeIndex index = injector.getInstance ( com.google.gerrit.lucene.LuceneChangeIndex.class ) ; index.markReady ( true ) ; index.close ( ) ; }
private void deleteDraftComment ( com.google.gerrit.reviewdb.client.PatchLineComment c ) throws com.google.gwtorm.server.OrmException { createDraftUpdateIfNull ( ) ; draftUpdate.deleteComment ( c ) ; }
void display ( final java.lang.String token ) { assert token != null ; try { com.google.gerrit.client.Dispatcher.select ( token ) ; } catch ( java.lang.RuntimeException err ) { com.google.gwt.core.client.GWT.log ( ( "Error parsing history token: " + token ) , err ) ; com.google.gerrit.client.Gerrit.display ( token , new com.google.gerrit.client.NotFoundScreen ( ) ) ; } }
protected void configureServlets ( ) { serve ( "/gitweb" ) . with ( com.google.gerrit.httpd.gitweb.GitWebServlet.class ) ; serve ( "/gitweb-logo.png" ) . with ( com.google.gerrit.httpd.gitweb.GitLogoServlet.class ) ; serve ( "/gitweb-default.css" ) . with ( GitWebCssServlet.Default.class ) ; serve ( "/gitweb-site.css" ) . with ( GitWebCssServlet.Site.class ) ; }
public com.google.gerrit.extensions.api.projects.CommitApi commit ( java.lang.String commit ) throws com.google.gerrit.extensions.restapi.RestApiException { try { return commitApi.create ( commitsCollection.parse ( checkExists ( ) , com.google.gerrit.extensions.restapi.IdString.fromDecoded ( commit ) ) ) ; } catch ( java.io.IOException e ) { throw new com.google.gerrit.extensions.restapi.RestApiException ( "Cannot parse commit" , e ) ; } }
public java.lang.String getRequestURI ( ) { return null ; }
private com.google.gerrit.server.account.AuthResult byUserName ( final javax.servlet.http.HttpServletResponse rsp , final java.lang.String userName ) { try { final com.google.gerrit.reviewdb.ReviewDb db = schema.open ( ) ; try { com.google.gerrit.reviewdb.AccountExternalId.Key key = new com.google.gerrit.reviewdb.AccountExternalId.Key ( com.google.gerrit.reviewdb.AccountExternalId.SCHEME_USERNAME , userName ) ; return auth ( db.accountExternalIds ( ) . get ( key ) ) ; } finally { db.close ( ) ; } } catch ( com.google.gwtorm.client.OrmException e ) { getServletContext ( ) . log ( "cannot query database" , e ) ; return null ; } }
HEAD ( ) { }
private org.apache.lucene.search.Query fullTextQuery ( com.google.gerrit.server.index.IndexPredicate < com.google.gerrit.server.query.change.ChangeData > p ) throws com.google.gerrit.server.query.QueryParseException { java.lang.String value = p.getValue ( ) ; if ( value == null ) { throw new com.google.gerrit.server.query.QueryParseException ( "Full-text search over empty string not supported" ) ; } return queryBuilder.createPhraseQuery ( p.getField ( ) . getName ( ) , value ) ; }
public void getMultiple ( ) throws java.lang.Exception { com.google.gerrit.gpg.testutil.TestKey key1 = com.google.gerrit.gpg.testutil.TestKeys.validKeyWithoutExpiration ( ) ; com.google.gerrit.gpg.testutil.TestKey key2 = com.google.gerrit.gpg.testutil.TestKeys.validKeyWithExpiration ( ) ; tr.branch ( com.google.gerrit.gpg.PublicKeyStore.REFS_GPG_KEYS ) . commit ( ) . add ( com.google.gerrit.gpg.PublicKeyStore.keyObjectId ( key1.getKeyId ( ) ) . name ( ) , ( ( key1.getPublicKeyArmored ( ) ) + ( key2.getPublicKeyArmored ( ) ) ) ) . create ( ) ; assertKeys ( key1.getKeyId ( ) , key1 , key2 ) ; }
public void testUpsertOneExisting ( ) throws com.google.gwtorm.client.OrmException , java.sql.SQLException { stubExecuteBatchOK ( com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE , 1 ) ; createClassUnderTest ( ) . upsert ( com.google.gwtorm.jdbc.TestJdbcAccess.ONE_ROW ) ; }
private void onFailure ( java.lang.Throwable caught ) { if ( failed ) { return ; } failed = true ; for ( java.lang.Object o : callbacks ) { if ( o instanceof com.google.gwt.user.client.rpc.AsyncCallback ) { @ java.lang.SuppressWarnings ( value = "unchecked" ) com.google.gwt.user.client.rpc.AsyncCallback < java.lang.Object > cb = ( ( com.google.gwt.user.client.rpc.AsyncCallback < java.lang.Object > ) ( o ) ) ; cb.onFailure ( caught ) ; } else { @ java.lang.SuppressWarnings ( value = "unchecked" ) com.google.gwtjsonrpc.common.AsyncCallback < java.lang.Object > cb = ( ( com.google.gwtjsonrpc.common.AsyncCallback < java.lang.Object > ) ( o ) ) ; cb.onFailure ( caught ) ; } } }
public void testPersonByNameRange_OrderByName ( ) throws java.lang.Exception { com.google.gwtorm.nosql.IndexFunction < com.google.gwtorm.data.TestPerson > idx = index ( "nameSuggest" , "WHERE name >= ? AND name <= ? ORDER BY name" ) ; com.google.gwtorm.nosql.IndexFunctionTest.assertEquals ( "nameSuggest" , idx.getName ( ) ) ; com.google.gwtorm.nosql.IndexKeyBuilder b ; com.google.gwtorm.data.TestPerson p ; b = new com.google.gwtorm.nosql.IndexKeyBuilder ( ) ; p = new com.google.gwtorm.data.TestPerson ( new com.google.gwtorm.data.TestPerson.Key ( "q" ) , 42 ) ; assertTrue ( idx.includes ( p ) ) ; idx.encode ( b , p ) ; com.google.gwtorm.nosql.IndexFunctionTest.assertEquals ( new byte [ ] { 'q' } , b ) ; }
public void testInheritRead_SingleBranchDoesNotOverrideInherited ( ) { grant ( parent , com.google.gerrit.common.data.Permission.READ , registered , "refs/*" ) ; grant ( parent , com.google.gerrit.common.data.Permission.PUSH , registered , "refs/for/refs/*" ) ; grant ( local , com.google.gerrit.common.data.Permission.READ , registered , "refs/heads/foobar" ) ; com.google.gerrit.server.project.ProjectControl u = user ( ) ; assertTrue ( "can upload" , u.canPushToAtLeastOneRef ( ) ) ; assertTrue ( "can upload refs/heads/master" , u.controlForRef ( "refs/heads/master" ) . canUpload ( ) ) ; assertTrue ( "can upload refs/heads/foobar" , u.controlForRef ( "refs/heads/foobar" ) . canUpload ( ) ) ; }
byte [ ] build ( com.google.gerrit.server.notedb.CommentsInNotesUtil commentsUtil ) { return commentsUtil.buildNote ( com.google.gerrit.server.PatchLineCommentsUtil.PLC_ORDER.sortedCopy ( comments.values ( ) ) ) ; }
public void testCUSTOM_NoFullNameUser ( ) { setFrom ( "A ${user} B <my.server@email.address>" ) ; final java.lang.String email = "a.u.thor@test.example.com" ; final com.google.gerrit.reviewdb.client.Account.Id user = user ( null , email ) ; org.easymock.EasyMock.replay ( accountCache ) ; final com.google.gerrit.server.mail.Address r = create ( ) . from ( user ) ; assertNotNull ( r ) ; assertEquals ( "A Anonymous Coward B" , r.name ) ; assertEquals ( "my.server@email.address" , r.email ) ; org.easymock.EasyMock.verify ( accountCache ) ; }
public void replace ( byte [ ] key , byte [ ] data ) throws com.google.gwtorm.client.OrmException { upsert ( key , data ) ; }
private static void assertUsedBatchingOnly ( java.sql.PreparedStatement statement ) throws java.sql.SQLException { org.mockito.Mockito.verify ( statement , org.mockito.Mockito.atLeastOnce ( ) ) . addBatch ( ) ; org.mockito.Mockito.verify ( statement ) . executeBatch ( ) ; org.mockito.Mockito.verify ( statement , org.mockito.Mockito.never ( ) ) . executeUpdate ( ) ; }
public void insert ( com.google.gerrit.server.query.change.ChangeData cd ) throws java.io.IOException { org.apache.lucene.index.Term id = idTerm ( cd ) ; org.apache.lucene.document.Document doc = toDocument ( cd ) ; if ( cd.getChange ( ) . getStatus ( ) . isOpen ( ) ) { closedIndex.delete ( id ) ; openIndex.insert ( doc ) ; } else { openIndex.delete ( id ) ; closedIndex.insert ( doc ) ; } }
private java.util.HashMap < java.util.regex.Pattern , com.googlesource.gerrit.plugins.hooks.validation.ItsAssociationPolicy > getCommentRegexMap ( ) { java.util.HashMap < java.util.regex.Pattern , com.googlesource.gerrit.plugins.hooks.validation.ItsAssociationPolicy > regexMap = new java.util.HashMap < java.util.regex.Pattern , com.googlesource.gerrit.plugins.hooks.validation.ItsAssociationPolicy > ( ) ; java.util.regex.Pattern pattern = issueExtractor.getPattern ( ) ; if ( pattern != null ) { regexMap.put ( pattern , gerritConfig.getEnum ( "commentLink" , itsName , "association" , ItsAssociationPolicy.OPTIONAL ) ) ; } return regexMap ; }
public void setSshInjector ( com.google.inject.Injector injector ) { sshModule = com.google.gerrit.server.plugins.PluginGuiceEnvironment.copy ( injector ) ; sshGen = injector.getProvider ( com.google.gerrit.server.plugins.ModuleGenerator.class ) ; sshSets = com.google.gerrit.server.plugins.PluginGuiceEnvironment.dynamicSetsOf ( injector ) ; sshMaps = com.google.gerrit.server.plugins.PluginGuiceEnvironment.dynamicMapsOf ( injector ) ; onStart.addAll ( com.google.gerrit.server.plugins.PluginGuiceEnvironment.listeners ( injector , com.google.gerrit.server.plugins.StartPluginListener.class ) ) ; onReload.addAll ( com.google.gerrit.server.plugins.PluginGuiceEnvironment.listeners ( injector , com.google.gerrit.server.plugins.ReloadPluginListener.class ) ) ; }
protected void delegateTo ( final org.apache.sshd.server.CommandFactory.Command cmd ) throws java.io.IOException { if ( cmd instanceof org.apache.sshd.server.CommandFactory.SessionAware ) { ( ( org.apache.sshd.server.CommandFactory.SessionAware ) ( cmd ) ) . setSession ( session ) ; } cmd.setInputStream ( in ) ; cmd.setOutputStream ( out ) ; cmd.setErrorStream ( err ) ; cmd.setExitCallback ( exit ) ; cmd.start ( ) ; }
public void generatesExpectedMessage ( ) throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig ( ) ; mockEvent.change = com.google.common.base.Suppliers.ofInstance ( mockChange ) ; mockEvent.reviewer = com.google.common.base.Suppliers.ofInstance ( mockAccount ) ; mockChange.project = "testproject" ; mockChange.branch = "master" ; mockChange.commitMessage = "This is the first line\nAnd the second line." ; mockChange.url = "https://change/" ; mockAccount.name = "Unit Tester" ; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator ; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance ( mockEvent , config ) ; java.lang.String expectedResult ; expectedResult = "{\"text\": \"Unit Tester was added to review\\n>>>" + ( ( "testproject (master): This is the first line" + " (https://change/)\",\"channel\": \"#testchannel\"," ) + "\"username\": \"testuser\"}\n" ) ; java.lang.String actualResult ; actualResult = messageGenerator.generate ( ) ; org.junit.Assert.assertThat ( actualResult , org.hamcrest.core.Is.is ( org.hamcrest.CoreMatchers.equalTo ( expectedResult ) ) ) ; }
public void onSuccess ( final com.google.gerrit.common.data.PatchSetDetail result ) { ensureLoaded ( result ) ; patchTable.setRegisterKeys ( true ) ; }
private static com.google.gerrit.server.git.CodeReviewCommit failed ( final org.eclipse.jgit.revwalk.RevWalk rw , final org.eclipse.jgit.revwalk.RevFlag canMergeFlag , final com.google.gerrit.server.git.CodeReviewCommit mergeTip , final com.google.gerrit.server.git.CodeReviewCommit n , final com.google.gerrit.server.git.CommitMergeStatus failure ) throws java.io.IOException , org.eclipse.jgit.errors.IncorrectObjectTypeException , org.eclipse.jgit.errors.MissingObjectException { rw.resetRetain ( canMergeFlag ) ; rw.markStart ( n ) ; rw.markUninteresting ( mergeTip ) ; com.google.gerrit.server.git.CodeReviewCommit failed ; while ( ( failed = ( ( com.google.gerrit.server.git.CodeReviewCommit ) ( rw.next ( ) ) ) ) != null ) { failed.setStatusCode ( failure ) ; } return failed ; }
public int compare ( com.google.gerrit.server.notedb.ChangeRebuilderImpl.Event a , com.google.gerrit.server.notedb.ChangeRebuilderImpl.Event b ) { return com.google.common.collect.ComparisonChain.start ( ) . compareTrueFirst ( a.predatesChange , b.predatesChange ) . compare ( a.when , b.when ) . compare ( a.who , b.who , com.google.gerrit.reviewdb.server.ReviewDbUtil.intKeyOrdering ( ) ) . compare ( a.psId , b.psId , com.google.gerrit.reviewdb.server.ReviewDbUtil.intKeyOrdering ( ) . nullsLast ( ) ) . result ( ) ; }
protected void configure ( ) { bind ( java.lang.String.class ) . annotatedWith ( com.googlesource.gerrit.plugins.hooks.its.ItsName.class ) . toInstance ( "ItsTestName" ) ; serverConfig = createMock ( org.eclipse.jgit.lib.Config.class ) ; bind ( org.eclipse.jgit.lib.Config.class ) . annotatedWith ( com.google.gerrit.server.config.GerritServerConfig.class ) . toInstance ( serverConfig ) ; commitMessageFetcher = createMock ( com.googlesource.gerrit.plugins.hooks.util.CommitMessageFetcher.class ) ; bind ( com.googlesource.gerrit.plugins.hooks.util.CommitMessageFetcher.class ) . toInstance ( commitMessageFetcher ) ; }
private void assertIncludes ( java.util.List < com.google.gerrit.extensions.common.GroupInfo > includes , java.lang.String ... names ) { java.lang.Iterable < java.lang.String > includeNames = com.google.common.collect.Iterables.transform ( includes , new com.google.common.base.Function < com.google.gerrit.extensions.common.GroupInfo , java.lang.String > ( ) { @ java.lang.Override public java.lang.String apply ( @ com.google.gerrit.common.Nullable com.google.gerrit.extensions.common.GroupInfo info ) { return info.name ; } } ) ; com.google.common.truth.Truth.assertThat ( includeNames ) . containsExactlyElementsIn ( java.util.Arrays.asList ( names ) ) . inOrder ( ) ; }
public java.lang.String toString ( ) { return com.google.common.base.MoreObjects.toStringHelper ( this ) . addValue ( getId ( ) ) . toString ( ) ; }
private static java.util.List < java.lang.String > splitProjection ( java.lang.String projection ) { return com.google.common.collect.Lists.newArrayList ( com.google.common.base.Splitter.on ( '~' ) . limit ( 2 ) . split ( projection ) ) ; }
protected java.util.SortedSet < java.lang.String > cacheNames ( ) { java.util.SortedSet < java.lang.String > names = com.google.common.collect.Sets.newTreeSet ( ) ; for ( java.lang.String plugin : cacheMap.plugins ( ) ) { for ( java.lang.String name : cacheMap.byPlugin ( plugin ) . keySet ( ) ) { names.add ( cacheNameOf ( plugin , name ) ) ; } } return names ; }
public void subsetOfBranchesVisibleIncludingHead ( ) throws java.lang.Exception { allow ( Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS , "refs/heads/master" ) ; deny ( Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS , "refs/heads/branch" ) ; assertRefs ( "HEAD" , ( ( r1 ) + "1" ) , ( ( r1 ) + "meta" ) , "refs/heads/master" , "refs/tags/master-tag" ) ; }
private int getCodeMirrorHeight ( ) { int rest = ( ( ( com.google.gerrit.client.Gerrit.getHeaderFooterHeight ( ) ) + ( header.getOffsetHeight ( ) ) ) + ( diffTable.getHeaderHeight ( ) ) ) + 5 ; return ( com.google.gwt.user.client.Window.getClientHeight ( ) ) - rest ; }
public java.util.Map < java.lang.String , com.j2bugzilla.rpc.GetLegalValues.Fields > getFields ( ) { java.util.Map < java.lang.String , com.j2bugzilla.rpc.GetLegalValues.Fields > fields = new java.util.HashMap < java.lang.String , com.j2bugzilla.rpc.GetLegalValues.Fields > ( ) ; fields.put ( "status" , Fields.STATUS ) ; return fields ; }
public void setDefault ( ) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.common.SetDashboardInput input = new com.google.gerrit.extensions.common.SetDashboardInput ( ) ; input.id = id ; try { set.apply ( com.google.gerrit.server.project.DashboardResource.projectDefault ( project.getControl ( ) ) , input ) ; } catch ( java.lang.Exception e ) { java.lang.String msg = java.lang.String.format ( "Cannot %s default dashboard" , ( ( id ) != null ? "set" : "remove" ) ) ; throw com.google.gerrit.server.api.ApiUtil.asRestApiException ( msg , e ) ; } }
private org.eclipse.jgit.revwalk.RevCommit parse ( final org.eclipse.jgit.lib.Repository git , com.google.gerrit.reviewdb.PatchSet ps ) throws java.io.IOException , org.eclipse.jgit.errors.IncorrectObjectTypeException , org.eclipse.jgit.errors.MissingObjectException { return new org.eclipse.jgit.revwalk.RevWalk ( git ) . parseCommit ( org.eclipse.jgit.lib.ObjectId.fromString ( ps.getRevision ( ) . get ( ) ) ) ; }
private void setListBox ( final com.google.gwt.user.client.ui.ListBox f , final short defaultValue , final short currentValue ) { final int n = f.getItemCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( java.lang.Short.parseShort ( f.getValue ( i ) ) ) == currentValue ) { f.setSelectedIndex ( i ) ; return ; } } if ( currentValue != defaultValue ) { setListBox ( f , defaultValue , defaultValue ) ; } }
protected PushOneCommit.Result amendChange ( java.lang.String changeId , java.lang.String ref ) throws java.io.IOException , org.eclipse.jgit.api.errors.GitAPIException { java.util.Collections.shuffle ( com.google.gerrit.acceptance.AbstractDaemonTest.RANDOM ) ; com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create ( db , admin.getIdent ( ) , PushOneCommit.SUBJECT , PushOneCommit.FILE_NAME , new java.lang.String ( com.google.common.primitives.Chars.toArray ( com.google.gerrit.acceptance.AbstractDaemonTest.RANDOM ) ) , changeId ) ; return push.to ( git , ref ) ; }
public com.googlecode.prolog_cafe.builtin.Operation exec ( com.googlecode.prolog_cafe.builtin.Prolog engine ) { engine.setB0 ( ) ; com.googlecode.prolog_cafe.builtin.Term a1 ; a1 = arg1 ; a1 = a1.dereference ( ) ; if ( a1.isVariable ( ) ) throw new com.googlecode.prolog_cafe.exceptions.PInstantiationException ( this , 1 ) ; if ( ! ( a1.isInteger ( ) ) ) throw new com.googlecode.prolog_cafe.exceptions.IllegalTypeException ( this , 1 , "integer" , a1 ) ; engine.halt = 1 + ( ( ( com.googlecode.prolog_cafe.builtin.IntegerTerm ) ( a1 ) ) . intValue ( ) ) ; return cont ; }
private com.google.gerrit.acceptance.RestResponse GET ( java.lang.String endpoint ) throws java.io.IOException { return adminSession.get ( endpoint ) ; }
public void onShowView ( ) { super . onShowView ( ) ; int rest = ( com.google.gerrit.client.Gerrit.getHeaderFooterHeight ( ) ) + 30 ; cm.setHeight ( ( ( com.google.gwt.user.client.Window.getClientHeight ( ) ) - rest ) ) ; cm.refresh ( ) ; cm.focus ( ) ; }
protected void onLoad ( ) { super . onLoad ( ) ; Util.LIST_SVC.forAccount ( ownerId , new com.google.gerrit.client.rpc.ScreenLoadCallback < com.google.gerrit.common.data.AccountDashboardInfo > ( this ) { @ java.lang.Override protected void preDisplay ( final com.google.gerrit.common.data.AccountDashboardInfo r ) { display ( r ) ; } } ) ; }
public void testHasValidScheme ( ) { org.junit.Assert.assertTrue ( com.google.gwtexpui.safehtml.client.LinkFindReplace.hasValidScheme ( "/absolute/path" ) ) ; org.junit.Assert.assertTrue ( com.google.gwtexpui.safehtml.client.LinkFindReplace.hasValidScheme ( "relative/path" ) ) ; org.junit.Assert.assertTrue ( com.google.gwtexpui.safehtml.client.LinkFindReplace.hasValidScheme ( "http://url/" ) ) ; org.junit.Assert.assertTrue ( com.google.gwtexpui.safehtml.client.LinkFindReplace.hasValidScheme ( "HTTP://url/" ) ) ; org.junit.Assert.assertTrue ( com.google.gwtexpui.safehtml.client.LinkFindReplace.hasValidScheme ( "https://url/" ) ) ; org.junit.Assert.assertTrue ( com.google.gwtexpui.safehtml.client.LinkFindReplace.hasValidScheme ( "mailto://url/" ) ) ; org.junit.Assert.assertFalse ( com.google.gwtexpui.safehtml.client.LinkFindReplace.hasValidScheme ( "ftp://url/" ) ) ; org.junit.Assert.assertFalse ( com.google.gwtexpui.safehtml.client.LinkFindReplace.hasValidScheme ( "data:evil" ) ) ; org.junit.Assert.assertFalse ( com.google.gwtexpui.safehtml.client.LinkFindReplace.hasValidScheme ( "javascript:alert(1)" ) ) ; }
public void testStringFF ( ) { com.google.gwtorm.nosql.IndexKeyBuilder ib = new com.google.gwtorm.nosql.IndexKeyBuilder ( ) ; ib.add ( new byte [ ] { ( ( byte ) ( 255 ) ) } ) ; com.google.gwtorm.nosql.IndexKeyBuilderTest.assertEquals ( new byte [ ] { ( ( byte ) ( 255 ) ) , 0 } , ib ) ; }
public boolean retryRequest ( java.io.IOException exception , int executionCount , org.apache.http.protocol.HttpContext context ) { if ( ( executionCount > ( cfg.getMaxTries ( ) ) ) || ( exception instanceof javax.net.ssl.SSLException ) ) { return false ; } logRetry ( exception.getMessage ( ) , context ) ; try { java.lang.Thread.sleep ( cfg.getRetryInterval ( ) ) ; } catch ( java.lang.InterruptedException e ) { java.lang.Thread.currentThread ( ) . interrupt ( ) ; return false ; } return true ; }
public void testSubscriptionFailOnWrongBranchACL ( ) throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository < ? > superRepo = createProjectWithPush ( "super-project" ) ; org.eclipse.jgit.junit.TestRepository < ? > subRepo = createProjectWithPush ( "subscribed-to-project" ) ; allowSubmoduleSubscription ( "subscribed-to-project" , "refs/heads/master" , "super-project" , "refs/heads/wrong-branch" ) ; pushChangeTo ( subRepo , "master" ) ; createSubmoduleSubscription ( superRepo , "master" , "subscribed-to-project" , "master" ) ; pushChangeTo ( subRepo , "master" ) ; com.google.common.truth.Truth.assertThat ( hasSubmodule ( superRepo , "master" , "subscribed-to-project" ) ) . isFalse ( ) ; }
public void testIsEnabledChangeRestoredEvent ( ) { java.lang.String [ ] branches = new java.lang.String [ ] { } ; setupIsEnabled ( "true" , null , branches ) ; com.google.gerrit.server.events.ChangeRestoredEvent event = new com.google.gerrit.server.events.ChangeRestoredEvent ( ) ; com.google.gerrit.server.data.ChangeAttribute changeAttribute = new com.google.gerrit.server.data.ChangeAttribute ( ) ; changeAttribute.project = "testProject" ; changeAttribute.branch = "testBranch" ; event.change = com.google.common.base.Suppliers.ofInstance ( changeAttribute ) ; com.googlesource.gerrit.plugins.its.base.its.ItsConfig itsConfig = createItsConfig ( ) ; replayMocks ( ) ; assertTrue ( itsConfig.isEnabled ( event ) ) ; }
public void onFailure ( java.lang.Throwable e ) { enableEdit ( true ) ; pendingGroup = null ; super . onFailure ( e ) ; }
public void duplicatePatchSetRevisions ( ) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = insertChange ( ) ; com.google.gerrit.reviewdb.client.PatchSet ps1 = insertPatchSet ( c ) ; java.lang.String rev = ps1.getRevision ( ) . get ( ) ; incrementPatchSet ( c ) ; com.google.gerrit.reviewdb.client.PatchSet ps2 = insertMissingPatchSet ( c , rev ) ; updatePatchSetRef ( ps2 ) ; assertProblems ( c , ( ( "Multiple patch sets pointing to " + rev ) + ": [1, 2]" ) ) ; }
private com.google.gerrit.server.permissions.ProjectControl user ( com.google.gerrit.server.git.ProjectConfig local , java.lang.String name , com.google.gerrit.reviewdb.client.AccountGroup ... memberOf ) { return new com.google.gerrit.server.permissions.ProjectControl ( java.util.Collections.< com.google.gerrit.reviewdb.client.AccountGroup.UUID > emptySet ( ) , java.util.Collections.< com.google.gerrit.reviewdb.client.AccountGroup.UUID > emptySet ( ) , sectionSorter , changeControlFactory , permissionBackend , refFilterFactory , new com.google.gerrit.server.permissions.RefControlTest.MockUser ( name , memberOf ) , newProjectState ( local ) ) ; }
private com.google.gerrit.common.data.SubmitTypeRecord typeError ( java.lang.String err , java.lang.Exception e ) { if ( logErrors ) { com.google.gerrit.server.project.SubmitRuleEvaluator.log.error ( err , e ) ; return com.google.gerrit.server.project.SubmitRuleEvaluator.defaultTypeError ( ) ; } else { return com.google.gerrit.server.project.SubmitRuleEvaluator.createTypeError ( err ) ; } }
public void fire ( com.google.gerrit.extensions.common.ChangeInfo change , com.google.gerrit.extensions.common.AccountInfo editor , java.lang.String oldTopic , java.sql.Timestamp when ) { if ( ! ( listeners.iterator ( ) . hasNext ( ) ) ) { return ; } com.google.gerrit.server.extensions.events.TopicEdited.Event event = new com.google.gerrit.server.extensions.events.TopicEdited.Event ( change , editor , oldTopic , when ) ; for ( com.google.gerrit.extensions.events.TopicEditedListener l : listeners ) { try { l.onTopicEdited ( event ) ; } catch ( java.lang.Exception e ) { com.google.gerrit.server.extensions.events.TopicEdited.log.warn ( "Error in event listener" , e ) ; } } }
public java.util.Set < com.google.gerrit.reviewdb.client.AccountGroup.UUID > load ( java.lang.String key ) throws java.lang.Exception { try ( com.google.gerrit.reviewdb.server.ReviewDb db = schema.open ( ) ) { java.util.Set < com.google.gerrit.reviewdb.client.AccountGroup.UUID > ids = com.google.common.collect.Sets.newHashSet ( ) ; for ( com.google.gerrit.reviewdb.client.AccountGroupById agi : db.accountGroupById ( ) . all ( ) ) { if ( ! ( com.google.gerrit.reviewdb.client.AccountGroup.isInternalGroup ( agi.getIncludeUUID ( ) ) ) ) { ids.add ( agi.getIncludeUUID ( ) ) ; } } return com.google.common.collect.ImmutableSet.copyOf ( ids ) ; } }
public void httpLink ( ) { com.google.gitiles.doc.MarkdownToHtml md = new com.google.gitiles.doc.MarkdownToHtml ( view , config , "index.md" ) ; java.lang.String url ; url = "http://example.com/foo.html" ; com.google.common.truth.Truth.assertThat ( md.href ( url ) ) . isEqualTo ( url ) ; url = "https://example.com/foo.html" ; com.google.common.truth.Truth.assertThat ( md.href ( url ) ) . isEqualTo ( url ) ; url = "//example.com/foo.html" ; com.google.common.truth.Truth.assertThat ( md.href ( url ) ) . isEqualTo ( url ) ; }
private int finish ( final java.util.Iterator < com.google.gerrit.reviewdb.client.PatchLineComment > i , int row , final int col , boolean expandComment ) { while ( i.hasNext ( ) ) { final com.google.gerrit.reviewdb.client.PatchLineComment c = i.next ( ) ; insertRow ( row ) ; bindComment ( row , col , c , ( ! ( i.hasNext ( ) ) ) , expandComment ) ; row ++ ; } return row ; }
private HostPageData.Theme getTheme ( java.lang.String name ) { com.google.gerrit.common.data.HostPageData.Theme theme = new com.google.gerrit.common.data.HostPageData.Theme ( ) ; theme.backgroundColor = color ( name , "backgroundColor" , "#FFFFFF" ) ; theme.textColor = color ( name , "textColor" , "#000000" ) ; theme.trimColor = color ( name , "trimColor" , "#D4E9A9" ) ; theme.selectionColor = color ( name , "selectionColor" , "#FFFFCC" ) ; theme.topMenuColor = color ( name , "topMenuColor" , theme.trimColor ) ; return theme ; }
public com.google.gerrit.server.notedb.ChangeNotes call ( ) throws java.lang.Exception { com.google.common.base.Preconditions.checkArgument ( change.getProject ( ) . equals ( project ) , ( "passed project %s when creating ChangeNotes for %s," + " but actual project is %s" ) , project , changeId , change.getProject ( ) ) ; return new com.google.gerrit.server.notedb.ChangeNotes ( repoManager , migration , allUsers , project , change ) . load ( ) ; }
private java.lang.String getScopesKey ( javax.servlet.http.HttpServletRequest request , javax.servlet.http.HttpServletResponse response ) { java.lang.String scopeRequested = request.getParameter ( "scope" ) ; if ( scopeRequested == null ) { scopeRequested = getScopesKeyFromCookie ( request ) ; } if ( scopeRequested != null ) { javax.servlet.http.Cookie scopeCookie = new javax.servlet.http.Cookie ( "scope" , scopeRequested ) ; scopeCookie.setPath ( "/" ) ; scopeCookie.setMaxAge ( ( ( int ) ( com.googlesource.gerrit.plugins.github.oauth.GitHubLogin.SCOPE_COOKIE_NEVER_EXPIRES ) ) ) ; response.addCookie ( scopeCookie ) ; } return com.google.common.base.Objects.firstNonNull ( scopeRequested , "scopes" ) ; }
public boolean updateChange ( com.google.gerrit.server.update.ChangeContext ctx ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gwtorm.server.OrmException { change = ctx.getChange ( ) ; com.google.gerrit.server.notedb.ChangeUpdate update = ctx.getUpdate ( change.currentPatchSetId ( ) ) ; com.google.gerrit.reviewdb.client.Account.Id currentAssigneeId = change.getAssignee ( ) ; if ( currentAssigneeId == null ) { return false ; } com.google.gerrit.server.IdentifiedUser deletedAssigneeUser = userFactory.create ( currentAssigneeId ) ; deletedAssignee = deletedAssigneeUser.getAccount ( ) ; update.removeAssignee ( ) ; change.setAssignee ( null ) ; addMessage ( ctx , update , deletedAssigneeUser ) ; return true ; }
com.google.gerrit.metrics.dropwizard.DropWizardMetricMaker.HistogramImpl forceCreate ( java.lang.Object key ) { com.google.gerrit.metrics.dropwizard.DropWizardMetricMaker.HistogramImpl c = cells.get ( key ) ; if ( c != null ) { return c ; } synchronized ( cells ) { c = cells.get ( key ) ; if ( c == null ) { c = metrics.newHistogramImpl ( submetric ( key ) ) ; cells.put ( key , c ) ; } return c ; } }
public com.google.common.collect.ImmutableList < com.google.gerrit.reviewdb.client.AccountGroup > all ( ) { try ( com.google.gerrit.reviewdb.server.ReviewDb db = schema.open ( ) ) { return groups.getAll ( db ) ; } catch ( com.google.gwtorm.server.OrmException e ) { com.google.gerrit.server.account.GroupCacheImpl.log.warn ( "Cannot list internal groups" , e ) ; return com.google.common.collect.ImmutableList.of ( ) ; } }
public void testItsAssociationPolicyMandatory ( ) { com.googlesource.gerrit.plugins.hooks.its.ItsConfig itsConfig = createItsConfig ( ) ; org.easymock.EasyMock.expect ( serverConfig.getString ( "ItsTestName" , null , "commentlink" ) ) . andReturn ( null ) . atLeastOnce ( ) ; org.easymock.EasyMock.expect ( serverConfig.getEnum ( "commentlink" , "ItsTestName" , "association" , ItsAssociationPolicy.OPTIONAL ) ) . andReturn ( ItsAssociationPolicy.MANDATORY ) . atLeastOnce ( ) ; replayMocks ( ) ; assertEquals ( "Expected and generated associated policy do not match" , ItsAssociationPolicy.MANDATORY , itsConfig.getItsAssociationPolicy ( ) ) ; }
public void writeToConfig ( org.eclipse.jgit.lib.Config c ) { java.lang.String externalIdKey = key ( ) . get ( ) ; c.setInt ( com.google.gerrit.server.account.externalids.ExternalId.EXTERNAL_ID_SECTION , externalIdKey , com.google.gerrit.server.account.externalids.ExternalId.ACCOUNT_ID_KEY , accountId ( ) . get ( ) ) ; if ( ( email ( ) ) != null ) { c.setString ( com.google.gerrit.server.account.externalids.ExternalId.EXTERNAL_ID_SECTION , externalIdKey , com.google.gerrit.server.account.externalids.ExternalId.EMAIL_KEY , email ( ) ) ; } if ( ( password ( ) ) != null ) { c.setString ( com.google.gerrit.server.account.externalids.ExternalId.EXTERNAL_ID_SECTION , externalIdKey , com.google.gerrit.server.account.externalids.ExternalId.PASSWORD_KEY , password ( ) ) ; } }
private void registerCmEvents ( final net.codemirror.lib.CodeMirror cm ) { cm.on ( "beforeSelectionChange" , onSelectionChange ( cm ) ) ; cm.on ( "cursorActivity" , updateActiveLine ( cm ) ) ; cm.on ( "gutterClick" , onGutterClick ( cm ) ) ; cm.on ( "focus" , updateActiveLine ( cm ) ) ; }
public com.google.gitiles.GitilesView.Builder setPathPart ( java.lang.String path ) { switch ( type ) { case PATH : case DIFF : this . path = com.google.gitiles.GitilesView.maybeTrimLeadingAndTrailingSlash ( com.google.common.base.Preconditions.checkNotNull ( path ) ) ; break ; case DESCRIBE : case REFS : case LOG : this . path = ( path != null ) ? com.google.gitiles.GitilesView.maybeTrimLeadingAndTrailingSlash ( path ) : null ; break ; default : com.google.common.base.Preconditions.checkState ( ( path == null ) , "cannot set path on %s view" , type ) ; this . path = path ; break ; } return this ; }
protected void insert ( final int row , final com.google.gerrit.client.dashboards.DashboardInfo k ) { table.insertRow ( row ) ; applyDataRowStyle ( row ) ; final com.google.gwt.user.client.ui.FlexTable.FlexCellFormatter fmt = table.getFlexCellFormatter ( ) ; fmt.addStyleName ( row , 1 , Gerrit.RESOURCES.css ( ) . dataCell ( ) ) ; fmt.addStyleName ( row , 2 , Gerrit.RESOURCES.css ( ) . dataCell ( ) ) ; populate ( row , k ) ; }
public void revokedKeyDueToCompromise ( ) throws java.lang.Exception { com.google.gerrit.gpg.testutil.TestKey k = add ( com.google.gerrit.gpg.testutil.TestKeys.revokedCompromisedKey ( ) ) ; add ( com.google.gerrit.gpg.testutil.TestKeys.validKeyWithoutExpiration ( ) ) ; save ( ) ; assertProblems ( k , ( "Key is revoked (key material has been compromised):" + " test6 compromised" ) ) ; org.bouncycastle.openpgp.PGPPublicKeyRing kr = removeRevokers ( k.getPublicKeyRing ( ) ) ; store.add ( kr ) ; save ( ) ; assertNoProblems ( kr.getPublicKey ( ) ) ; }
private static org.eclipse.jgit.util.TemporaryBuffer.Heap compress ( com.google.gerrit.extensions.restapi.BinaryResult bin ) throws java.io.IOException { org.eclipse.jgit.util.TemporaryBuffer.Heap buf = com.google.gerrit.httpd.restapi.RestApiServlet.heap ( ( 20 << 20 ) ) ; java.util.zip.GZIPOutputStream gz = new java.util.zip.GZIPOutputStream ( buf ) ; bin.writeTo ( gz ) ; gz.finish ( ) ; gz.flush ( ) ; return buf ; }
public boolean canSubmit ( ) { return getRefControl ( ) . canSubmit ( isOwner ( ) ) ; }
private static void updateHeadLocally ( org.eclipse.jgit.transport.URIish uri , java.lang.String newHead ) { try { org.eclipse.jgit.lib.Repository repo = new org.eclipse.jgit.internal.storage.file.FileRepository ( uri.getPath ( ) ) ; try { if ( newHead != null ) { org.eclipse.jgit.lib.RefUpdate u = repo.updateRef ( Constants.HEAD ) ; u.link ( newHead ) ; } } finally { repo.close ( ) ; } } catch ( java.io.IOException e ) { com.googlesource.gerrit.plugins.replication.ReplicationQueue.log.error ( java.lang.String.format ( "Failed to update HEAD of repository %s to %s" , uri.getPath ( ) , newHead ) , e ) ; } }
public void onFailure ( final java.lang.Throwable caught ) { text.setReadOnly ( false ) ; save.setEnabled ( true ) ; cancel.setEnabled ( true ) ; discard.setEnabled ( true ) ; super . onFailure ( caught ) ; }
public void tearDown ( ) { if ( ( repo ) != null ) { repo.getRepository ( ) . close ( ) ; } if ( ( lifecycle ) != null ) { lifecycle.stop ( ) ; } if ( ( db ) != null ) { db.close ( ) ; } com.google.gerrit.testutil.InMemoryDatabase.drop ( schemaFactory ) ; }
boolean filterMatch ( java.lang.String filter , com.google.gerrit.server.query.change.ChangeData changeData ) throws com.google.gerrit.server.query.QueryParseException , com.google.gwtorm.server.OrmException { com.google.common.base.Preconditions.checkNotNull ( filter ) ; com.google.gerrit.server.query.change.ChangeQueryBuilder qb = queryBuilder.asUser ( user.get ( ) ) ; com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > filterPredicate = qb.parse ( filter ) ; return filterPredicate.asMatchable ( ) . match ( changeData ) ; }
private PushOneCommit.Result createChange ( org.eclipse.jgit.api.Git git , boolean conflicting ) throws java.io.IOException , org.eclipse.jgit.api.errors.GitAPIException { com.google.gerrit.acceptance.GitUtil.checkout ( git , "origin/master" ) ; java.lang.String file = ( conflicting ) ? "test.txt" : ( "test-" + ( count ) ) + ".txt" ; com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create ( db , admin.getIdent ( ) , git , ( "Change " + ( count ) ) , file , ( "content " + ( count ) ) ) ; ( count ) ++ ; return push.to ( "refs/for/master" ) ; }
public void setUp ( ) { java.lang.String tz = "US/Eastern" ; systemTimeZoneProperty = java.lang.System.setProperty ( "user.timezone" , tz ) ; systemTimeZone = java.util.TimeZone.getDefault ( ) ; java.util.TimeZone.setDefault ( java.util.TimeZone.getTimeZone ( tz ) ) ; com.google.gerrit.testutil.TestTimeUtil.resetWithClockStep ( 1 , java.util.concurrent.TimeUnit.SECONDS ) ; project = new com.google.gerrit.reviewdb.client.Project.NameKey ( "project" ) ; accountId = new com.google.gerrit.reviewdb.client.Account.Id ( 100 ) ; }
public void onSuccess ( final com.google.gerrit.reviewdb.Account result ) { if ( com.google.gerrit.client.Gerrit.isSignedIn ( ) ) { com.google.gerrit.client.Gerrit.getUserAccount ( ) . setSshUserName ( result.getSshUserName ( ) ) ; } userNameTxt.setText ( result.getSshUserName ( ) ) ; userNameTxt.setEnabled ( true ) ; }
private java.util.List < com.google.gerrit.reviewdb.client.Project > getChildren ( final com.google.gerrit.reviewdb.client.Project.NameKey parentName ) { final java.util.List < com.google.gerrit.reviewdb.client.Project > childProjects = new java.util.ArrayList < com.google.gerrit.reviewdb.client.Project > ( ) ; for ( final com.google.gerrit.reviewdb.client.Project.NameKey projectName : projectCache.all ( ) ) { final com.google.gerrit.server.project.ProjectState e = projectCache.get ( projectName ) ; if ( e == null ) { continue ; } if ( parentName.equals ( e.getProject ( ) . getParent ( projectName ) ) ) { childProjects.add ( e.getProject ( ) ) ; } } return childProjects ; }
public void testlinkifyMessageUrl ( ) throws java.lang.Exception { com.google.gitiles.Linkifier l = new com.google.gitiles.Linkifier ( TestGitilesUrls.URLS ) ; assertEquals ( com.google.common.collect.ImmutableList.of ( com.google.common.collect.ImmutableMap.of ( "text" , "http://my/url" , "url" , "http://my/url" ) ) , l.linkify ( com.google.gitiles.LinkifierTest.REQ , "http://my/url" ) ) ; assertEquals ( com.google.common.collect.ImmutableList.of ( com.google.common.collect.ImmutableMap.of ( "text" , "https://my/url" , "url" , "https://my/url" ) ) , l.linkify ( com.google.gitiles.LinkifierTest.REQ , "https://my/url" ) ) ; assertEquals ( com.google.common.collect.ImmutableList.of ( com.google.common.collect.ImmutableMap.of ( "text" , "foo " ) , com.google.common.collect.ImmutableMap.of ( "text" , "http://my/url" , "url" , "http://my/url" ) , com.google.common.collect.ImmutableMap.of ( "text" , " bar" ) ) , l.linkify ( com.google.gitiles.LinkifierTest.REQ , "foo http://my/url bar" ) ) ; assertEquals ( com.google.common.collect.ImmutableList.of ( com.google.common.collect.ImmutableMap.of ( "text" , "foo " ) , com.google.common.collect.ImmutableMap.of ( "text" , "http://my/url" , "url" , "http://my/url" ) , com.google.common.collect.ImmutableMap.of ( "text" , " bar " ) , com.google.common.collect.ImmutableMap.of ( "text" , "http://my/other/url" , "url" , "http://my/other/url" ) , com.google.common.collect.ImmutableMap.of ( "text" , " baz" ) ) , l.linkify ( com.google.gitiles.LinkifierTest.REQ , "foo http://my/url bar http://my/other/url baz" ) ) ; }
public void description ( java.lang.String description ) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.change.PutDescription.Input in = new com.google.gerrit.server.change.PutDescription.Input ( ) ; in.description = description ; try { putDescription.apply ( revision , in ) ; } catch ( com.google.gerrit.server.git.UpdateException e ) { throw new com.google.gerrit.extensions.restapi.RestApiException ( "Cannot set description" , e ) ; } }
public void onResize ( com.google.gwt.event.logical.shared.ResizeEvent event ) { if ( ( cmA ) != null ) { cmA.setHeight ( ( ( event.getHeight ( ) ) - ( com.google.gerrit.client.diff.SideBySide2.HEADER_FOOTER ) ) ) ; cmA.refresh ( ) ; } if ( ( cmB ) != null ) { cmB.setHeight ( ( ( event.getHeight ( ) ) - ( com.google.gerrit.client.diff.SideBySide2.HEADER_FOOTER ) ) ) ; cmB.refresh ( ) ; } }
protected void configure ( ) { com.google.gerrit.extensions.registration.DynamicSet.bind ( binder ( ) , com.google.gerrit.extensions.events.GitReferenceUpdatedListener.class ) . to ( com.googlesource.gerrit.plugins.repositoryuse.RefUpdateHandler.class ) ; requestStaticInjection ( com.googlesource.gerrit.plugins.repositoryuse.Config.class ) ; requestStaticInjection ( Ref.Table.class ) ; requestStaticInjection ( Usage.Table.class ) ; }
public com.google.gerrit.extensions.restapi.Response < com.google.gerrit.extensions.common.SshKeyInfo > apply ( com.google.gerrit.server.account.AccountResource rsrc , com.google.gerrit.server.account.AddSshKey.Input input ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.extensions.restapi.BadRequestException , com.google.gerrit.server.permissions.PermissionBackendException , com.google.gwtorm.server.OrmException , java.io.IOException , org.eclipse.jgit.errors.ConfigInvalidException { if ( ( self.get ( ) ) != ( rsrc.getUser ( ) ) ) { permissionBackend.user ( self ) . check ( GlobalPermission.ADMINISTRATE_SERVER ) ; } return apply ( rsrc.getUser ( ) , input ) ; }
void setDiffPrefs ( final com.google.gerrit.reviewdb.client.AccountDiffPreference dp ) { diffPrefs = dp ; context = diffPrefs.getContext ( ) ; if ( ( context ) == ( com.google.gerrit.reviewdb.client.AccountDiffPreference.WHOLE_FILE_CONTEXT ) ) { context = com.google.gerrit.server.patch.PatchScriptBuilder.MAX_CONTEXT ; } else if ( ( context ) > ( com.google.gerrit.server.patch.PatchScriptBuilder.MAX_CONTEXT ) ) { context = com.google.gerrit.server.patch.PatchScriptBuilder.MAX_CONTEXT ; } }
public void deleteBranchesNotFound ( ) throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DeleteBranchesInput input = new com.google.gerrit.extensions.api.projects.DeleteBranchesInput ( ) ; java.util.List < java.lang.String > branches = com.google.common.collect.Lists.newArrayList ( com.google.gerrit.acceptance.rest.project.DeleteBranchesIT.BRANCHES ) ; branches.add ( "refs/heads/does-not-exist" ) ; input.branches = branches ; try { project ( ) . deleteBranches ( input ) ; org.junit.Assert.fail ( "Expected ResourceConflictException" ) ; } catch ( com.google.gerrit.extensions.restapi.ResourceConflictException e ) { com.google.common.truth.Truth.assertThat ( e ) . hasMessage ( errorMessageForBranches ( com.google.common.collect.ImmutableList.of ( "refs/heads/does-not-exist" ) ) ) ; } assertBranchesDeleted ( ) ; }
private void setNew ( com.google.gerrit.reviewdb.Change c , com.google.gerrit.reviewdb.ChangeMessage msg ) { sendMergeFail ( c , msg , true , true ) ; }
static com.google.gerrit.acceptance.GerritServer.Description forTestClass ( com.google.gerrit.acceptance.Description testDesc , java.lang.String configName ) { return new com.google.gerrit.acceptance.AutoValue_GerritServer_Description ( configName , true , ( ( testDesc.getTestClass ( ) . getAnnotation ( com.google.gerrit.acceptance.NoHttpd.class ) ) == null ) , null , null ) ; }
void onChangeRevision ( @ java.lang.SuppressWarnings ( value = "unused" ) com.google.gwt.event.dom.client.ChangeEvent e ) { int idx = diffBase.getSelectedIndex ( ) ; if ( 0 <= idx ) { java.lang.String n = diffBase.getValue ( idx ) ; loadConfigInfo ( changeInfo , ( ! ( n.isEmpty ( ) ) ? n : null ) ) ; } }
private void setupCommonMocks ( ) { org.easymock.EasyMock.expect ( itsConfig.getIssuePattern ( ) ) . andReturn ( java.util.regex.Pattern.compile ( "bug#(\\d+)" ) ) . anyTimes ( ) ; org.easymock.EasyMock.expect ( itsConfig.isEnabled ( "myProject" , null ) ) . andReturn ( true ) . anyTimes ( ) ; }
public static int findApproval ( com.googlecode.prolog_cafe.lang.Prolog engine , int minVoteLevel ) { try { com.google.gerrit.server.account.AccountCache accountCache = StoredValues.ACCOUNT_CACHE.get ( engine ) ; com.google.gerrit.server.query.change.ChangeData changeData = StoredValues.CHANGE_DATA.get ( engine ) ; org.eclipse.jgit.lib.Repository repository = StoredValues.REPOSITORY.get ( engine ) ; return new com.googlesource.gerrit.plugins.findowners.Checker ( repository , changeData , minVoteLevel ) . findApproval ( accountCache ) ; } catch ( com.google.gwtorm.server.OrmException e ) { com.googlesource.gerrit.plugins.findowners.Checker.log.error ( "Exception" , e ) ; return 0 ; } }
private javax.net.ssl.SSLContext buildSslContext ( ) { try { javax.net.ssl.TrustManager [ ] trustAllCerts = new javax.net.ssl.TrustManager [ ] { new com.ericsson.gerrit.plugins.syncindex.HttpClientProvider.DummyX509TrustManager ( ) } ; javax.net.ssl.SSLContext context = javax.net.ssl.SSLContext.getInstance ( "TLS" ) ; context.init ( null , trustAllCerts , null ) ; return context ; } catch ( java.security.KeyManagementException | java.security.NoSuchAlgorithmException e ) { com.ericsson.gerrit.plugins.syncindex.HttpClientProvider.log.warn ( "Error building SSLContext object" , e ) ; return null ; } }
private boolean hasOneParent ( com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId ) { try { return ( dbProvider.get ( ) . patchSetAncestors ( ) . ancestorsOf ( patchSetId ) . toList ( ) . size ( ) ) == 1 ; } catch ( com.google.gwtorm.server.OrmException e ) { com.google.gerrit.server.change.Rebase.log.error ( ( "Failed to get ancestors of patch set " + ( patchSetId.toRefName ( ) ) ) , e ) ; return false ; } }
protected void parseCommandLine ( ) throws com.google.gerrit.sshd.commands.UnloggedFailure { processor.setOutput ( out , QueryProcessor.OutputFormat.TEXT ) ; super . parseCommandLine ( ) ; if ( ( processor.getIncludeFiles ( ) ) && ( ! ( ( processor.getIncludePatchSets ( ) ) || ( processor.getIncludeCurrentPatchSet ( ) ) ) ) ) { throw new com.google.gerrit.sshd.commands.UnloggedFailure ( 1 , "--files option needs --patch-sets or --current-patch-set" ) ; } }
protected void configure ( ) { factory ( ReviewerResource.Factory.class ) ; factory ( AccountInfo.Loader.Factory.class ) ; factory ( EmailReviewComments.Factory.class ) ; factory ( ChangeInserter.Factory.class ) ; factory ( PatchSetInserter.Factory.class ) ; factory ( ListChangeEdits.Factory.class ) ; }
private void addEmail ( java.lang.String email ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.sshd.commands.UnloggedFailure , com.google.gwtorm.server.OrmException { com.google.gerrit.server.account.CreateEmail.Input in = new com.google.gerrit.server.account.CreateEmail.Input ( ) ; in.email = email ; in.noConfirmation = true ; try { createEmailFactory.create ( email ) . apply ( rsrc , in ) ; } catch ( com.google.gerrit.common.errors.EmailException e ) { throw die ( e.getMessage ( ) ) ; } }
protected void configure ( ) { factory ( ChangeDetailFactory.Factory.class ) ; factory ( PatchSetDetailFactory.Factory.class ) ; factory ( PatchSetPublishDetailFactory.Factory.class ) ; }
public void onFailure ( final java.lang.Throwable caught ) { text.setReadOnly ( false ) ; save.setEnabled ( true ) ; cancel.setEnabled ( true ) ; discard.setEnabled ( true ) ; super . onFailure ( caught ) ; onSave.onFailure ( caught ) ; }
public void onClick ( com.google.gwt.event.dom.client.ClickEvent event ) { final com.google.gwt.user.client.ui.HTMLTable.Cell cell = table.getCellForEvent ( event ) ; if ( cell != null ) { switch ( cell.getCellIndex ( ) ) { case 1 : case 3 : break ; default : if ( ( getRowItem ( cell.getRowIndex ( ) ) ) != null ) { movePointerTo ( cell.getRowIndex ( ) ) ; } break ; } } }
private static com.google.gerrit.server.account.AccountState missing ( com.google.gerrit.reviewdb.client.Account.Id accountId ) { com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account ( accountId , com.google.gerrit.server.util.TimeUtil.nowTs ( ) ) ; java.util.Collection < com.google.gerrit.reviewdb.client.AccountExternalId > ids = java.util.Collections.emptySet ( ) ; java.util.Set < com.google.gerrit.reviewdb.client.AccountGroup.UUID > anon = com.google.common.collect.ImmutableSet.of ( ) ; return new com.google.gerrit.server.account.AccountState ( account , anon , ids ) ; }
private boolean getInheritableBoolean ( java.util.function.Function < com.google.gerrit.reviewdb.client.Project , com.google.gerrit.extensions.client.InheritableBoolean > func ) { for ( com.google.gerrit.server.project.ProjectState s : tree ( ) ) { switch ( func.apply ( s.getProject ( ) ) ) { case TRUE : return true ; case FALSE : return false ; case INHERIT : default : continue ; } } return false ; }
public void testVerifyAgainstDifferentObjectId ( ) throws java.lang.Exception { java.lang.String token = auth.generateToken ( "o" , org.eclipse.jgit.lfs.lib.LongObjectId.zeroId ( ) , 1 ) ; com.google.common.truth.Truth.assertThat ( auth.verifyAgainstToken ( token , "o" , org.eclipse.jgit.lfs.lib.LongObjectId.fromString ( ( "123456789012345678901234567890" + ( "123456789012345678901234567890" + "1234" ) ) ) ) ) . isFalse ( ) ; }
public SiteIndexer.Result indexAll ( final com.google.gerrit.server.index.project.ProjectIndex index ) { org.eclipse.jgit.lib.ProgressMonitor progress = new org.eclipse.jgit.lib.TextProgressMonitor ( new java.io.PrintWriter ( progressOut ) ) ; progress.start ( 2 ) ; java.util.List < com.google.gerrit.reviewdb.client.Project.NameKey > names = collectProjects ( progress ) ; return reindexProjects ( index , names , progress ) ; }
public void testBulletList4 ( ) { final com.google.gwtexpui.safehtml.client.SafeHtml o = com.google.gwtexpui.safehtml.client.SafeHtml_WikifyListTest.html ( ( "To see this bug, you have to:\n" + ( "* Be on IMAP or EAS (not on POP)\n" + "* Be very unlucky\n" ) ) ) ; final com.google.gwtexpui.safehtml.client.SafeHtml n = o.wikify ( ) ; org.junit.Assert.assertNotSame ( o , n ) ; org.junit.Assert.assertEquals ( ( ( ( ( "<p>To see this bug, you have to:</p>" + ( com.google.gwtexpui.safehtml.client.SafeHtml_WikifyListTest.BEGIN_LIST ) ) + ( com.google.gwtexpui.safehtml.client.SafeHtml_WikifyListTest.item ( "Be on IMAP or EAS (not on POP)" ) ) ) + ( com.google.gwtexpui.safehtml.client.SafeHtml_WikifyListTest.item ( "Be very unlucky" ) ) ) + ( com.google.gwtexpui.safehtml.client.SafeHtml_WikifyListTest.END_LIST ) ) , n.asString ( ) ) ; }
private static com.google.protobuf.ByteString deflate ( final byte [ ] buf ) { final com.google.protobuf.ByteString.Output r = com.google.protobuf.ByteString.newOutput ( ) ; final java.util.zip.DeflaterOutputStream out = new java.util.zip.DeflaterOutputStream ( r ) ; try { out.write ( buf ) ; out.close ( ) ; } catch ( java.io.IOException err ) { throw new com.google.codereview.manager.StopProcessingException ( "Unexpected IO error" , err ) ; } return r.toByteString ( ) ; }
private static boolean onSupportedJavaVersion ( ) { final java.lang.String version = java.lang.System.getProperty ( "java.specification.version" ) ; if ( 1.7 <= ( Main.parse ( version ) ) ) { return true ; } else { java.lang.System.err.println ( "fatal: Gerrit Code Review requires Java 7 or later" ) ; java.lang.System.err.println ( ( ( " (trying to run on Java " + version ) + ")" ) ) ; return false ; } }
public WorkQueue.Executor get ( ) { final com.google.gerrit.server.git.WorkQueue.Executor executor ; executor = queues.createQueue ( poolSize , "SSH-Stream-Worker" ) ; final java.util.concurrent.ThreadFactory parent = executor.getThreadFactory ( ) ; executor.setThreadFactory ( new java.util.concurrent.ThreadFactory ( ) { @ java.lang.Override public java.lang.Thread newThread ( final java.lang.Runnable task ) { final java.lang.Thread t = parent.newThread ( task ) ; t.setPriority ( java.lang.Thread.MIN_PRIORITY ) ; return t ; } } ) ; return executor ; }
private java.lang.String getGerritHost ( ) { if ( ( getGerritUrl ( ) ) != null ) { try { return new java.net.URL ( getGerritUrl ( ) ) . getHost ( ) ; } catch ( java.net.MalformedURLException e ) { } } try { return java.net.InetAddress.getLocalHost ( ) . getCanonicalHostName ( ) ; } catch ( java.net.UnknownHostException e ) { return "localhost" ; } }
private static java.util.Set < com.google.gerrit.reviewdb.client.Account.Id > getReviewers ( com.google.gerrit.extensions.common.ChangeInfo ci ) { java.util.Set < com.google.gerrit.reviewdb.client.Account.Id > result = com.google.common.collect.Sets.newHashSet ( ) ; for ( com.google.gerrit.extensions.common.LabelInfo li : ci.labels.values ( ) ) { for ( com.google.gerrit.extensions.common.ApprovalInfo ai : li.all ) { result.add ( new com.google.gerrit.reviewdb.client.Account.Id ( ai._accountId ) ) ; } } return result ; }
protected void configure ( ) { bind ( com.google.gerrit.acceptance.AccountCreator.class ) ; factory ( PushOneCommit.Factory.class ) ; }
private void setUp ( ) { try { getEventsDb ( ) . createDBIfNotCreated ( ) ; } catch ( java.sql.SQLException e ) { com.ericsson.gerrit.plugins.eventslog.sql.SQLStore.log.warn ( ( "Cannot start the database. Events will be stored locally " + "until database connection can be established" ) , e ) ; setOnline ( false ) ; } if ( online ) { restoreEventsFromLocal ( ) ; } removeOldEvents ( ) ; }
protected void configure ( ) { factory ( AbandonChangeHandler.Factory.class ) ; factory ( RestoreChange.Factory.class ) ; factory ( RevertChange.Factory.class ) ; factory ( ChangeDetailFactory.Factory.class ) ; factory ( IncludedInDetailFactory.Factory.class ) ; factory ( PatchSetDetailFactory.Factory.class ) ; factory ( PatchSetPublishDetailFactory.Factory.class ) ; factory ( SubmitAction.Factory.class ) ; factory ( PublishAction.Factory.class ) ; factory ( DeleteDraftChange.Factory.class ) ; }
protected void configure ( ) { final com.google.gerrit.sshd.CommandName gerrit = com.google.gerrit.sshd.Commands.named ( "gerrit" ) ; command ( gerrit , "approve" ) . to ( com.google.gerrit.sshd.commands.ErrorSlaveMode.class ) ; command ( gerrit , "create-project" ) . to ( com.google.gerrit.sshd.commands.ErrorSlaveMode.class ) ; command ( gerrit , "receive-pack" ) . to ( com.google.gerrit.sshd.commands.ErrorSlaveMode.class ) ; command ( gerrit , "replicate" ) . to ( com.google.gerrit.sshd.commands.ErrorSlaveMode.class ) ; }
public void isEnabledForRegexRef ( ) throws java.lang.Exception { com.googlesource.gerrit.plugins.uploadvalidator.ValidatorConfig config = getConfig ( ( "[plugin \"uploadvalidator\"]\n" + ( " ref = ^refs/heads/mybranch.*\n" + " blockedFileExtension = jar" ) ) ) ; assertThat ( config.isEnabledForRef ( projectName , "refs/heads/anotherref" ) ) . isFalse ( ) ; assertThat ( config.isEnabledForRef ( projectName , "refs/heads/mybranch123" ) ) . isTrue ( ) ; }
private void insertEmptyLines ( net.codemirror.lib.CodeMirror cm , int line , int cnt ) { com.google.gwt.dom.client.Element div = com.google.gwt.user.client.DOM.createDiv ( ) ; div.setClassName ( diffTable.style.padding ( ) ) ; div.getStyle ( ) . setHeight ( cnt , Unit.EM ) ; net.codemirror.lib.Configuration config = net.codemirror.lib.Configuration.create ( ) . set ( "coverGutter" , true ) . set ( "above" , ( line == 0 ) ) ; cm.addLineWidget ( ( line == 0 ? 0 : line - 1 ) , div , config ) ; }
private static java.util.List < java.lang.String > parseChangeTableColumns ( org.eclipse.jgit.lib.Config cfg , @ com.google.gerrit.common.Nullable org.eclipse.jgit.lib.Config defaultCfg ) { java.util.List < java.lang.String > changeTable = com.google.gerrit.server.account.PreferencesConfig.changeTable ( cfg ) ; if ( ( changeTable == null ) && ( defaultCfg != null ) ) { changeTable = com.google.gerrit.server.account.PreferencesConfig.changeTable ( defaultCfg ) ; } return changeTable ; }
public void testUsernamePatternWithRegex ( ) { com.google.gerrit.server.project.Util.allow ( local , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.project.Util.DEVS , "^refs/sb/${username}/heads/.*" ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , "d.v" , com.google.gerrit.server.project.Util.DEVS ) ; com.google.gerrit.server.project.ProjectControl d = util.user ( local , "dev" , com.google.gerrit.server.project.Util.DEVS ) ; org.junit.Assert.assertFalse ( "u can't read" , u.controlForRef ( "refs/sb/dev/heads/foobar" ) . isVisible ( ) ) ; org.junit.Assert.assertTrue ( "d can read" , d.controlForRef ( "refs/sb/dev/heads/foobar" ) . isVisible ( ) ) ; }
private java.lang.String buildText ( java.lang.String pathAndQuery , java.lang.String expectedMode ) throws java.lang.Exception { com.google.gitiles.TestViewFilter.Result res = service ( pathAndQuery ) ; org.junit.Assert.assertNull ( res.getResponse ( ) . getHeader ( com.google.common.net.HttpHeaders.CONTENT_TYPE ) ) ; org.junit.Assert.assertEquals ( expectedMode , res.getResponse ( ) . getHeader ( PathServlet.MODE_HEADER ) ) ; return res.getResponse ( ) . getActualBodyString ( ) ; }
private java.lang.String newChange2 ( org.eclipse.jgit.api.Git git , org.eclipse.jgit.lib.PersonIdent ident ) throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create ( db , ident , PushOneCommit.SUBJECT , com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME , com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_OLD ) ; return push.rm ( git , "refs/for/master" ) . getChangeId ( ) ; }
public void defaultGroupsCreated_ssh ( ) throws java.lang.Exception { com.google.gerrit.acceptance.SshSession session = new com.google.gerrit.acceptance.SshSession ( server , admin ) ; java.lang.String result = session.exec ( "gerrit ls-groups" ) ; org.junit.Assert.assertFalse ( session.getError ( ) , session.hasError ( ) ) ; org.junit.Assert.assertTrue ( result.contains ( "Administrators" ) ) ; org.junit.Assert.assertTrue ( result.contains ( "Non-Interactive Users" ) ) ; session.close ( ) ; }
private com.google.gerrit.server.project.ChangeControl controlFor ( com.google.gerrit.server.change.RevisionResource rsrc , com.google.gerrit.reviewdb.client.Change.Id id ) throws com.google.gwtorm.server.OrmException { if ( rsrc.getChange ( ) . getId ( ) . equals ( id ) ) { return rsrc.getControl ( ) ; } com.google.gerrit.reviewdb.client.Change c = dbProvider.get ( ) . changes ( ) . get ( id ) ; if ( c == null ) { return null ; } return rsrc.getControl ( ) . getProjectControl ( ) . controlFor ( c ) ; }
public void addReviewer ( ) throws com.google.gerrit.extensions.restapi.RestApiException , java.io.IOException , org.eclipse.jgit.api.errors.GitAPIException { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange ( ) ; com.google.gerrit.extensions.api.changes.AddReviewerInput in = new com.google.gerrit.extensions.api.changes.AddReviewerInput ( ) ; in.reviewer = user.email ; gApi.changes ( ) . id ( ( "p~master~" + ( r.getChangeId ( ) ) ) ) . addReviewer ( in ) ; }
public void testUnblockInLocalVisibilityByRegisteredUsers_Fails ( ) { com.google.gerrit.server.project.Util.grant ( util.getParentConfig ( ) , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.project.Util.ANONYMOUS , "refs/heads/*" ) . setBlock ( ) ; com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.project.Util.REGISTERED , "refs/heads/*" ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.project.Util.REGISTERED ) ; assertFalse ( "u can't read" , u.controlForRef ( "refs/heads/master" ) . isVisibleByRegisteredUsers ( ) ) ; }
public void testBlockRule_ParentBlocksChildEvenIfAlreadyBlockedInChild ( ) { com.google.gerrit.server.project.Util.allow ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.Util.DEVS , "refs/tags/*" ) ; com.google.gerrit.server.project.Util.block ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/tags/*" ) ; com.google.gerrit.server.project.Util.block ( util.getParentConfig ( ) , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/tags/*" ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.project.Util.DEVS ) ; org.junit.Assert.assertFalse ( "u can't update tag" , u.controlForRef ( "refs/tags/V10" ) . canUpdate ( ) ) ; }
private java.util.Map < java.lang.String , com.google.gerrit.reviewdb.client.PatchLineComment > patchSetDrafts ( com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx ) throws com.google.gwtorm.server.OrmException { java.util.Map < java.lang.String , com.google.gerrit.reviewdb.client.PatchLineComment > drafts = com.google.common.collect.Maps.newHashMap ( ) ; for ( com.google.gerrit.reviewdb.client.PatchLineComment c : plcUtil.draftByPatchSetAuthor ( ctx.getDb ( ) , psId , user.getAccountId ( ) , ctx.getChangeNotes ( ) ) ) { drafts.put ( c.getKey ( ) . get ( ) , c ) ; } return drafts ; }
public void testGetMultiple ( ) throws java.lang.Exception { com.google.gerrit.gpg.testutil.TestKey key1 = com.google.gerrit.gpg.testutil.TestKey.key1 ( ) ; com.google.gerrit.gpg.testutil.TestKey key2 = com.google.gerrit.gpg.testutil.TestKey.key2 ( ) ; tr.branch ( RefNames.REFS_GPG_KEYS ) . commit ( ) . add ( com.google.gerrit.gpg.PublicKeyStore.keyObjectId ( key1.getKeyId ( ) ) . name ( ) , ( ( key1.getPublicKeyArmored ( ) ) + ( key2.getPublicKeyArmored ( ) ) ) ) . create ( ) ; assertKeys ( key1.getKeyId ( ) , key1 , key2 ) ; }
void onDiscard ( com.google.gwt.event.dom.client.ClickEvent e ) { e.stopPropagation ( ) ; if ( ( comment.id ( ) ) == null ) { removeUI ( ) ; } else { setEdit ( false ) ; com.google.gerrit.client.changes.CommentApi.deleteDraft ( psId , comment.id ( ) , new com.google.gerrit.client.rpc.GerritCallback < com.google.gwt.core.client.JavaScriptObject > ( ) { @ java.lang.Override public void onSuccess ( com.google.gwt.core.client.JavaScriptObject result ) { removeUI ( ) ; } } ) ; } }
public void setUp ( ) { java.lang.String tz = "US/Eastern" ; systemTimeZoneProperty = java.lang.System.setProperty ( "user.timezone" , tz ) ; systemTimeZone = java.util.TimeZone.getDefault ( ) ; java.util.TimeZone.setDefault ( java.util.TimeZone.getTimeZone ( tz ) ) ; com.google.gerrit.testutil.TestTimeUtil.resetWithClockStep ( 1 , java.util.concurrent.TimeUnit.SECONDS ) ; project = new com.google.gerrit.reviewdb.client.Project.NameKey ( "project" ) ; accountId = new com.google.gerrit.reviewdb.client.Account.Id ( 100 ) ; }
public void onSuccess ( com.googlesource.gerrit.plugins.verifystatus.client.ConfigInfo info ) { if ( info.showJobsPanel ( ) ) { com.google.gerrit.plugin.client.Plugin.get ( ) . panel ( GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK , new com.googlesource.gerrit.plugins.verifystatus.client.JobsPanel.Factory ( ) ) ; } if ( info.showJobsDropDownPanel ( ) ) { com.google.gerrit.plugin.client.Plugin.get ( ) . panel ( GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS , new com.googlesource.gerrit.plugins.verifystatus.client.JobsDropDownPanel.Factory ( ) ) ; } }
public static java.lang.String refsUsers ( com.google.gerrit.reviewdb.client.Account.Id accountId ) { java.lang.StringBuilder r = new java.lang.StringBuilder ( ) ; r.append ( com.google.gerrit.reviewdb.client.RefNames.REFS_USERS ) ; int account = accountId.get ( ) ; int m = account % 100 ; if ( m < 10 ) { r.append ( '0' ) ; } r.append ( m ) ; r.append ( '/' ) ; r.append ( account ) ; return r.toString ( ) ; }
public void testSubscriptionToEmptyRepo ( ) throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository < ? > superRepo = createProjectWithPush ( "super-project" ) ; org.eclipse.jgit.junit.TestRepository < ? > subRepo = createProjectWithPush ( "subscribed-to-project" ) ; allowSubmoduleSubscription ( "subscribed-to-project" , "refs/heads/master" , "super-project" , "refs/heads/master" ) ; createSubmoduleSubscription ( superRepo , "master" , "subscribed-to-project" , "master" ) ; pushChangeTo ( subRepo , "master" ) ; org.eclipse.jgit.lib.ObjectId subHEAD = pushChangeTo ( subRepo , "master" ) ; expectToHaveSubmoduleState ( superRepo , "master" , "subscribed-to-project" , subHEAD ) ; }
private static boolean isReviewer ( final org.eclipse.jgit.revwalk.FooterLine candidateFooterLine ) { return ( ( ( candidateFooterLine.matches ( FooterKey.SIGNED_OFF_BY ) ) || ( candidateFooterLine.matches ( FooterKey.ACKED_BY ) ) ) || ( candidateFooterLine.matches ( com.google.gerrit.server.mail.MailUtil.REVIEWED_BY ) ) ) || ( candidateFooterLine.matches ( com.google.gerrit.server.mail.MailUtil.TESTED_BY ) ) ; }
public static boolean isChild ( final com.google.gerrit.server.ssh.CommandName parent , final com.google.gerrit.server.ssh.CommandName name ) { if ( name instanceof com.google.gerrit.server.ssh.Commands.NestedCommandNameImpl ) { return parent.equals ( ( ( com.google.gerrit.server.ssh.Commands.NestedCommandNameImpl ) ( name ) ) . parent ) ; } if ( parent == ( com.google.gerrit.server.ssh.Commands.ROOT ) ) { return true ; } return false ; }
public boolean execute ( ) { other.setScrollSetByOther ( false ) ; return false ; }
private void assertProblems ( com.google.gerrit.gpg.PublicKeyChecker checker , com.google.gerrit.gpg.testutil.TestKey k , java.lang.String first , java.lang.String ... rest ) { com.google.gerrit.gpg.CheckResult result = checker.setStore ( store ) . check ( k.getPublicKey ( ) ) ; org.junit.Assert.assertEquals ( com.google.gerrit.gpg.PublicKeyCheckerTest.list ( first , rest ) , result.getProblems ( ) ) ; }
private static org.apache.lucene.store.Directory dir ( com.google.gerrit.server.index.Schema < com.google.gerrit.reviewdb.client.AccountGroup > schema , org.eclipse.jgit.lib.Config cfg , com.google.gerrit.server.config.SitePaths sitePaths ) throws java.io.IOException { if ( com.google.gerrit.lucene.LuceneIndexModule.isInMemoryTest ( cfg ) ) { return new org.apache.lucene.store.RAMDirectory ( ) ; } java.nio.file.Path indexDir = com.google.gerrit.lucene.LuceneVersionManager.getDir ( sitePaths , com.google.gerrit.lucene.LuceneGroupIndex.GROUPS , schema ) ; return org.apache.lucene.store.FSDirectory.open ( indexDir ) ; }
public void groupCannotBeRenamedWhenOldNameIsWrong ( ) throws java.lang.Exception { createGroup ( groupUuid , groupName ) ; com.google.gerrit.reviewdb.client.AccountGroup.NameKey anotherOldName = new com.google.gerrit.reviewdb.client.AccountGroup.NameKey ( "contributors" ) ; com.google.gerrit.reviewdb.client.AccountGroup.NameKey anotherName = new com.google.gerrit.reviewdb.client.AccountGroup.NameKey ( "admins" ) ; expectedException.expect ( org.eclipse.jgit.errors.ConfigInvalidException.class ) ; expectedException.expectMessage ( anotherOldName.get ( ) ) ; com.google.gerrit.server.group.db.GroupNameNotes.loadForRename ( repo , groupUuid , anotherOldName , anotherName ) ; }
public void onMouseMove ( com.google.gwt.event.dom.client.MouseMoveEvent event ) { resizePaddingWidget ( ) ; }
private com.google.gerrit.server.notedb.ChangeNotes createFromChangeOnlyWhenNotedbDisabled ( com.google.gerrit.reviewdb.client.Change change ) throws com.google.gwtorm.server.OrmException { com.google.common.base.Preconditions.checkState ( ( ! ( args.migration.readChanges ( ) ) ) , ( "do not call" + " createFromChangeWhenNotedbDisabled when notedb is enabled" ) ) ; return new com.google.gerrit.server.notedb.ChangeNotes ( args , change.getProject ( ) , change ) . load ( ) ; }
private void addDiffChunkAndPadding ( net.codemirror.lib.CodeMirror cmToPad , int lineToPad , int lineOnOther , int chunkSize , boolean edit ) { net.codemirror.lib.CodeMirror otherCm = otherCm ( cmToPad ) ; linePaddingOnOtherSideMap.put ( otherCm.getLineHandle ( lineOnOther ) , new com.google.gerrit.client.diff.PaddingManager.LinePaddingWidgetWrapper ( addPaddingWidget ( cmToPad , lineToPad , 0 , Unit.EM , null ) , lineToPad , chunkSize ) ) ; diffChunks.add ( new com.google.gerrit.client.diff.DiffChunkInfo ( getSideFromCm ( otherCm ) , ( ( lineOnOther - chunkSize ) + 1 ) , lineOnOther , edit ) ) ; }
private com.google.gerrit.extensions.common.CommentInfo addDraft ( java.lang.String changeId , java.lang.String revId , com.google.gerrit.extensions.api.changes.ReviewInput.CommentInput c ) throws java.io.IOException { com.google.gerrit.acceptance.RestResponse r = userSession.put ( ( ( ( ( "/changes/" + changeId ) + "/revisions/" ) + revId ) + "/drafts" ) , c ) ; com.google.common.truth.Truth.assertThat ( r.getStatusCode ( ) ) . isEqualTo ( HttpStatus.SC_CREATED ) ; return newGson ( ) . fromJson ( r.getReader ( ) , com.google.gerrit.extensions.common.CommentInfo.class ) ; }
public void validNewChange ( ) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = insertChange ( ) ; insertPatchSet ( c ) ; incrementPatchSet ( c ) ; insertPatchSet ( c ) ; assertProblems ( c ) ; }
public void markReady ( boolean ready ) throws java.io.IOException { org.eclipse.jgit.storage.file.FileBasedConfig cfg = new org.eclipse.jgit.storage.file.FileBasedConfig ( com.google.gerrit.solr.IndexVersionCheck.solrIndexConfig ( sitePaths ) , org.eclipse.jgit.util.FS.detect ( ) ) ; for ( java.util.Map.Entry < java.lang.String , java.lang.Integer > e : com.google.gerrit.solr.IndexVersionCheck.SCHEMA_VERSIONS.entrySet ( ) ) { cfg.setInt ( "index" , e.getKey ( ) , "schemaVersion" , ( ready ? e.getValue ( ) : - 1 ) ) ; } cfg.save ( ) ; }
private static java.lang.String format ( com.google.gerrit.server.git.WorkQueue.Task.State state ) { switch ( state ) { case DONE : return "....... done" ; case CANCELLED : return "..... killed" ; case RUNNING : return "" ; case READY : return "waiting ...." ; case SLEEPING : return "sleeping" ; default : return state.toString ( ) ; } }
protected void configureServlets ( ) { rpc ( com.google.gerrit.server.rpc.AccountServiceImpl.class ) ; rpc ( com.google.gerrit.server.rpc.AccountSecurityImpl.class ) ; rpc ( com.google.gerrit.server.rpc.GroupAdminServiceImpl.class ) ; rpc ( com.google.gerrit.server.rpc.ChangeListServiceImpl.class ) ; rpc ( com.google.gerrit.server.patch.PatchDetailServiceImpl.class ) ; rpc ( com.google.gerrit.server.rpc.ProjectAdminServiceImpl.class ) ; rpc ( com.google.gerrit.server.rpc.SuggestServiceImpl.class ) ; rpc ( com.google.gerrit.server.rpc.SystemInfoServiceImpl.class ) ; install ( new com.google.gerrit.server.rpc.changedetail.ChangeDetailModule ( ) ) ; }
public com.google.gerrit.server.notedb.ChangeNotes createChecked ( com.google.gerrit.reviewdb.server.ReviewDb db , com.google.gerrit.reviewdb.client.Project.NameKey project , com.google.gerrit.reviewdb.client.Change.Id changeId ) throws com.google.gerrit.server.project.NoSuchChangeException , com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change change = com.google.gerrit.reviewdb.server.ReviewDbUtil.unwrapDb ( db ) . changes ( ) . get ( changeId ) ; if ( ( change == null ) || ( ! ( change.getProject ( ) . equals ( project ) ) ) ) { throw new com.google.gerrit.server.project.NoSuchChangeException ( changeId ) ; } return new com.google.gerrit.server.notedb.ChangeNotes ( args , change ) . load ( ) ; }
public void createdOnIsPopulatedForGroupsCreatedBeforeAudit ( ) throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = createGroup ( "Ancient group for schema migration" ) ; setCreatedOnToVeryOldTimestamp ( groupId ) ; removeAuditEntriesFor ( groupId ) ; schema151.migrateData ( db , new com.google.gerrit.server.schema.Schema_150_to_151_Test.TestUpdateUI ( ) ) ; com.google.gerrit.reviewdb.client.AccountGroup group = db.accountGroups ( ) . get ( groupId ) ; com.google.common.truth.Truth.assertThat ( group.getCreatedOn ( ) ) . isEqualTo ( java.sql.Timestamp.from ( Schema_151.AUDIT_CREATION_INSTANT ) ) ; }
public void reviewId ( ) throws com.google.gerrit.extensions.restapi.RestApiException , java.io.IOException , org.eclipse.jgit.api.errors.GitAPIException { com.google.gerrit.acceptance.git.PushOneCommit.Result r = createChange ( ) ; gApi.changes ( ) . id ( r.getChangeId ( ) ) . revision ( r.getCommit ( ) . name ( ) ) . review ( com.google.gerrit.acceptance.api.revision.ReviewIT.makeReview ( ) ) ; }
public void onSuccess ( com.google.gerrit.client.diff.DiffInfo diffInfo ) { if ( ( id == ( reloadVersionId ) ) && ( isAttached ( ) ) ) { diff = diffInfo ; operation ( new java.lang.Runnable ( ) { @ java.lang.Override public void run ( ) { clearSkipBars ( ) ; clearMarkers ( ) ; diffTable.sidePanel.clearDiffGutters ( ) ; setShowIntraline ( prefs.intralineDifference ( ) ) ; render ( diff ) ; renderSkips ( prefs.context ( ) ) ; } } ) ; } }
public void suggestReviewersWithoutLimitOptionSpecified ( ) throws java.lang.Exception { java.lang.String changeId = createChange ( ) . getChangeId ( ) ; java.lang.String query = user3.fullName ; java.util.List < com.google.gerrit.extensions.common.SuggestedReviewerInfo > suggestedReviewerInfos = gApi.changes ( ) . id ( changeId ) . suggestReviewers ( query ) . get ( ) ; com.google.common.truth.Truth.assertThat ( suggestedReviewerInfos ) . hasSize ( 1 ) ; }
private void checkRemoveReviewer ( com.google.gerrit.server.notedb.ChangeNotes notes , com.google.gerrit.server.CurrentUser currentUser , com.google.gerrit.reviewdb.client.Account.Id reviewer , int val ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.server.permissions.PermissionBackendException , com.google.gerrit.server.project.NoSuchProjectException , java.io.IOException { if ( canRemoveReviewerWithoutPermissionCheck ( notes.getChange ( ) , currentUser , reviewer , val ) ) { return ; } permissionBackend.user ( currentUser ) . change ( notes ) . database ( dbProvider ) . check ( ChangePermission.REMOVE_REVIEWER ) ; }
public java.util.Collection < com.google.gerrit.client.reviewdb.ProjectRight > getProjectRights ( final com.google.gerrit.client.reviewdb.ApprovalCategory.Id id ) { if ( ( projectRights ) == null ) { projectRights = com.google.gerrit.server.workflow.FunctionState.index ( project.getRights ( ) ) ; } final java.util.Collection < com.google.gerrit.client.reviewdb.ProjectRight > l = projectRights.get ( id ) ; return l != null ? l : java.util.Collections.< com.google.gerrit.client.reviewdb.ProjectRight > emptySet ( ) ; }
public void defaultMessage ( ) throws com.google.gerrit.extensions.restapi.RestApiException , java.io.IOException , org.eclipse.jgit.api.errors.GitAPIException { java.lang.String changeId = createChange ( ) ; com.google.gerrit.extensions.common.ChangeInfo c = getChange ( ( "p~master~" + changeId ) , java.util.EnumSet.of ( com.google.gerrit.extensions.common.ListChangesOption.MESSAGES ) ) ; org.junit.Assert.assertNotNull ( c.messages ) ; org.junit.Assert.assertEquals ( 1 , c.messages.size ( ) ) ; org.junit.Assert.assertEquals ( "Uploaded patch set 1." , c.messages.iterator ( ) . next ( ) . message ) ; }
public static void createTableIfNotExists ( java.lang.String url ) throws com.google.gwtorm.server.OrmException { try ( java.sql.Connection con = java.sql.DriverManager.getConnection ( url ) ; java.sql.Statement stmt = con.createStatement ( ) ) { stmt.executeUpdate ( ( "CREATE TABLE IF NOT EXISTS ACCOUNT_PATCH_REVIEWS (" + ( ( ( ( ( ( "ACCOUNT_ID INTEGER DEFAULT 0 NOT NULL, " + "CHANGE_ID INTEGER DEFAULT 0 NOT NULL, " ) + "PATCH_SET_ID INTEGER DEFAULT 0 NOT NULL, " ) + "FILE_NAME VARCHAR(255) DEFAULT '' NOT NULL, " ) + "CONSTRAINT PRIMARY_KEY_ACCOUNT_PATCH_REVIEWS " ) + "PRIMARY KEY (ACCOUNT_ID, CHANGE_ID, PATCH_SET_ID, FILE_NAME)" ) + ")" ) ) ) ; } catch ( java.sql.SQLException e ) { throw com.google.gerrit.server.schema.H2AccountPatchReviewStore.convertError ( "create" , e ) ; } }
public void bothDateTime ( ) throws java.lang.Exception { java.util.Map < java.lang.String , java.lang.String > params = new java.util.HashMap < > ( ) ; params.put ( "t1" , "2013-10-10 10:00:00" ) ; params.put ( "t2" , "2014-10-10 10:00:00" ) ; java.lang.String query = com.ericsson.gerrit.plugins.eventslog.QueryMakerTest.queryMaker.formQueryFromRequestParameters ( params ) ; org.junit.Assert.assertFalse ( query.equals ( com.ericsson.gerrit.plugins.eventslog.QueryMakerTest.defaultQuery ) ) ; }
public void parseInvalidWatchConfig ( ) throws java.lang.Exception { org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config ( ) ; cfg.fromText ( ( "[project \"myProject\"]\n" + ( ( ( " notify = * [ALL_COMMENTS, NEW_PATCHSETS]\n" + " notify = branch:master [INVALID, NEW_CHANGES]\n" ) + "[project \"otherProject\"]\n" ) + " notify = [NEW_PATCHSETS]\n" ) ) ) ; com.google.gerrit.server.account.WatchConfig.parse ( new com.google.gerrit.reviewdb.client.Account.Id ( 1000000 ) , cfg , this ) ; com.google.common.truth.Truth.assertThat ( validationErrors ) . hasSize ( 1 ) ; com.google.common.truth.Truth.assertThat ( validationErrors.get ( 0 ) . getMessage ( ) ) . isEqualTo ( ( "watch.config: Invalid notify type INVALID in project watch of" + ( " account 1000000 for project myProject: branch:master" + " [INVALID, NEW_CHANGES]" ) ) ) ; }
private void executePostOps ( ) throws java.lang.Exception { com.google.gerrit.server.git.BatchUpdate.Context ctx = new com.google.gerrit.server.git.BatchUpdate.Context ( ) ; for ( com.google.gerrit.server.git.BatchUpdate.Op op : ops.values ( ) ) { op.postUpdate ( ctx ) ; } }
void onSave ( @ java.lang.SuppressWarnings ( value = "unused" ) com.google.gwt.event.dom.client.ClickEvent e ) { if ( cm.isClean ( generation ) ) { upToChange ( ) ; return ; } com.google.gerrit.client.changes.ChangeEditApi.put ( revision.getParentKey ( ) . get ( ) , path , cm.getValue ( ) , new com.google.gerrit.client.rpc.GerritCallback < com.google.gerrit.client.VoidResult > ( ) { @ java.lang.Override public void onSuccess ( com.google.gerrit.client.VoidResult result ) { upToChange ( ) ; } } ) ; }
public java.lang.String getSqlType ( final com.google.gwtorm.schema.ColumnModel col , final com.google.gwtorm.schema.sql.SqlDialect dialect ) { final com.google.gwtorm.client.Column column = col.getColumnAnnotation ( ) ; final java.lang.StringBuilder r = new java.lang.StringBuilder ( ) ; r.append ( dialect.getSqlTypeName ( getSqlTypeConstant ( ) ) ) ; if ( column.notNull ( ) ) { r.append ( " DEFAULT ''" ) ; r.append ( " NOT NULL" ) ; } return r.toString ( ) ; }
public void changeMessageWithTrailingDoubleNewline ( ) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange ( ) ; com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate ( c , changeOwner ) ; update.setChangeMessage ( ( "Testing trailing double newline\n" + "\n" ) ) ; update.commit ( ) ; assertBodyEquals ( ( "Update patch set 1\n" + ( ( ( ( ( "\n" + "Testing trailing double newline\n" ) + "\n" ) + "\n" ) + "\n" ) + "Patch-set: 1\n" ) ) , update.getRevision ( ) ) ; }
protected void add ( com.google.gerrit.server.mail.RecipientType type , com.google.gerrit.server.mail.ChangeEmail.Watchers.List list ) { for ( com.google.gerrit.reviewdb.client.Account.Id user : list.accounts ) { add ( type , user ) ; } for ( com.google.gerrit.server.mail.Address addr : list.emails ) { add ( type , addr ) ; } }
public static com.google.gerrit.extensions.events.LifecycleListener start ( final java.nio.file.Path sitePath ) throws java.io.IOException { java.nio.file.Path logdir = com.google.gerrit.common.FileUtil.mkdirsOrDie ( new com.google.gerrit.server.config.SitePaths ( sitePath ) . logs_dir , "Cannot create log directory" ) ; if ( com.google.gerrit.server.util.SystemLog.shouldConfigure ( ) ) { com.google.gerrit.pgm.util.ErrorLogFile.initLogSystem ( logdir ) ; } return new com.google.gerrit.extensions.events.LifecycleListener ( ) { @ java.lang.Override public void start ( ) { } @ java.lang.Override public void stop ( ) { org.apache.log4j.LogManager.shutdown ( ) ; } } ; }
public final SubmitRecord.Label.Status status ( ) { if ( ( approved ( ) ) != null ) { return SubmitRecord.Label.Status.OK ; } else if ( ( rejected ( ) ) != null ) { return SubmitRecord.Label.Status.REJECT ; } else { return SubmitRecord.Label.Status.NEED ; } }
public com.google.gerrit.client.account.ExternalIdDetail run ( com.google.gerrit.client.reviewdb.ReviewDb db ) throws com.google.gwtorm.client.OrmException { final com.google.gerrit.client.reviewdb.Account.Id me = com.google.gerrit.client.rpc.Common.getAccountId ( ) ; final java.util.List < com.google.gerrit.client.reviewdb.TrustedExternalId > trusted = com.google.gerrit.client.rpc.Common.getGroupCache ( ) . getTrustedExternalIds ( db ) ; final java.util.List < com.google.gerrit.client.reviewdb.AccountExternalId > myIds = db.accountExternalIds ( ) . byAccount ( me ) . toList ( ) ; return new com.google.gerrit.client.account.ExternalIdDetail ( myIds , trusted ) ; }
public void addComment ( final java.lang.String issueId , final java.lang.String comment ) throws java.io.IOException { com.googlesource.gerrit.plugins.its.storyboard.StoryboardClient.log.debug ( "Posting comment with data: ({},{})" , issueId , comment ) ; final java.lang.String url = ( ( ( ( baseUrl ) + ( com.googlesource.gerrit.plugins.its.storyboard.StoryboardClient.STORIES_ENDPOINT ) ) + "/" ) + issueId ) + "/comments" ; final java.lang.String escapedComment = comment.replace ( "\n" , "\\n" ) ; final java.lang.String json = ( ( ( "{\"story_id\":\"" + issueId ) + "\",\"content\":\"" ) + escapedComment ) + "\"}" ; postData ( url , json ) ; }
public void submitOnPush ( ) throws com.google.gwtorm.server.OrmException , java.io.IOException , org.eclipse.jgit.api.errors.GitAPIException , org.eclipse.jgit.errors.ConfigInvalidException { grantSubmit ( project , "refs/for/refs/heads/master" ) ; com.google.gerrit.acceptance.git.PushOneCommit.Result r = pushTo ( "refs/for/master%submit" ) ; r.assertOkStatus ( ) ; r.assertChange ( Change.Status.MERGED , null , admin ) ; assertSubmitApproval ( r.getPatchSetId ( ) ) ; assertCommit ( project , "refs/heads/master" ) ; }
public java.util.List < java.lang.String > getMoreStable ( java.lang.String branch ) { int i = order.indexOf ( com.google.gerrit.reviewdb.client.RefNames.fullName ( branch ) ) ; if ( 0 <= i ) { return order.subList ( ( i + 1 ) , order.size ( ) ) ; } else { return com.google.common.collect.ImmutableList.of ( ) ; } }
public static com.google.gerrit.common.data.PermissionRule remove ( com.google.gerrit.server.git.ProjectConfig project , java.lang.String capabilityName , com.google.gerrit.reviewdb.client.AccountGroup.UUID group ) { com.google.gerrit.common.data.PermissionRule rule = com.google.gerrit.server.project.testing.Util.newRule ( project , group ) ; project.getAccessSection ( AccessSection.GLOBAL_CAPABILITIES , true ) . getPermission ( capabilityName , true ) . remove ( rule ) ; return rule ; }
public void insertedWhitespaceIsRecognizedInIdenticalLines ( ) throws java.lang.Exception { java.lang.String a = " int *foobar\n int *foobar\n" ; java.lang.String b = " int * foobar\n int * foobar\n" ; java.util.List < org.eclipse.jgit.diff.Edit > expected = new org.eclipse.jgit.diff.EditList ( ) ; expected.add ( new org.eclipse.jgit.diff.Edit ( 6 , 6 , 6 , 7 ) ) ; expected.add ( new org.eclipse.jgit.diff.Edit ( 19 , 19 , 20 , 21 ) ) ; com.google.common.truth.Truth.assertThat ( com.google.gerrit.server.patch.IntraLineLoaderTest.intraline ( a , b ) ) . isEqualTo ( expected ) ; }
private PushOneCommit.Result push ( java.lang.String content , java.lang.String baseChangeId ) throws java.lang.Exception { java.lang.String subject = "Change subject" ; java.lang.String fileName = "a.txt" ; com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create ( db , admin.getIdent ( ) , git , subject , fileName , content , baseChangeId ) ; com.google.gerrit.acceptance.PushOneCommit.Result r = push.to ( "refs/for/master" ) ; r.assertOkStatus ( ) ; return r ; }
private static void printCommits ( final java.io.PrintWriter stdout , final java.util.List < org.eclipse.jgit.lib.ObjectId > commits ) { boolean first = true ; for ( final org.eclipse.jgit.lib.ObjectId c : commits ) { if ( ! first ) { stdout.print ( ",\n" ) ; } stdout.print ( c.getName ( ) ) ; first = false ; } stdout.print ( "\n\n" ) ; }
public void testHeadRefReplicated ( ) throws java.net.URISyntaxException { org.easymock.EasyMock.reset ( dispatcherMock ) ; com.googlesource.gerrit.plugins.replication.RefReplicatedEvent expectedEvent = new com.googlesource.gerrit.plugins.replication.RefReplicatedEvent ( "someProject" , "refs/heads/master" , "someHost" , com.googlesource.gerrit.plugins.replication.ReplicationState.RefPushResult.SUCCEEDED , RemoteRefUpdate.Status.OK ) ; dispatcherMock.postEvent ( org.easymock.EasyMock.anyObject ( Branch.NameKey.class ) , com.googlesource.gerrit.plugins.replication.RefReplicatedEventEquals.eqEvent ( expectedEvent ) ) ; org.easymock.EasyMock.expectLastCall ( ) . once ( ) ; org.easymock.EasyMock.replay ( dispatcherMock ) ; gitUpdateProcessing.onRefReplicatedToOneNode ( "someProject" , "refs/heads/master" , new org.eclipse.jgit.transport.URIish ( "git://someHost/someProject.git" ) , RefPushResult.SUCCEEDED , RemoteRefUpdate.Status.OK ) ; org.easymock.EasyMock.verify ( dispatcherMock ) ; }
private static boolean isChangeScreen2 ( ) { if ( com.google.gerrit.client.Dispatcher.changeScreen2 ) { return true ; } com.google.gerrit.reviewdb.client.AccountGeneralPreferences.ChangeScreen ui = null ; if ( com.google.gerrit.client.Gerrit.isSignedIn ( ) ) { ui = com.google.gerrit.client.Gerrit.getUserAccount ( ) . getGeneralPreferences ( ) . getChangeScreen ( ) ; } if ( ui == null ) { ui = com.google.gerrit.client.Gerrit.getConfig ( ) . getChangeScreen ( ) ; } return ui == ( com.google.gerrit.client.changes.ChangeScreen.CHANGE_SCREEN2 ) ; }
public java.util.Set < com.google.gerrit.reviewdb.client.Change.Id > getStarredChanges ( ) { if ( ( starredChanges ) == null ) { checkRequestScope ( ) ; try { starredChanges = com.google.gerrit.server.IdentifiedUser.starredChangeIds ( ( ( starredQuery ) != null ? starredQuery : starredQuery ( ) ) ) ; } catch ( com.google.gwtorm.server.OrmException | java.lang.RuntimeException e ) { com.google.gerrit.server.IdentifiedUser.log.warn ( "Cannot query starred changes" , e ) ; starredChanges = java.util.Collections.emptySet ( ) ; } finally { starredQuery = null ; } } return starredChanges ; }
protected < T > org.elasticsearch.index.query.QueryBuilder toQueryBuilder ( com.google.gerrit.server.query.Predicate < T > p ) throws com.google.gerrit.index.query.QueryParseException { if ( p instanceof com.google.gerrit.server.query.AndPredicate ) { return and ( p ) ; } else if ( p instanceof com.google.gerrit.server.query.OrPredicate ) { return or ( p ) ; } else if ( p instanceof com.google.gerrit.server.query.NotPredicate ) { return not ( p ) ; } else if ( p instanceof com.google.gerrit.server.index.IndexPredicate ) { return fieldQuery ( ( ( com.google.gerrit.server.index.IndexPredicate < T > ) ( p ) ) ) ; } else { throw new com.google.gerrit.index.query.QueryParseException ( ( "cannot create query for index: " + p ) ) ; } }
private static com.google.gerrit.extensions.client.EditPreferencesInfo parseEditPreferences ( org.eclipse.jgit.lib.Config cfg , @ com.google.gerrit.common.Nullable org.eclipse.jgit.lib.Config defaultCfg , @ com.google.gerrit.common.Nullable com.google.gerrit.extensions.client.EditPreferencesInfo input ) throws org.eclipse.jgit.errors.ConfigInvalidException { return com.google.gerrit.server.config.ConfigUtil.loadSection ( cfg , UserConfigSections.EDIT , null , new com.google.gerrit.extensions.client.EditPreferencesInfo ( ) , ( defaultCfg != null ? com.google.gerrit.server.account.PreferencesConfig.parseDefaultEditPreferences ( defaultCfg , input ) : com.google.gerrit.extensions.client.EditPreferencesInfo.defaults ( ) ) , input ) ; }
public void testToString ( ) { final com.google.gerrit.server.query.OrPredicateTest.TestPredicate a = com.google.gerrit.server.query.OrPredicateTest.f ( "q" , "alice" ) ; final com.google.gerrit.server.query.OrPredicateTest.TestPredicate b = com.google.gerrit.server.query.OrPredicateTest.f ( "q" , "bob" ) ; final com.google.gerrit.server.query.OrPredicateTest.TestPredicate c = com.google.gerrit.server.query.OrPredicateTest.f ( "q" , "charlie" ) ; org.junit.Assert.assertEquals ( "(q:alice OR q:bob)" , com.google.gerrit.server.query.Predicate.or ( a , b ) . toString ( ) ) ; org.junit.Assert.assertEquals ( "(q:alice OR q:bob OR q:charlie)" , com.google.gerrit.server.query.Predicate.or ( a , b , c ) . toString ( ) ) ; }
net.codemirror.lib.CodeMirror getCmB ( ) { return cmB ; }
public void registerKeys ( ) { super . registerKeys ( ) ; handlers.add ( com.google.gwtexpui.globalkey.client.GlobalKey.add ( this , keysNavigation ) ) ; handlers.add ( com.google.gwtexpui.globalkey.client.GlobalKey.add ( this , keysAction ) ) ; files.registerKeys ( ) ; related.registerKeys ( ) ; }
protected void run ( ) throws com.google.gerrit.sshd.commands.UnloggedFailure { try { if ( luceneVersionManager.activateLatestIndex ( name ) ) { stdout.println ( "Activated latest index version" ) ; } else { stdout.println ( "Not activating index, already using latest version" ) ; } } catch ( com.google.gerrit.lucene.ReindexerAlreadyRunningException e ) { throw new com.google.gerrit.sshd.commands.UnloggedFailure ( ( "Failed to activate latest index: " + ( e.getMessage ( ) ) ) ) ; } }
private boolean isVisible ( com.google.gerrit.reviewdb.server.ReviewDb db , @ com.google.gerrit.common.Nullable com.google.gerrit.server.query.change.ChangeData cd ) throws com.google.gwtorm.server.OrmException { if ( ( getChange ( ) . isPrivate ( ) ) && ( ! ( isPrivateVisible ( db , cd ) ) ) ) { return false ; } return refControl.isVisible ( ) ; }
private java.util.Map < java.lang.String , com.google.gerrit.server.dashboard.ListDashboards.DashboardInfo > addProjectDashboards ( final com.google.gerrit.server.project.ProjectState projectState , java.util.Map < java.lang.String , com.google.gerrit.server.dashboard.ListDashboards.DashboardInfo > all ) { final java.util.Map < java.lang.String , com.google.gerrit.server.dashboard.ListDashboards.DashboardInfo > dashboards = projectDashboards ( projectState ) ; dashboards.putAll ( all ) ; return dashboards ; }
public static void grant ( com.google.gerrit.server.git.ProjectConfig config , com.google.gerrit.common.data.AccessSection section , java.lang.String permission , boolean force , com.google.gerrit.common.data.GroupReference ... groupList ) { com.google.gerrit.common.data.Permission p = section.getPermission ( permission , true ) ; for ( com.google.gerrit.common.data.GroupReference group : groupList ) { if ( group != null ) { com.google.gerrit.common.data.PermissionRule r = com.google.gerrit.server.schema.AclUtil.rule ( config , group ) ; r.setForce ( force ) ; p.add ( r ) ; } } }
public UiAction.Description getDescription ( com.google.gerrit.server.change.ChangeResource resource ) { return new com.google.gerrit.extensions.webui.UiAction.Description ( ) . setLabel ( "Revert" ) . setVisible ( ( ( ( resource.getChange ( ) . getStatus ( ) ) == ( com.google.gerrit.reviewdb.client.Change.Status.MERGED ) ) && ( resource.getControl ( ) . getRefControl ( ) . canUpload ( ) ) ) ) ; }
static com.google.gerrit.acceptance.GerritServer.Description forTestClass ( com.google.gerrit.acceptance.Description testDesc , java.lang.String configName ) { }
public static com.google.gerrit.server.query.change.QueryOptions create ( com.google.gerrit.server.index.IndexConfig config , int start , int limit ) { com.google.common.base.Preconditions.checkArgument ( ( start >= 0 ) , "start must be nonnegative: %s" , start ) ; com.google.common.base.Preconditions.checkArgument ( ( limit > 0 ) , "limit must be positive: %s" , limit ) ; return new com.google.gerrit.server.query.change.AutoValue_QueryOptions ( config , start , limit ) ; }
private void populateTableHeader ( final com.google.gerrit.common.data.PatchScript script , final com.google.gerrit.common.data.PatchSetDetail detail ) { prepareHeaderWidgets ( script , detail ) ; table.setWidget ( com.google.gerrit.client.patches.R_HEAD , com.google.gerrit.client.patches.UnifiedDiffTable.PC , psListOfHeaderA ) ; table.setWidget ( rowOfTableHeaderB , com.google.gerrit.client.patches.UnifiedDiffTable.PC , psListOfHeaderB ) ; table.getFlexCellFormatter ( ) . addStyleName ( com.google.gerrit.client.patches.R_HEAD , com.google.gerrit.client.patches.UnifiedDiffTable.PC , Gerrit.RESOURCES.css ( ) . unifiedTableHeader ( ) ) ; table.getFlexCellFormatter ( ) . addStyleName ( rowOfTableHeaderB , com.google.gerrit.client.patches.UnifiedDiffTable.PC , Gerrit.RESOURCES.css ( ) . unifiedTableHeader ( ) ) ; }
public com.google.gerrit.extensions.restapi.BinaryResult apply ( com.google.gerrit.server.change.FileResource rsrc ) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException , com.google.gerrit.server.project.NoSuchChangeException , com.google.gwtorm.server.OrmException , java.io.IOException { java.lang.String path = rsrc.getPatchKey ( ) . get ( ) ; com.google.gerrit.server.project.ProjectState projectState = rsrc.getRevision ( ) . getControl ( ) . getProjectControl ( ) . getProjectState ( ) ; org.eclipse.jgit.lib.ObjectId revstr = org.eclipse.jgit.lib.ObjectId.fromString ( rsrc.getRevision ( ) . getPatchSet ( ) . getRevision ( ) . get ( ) ) ; return fileContentUtil.downloadContent ( projectState , revstr , path , parent ) ; }
protected void onStarClick ( final int row ) { final com.google.gerrit.client.data.ChangeInfo c = getChangeInfo ( row ) ; if ( ( c != null ) && ( com.google.gerrit.client.Gerrit.isSignedIn ( ) ) ) { c.setStarred ( ( ! ( c.isStarred ( ) ) ) ) ; setStar ( row , c ) ; final com.google.gerrit.client.changes.ToggleStarRequest req = new com.google.gerrit.client.changes.ToggleStarRequest ( ) ; req.toggle ( c.getId ( ) , c.isStarred ( ) ) ; Util.LIST_SVC.toggleStars ( req , VoidCallback.INSTANCE ) ; } }
private com.google.gerrit.server.project.SubmitRuleEvaluator makeEvaluator ( ) { com.google.gerrit.server.query.change.ChangeData cd = com.google.gerrit.server.query.change.ChangeData.createForTest ( project , new com.google.gerrit.reviewdb.client.Change.Id ( 1 ) , 1 ) ; cd.setChange ( com.google.gerrit.testing.TestChanges.newChange ( project , admin.id ) ) ; return evaluatorFactory.create ( cd ) ; }
public static com.google.gerrit.reviewdb.client.Change newChange ( com.google.gerrit.reviewdb.client.Project.NameKey project , com.google.gerrit.server.IdentifiedUser user , int id ) { com.google.gerrit.reviewdb.client.Change.Id changeId = new com.google.gerrit.reviewdb.client.Change.Id ( id ) ; com.google.gerrit.reviewdb.client.Change c = new com.google.gerrit.reviewdb.client.Change ( new com.google.gerrit.reviewdb.client.Change.Key ( "Iabcd1234abcd1234abcd1234abcd1234abcd1234" ) , changeId , user.getAccount ( ) . getId ( ) , new com.google.gerrit.reviewdb.client.Branch.NameKey ( project , "master" ) , com.google.gerrit.server.util.TimeUtil.nowTs ( ) ) ; com.google.gerrit.testutil.TestChanges.incrementPatchSet ( c ) ; return c ; }
public void run ( ) throws java.lang.Exception { processor.setOutput ( out , QueryProcessor.OutputFormat.TEXT ) ; parseCommandLine ( ) ; verifyCommandLine ( ) ; processor.query ( com.google.gerrit.sshd.commands.Query.join ( query , " " ) ) ; }
public boolean hasRepositoryPermission ( java.lang.String name ) { boolean result = false ; try { name = getRepositoryName ( name ) ; com.google.gerrit.server.project.ProjectControl control = projectControlFactory.controlFor ( new com.google.gerrit.reviewdb.client.Project.NameKey ( name ) ) ; result = ( control != null ) && ( ! ( control.isHidden ( ) ) ) ; } catch ( com.google.gerrit.server.project.NoSuchProjectException e ) { result = false ; } return result ; }
public static GroupDescription.Internal forAccountGroup ( com.google.gerrit.reviewdb.client.AccountGroup group ) { return new com.google.gerrit.common.data.GroupDescription.Internal ( ) { @ java.lang.Override public AccountGroup.UUID getGroupUUID ( ) { return group.getGroupUUID ( ) ; } @ java.lang.Override public java.lang.String getName ( ) { return group.getName ( ) ; } @ java.lang.Override public com.google.gerrit.reviewdb.client.AccountGroup getAccountGroup ( ) { return group ; } @ java.lang.Override @ com.google.gerrit.common.Nullable public java.lang.String getEmailAddress ( ) { return null ; } @ java.lang.Override @ com.google.gerrit.common.Nullable public java.lang.String getUrl ( ) { return "#" + ( com.google.gerrit.common.PageLinks.toGroup ( getGroupUUID ( ) ) ) ; } } ; }
public java.util.Collection < com.google.gerrit.reviewdb.client.PatchLineComment > comments ( com.google.inject.Provider < com.google.gerrit.reviewdb.server.ReviewDb > db ) throws com.google.gwtorm.server.OrmException { if ( ( comments ) == null ) { comments = db.get ( ) . patchComments ( ) . byChange ( legacyId ) . toList ( ) ; } return comments ; }
public void testIsSuccessful ( ) throws java.lang.Exception { org.apache.http.HttpResponse response = setupMocks ( com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpResponseHandlerTest.OK , com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpResponseHandlerTest.EMPTY_ENTITY ) ; com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpResponseHandler.HttpResult result = handler.handleResponse ( response ) ; com.google.common.truth.Truth.assertThat ( result.isSuccessful ( ) ) . isTrue ( ) ; com.google.common.truth.Truth.assertThat ( result.getMessage ( ) ) . isEmpty ( ) ; }
private void afterTest ( ) throws java.lang.Exception { server.stop ( ) ; }
public void onPreMerge ( org.eclipse.jgit.lib.Repository repo , com.google.gerrit.server.git.CodeReviewCommit commit , com.google.gerrit.server.project.ProjectState destProject , com.google.gerrit.reviewdb.client.Branch.NameKey destBranch , com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId , com.google.gerrit.server.IdentifiedUser caller ) throws com.google.gerrit.server.git.validators.MergeValidationException { if ( ( ! ( allUsersName.equals ( destProject.getNameKey ( ) ) ) ) || ( ! ( destBranch.get ( ) . startsWith ( RefNames.REFS_GROUPS ) ) ) ) { return ; } throw new com.google.gerrit.server.git.validators.MergeValidationException ( "group update not allowed" ) ; }
public T get ( ) { final com.google.gerrit.server.ssh.SshScopes.Context ctx = com.google.gerrit.server.ssh.SshScopes.getContext ( ) ; final java.util.Map < com.google.inject.Key < ? > , java.lang.Object > map = ctx.session.sessionContext.map ; synchronized ( map ) { @ java.lang.SuppressWarnings ( value = "unchecked" ) T t = ( ( T ) ( map.get ( key ) ) ) ; if ( t == null ) { t = creator.get ( ) ; map.put ( key , t ) ; } return t ; } }
private void postMessage ( java.lang.String changeId , java.lang.String msg ) throws java.lang.Exception { com.google.gerrit.extensions.api.changes.ReviewInput in = new com.google.gerrit.extensions.api.changes.ReviewInput ( ) ; in.message = msg ; gApi.changes ( ) . id ( changeId ) . current ( ) . review ( in ) ; }
public void testSyncUrlProvider ( ) { com.ericsson.gerrit.plugins.syncindex.Configuration configMock = createNiceMock ( com.ericsson.gerrit.plugins.syncindex.Configuration.class ) ; java.lang.String expected = "someUrl" ; org.easymock.EasyMock.expect ( configMock.getUrl ( ) ) . andReturn ( expected ) ; replayAll ( ) ; com.ericsson.gerrit.plugins.syncindex.Module module = new com.ericsson.gerrit.plugins.syncindex.Module ( ) ; com.google.common.truth.Truth.assertThat ( module.syncUrl ( configMock ) ) . isEqualTo ( expected ) ; }
private void saveLabelConfig ( ) throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet ( project ) . getConfig ( ) ; cfg.getLabelSections ( ) . put ( label.getName ( ) , label ) ; cfg.getLabelSections ( ) . put ( P.getName ( ) , P ) ; saveProjectConfig ( project , cfg ) ; }
private void parseDelete ( final org.eclipse.jgit.transport.ReceiveCommand cmd ) { com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef ( cmd.getRefName ( ) ) ; if ( ctl.canDelete ( ) ) { cmd.execute ( rp ) ; } else { reject ( cmd , "can not delete references" ) ; } }
public void empty1 ( ) { final java.lang.String name = "empty-file" ; final com.google.gerrit.server.patch.PatchListEntry e = com.google.gerrit.server.patch.PatchListEntry.empty ( name ) ; org.junit.Assert.assertNull ( e.getOldName ( ) ) ; org.junit.Assert.assertEquals ( name , e.getNewName ( ) ) ; org.junit.Assert.assertSame ( Patch.PatchType.UNIFIED , e.getPatchType ( ) ) ; org.junit.Assert.assertSame ( Patch.ChangeType.MODIFIED , e.getChangeType ( ) ) ; org.junit.Assert.assertTrue ( e.getEdits ( ) . isEmpty ( ) ) ; }
public com.google.gerrit.extensions.common.ChangeInfo addChangeActions ( com.google.gerrit.extensions.common.ChangeInfo to , com.google.gerrit.server.project.ChangeControl ctl ) { to.actions = toActionMap ( ctl ) ; return to ; }
private static java.lang.String stripPrefix ( @ javax.annotation.Nullable java.lang.String prefix , java.lang.String name ) { return prefix != null ? name.substring ( ( ( prefix.length ( ) ) + 1 ) ) : name ; }
private com.google.gwtorm.jdbc.JdbcSchema setupSchema ( final com.google.gwtorm.schema.sql.SqlDialect dialect ) { @ java.lang.SuppressWarnings ( value = "rawtypes" ) com.google.gwtorm.jdbc.Database db = org.mockito.Mockito.mock ( com.google.gwtorm.jdbc.Database.class ) ; try { org.mockito.Mockito.stub ( db.getDialect ( ) ) . toReturn ( dialect ) ; com.google.gwtorm.jdbc.JdbcSchema schema = new com.google.gwtorm.jdbc.TestJdbcAccess.Schema ( db , conn ) ; return schema ; } catch ( com.google.gwtorm.client.OrmException e ) { throw new java.lang.RuntimeException ( e ) ; } }
static void link ( com.google.gerrit.client.diff.PaddingManager a , com.google.gerrit.client.diff.PaddingManager b ) { a.other = b ; b.other = a ; }
public void onSuccess ( com.googlesource.gerrit.plugins.xdocs.client.CommitInfo commit ) { if ( ( commit.parents ( ) ) != null ) { java.util.List < com.googlesource.gerrit.plugins.xdocs.client.CommitInfo > parents = com.google.gerrit.client.rpc.Natives.asList ( commit.parents ( ) ) ; if ( ! ( parents.isEmpty ( ) ) ) { revisionA = parents.get ( 0 ) . commit ( ) ; } } show ( change ) ; }
private boolean finite ( java.lang.String pattern ) { if ( pattern.startsWith ( RefRight.REGEX_PREFIX ) ) { return com.google.gerrit.server.project.RefControl.toRegExp ( pattern ) . toAutomaton ( ) . isFinite ( ) ; } else if ( pattern.endsWith ( "/*" ) ) { return false ; } else { return true ; } }
private void bccWatchesNotifySubmittedChanges ( ) { try { for ( final com.google.gerrit.reviewdb.AccountProjectWatch w : getWatches ( ) ) { if ( w.isNotifySubmittedChanges ( ) ) { add ( RecipientType.BCC , w.getAccountId ( ) ) ; } } } catch ( com.google.gwtorm.client.OrmException err ) { } }
public void missingKey ( ) throws java.lang.Exception { com.google.gerrit.gpg.testutil.TestKey key2 = com.google.gerrit.gpg.testutil.TestKeys.key2 ( ) ; org.eclipse.jgit.transport.PushCertificate cert = newSignedCert ( validNonce ( ) , key2 ) ; assertProblems ( cert , ( "No public keys found for key ID " + ( com.google.gerrit.gpg.PublicKeyStore.keyIdToString ( key2.getKeyId ( ) ) ) ) ) ; }
public void index ( com.google.gerrit.reviewdb.client.Account.Id id ) throws java.io.IOException { for ( com.google.gerrit.server.index.Index < com.google.gerrit.reviewdb.client.Account.Id , com.google.gerrit.server.account.AccountState > i : getWriteIndexes ( ) ) { com.google.gerrit.server.account.AccountState accountState = byIdCache.getOrNull ( id ) ; if ( accountState != null ) { i.replace ( accountState ) ; } else { i.delete ( id ) ; } } fireAccountIndexedEvent ( id.get ( ) ) ; }
private org.eclipse.jgit.transport.PushCertificate newSignedCert ( java.lang.String nonce , com.google.gerrit.server.git.gpg.TestKey signingKey ) throws java.lang.Exception { org.eclipse.jgit.transport.PushCertificateIdent ident = new org.eclipse.jgit.transport.PushCertificateIdent ( signingKey.getFirstUserId ( ) , java.lang.System.currentTimeMillis ( ) , ( ( - 7 ) * 60 ) ) ; java.lang.String payload = ( ( ( ( ( ( ( ( ( ( "certificate version 0.1\n" + "pusher " ) + ( ident.getRaw ( ) ) ) + "\n" ) + "pushee test://localhost/repo.git\n" ) + "nonce " ) + nonce ) + "\n" ) + "\n" ) + "0000000000000000000000000000000000000000" ) + " deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" ) + " refs/heads/master\n" ; org.bouncycastle.openpgp.PGPSignatureGenerator gen = new org.bouncycastle.openpgp.PGPSignatureGenerator ( new org.bouncycastle.openpgp.operator.bc.BcPGPContentSignerBuilder ( signingKey.getPublicKey ( ) . getAlgorithm ( ) , org.bouncycastle.openpgp.PGPUtil.SHA1 ) ) ; gen.init ( PGPSignature.BINARY_DOCUMENT , signingKey.getPrivateKey ( ) ) ; gen.update ( payload.getBytes ( java.nio.charset.StandardCharsets.UTF_8 ) ) ; org.bouncycastle.openpgp.PGPSignature sig = gen.generate ( ) ; java.io.ByteArrayOutputStream bout = new java.io.ByteArrayOutputStream ( ) ; try ( org.bouncycastle.bcpg.BCPGOutputStream out = new org.bouncycastle.bcpg.BCPGOutputStream ( new org.bouncycastle.bcpg.ArmoredOutputStream ( bout ) ) ) { sig.encode ( out ) ; } java.lang.String cert = payload + ( new java.lang.String ( bout.toByteArray ( ) , java.nio.charset.StandardCharsets.UTF_8 ) ) ; java.io.Reader reader = new java.io.InputStreamReader ( new java.io.ByteArrayInputStream ( cert.getBytes ( java.nio.charset.StandardCharsets.UTF_8 ) ) ) ; org.eclipse.jgit.transport.PushCertificateParser parser = new org.eclipse.jgit.transport.PushCertificateParser ( tr.getRepository ( ) , signedPushConfig ) ; return parser.parse ( reader ) ; }
private void index ( com.google.gerrit.server.project.ProjectControl projectControl ) { try { index.apply ( new com.google.gerrit.server.project.ProjectResource ( projectControl ) , null ) ; } catch ( java.lang.Exception e ) { writeError ( "error" , java.lang.String.format ( "Unable to index %s: %s" , projectControl.getProject ( ) . getName ( ) , e.getMessage ( ) ) ) ; } }
public void onClick ( com.google.gwt.event.dom.client.ClickEvent event ) { save.setEnabled ( false ) ; com.google.gerrit.client.projects.ProjectApi.setHead ( getProjectKey ( ) , input.getValue ( ) . trim ( ) , new com.google.gerrit.client.rpc.GerritCallback < com.google.gerrit.client.rpc.NativeString > ( ) { @ java.lang.Override public void onSuccess ( com.google.gerrit.client.rpc.NativeString result ) { com.google.gerrit.client.Gerrit.display ( com.google.gerrit.common.PageLinks.toProjectTags ( getProjectKey ( ) ) ) ; } @ java.lang.Override public void onFailure ( java.lang.Throwable caught ) { super . onFailure ( caught ) ; save.setEnabled ( true ) ; } } ) ; }
void setRoot ( org.pegdown.ast.RootNode doc ) { outline = new java.util.ArrayList < > ( ) ; com.google.common.collect.Multimap < java.lang.String , com.google.gitiles.doc.TocFormatter.TocEntry > entries = com.google.common.collect.ArrayListMultimap.create ( 16 , 4 ) ; scan ( doc , entries , new java.util.ArrayDeque < org.pegdown.ast.HeaderNode > ( ) ) ; ids = generateIds ( entries ) ; }
private com.google.gerrit.server.project.ProjectData toProjectData ( com.google.gson.JsonElement json ) { com.google.gson.JsonElement source = json.getAsJsonObject ( ) . get ( "_source" ) ; if ( source == null ) { source = json.getAsJsonObject ( ) . get ( "fields" ) ; } com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey ( source.getAsJsonObject ( ) . get ( ProjectField.NAME.getName ( ) ) . getAsString ( ) ) ; return projectCache.get ( ) . get ( nameKey ) . toProjectData ( ) ; }
private java.util.Map < com.google.gerrit.reviewdb.Change.Key , com.google.gerrit.reviewdb.Change.Id > openChangesByKey ( com.google.gerrit.reviewdb.Branch.NameKey branch ) throws com.google.gwtorm.client.OrmException { final java.util.Map < com.google.gerrit.reviewdb.Change.Key , com.google.gerrit.reviewdb.Change.Id > r = new java.util.HashMap < com.google.gerrit.reviewdb.Change.Key , com.google.gerrit.reviewdb.Change.Id > ( ) ; for ( com.google.gerrit.reviewdb.Change c : db.changes ( ) . byBranchOpenAll ( branch ) ) { r.put ( c.getKey ( ) , c.getId ( ) ) ; } return r ; }
public void updateRepo ( com.google.gerrit.server.update.BatchUpdate.RepoContext ctx ) throws java.lang.Exception { com.google.gerrit.server.git.CodeReviewCommit c = composeGitlinksCommit ( branch ) ; if ( c != null ) { ctx.addRefUpdate ( new org.eclipse.jgit.transport.ReceiveCommand ( c.getParent ( 0 ) , c , branch.get ( ) ) ) ; addBranchTip ( branch , c ) ; } }
public int run ( ) throws java.lang.Exception { final com.google.inject.Injector injector = com.google.inject.Guice.createInjector ( new com.google.gerrit.server.GerritServerModule ( ) , new com.google.gerrit.server.ssh.SshDaemonModule ( ) ) ; com.google.gerrit.client.rpc.Common.setGerritConfig ( injector.getInstance ( com.google.gerrit.client.data.GerritConfig.class ) ) ; injector.getInstance ( com.google.gerrit.server.ssh.GerritSshDaemon.class ) . start ( ) ; return never ( ) ; }
private com.google.gerrit.reviewdb.client.Change.Id getOrRegisterAccount ( com.google.gerrit.reviewdb.server.ReviewDb db , org.kohsuke.github.GHUser user ) throws com.google.gerrit.extensions.restapi.BadRequestException , com.google.gerrit.extensions.restapi.ResourceConflictException , com.google.gerrit.extensions.restapi.UnprocessableEntityException , com.google.gwtorm.server.OrmException , java.io.IOException { com.google.gerrit.reviewdb.client.AccountExternalId.Key userExtKey = new com.google.gerrit.reviewdb.client.AccountExternalId.Key ( com.google.gerrit.reviewdb.client.AccountExternalId.SCHEME_USERNAME , user.getLogin ( ) ) ; com.google.gerrit.reviewdb.server.AccountExternalIdAccess gerritExtIds = db.accountExternalIds ( ) ; com.google.gerrit.reviewdb.client.AccountExternalId userExtId = gerritExtIds.get ( userExtKey ) ; if ( userExtId == null ) { return accountImporter.importAccount ( user ) ; } else { return userExtId.getAccountId ( ) ; } }
public void listNonEmptyGroupIncludes ( ) throws java.lang.Exception { group ( "gx" , "Administrators" ) ; group ( "gy" , "Administrators" ) ; PUT ( "/groups/Administrators/groups/gx" ) ; PUT ( "/groups/Administrators/groups/gy" ) ; assertIncludes ( GET ( "/groups/Administrators/groups/" ) , "gx" , "gy" ) ; }
public boolean hasNext ( ) { while ( ( ( next ) == null ) && ( itr.hasNext ( ) ) ) { com.google.inject.Provider < T > p = itr.next ( ) . get ( ) ; if ( p != null ) { try { next = p.get ( ) ; } catch ( java.lang.RuntimeException e ) { } } } return ( next ) != null ; }
private void call ( com.googlecode.prolog_cafe.lang.BufferingPrologControl env , java.lang.String name ) { com.googlecode.prolog_cafe.lang.StructureTerm head = com.googlecode.prolog_cafe.lang.SymbolTerm.create ( pkg , name , 0 ) ; com.google.common.truth.Truth.assert_ ( ) . withMessage ( ( ( ( "Cannot invoke " + ( pkg ) ) + ":" ) + name ) ) . that ( env.execute ( Prolog.BUILTIN , "call" , head ) ) . isTrue ( ) ; }
public void onSuccess ( com.google.gerrit.client.groups.GroupMap result ) { priorResults.clear ( ) ; java.util.ArrayList < com.google.gerrit.client.ui.AccountGroupSuggestOracle.AccountGroupSuggestion > r = new java.util.ArrayList ( result.size ( ) ) ; for ( com.google.gerrit.client.groups.GroupInfo group : com.google.gerrit.client.rpc.Natives.asList ( result.values ( ) ) ) { r.add ( new com.google.gerrit.client.ui.AccountGroupSuggestOracle.AccountGroupSuggestion ( group ) ) ; priorResults.put ( group.name ( ) , group.getGroupUUID ( ) ) ; } callback.onSuggestionsReady ( req , new com.google.gerrit.client.ui.Response ( r ) ) ; }
protected void configure ( ) { try { bind ( com.google.gerrit.server.GerritServer.class ) . toInstance ( com.google.gerrit.server.GerritServer.getInstance ( true ) ) ; } catch ( com.google.gwtorm.client.OrmException e ) { addError ( e ) ; } catch ( com.google.gwtjsonrpc.server.XsrfException e ) { addError ( e ) ; } }
public void onSuccess ( com.google.gerrit.client.info.ChangeInfo info ) { info.init ( ) ; addExtensionPoints ( info ) ; loadConfigInfo ( info , base ) ; }
public void deleteGpgKey ( ) throws java.lang.Exception { com.google.gerrit.server.git.gpg.TestKey key = com.google.gerrit.server.git.gpg.TestKey.key1 ( ) ; java.lang.String id = key.getKeyIdString ( ) ; addExternalIdEmail ( admin , "test1@example.com" ) ; addGpgKey ( key.getPublicKeyArmored ( ) ) ; assertKeys ( key ) ; gApi.accounts ( ) . self ( ) . gpgKey ( id ) . delete ( ) ; assertKeys ( ) ; exception.expect ( com.google.gerrit.extensions.restapi.ResourceNotFoundException.class ) ; exception.expectMessage ( id ) ; gApi.accounts ( ) . self ( ) . gpgKey ( id ) . get ( ) ; }
public void onFailure ( java.lang.Exception reason ) { com.google.gerrit.client.ErrorDialog d = new com.google.gerrit.client.ErrorDialog ( reason ) ; d.setTitle ( com.google.gerrit.client.Gerrit.M.pluginFailed ( url ) ) ; d.center ( ) ; }
public void setNonExistingParent_UnprocessibleEntity ( ) throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = adminSession.put ( ( ( "/projects/" + ( project.get ( ) ) ) + "/parent" ) , newParentInput ( "non-existing" ) ) ; com.google.common.truth.Truth.assertThat ( r.getStatusCode ( ) ) . isEqualTo ( HttpStatus.SC_UNPROCESSABLE_ENTITY ) ; r.consume ( ) ; }
public void testUpdateOneException ( ) throws com.google.gwtorm.client.OrmException , java.sql.SQLException { stubExecuteBatchException ( com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE , new java.sql.BatchUpdateException ( ) ) ; try { createClassUnderTest ( ) . update ( com.google.gwtorm.jdbc.TestJdbcAccess.ONE_ROW ) ; org.junit.Assert.fail ( "missingException" ) ; } catch ( com.google.gwtorm.client.OrmException e ) { } }
protected void assertApproved ( java.lang.String changeId ) throws java.io.IOException { com.google.gerrit.extensions.common.ChangeInfo c = getChange ( changeId , com.google.gerrit.extensions.common.ListChangesOption.DETAILED_LABELS ) ; com.google.gerrit.extensions.common.LabelInfo cr = c.labels.get ( "Code-Review" ) ; org.junit.Assert.assertEquals ( 1 , cr.all.size ( ) ) ; org.junit.Assert.assertEquals ( 2 , cr.all.get ( 0 ) . value.intValue ( ) ) ; org.junit.Assert.assertEquals ( admin.getId ( ) , new com.google.gerrit.reviewdb.client.Account.Id ( cr.all.get ( 0 ) . _accountId ) ) ; }
public void start ( ) { try { createTableIfNotExists ( ) ; } catch ( com.google.gwtorm.server.OrmException e ) { com.google.gerrit.server.schema.H2AccountPatchReviewStore.log.error ( "Failed to create table to store account patch reviews" , e ) ; } }
private com.google.gerrit.server.git.strategy.SubmitStrategy createStrategy ( com.google.gerrit.server.git.MergeOp.OpenRepo or , com.google.gerrit.server.git.MergeTip mergeTip , com.google.gerrit.reviewdb.client.Branch.NameKey destBranch , com.google.gerrit.extensions.client.SubmitType submitType , com.google.gerrit.server.git.CodeReviewCommit branchTip ) throws com.google.gerrit.server.git.IntegrationException { return submitStrategyFactory.create ( submitType , db , or.repo , or.rw , or.ins , or.canMergeFlag , getAlreadyAccepted ( or , branchTip ) , destBranch , caller , mergeTip , commits , submissionId ) ; }
private void delete ( final java.util.List < org.eclipse.jgit.transport.RemoteRefUpdate > cmds , final org.eclipse.jgit.transport.RefSpec spec ) throws java.io.IOException { final java.lang.String dst = spec.getDestination ( ) ; final boolean force = spec.isForceUpdate ( ) ; cmds.add ( new org.eclipse.jgit.transport.RemoteRefUpdate ( db , null , dst , force , null , null ) ) ; }
public void run ( ) { java.nio.file.Path pluginPath = pluginDir.resolve ( ( ( pluginName ) + ".ssh" ) ) ; try { java.nio.file.Files.copy ( pluginPath , out ) ; } catch ( java.io.IOException e ) { throw new java.lang.RuntimeException ( ( "Cannot read plugin content of " + pluginPath ) , e ) ; } }
private static void validateLabels ( java.util.Collection < java.lang.String > labels ) { if ( labels == null ) { return ; } java.util.SortedSet < java.lang.String > invalidLabels = new java.util.TreeSet < > ( ) ; for ( java.lang.String label : labels ) { if ( com.google.common.base.CharMatcher.whitespace ( ) . matchesAnyOf ( label ) ) { invalidLabels.add ( label ) ; } } if ( ! ( invalidLabels.isEmpty ( ) ) ) { throw com.google.gerrit.server.StarredChangesUtil.IllegalLabelException.invalidLabels ( invalidLabels ) ; } }
void init ( javax.servlet.ServletContext context ) { runtime.setBaseFolder ( sitePaths.site_path ) ; runtime.getStatus ( ) . servletContainer = context.getServerInfo ( ) ; runtime.start ( ) ; startManager ( notificationManager ) ; startManager ( userManager ) ; startManager ( authenticationManager ) ; startManager ( repositoryManager ) ; startManager ( projectManager ) ; startManager ( gitblit ) ; logger.info ( "All Gitblit managers started." ) ; }
public boolean isReviewer ( com.google.gerrit.reviewdb.server.ReviewDb db , @ com.google.gerrit.common.Nullable com.google.gerrit.server.query.change.ChangeData cd ) throws com.google.gwtorm.server.OrmException { if ( getUser ( ) . isIdentifiedUser ( ) ) { java.util.Collection < com.google.gerrit.reviewdb.client.Account.Id > results = changeData ( db , cd ) . reviewers ( ) . values ( ) ; return results.contains ( getUser ( ) . getAccountId ( ) ) ; } return false ; }
public com.google.gerrit.extensions.common.ChangeInfo createMergePatchSet ( com.google.gerrit.extensions.common.MergePatchSetInput in ) throws com.google.gerrit.extensions.restapi.RestApiException { try { return updateByMerge.apply ( change , in ) . value ( ) ; } catch ( java.io.IOException | com.google.gerrit.server.update.UpdateException | com.google.gerrit.server.project.InvalidChangeOperationException | com.google.gwtorm.server.OrmException e ) { throw new com.google.gerrit.extensions.restapi.RestApiException ( "Cannot update change by merge" , e ) ; } }
public void set ( com.google.gerrit.reviewdb.client.PatchSet.Id base , com.google.gerrit.reviewdb.client.PatchSet.Id curr , com.google.gerrit.client.change.ChangeScreen2.Style style , com.google.gwt.user.client.ui.Widget editButton , com.google.gwt.user.client.ui.Widget replyButton ) { this . base = base ; this . curr = curr ; this . style = style ; this . editButton = editButton ; this . replyButton = replyButton ; }
public void setUp ( ) throws java.lang.Exception { executorMock = createStrictMock ( WorkQueue.Executor.class ) ; com.google.gerrit.server.git.WorkQueue workQueueMock = createNiceMock ( com.google.gerrit.server.git.WorkQueue.class ) ; org.easymock.EasyMock.expect ( workQueueMock.createQueue ( 4 , "Sync remote index" ) ) . andReturn ( executorMock ) ; com.ericsson.gerrit.plugins.syncindex.Configuration configMock = createStrictMock ( com.ericsson.gerrit.plugins.syncindex.Configuration.class ) ; org.easymock.EasyMock.expect ( configMock.getThreadPoolSize ( ) ) . andReturn ( 4 ) ; replayAll ( ) ; syncIndexExecutorProvider = new com.ericsson.gerrit.plugins.syncindex.SyncIndexExecutorProvider ( workQueueMock , configMock ) ; }
public void testBlockPushDrafts ( ) { com.google.gerrit.server.project.Util.grant ( util.getParentConfig ( ) , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.REGISTERED , "refs/for/refs/*" ) ; com.google.gerrit.server.project.Util.grant ( util.getParentConfig ( ) , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.ANONYMOUS , "refs/drafts/*" ) . setBlock ( ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local ) ; org.junit.Assert.assertTrue ( "can upload refs/heads/master" , u.controlForRef ( "refs/heads/master" ) . canUpload ( ) ) ; org.junit.Assert.assertTrue ( "push is blocked to refs/drafts/master" , u.controlForRef ( "refs/drafts/refs/heads/master" ) . isBlocked ( com.google.gerrit.common.data.Permission.PUSH ) ) ; }
public void blockPushDrafts ( ) { com.google.gerrit.server.project.Util.allow ( parent , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS , "refs/for/refs/*" ) ; com.google.gerrit.server.project.Util.block ( parent , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/drafts/*" ) ; com.google.gerrit.server.project.ProjectControl u = user ( local ) ; assertCreateChange ( "refs/heads/master" , u ) ; assertBlocked ( com.google.gerrit.common.data.Permission.PUSH , "refs/drafts/refs/heads/master" , u ) ; }
public boolean deleteChangeFromIndex ( int changeId ) { try { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpResponseHandler.HttpResult result = httpSession.delete ( buildIndexEndpoint ( changeId ) ) ; if ( result.isSuccessful ( ) ) { return true ; } com.ericsson.gerrit.plugins.highavailability.forwarder.rest.RestForwarder.log.error ( "Unable to delete from index change {}. Cause: {}" , changeId , result.getMessage ( ) ) ; } catch ( java.io.IOException e ) { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.RestForwarder.log.error ( ( "Error trying to delete from index change " + changeId ) , e ) ; } return false ; }
public void onSuccess ( final com.google.gerrit.client.diff.DiffInfo diffInfo ) { diff = diffInfo ; new net.codemirror.lib.ModeInjector ( ) . add ( com.google.gerrit.client.diff.CodeMirrorDemo.getContentType ( diff.meta_a ( ) ) ) . add ( com.google.gerrit.client.diff.CodeMirrorDemo.getContentType ( diff.meta_b ( ) ) ) . inject ( loadCallback ) ; }
private java.lang.String readEmail ( ) { java.lang.String email = ui.readString ( "admin@example.com" , "email" ) ; if ( ( email != null ) && ( ! ( org.apache.commons.validator.routines.EmailValidator.getInstance ( ) . isValid ( email ) ) ) ) { ui.message ( "error: invalid email address\n" ) ; return readEmail ( ) ; } return email ; }
private void addExtensionPoints ( com.google.gerrit.client.info.ChangeInfo change ) { addExtensionPoint ( GerritUiExtensionPoint.CHANGE_SCREEN_HEADER , headerExtension , change ) ; addExtensionPoint ( GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_BUTTONS , headerExtensionMiddle , change ) ; addExtensionPoint ( GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS , headerExtensionRight , change ) ; addExtensionPoint ( GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK , changeExtension , change ) ; }
private com.google.gerrit.acceptance.RestResponse publishPatchSet ( java.lang.String changeId ) throws java.lang.Exception { com.google.gerrit.reviewdb.client.PatchSet patchSet = com.google.common.collect.Iterables.getOnlyElement ( queryProvider.get ( ) . byKeyPrefix ( changeId ) ) . currentPatchSet ( ) ; return adminSession.post ( ( ( ( ( "/changes/" + changeId ) + "/revisions/" ) + ( patchSet.getRevision ( ) . get ( ) ) ) + "/publish" ) ) ; }
private java.util.Collection < com.google.gerrit.reviewdb.client.ChangeMessage > filterChangeMessages ( ) { final com.google.common.base.Predicate < com.google.gerrit.reviewdb.client.PatchSet.Id > upToCurrent = upToCurrentPredicate ( ) ; return com.google.common.collect.Collections2.filter ( changeMessages , new com.google.common.base.Predicate < com.google.gerrit.reviewdb.client.ChangeMessage > ( ) { @ java.lang.Override public boolean apply ( com.google.gerrit.reviewdb.client.ChangeMessage in ) { com.google.gerrit.reviewdb.client.PatchSet.Id psId = in.getPatchSetId ( ) ; if ( psId == null ) { return true ; } return ( upToCurrent.apply ( psId ) ) && ( patchSets.containsKey ( psId ) ) ; } } ) ; }
public void onSuccess ( com.google.gerrit.client.changes.ChangeList result ) { com.google.gwt.core.client.JsArray < com.google.gerrit.client.change.RelatedChanges.ChangeAndCommit > changes = convertChangeList ( result ) ; if ( ( changes.length ( ) ) > 0 ) { getTab ( ) . setTitle ( Resources.M.sameTopic ( changes.length ( ) ) ) ; getTab ( ) . setChanges ( info.project ( ) , revision , changes ) ; } }
private com.google.gerrit.server.group.GroupJson.GroupInfo GET_ONE ( java.lang.String endpoint ) throws java.io.IOException { com.google.gerrit.acceptance.RestResponse r = adminSession.get ( endpoint ) ; com.google.common.truth.Truth.assertThat ( r.getStatusCode ( ) ) . isEqualTo ( HttpStatus.SC_OK ) ; return newGson ( ) . fromJson ( r.getReader ( ) , com.google.gerrit.server.group.GroupJson.GroupInfo.class ) ; }
private static boolean isUnifiedPatchLink ( final com.google.gerrit.reviewdb.client.Patch patch ) { return ( patch.getPatchType ( ) . equals ( PatchType.BINARY ) ) || ( com.google.gerrit.client.Gerrit.getUserAccount ( ) . getGeneralPreferences ( ) . getDiffView ( ) . equals ( DiffView.UNIFIED_DIFF ) ) ; }
public void run ( ) { try { com.google.gerrit.server.mail.CreateChangeSender cm = createChangeSenderFactory.create ( change.getId ( ) ) ; cm.setFrom ( change.getOwner ( ) ) ; cm.setPatchSet ( patchSet , patchSetInfo ) ; cm.addReviewers ( reviewers ) ; cm.addExtraCC ( extraCC ) ; cm.send ( ) ; } catch ( java.lang.Exception e ) { com.google.gerrit.server.change.ChangeInserter.log.error ( ( "Cannot send email for new change " + ( change.getId ( ) ) ) , e ) ; } }
public static java.io.File storeInTemp ( java.lang.String pluginName , java.io.InputStream in , com.google.gerrit.server.config.SitePaths sitePaths ) throws java.io.IOException { if ( ! ( java.nio.file.Files.exists ( sitePaths.tmp_dir ) ) ) { java.nio.file.Files.createDirectories ( sitePaths.tmp_dir ) ; } return com.google.gerrit.server.plugins.PluginLoader.asTemp ( in , com.google.gerrit.server.plugins.JarPluginProvider.tempNameFor ( pluginName ) , ".jar" , sitePaths.tmp_dir.toFile ( ) ) ; }
private java.util.List < java.lang.reflect.Field > fieldsOf ( java.lang.Class < ? > type ) { java.util.List < java.lang.reflect.Field > r = new java.util.ArrayList < > ( ) ; if ( ( type.getSuperclass ( ) ) != null ) { r.addAll ( fieldsOf ( type.getSuperclass ( ) ) ) ; } r.addAll ( java.util.Arrays.asList ( type.getDeclaredFields ( ) ) ) ; return r ; }
public void rejectMissingEmail ( ) throws java.lang.Exception { com.google.common.truth.TruthJUnit.assume ( ) . that ( notesMigration.enabled ( ) ) . isTrue ( ) ; com.google.gerrit.acceptance.PushOneCommit.Result r = createChange ( ) ; exception.expect ( com.google.gerrit.extensions.restapi.UnprocessableEntityException.class ) ; exception.expectMessage ( "email invalid" ) ; gApi.changes ( ) . id ( r.getChangeId ( ) ) . addReviewer ( "" ) ; }
public static java.util.List < com.google.gerrit.reviewdb.client.Change > scan ( com.google.gerrit.server.notedb.NotesMigration notesMigration , com.google.gerrit.server.notedb.ChangeNotes.Factory notesFactory , org.eclipse.jgit.lib.Repository repo , com.google.gerrit.reviewdb.server.ReviewDb db , com.google.gerrit.reviewdb.client.Project.NameKey project ) throws com.google.gwtorm.server.OrmException , java.io.IOException { if ( ! ( notesMigration.readChanges ( ) ) ) { return com.google.gerrit.server.git.ScanningChangeCacheImpl.scanDb ( repo , db ) ; } return com.google.gerrit.server.git.ScanningChangeCacheImpl.scanNotedb ( notesFactory , repo , db , project ) ; }
public static com.google.common.cache.CacheBuilder < com.google.gitiles.blame.BlameCacheImpl.Key , java.util.List < com.google.gitiles.blame.Region > > weigher ( com.google.common.cache.CacheBuilder < ? super com.google.gitiles.blame.BlameCacheImpl.Key , ? super java.util.List < com.google.gitiles.blame.Region > > builder ) { return builder.weigher ( new com.google.common.cache.Weigher < com.google.gitiles.blame.BlameCacheImpl.Key , java.util.List < com.google.gitiles.blame.Region > > ( ) { @ java.lang.Override public int weigh ( com.google.gitiles.blame.BlameCacheImpl.Key key , java.util.List < com.google.gitiles.blame.Region > value ) { return value.size ( ) ; } } ) ; }
public void testUnblockVisibilityByRegisteredUsers ( ) { com.google.gerrit.server.project.Util.block ( local , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/heads/*" ) ; com.google.gerrit.server.project.Util.allow ( local , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS , "refs/heads/*" ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS ) ; org.junit.Assert.assertTrue ( "u can read" , u.controlForRef ( "refs/heads/master" ) . isVisibleByRegisteredUsers ( ) ) ; }
public com.google.gerrit.extensions.api.changes.ChangeApi revert ( com.google.gerrit.extensions.api.changes.RevertInput in ) throws com.google.gerrit.extensions.restapi.RestApiException { try { return changeApi.id ( revert.apply ( change , in ) . _number ) ; } catch ( com.google.gwtorm.server.OrmException | java.io.IOException | com.google.gerrit.server.update.UpdateException e ) { throw new com.google.gerrit.extensions.restapi.RestApiException ( "Cannot revert change" , e ) ; } }
public com.googlesource.gerrit.plugins.lfs.LfsProjectConfigInfo apply ( com.google.gerrit.server.project.ProjectResource resource ) throws com.google.gerrit.extensions.restapi.RestApiException { com.googlesource.gerrit.plugins.lfs.LfsProjectConfigInfo info = new com.googlesource.gerrit.plugins.lfs.LfsProjectConfigInfo ( ) ; com.googlesource.gerrit.plugins.lfs.LfsProjectConfigSection config = lfsConfigFactory.getProjectsConfig ( ) . getForProject ( resource.getNameKey ( ) ) ; if ( config != null ) { info.enabled = config.isEnabled ( ) ; info.maxObjectSize = config.getMaxObjectSize ( ) ; } return info ; }
public void publishesWhenMessageMatchesIgnore ( ) throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig ( ) ; mockEvent.change = com.google.common.base.Suppliers.ofInstance ( mockChange ) ; mockChange.commitMessage = "WIP:This is a title\nAnd a the body." ; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator ; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance ( mockEvent , config ) ; org.junit.Assert.assertThat ( messageGenerator.shouldPublish ( ) , org.hamcrest.core.Is.is ( true ) ) ; }
public void testRejectJavaScript_FormAction ( ) { final java.lang.String href = "javascript:window.close();" ; try { new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder ( ) . openElement ( "form" ) . setAttribute ( "action" , href ) ; fail ( "accepted javascript in form action" ) ; } catch ( java.lang.RuntimeException e ) { assertEquals ( ( "javascript unsafe in href: " + href ) , e.getMessage ( ) ) ; } }
private void applyAllSuccess ( ) { if ( ( ( ! ( failed ) ) && ( finalAdded ) ) && ( remaining.isEmpty ( ) ) ) { for ( com.google.gerrit.client.rpc.CallbackGroup.CallbackImpl < ? > cb : callbacks ) { cb.applySuccess ( ) ; } callbacks.clear ( ) ; } }
protected void configure ( ) { install ( new com.google.gerrit.extensions.restapi.RestApiModule ( ) { @ java.lang.Override protected void configure ( ) { post ( com.google.gerrit.server.change.RevisionResource.REVISION_KIND , "say-hello" ) . to ( com.googlesource.gerrit.plugins.cookbook.HelloWorldAction.class ) ; } } ) ; }
public com.google.gerrit.client.diff.DiffApi base ( com.google.gerrit.reviewdb.client.PatchSet.Id id ) { if ( id != null ) { call.addParameter ( "base" , id.get ( ) ) ; } return this ; }
protected void onPostExecute ( java.lang.String errorMsg ) { if ( errorMsg != null ) { widgetUtil.showError ( errorMsg ) ; } else { com.google.reviewit.AddReviewerFragment fragment = new com.google.reviewit.AddReviewerFragment ( ) ; android.os.Bundle bundle = new android.os.Bundle ( ) ; bundle.putAll ( getArguments ( ) ) ; fragment.setArguments ( bundle ) ; display ( fragment , false ) ; } }
public void testUnblockForceWithAllowNoForce_NotPossible ( ) { com.google.gerrit.common.data.PermissionRule r = com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.Util.ANONYMOUS , "refs/heads/*" ) ; r.setBlock ( ) ; r.setForce ( true ) ; com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.Util.DEVS , "refs/heads/*" ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.project.Util.DEVS ) ; assertFalse ( "u can't force push" , u.controlForRef ( "refs/heads/master" ) . canForceUpdate ( ) ) ; }
private com.google.gerrit.client.diff.DraftBox addDraftBox ( com.google.gerrit.client.changes.CommentInfo info , boolean doSave ) { com.google.gerrit.client.diff.DraftBox box = new com.google.gerrit.client.diff.DraftBox ( this , revision , info , commentLinkProcessor , true , doSave ) ; addCommentBox ( info , box ) ; if ( ! doSave ) { box.setEdit ( true ) ; } getLineBoxMapFromSide ( info.side ( ) ) . put ( ( ( info.line ( ) ) - 1 ) , box ) ; return box ; }
public boolean match ( T object ) throws com.google.gwtorm.server.OrmException { for ( com.google.gerrit.server.query.Predicate < T > c : children ) { com.google.common.base.Preconditions.checkState ( c.isMatchable ( ) , "match invoked, but child predicate %s doesn't implement %s" , c , com.google.gerrit.server.query.Matchable.class . getName ( ) ) ; if ( c.asMatchable ( ) . match ( object ) ) { return true ; } } return false ; }
public void onSuccess ( com.google.gerrit.client.VoidResult result ) { for ( int row = 1 ; row < ( table.getRowCount ( ) ) ; ) { com.google.gerrit.client.projects.BranchInfo k = getRowItem ( row ) ; if ( ( k != null ) && ( branches.contains ( k.ref ( ) ) ) ) { table.removeRow ( row ) ; } else { row ++ ; } } }
public void errorWhileSendingErrorMessage ( ) throws java.lang.Exception { org.easymock.EasyMock.expect ( request.getPathInfo ( ) ) . andReturn ( "/someCache" ) ; java.lang.String errorMessage = "someError" ; org.easymock.EasyMock.expect ( request.getReader ( ) ) . andThrow ( new java.io.IOException ( errorMessage ) ) ; response.sendError ( javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST , errorMessage ) ; org.easymock.EasyMock.expectLastCall ( ) . andThrow ( new java.io.IOException ( "someOtherError" ) ) ; replayAll ( ) ; servlet.doPost ( request , response ) ; verifyAll ( ) ; }
public java.lang.Void call ( ) throws java.io.IOException { for ( com.google.gerrit.server.index.change.ChangeIndex i : getWriteIndexes ( ) ) { i.delete ( id ) ; } fireChangeDeletedFromIndexEvent ( id.get ( ) ) ; return null ; }
public com.google.common.collect.ImmutableSetMultimap < com.google.gerrit.server.notedb.ReviewerState , com.google.gerrit.reviewdb.client.Account.Id > getReviewers ( com.google.gerrit.server.notedb.ChangeNotes notes , java.lang.Iterable < com.google.gerrit.reviewdb.client.PatchSetApproval > allApprovals ) throws com.google.gwtorm.server.OrmException { if ( ! ( migration.readPatchSetApprovals ( ) ) ) { return com.google.gerrit.server.ApprovalsUtil.getReviewers ( allApprovals ) ; } return notes.load ( ) . getReviewers ( ) ; }
public void onSuccess ( final com.google.gerrit.common.data.HostPageData result ) { com.google.gwt.dom.client.Document.get ( ) . getElementById ( "gerrit_hostpagedata" ) . removeFromParent ( ) ; com.google.gerrit.client.Gerrit.myConfig = result.config ; com.google.gerrit.client.Gerrit.myTheme = result.theme ; com.google.gerrit.client.Gerrit.isNoteDbEnabled = result.isNoteDbEnabled ; if ( ( result.account ) != null ) { com.google.gerrit.client.Gerrit.myAccount = result.account ; com.google.gerrit.client.Gerrit.xGerritAuth = result.xGerritAuth ; } if ( ( result.accountDiffPref ) != null ) { com.google.gerrit.client.Gerrit.myAccountDiffPref = result.accountDiffPref ; com.google.gerrit.client.Gerrit.applyUserPreferences ( ) ; } onModuleLoad2 ( result ) ; }
public void newPatchSetByOtherOnReviewableChangeInReviewDb ( ) throws java.lang.Exception { com.google.common.truth.TruthJUnit.assume ( ) . that ( notesMigration.readChanges ( ) ) . isFalse ( ) ; com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.NEW_PATCHSETS ) ; pushTo ( sc , "refs/for/master" , other ) ; assertThat ( sender ) . sent ( "newpatchset" , sc ) . notTo ( sc.owner ) . to ( sc.reviewer , sc.ccer , other ) . notTo ( sc.reviewerByEmail , sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.NEW_PATCHSETS ) ; }
public boolean apply ( java.lang.String refPart ) { return refPart.endsWith ( ( "/" + ( changeId.get ( ) ) ) ) ; }
protected org.apache.sshd.common.session.AbstractSession createSession ( final org.apache.mina.core.session.IoSession ioSession ) throws java.lang.Exception { final org.apache.sshd.common.session.AbstractSession s = super . createSession ( ioSession ) ; s.setAttribute ( SshUtil.REMOTE_PEER , ioSession.getRemoteAddress ( ) ) ; return s ; }
public void testUnblockLargerScope_Fails ( ) { com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/heads/master" ) . setBlock ( ) ; com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.Util.DEVS , "refs/heads/*" ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.project.Util.DEVS ) ; org.junit.Assert.assertFalse ( "u can't push" , u.controlForRef ( "refs/heads/master" ) . canUpdate ( ) ) ; }
protected void deny ( java.lang.String permission , com.google.gerrit.reviewdb.client.AccountGroup.UUID id , java.lang.String ref ) throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet ( project ) . getConfig ( ) ; com.google.gerrit.server.project.Util.deny ( cfg , permission , id , ref ) ; saveProjectConfig ( project , cfg ) ; }
private void addSuggestion ( java.util.Map < com.google.gerrit.reviewdb.client.Account.Id , com.google.gerrit.common.data.AccountInfo > map , com.google.gerrit.reviewdb.client.Account account , com.google.gerrit.common.data.AccountInfo info , java.lang.Boolean active ) { if ( map.containsKey ( account.getId ( ) ) ) { return ; } if ( ( active != null ) && ( active != ( account.isActive ( ) ) ) ) { return ; } if ( accountControlFactory.get ( ) . canSee ( account ) ) { map.put ( account.getId ( ) , info ) ; } }
public void stop ( ) { scanner.end ( ) ; synchronized ( this ) { for ( com.google.gerrit.server.plugins.Plugin p : running.values ( ) ) { p.stop ( ) ; } running.clear ( ) ; broken.clear ( ) ; } }
public void testPushForNonExistingBranch ( ) throws com.google.gwtorm.server.OrmException , java.io.IOException , org.eclipse.jgit.api.errors.GitAPIException { java.lang.String branchName = "non-existing" ; com.google.gerrit.acceptance.git.PushOneCommit.Result r = pushTo ( ( "refs/for/" + branchName ) ) ; r.assertErrorStatus ( ( ( "branch " + branchName ) + " not found" ) ) ; }
private void fireRefUpdated ( org.eclipse.jgit.lib.RefUpdate branchUpdate ) { gitRefUpdated.fire ( destBranch.getParentKey ( ) , branchUpdate ) ; com.google.gerrit.reviewdb.client.Account account = null ; com.google.gerrit.reviewdb.client.PatchSetApproval submitter = approvalsUtil.getSubmitter ( db , mergeTip.notes ( ) , mergeTip.getPatchsetId ( ) ) ; if ( submitter != null ) { account = accountCache.get ( submitter.getAccountId ( ) ) . getAccount ( ) ; } hooks.doRefUpdatedHook ( destBranch , branchUpdate , account ) ; }
protected com.google.gerrit.server.notedb.LoadHandle openHandle ( org.eclipse.jgit.lib.Repository repo ) throws java.io.IOException { if ( autoRebuild ) { com.google.gerrit.server.notedb.NoteDbChangeState state = com.google.gerrit.server.notedb.NoteDbChangeState.parse ( change ) ; if ( ( state == null ) || ( ! ( state.isChangeUpToDate ( repo ) ) ) ) { return rebuildAndOpen ( repo ) ; } } return super . openHandle ( repo ) ; }
protected org.eclipse.jgit.revwalk.RevCommit getRemoteHead ( com.google.gerrit.reviewdb.client.Project ... projects ) throws java.io.IOException { com.google.common.truth.Truth.assertThat ( projects.length ) . isLessThan ( 2 ) ; com.google.gerrit.reviewdb.client.Project.NameKey project = this . project ; if ( ( projects.length ) > 0 ) { project = projects [ 0 ] ; } try ( org.eclipse.jgit.lib.Repository repo = repoManager.openRepository ( project ) ) { return getHead ( repo , "refs/heads/master" ) ; } }
public java.lang.String decode ( java.lang.String s ) { try { javax.crypto.Cipher encoder = getCipher ( ) ; java.security.Key sKey = generateKey ( ) ; encoder.init ( javax.crypto.Cipher.DECRYPT_MODE , sKey , getCipherParameterSpec ( ) ) ; return new java.lang.String ( encoder.doFinal ( java.util.Base64.getDecoder ( ) . decode ( s ) ) , config.getEncoding ( ) ) ; } catch ( java.lang.Exception e ) { com.googlesource.gerrit.plugins.secureconfig.PBECodec.log.error ( "decode() failed" , e ) ; throw new java.lang.IllegalArgumentException ( "encode() failed" , e ) ; } }
private static org.eclipse.jgit.dircache.DirCacheEditor.PathEdit getPathEdit ( com.google.gerrit.server.edit.ChangeEditModifier.TreeOperation op , org.eclipse.jgit.revwalk.RevWalk rw , org.eclipse.jgit.revwalk.RevCommit base , java.lang.String path , org.eclipse.jgit.lib.ObjectInserter ins , byte [ ] content ) throws com.google.gerrit.server.project.InvalidChangeOperationException , java.io.IOException { final org.eclipse.jgit.lib.ObjectId oid = ( op == ( com.google.gerrit.server.edit.ChangeEditModifier.TreeOperation.CHANGE_ENTRY ) ) ? ins.insert ( Constants.OBJ_BLOB , content ) : com.google.gerrit.server.edit.ChangeEditModifier.getObjectIdForRestoreOperation ( rw , base , path ) ; return new org.eclipse.jgit.dircache.DirCacheEditor.PathEdit ( path ) { @ java.lang.Override public void apply ( org.eclipse.jgit.dircache.DirCacheEntry ent ) { ent.setFileMode ( FileMode.REGULAR_FILE ) ; ent.setObjectId ( oid ) ; } } ; }
public void display ( final java.util.List < com.google.gerrit.common.data.AccountProjectWatchInfo > result ) { while ( 2 < ( table.getRowCount ( ) ) ) { table.removeRow ( ( ( table.getRowCount ( ) ) - 1 ) ) ; } for ( final com.google.gerrit.common.data.AccountProjectWatchInfo k : result ) { final int row = table.getRowCount ( ) ; table.insertRow ( row ) ; applyDataRowStyle ( row ) ; populate ( row , k ) ; } }
public void setStars ( java.lang.String changeId , com.google.gerrit.extensions.api.changes.StarsInput input ) throws com.google.gerrit.extensions.restapi.RestApiException { try { com.google.gerrit.server.account.AccountResource.Star rsrc = stars.parse ( account , com.google.gerrit.extensions.restapi.IdString.fromUrl ( changeId ) ) ; starsPost.apply ( rsrc , input ) ; } catch ( com.google.gwtorm.server.OrmException e ) { throw new com.google.gerrit.extensions.restapi.RestApiException ( "Cannot post stars" , e ) ; } }
public void createDraftChangeNotAllowed ( ) throws java.lang.Exception { com.google.common.truth.TruthJUnit.assume ( ) . that ( isAllowDrafts ( ) ) . isFalse ( ) ; com.google.gerrit.extensions.common.ChangeInfo ci = newChangeInfo ( ChangeStatus.DRAFT ) ; com.google.gerrit.acceptance.RestResponse r = adminSession.post ( "/changes/" , ci ) ; com.google.common.truth.Truth.assertThat ( r.getStatusCode ( ) ) . isEqualTo ( HttpStatus.SC_METHOD_NOT_ALLOWED ) ; com.google.common.truth.Truth.assertThat ( r.getEntityContent ( ) ) . contains ( "draft workflow is disabled" ) ; }
private com.google.gitiles.GitilesView getView ( java.lang.String pathAndQuery ) throws java.io.IOException , javax.servlet.ServletException { com.google.gitiles.TestViewFilter.Result result = com.google.gitiles.TestViewFilter.service ( repo , pathAndQuery ) ; com.google.gitiles.FakeHttpServletResponse resp = result.getResponse ( ) ; org.junit.Assert.assertTrue ( ( "expected non-redirect status, got " + ( resp.getStatus ( ) ) ) , ( ( ( resp.getStatus ( ) ) < 300 ) || ( ( resp.getStatus ( ) ) >= 400 ) ) ) ; return result.getView ( ) ; }
protected void authorizeUser ( com.google.gerrit.server.project.ProjectControl control ) throws org.eclipse.jgit.lfs.errors.LfsUnauthorized { if ( ( com.google.gerrit.common.data.Capable.OK ) != ( control.canPushToAtLeastOneRef ( ) ) ) { throwUnauthorizedOp ( action.getName ( ) , control ) ; } }
public GroupDescription.Basic parse ( java.lang.String id ) throws com.google.gerrit.extensions.restapi.UnprocessableEntityException { com.google.gerrit.common.data.GroupDescription.Basic group = _parse ( id ) ; if ( ( group == null ) || ( ! ( groupControlFactory.controlFor ( group ) . isVisible ( ) ) ) ) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException ( java.lang.String.format ( "Group Not Found: %s" , id ) ) ; } return group ; }
protected void onOpenRow ( final int row ) { final java.lang.Object item = getRowItem ( row ) ; if ( item instanceof com.google.gerrit.client.patches.AbstractPatchContentTable.CommentList ) { for ( final com.google.gerrit.client.ui.ComplexDisclosurePanel p : ( ( com.google.gerrit.client.patches.AbstractPatchContentTable.CommentList ) ( item ) ) . panels ) { p.setOpen ( ( ! ( p.isOpen ( ) ) ) ) ; } } }
public boolean isCancelled ( ) { if ( cancelled ) { status = GitJobStatus.CANCELLED ; } return cancelled ; }
private void initProviderBouncyCastle ( org.eclipse.jgit.lib.Config cfg ) { org.apache.sshd.common.NamedFactory < org.apache.sshd.common.random.Random > factory ; if ( cfg.getBoolean ( "sshd" , null , "testUseInsecureRandom" , false ) ) { factory = new com.google.gerrit.sshd.SshDaemon.InsecureBouncyCastleRandom.Factory ( ) ; } else { factory = org.apache.sshd.common.util.SecurityUtils.getRandomFactory ( ) ; } setRandomFactory ( new org.apache.sshd.common.random.SingletonRandomFactory ( factory ) ) ; }
private java.util.List < com.google.gerrit.client.reviewdb.AccountGroup > myOwnedGroups ( final com.google.gerrit.client.reviewdb.ReviewDb db ) throws com.google.gwtorm.client.OrmException { final com.google.gerrit.client.reviewdb.Account.Id me = com.google.gerrit.client.rpc.RpcUtil.getAccountId ( ) ; final java.util.List < com.google.gerrit.client.reviewdb.AccountGroup > own = new java.util.ArrayList < com.google.gerrit.client.reviewdb.AccountGroup > ( ) ; for ( final com.google.gerrit.client.reviewdb.AccountGroup.Id groupId : groupCache.getGroups ( me ) ) { for ( final com.google.gerrit.client.reviewdb.AccountGroup g : db.accountGroups ( ) . ownedByGroup ( groupId ) ) { own.add ( g ) ; } } return own ; }
public void rescan ( boolean forceCleanup ) { if ( ( rescanImp ( ) ) || forceCleanup ) { java.lang.System.gc ( ) ; processPendingCleanups ( ) ; } }
private static java.util.Map < java.lang.String , com.google.gerrit.extensions.common.ProjectInfo > toProjectInfoMap ( com.google.gerrit.acceptance.RestResponse r ) throws java.io.IOException { java.util.Map < java.lang.String , com.google.gerrit.extensions.common.ProjectInfo > result = newGson ( ) . fromJson ( r.getReader ( ) , new com.google.gson.reflect.TypeToken < java.util.Map < java.lang.String , com.google.gerrit.extensions.common.ProjectInfo > > ( ) { } . getType ( ) ) ; return result ; }
public boolean equals ( java.lang.Object obj ) { return java.util.Objects.deepEquals ( this , obj ) ; }
private void enableForm ( final boolean canModifyAgreements , final boolean canModifyDescription , final boolean canModifyMergeType ) { submitType.setEnabled ( canModifyMergeType ) ; useContentMerge.setEnabled ( canModifyMergeType ) ; descTxt.setEnabled ( canModifyDescription ) ; useContributorAgreements.setEnabled ( canModifyAgreements ) ; useSignedOffBy.setEnabled ( canModifyAgreements ) ; requireChangeID.setEnabled ( canModifyMergeType ) ; }
private void addExtensionPoints ( com.google.gerrit.client.info.ChangeInfo change , com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev ) { addExtensionPoint ( GerritUiExtensionPoint.CHANGE_SCREEN_HEADER , headerExtension , change , rev ) ; addExtensionPoint ( GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_BUTTONS , headerExtensionMiddle , change , rev ) ; addExtensionPoint ( GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS , headerExtensionRight , change , rev ) ; addExtensionPoint ( GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK , changeExtension , change , rev ) ; addExtensionPoint ( GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_RELATED_INFO_BLOCK , relatedExtension , change , rev ) ; addExtensionPoint ( GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_COMMIT_INFO_BLOCK , commitExtension , change , rev ) ; }
public void setUp ( ) throws java.lang.Exception { normalProject = createProject ( "normal" ) ; secretProject = createProject ( "secret" ) ; secretRefProject = createProject ( "secretRef" ) ; privilegedGroup = groupCache.get ( new com.google.gerrit.reviewdb.client.AccountGroup.NameKey ( createGroup ( "privilegedGroup" ) ) ) ; privilegedUser = accounts.create ( "privilegedUser" , "snowden@nsa.gov" , "Ed Snowden" ) ; gApi.groups ( ) . id ( privilegedGroup.getGroupUUID ( ) . get ( ) ) . addMembers ( privilegedUser.username ) ; com.google.common.truth.Truth.assertThat ( gApi.groups ( ) . id ( privilegedGroup.getGroupUUID ( ) . get ( ) ) . members ( ) . get ( 0 ) . email ) . contains ( "snowden" ) ; grant ( secretProject , "refs/*" , Permission.READ , false , privilegedGroup.getGroupUUID ( ) ) ; block ( secretProject , "refs/*" , Permission.READ , SystemGroupBackend.REGISTERED_USERS ) ; deny ( secretRefProject , "refs/*" , Permission.READ , SystemGroupBackend.ANONYMOUS_USERS ) ; grant ( secretRefProject , "refs/heads/secret/*" , Permission.READ , false , privilegedGroup.getGroupUUID ( ) ) ; block ( secretRefProject , "refs/heads/secret/*" , Permission.READ , SystemGroupBackend.REGISTERED_USERS ) ; grant ( secretRefProject , "refs/heads/*" , Permission.READ , false , SystemGroupBackend.REGISTERED_USERS ) ; }
public void byProject ( ) throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository < com.google.gerrit.testutil.InMemoryRepositoryManager.Repo > repo1 = createProject ( "repo1" ) ; org.eclipse.jgit.junit.TestRepository < com.google.gerrit.testutil.InMemoryRepositoryManager.Repo > repo2 = createProject ( "repo2" ) ; com.google.gerrit.reviewdb.client.Change change1 = newChange ( repo1 , null , null , null , null ) . insert ( ) ; com.google.gerrit.reviewdb.client.Change change2 = newChange ( repo2 , null , null , null , null ) . insert ( ) ; assertQuery ( "project:foo" ) ; assertQuery ( "project:repo" ) ; assertQuery ( "project:repo1" , change1 ) ; assertQuery ( "project:repo2" , change2 ) ; }
private void dropRemovedDisabledPlugins ( java.util.List < java.io.File > jars ) { java.util.Set < java.lang.String > unload = com.google.common.collect.Sets.newHashSet ( disabled.keySet ( ) ) ; for ( java.io.File jar : jars ) { unload.remove ( com.google.gerrit.server.plugins.PluginLoader.nameOf ( jar ) ) ; } for ( java.lang.String name : unload ) { disabled.remove ( name ) ; } }
protected void onLoad ( ) { super . onLoad ( ) ; com.google.gerrit.client.rpc.CallbackGroup cmGroup = new com.google.gerrit.client.rpc.CallbackGroup ( ) ; net.codemirror.lib.CodeMirror.initLibrary ( cmGroup.add ( com.google.gerrit.client.rpc.CallbackGroup.< java.lang.Void > emptyCallback ( ) ) ) ; initPath ( ) ; com.google.gerrit.client.changes.ChangeFileApi.getContentOrMessage ( revision , path , cmGroup.addFinal ( new com.google.gerrit.client.rpc.ScreenLoadCallback < java.lang.String > ( this ) { @ java.lang.Override protected void preDisplay ( java.lang.String content ) { initEditor ( content ) ; } } ) ) ; }
protected void afterExecute ( java.lang.Runnable r , java.lang.Throwable t ) { final com.google.gerrit.server.git.WorkQueue.Task < ? > task = ( ( com.google.gerrit.server.git.WorkQueue.Task < ? > ) ( r ) ) ; if ( ! ( task.isPeriodic ( ) ) ) { remove ( task ) ; } super . afterExecute ( r , t ) ; }
private void initAllProjects ( org.eclipse.jgit.lib.Repository git ) throws java.io.IOException , org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.BatchRefUpdate bru = git.getRefDatabase ( ) . newBatchUpdate ( ) ; try ( com.google.gerrit.server.git.MetaDataUpdate md = new com.google.gerrit.server.git.MetaDataUpdate ( com.google.gerrit.server.extensions.events.GitReferenceUpdated.DISABLED , allProjectsName , git , bru ) ) { md.getCommitBuilder ( ) . setAuthor ( serverUser ) ; md.getCommitBuilder ( ) . setCommitter ( serverUser ) ; md.setMessage ( com.google.common.base.MoreObjects.firstNonNull ( com.google.common.base.Strings.emptyToNull ( message ) , ( "Initialized Gerrit Code Review " + ( com.google.gerrit.common.Version.getVersion ( ) ) ) ) ) ; com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read ( md ) ; com.google.gerrit.reviewdb.client.Project p = config.getProject ( ) ; p.setDescription ( "Access inherited by all other projects." ) ; p.setRequireChangeID ( InheritableBoolean.TRUE ) ; p.setUseContentMerge ( InheritableBoolean.TRUE ) ; p.setUseContributorAgreements ( InheritableBoolean.FALSE ) ; p.setUseSignedOffBy ( InheritableBoolean.FALSE ) ; p.setEnableSignedPush ( InheritableBoolean.FALSE ) ; com.google.gerrit.common.data.AccessSection cap = config.getAccessSection ( AccessSection.GLOBAL_CAPABILITIES , true ) ; com.google.gerrit.common.data.AccessSection all = config.getAccessSection ( AccessSection.ALL , true ) ; com.google.gerrit.common.data.AccessSection heads = config.getAccessSection ( AccessSection.HEADS , true ) ; com.google.gerrit.common.data.AccessSection tags = config.getAccessSection ( "refs/tags/*" , true ) ; com.google.gerrit.common.data.AccessSection meta = config.getAccessSection ( RefNames.REFS_CONFIG , true ) ; com.google.gerrit.common.data.AccessSection refsFor = config.getAccessSection ( "refs/for/*" , true ) ; com.google.gerrit.common.data.AccessSection magic = config.getAccessSection ( ( "refs/for/" + ( com.google.gerrit.common.data.AccessSection.ALL ) ) , true ) ; com.google.gerrit.server.schema.AclUtil.grant ( config , cap , GlobalCapability.ADMINISTRATE_SERVER , admin ) ; com.google.gerrit.server.schema.AclUtil.grant ( config , all , Permission.READ , admin , anonymous ) ; com.google.gerrit.server.schema.AclUtil.grant ( config , refsFor , Permission.ADD_PATCH_SET , registered ) ; if ( ( batch ) != null ) { com.google.gerrit.common.data.Permission priority = cap.getPermission ( GlobalCapability.PRIORITY , true ) ; com.google.gerrit.common.data.PermissionRule r = com.google.gerrit.server.schema.AclUtil.rule ( config , batch ) ; r.setAction ( Action.BATCH ) ; priority.add ( r ) ; com.google.gerrit.common.data.Permission stream = cap.getPermission ( GlobalCapability.STREAM_EVENTS , true ) ; stream.add ( com.google.gerrit.server.schema.AclUtil.rule ( config , batch ) ) ; } com.google.gerrit.common.data.LabelType cr = com.google.gerrit.server.schema.AllProjectsCreator.initCodeReviewLabel ( config ) ; com.google.gerrit.server.schema.AclUtil.grant ( config , heads , cr , ( - 1 ) , 1 , registered ) ; com.google.gerrit.server.schema.AclUtil.grant ( config , heads , cr , ( - 2 ) , 2 , admin , owners ) ; com.google.gerrit.server.schema.AclUtil.grant ( config , heads , Permission.CREATE , admin , owners ) ; com.google.gerrit.server.schema.AclUtil.grant ( config , heads , Permission.PUSH , admin , owners ) ; com.google.gerrit.server.schema.AclUtil.grant ( config , heads , Permission.SUBMIT , admin , owners ) ; com.google.gerrit.server.schema.AclUtil.grant ( config , heads , Permission.FORGE_AUTHOR , registered ) ; com.google.gerrit.server.schema.AclUtil.grant ( config , heads , Permission.FORGE_COMMITTER , admin , owners ) ; com.google.gerrit.server.schema.AclUtil.grant ( config , heads , Permission.EDIT_TOPIC_NAME , true , admin , owners ) ; com.google.gerrit.server.schema.AclUtil.grant ( config , tags , Permission.CREATE , admin , owners ) ; com.google.gerrit.server.schema.AclUtil.grant ( config , tags , Permission.CREATE_TAG , admin , owners ) ; com.google.gerrit.server.schema.AclUtil.grant ( config , tags , Permission.CREATE_SIGNED_TAG , admin , owners ) ; com.google.gerrit.server.schema.AclUtil.grant ( config , magic , Permission.PUSH , registered ) ; com.google.gerrit.server.schema.AclUtil.grant ( config , magic , Permission.PUSH_MERGE , registered ) ; meta.getPermission ( Permission.READ , true ) . setExclusiveGroup ( true ) ; com.google.gerrit.server.schema.AclUtil.grant ( config , meta , Permission.READ , admin , owners ) ; com.google.gerrit.server.schema.AclUtil.grant ( config , meta , cr , ( - 2 ) , 2 , admin , owners ) ; com.google.gerrit.server.schema.AclUtil.grant ( config , meta , Permission.CREATE , admin , owners ) ; com.google.gerrit.server.schema.AclUtil.grant ( config , meta , Permission.PUSH , admin , owners ) ; com.google.gerrit.server.schema.AclUtil.grant ( config , meta , Permission.SUBMIT , admin , owners ) ; config.commitToNewRef ( md , RefNames.REFS_CONFIG ) ; if ( ( notesMigration.readChangeSequence ( ) ) && ( ( git.exactRef ( ( ( com.google.gerrit.reviewdb.client.RefNames.REFS_SEQUENCES ) + ( com.google.gerrit.server.Sequences.CHANGES ) ) ) ) == null ) ) { try ( org.eclipse.jgit.lib.ObjectInserter ins = git.newObjectInserter ( ) ) { bru.addCommand ( com.google.gerrit.server.notedb.RepoSequence.storeNew ( ins , Sequences.CHANGES , ReviewDb.FIRST_CHANGE_ID ) ) ; ins.flush ( ) ; } } try ( org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk ( git ) ) { bru.execute ( rw , NullProgressMonitor.INSTANCE ) ; } for ( org.eclipse.jgit.transport.ReceiveCommand cmd : bru.getCommands ( ) ) { if ( ( cmd.getResult ( ) ) != ( ReceiveCommand.Result.OK ) ) { throw new java.io.IOException ( ( "Failed to initialize All-Users refs:\n" + bru ) ) ; } } } }
void onEdit ( ) { if ( canEdit ) { show.setVisible ( false ) ; com.google.gwt.user.client.ui.UIObject.setVisible ( form , true ) ; input.setText ( text.getText ( ) ) ; input.setFocus ( true ) ; } }
protected void ccExistingReviewers ( ) { if ( ( ! ( NotifyHandling.ALL.equals ( notify ) ) ) && ( ! ( NotifyHandling.OWNER_REVIEWERS.equals ( notify ) ) ) ) { return ; } try { for ( com.google.gerrit.reviewdb.client.Account.Id id : changeData.reviewers ( ) . get ( com.google.gerrit.server.notedb.ReviewerStateInternal.REVIEWER ) ) { add ( RecipientType.CC , id ) ; } } catch ( com.google.gwtorm.server.OrmException err ) { com.google.gerrit.server.mail.ChangeEmail.log.warn ( "Cannot CC users that commented on updated change" , err ) ; } }
public boolean canRebase ( ) { return rebaseUtil.canRebase ( revision ) ; }
public com.google.gerrit.server.group.GroupJson.GroupInfo format ( com.google.gerrit.server.group.GroupResource rsrc ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.group.GroupJson.GroupInfo info = init ( rsrc.getGroup ( ) ) ; initMembersAndIncludes ( rsrc , info ) ; return info ; }
public void onClick ( com.google.gwt.event.dom.client.ClickEvent event ) { cm.setCursor ( net.codemirror.lib.LineCharacter.create ( line ) ) ; cm.scrollToY ( ( height - ( 0.5 * scrollbarHeight ) ) ) ; cm.focus ( ) ; }
private void deleteAll ( ) throws java.io.IOException { java.io.File file = new java.io.File ( sitePaths.index_dir , "changes" ) ; if ( file.exists ( ) ) { org.apache.lucene.store.Directory dir = org.apache.lucene.store.FSDirectory.open ( file ) ; try { for ( java.lang.String name : dir.listAll ( ) ) { dir.deleteFile ( name ) ; } } finally { dir.close ( ) ; } } }
private com.google.gerrit.reviewdb.client.AccountGroup createAccountGroup ( com.google.gerrit.extensions.common.GroupInfo info ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = new com.google.gerrit.reviewdb.client.AccountGroup.Id ( db.nextAccountGroupId ( ) ) ; com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID ( info.id ) ; com.google.gerrit.reviewdb.client.AccountGroup group = new com.google.gerrit.reviewdb.client.AccountGroup ( new com.google.gerrit.reviewdb.client.AccountGroup.NameKey ( info.name ) , groupId , uuid ) ; group.setVisibleToAll ( cfg.getBoolean ( "groups" , "newGroupsVisibleToAll" , false ) ) ; group.setDescription ( info.description ) ; return group ; }
public void getNonExistingCommit_NotFound ( ) throws java.io.IOException { com.google.gerrit.acceptance.RestResponse r = adminSession.get ( ( ( ( "/projects/" + ( project.get ( ) ) ) + "/commits/" ) + ( org.eclipse.jgit.lib.ObjectId.zeroId ( ) . name ( ) ) ) ) ; org.junit.Assert.assertEquals ( HttpStatus.SC_NOT_FOUND , r.getStatusCode ( ) ) ; }
protected PushOneCommit.Result amendChange ( java.lang.String changeId , java.lang.String ref ) throws java.lang.Exception { java.util.Collections.shuffle ( com.google.gerrit.acceptance.AbstractDaemonTest.RANDOM ) ; com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create ( db , admin.getIdent ( ) , testRepo , PushOneCommit.SUBJECT , PushOneCommit.FILE_NAME , new java.lang.String ( com.google.common.primitives.Chars.toArray ( com.google.gerrit.acceptance.AbstractDaemonTest.RANDOM ) ) , changeId ) ; return push.to ( ref ) ; }
private com.google.gerrit.httpd.rpc.patch.PatchScriptBuilder newBuilder ( final com.google.gerrit.server.patch.PatchList list , org.eclipse.jgit.lib.Repository git ) { final com.google.gerrit.reviewdb.AccountDiffPreference dp = new com.google.gerrit.reviewdb.AccountDiffPreference ( diffPrefs ) ; final com.google.gerrit.httpd.rpc.patch.PatchScriptBuilder b = builderFactory.get ( ) ; b.setRepository ( git ) ; b.setChange ( change ) ; b.setDiffPrefs ( dp ) ; b.setTrees ( list.getOldId ( ) , list.getNewId ( ) ) ; return b ; }
public static com.google.gerrit.reviewdb.server.ReviewDb unwrapDb ( com.google.gerrit.reviewdb.server.ReviewDb db ) { if ( db instanceof com.google.gerrit.reviewdb.server.DisallowReadFromChangesReviewDbWrapper ) { return ( ( com.google.gerrit.reviewdb.server.DisallowReadFromChangesReviewDbWrapper ) ( db ) ) . unsafeGetDelegate ( ) ; } return db ; }
private com.google.gerrit.reviewdb.AccountGroup newGroup ( com.google.gerrit.reviewdb.ReviewDb c , java.lang.String name , com.google.gerrit.reviewdb.AccountGroup.UUID uuid ) throws com.google.gwtorm.client.OrmException { if ( uuid == null ) { uuid = com.google.gerrit.server.account.GroupUUID.make ( name , serverUser ) ; } return new com.google.gerrit.reviewdb.AccountGroup ( new com.google.gerrit.reviewdb.AccountGroup.NameKey ( name ) , new com.google.gerrit.reviewdb.AccountGroup.Id ( c.nextAccountGroupId ( ) ) , uuid ) ; }
protected void configureServlets ( ) { java.lang.Class < ? extends javax.servlet.Filter > authFilter ; if ( authConfig.isTrustContainerAuth ( ) ) { authFilter = com.google.gerrit.httpd.ContainerAuthFilter.class ; } else { authFilter = com.google.gerrit.httpd.ProjectDigestFilter.class ; } java.lang.String git = GitOverHttpServlet.URL_REGEX ; filterRegex ( git ) . through ( authFilter ) ; serveRegex ( git ) . with ( com.google.gerrit.httpd.GitOverHttpServlet.class ) ; filter ( "/a/*" ) . through ( authFilter ) ; }
public com.google.gerrit.server.notedb.ChangeNotes notes ( ) throws com.google.gwtorm.server.OrmException { if ( ( notes ) == null ) { notes = notesFactory.create ( db , project ( ) , legacyId ) ; } return notes ; }
private void extractMailExample ( java.lang.String orig ) throws java.lang.Exception { java.io.File ex = new java.io.File ( site.mail_dir , ( orig + ".example" ) ) ; com.google.gerrit.pgm.init.api.InitUtil.extract ( ex.toPath ( ) , com.google.gerrit.server.mail.OutgoingEmail.class , orig ) ; com.google.gerrit.common.FileUtil.chmod ( 292 , ex ) ; }
private boolean canPushWithForce ( ) { if ( ( GitRepositoryManager.REF_CONFIG.equals ( refName ) ) && ( ! ( projectControl.isOwner ( ) ) ) ) { return false ; } for ( com.google.gerrit.common.data.PermissionRule rule : access ( Permission.PUSH ) ) { if ( rule.getForce ( ) ) { return true ; } } return false ; }
public static org.eclipse.jgit.lib.Config allEnabledConfig ( ) { org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config ( ) ; for ( com.google.gerrit.server.notedb.NoteDbTable t : com.google.gerrit.server.notedb.NoteDbTable.values ( ) ) { cfg.setBoolean ( com.google.gerrit.server.notedb.ConfigNotesMigration.NOTE_DB , t.key ( ) , com.google.gerrit.server.notedb.ConfigNotesMigration.WRITE , true ) ; cfg.setBoolean ( com.google.gerrit.server.notedb.ConfigNotesMigration.NOTE_DB , t.key ( ) , com.google.gerrit.server.notedb.ConfigNotesMigration.READ , true ) ; } return cfg ; }
public void onFailure ( java.lang.Throwable err ) { com.google.gerrit.client.change.DraftActions.setEnabled ( true , draftButtons ) ; if ( com.google.gerrit.client.change.SubmitFailureDialog.isConflict ( err ) ) { new com.google.gerrit.client.change.SubmitFailureDialog ( err.getMessage ( ) ) . center ( ) ; com.google.gerrit.client.Gerrit.display ( PageLinks.MINE ) ; } else { super . onFailure ( err ) ; } }
private void enableForm ( final boolean canModifyAgreements , final boolean canModifyDescription , final boolean canModifyMergeType ) { submitType.setEnabled ( canModifyMergeType ) ; descTxt.setEnabled ( canModifyDescription ) ; useContributorAgreements.setEnabled ( canModifyAgreements ) ; useSignedOffBy.setEnabled ( canModifyAgreements ) ; requireChangeID.setEnabled ( canModifyMergeType ) ; saveProject.setEnabled ( ( ( canModifyAgreements || canModifyDescription ) || canModifyMergeType ) ) ; }
private static int index ( com.google.gerrit.common.data.Permission a ) { if ( com.google.gerrit.common.data.Permission.isLabel ( a.getName ( ) ) ) { return com.google.gerrit.common.data.Permission.labelIndex ; } else if ( com.google.gerrit.common.data.Permission.isLabelAs ( a.getName ( ) ) ) { return com.google.gerrit.common.data.Permission.labelAsIndex ; } int index = com.google.gerrit.common.data.Permission.NAMES_LC.indexOf ( a.getName ( ) . toLowerCase ( ) ) ; return 0 <= index ? index : com.google.gerrit.common.data.Permission.NAMES_LC.size ( ) ; }
public void parseMetadataFromHeader ( ) { com.google.gerrit.server.mail.receive.MailMessage.Builder b = com.google.gerrit.server.mail.receive.MailMessage.builder ( ) ; b.id ( "" ) ; b.dateReceived ( java.time.Instant.now ( ) ) ; b.subject ( "" ) ; b.addAdditionalHeader ( ( ( com.google.gerrit.server.mail.MetadataName.toHeaderWithDelimiter ( MetadataName.CHANGE_NUMBER ) ) + "123" ) ) ; b.addAdditionalHeader ( ( ( com.google.gerrit.server.mail.MetadataName.toHeaderWithDelimiter ( MetadataName.PATCH_SET ) ) + "1" ) ) ; b.addAdditionalHeader ( ( ( com.google.gerrit.server.mail.MetadataName.toHeaderWithDelimiter ( MetadataName.MESSAGE_TYPE ) ) + "comment" ) ) ; b.addAdditionalHeader ( ( ( com.google.gerrit.server.mail.MetadataName.toHeaderWithDelimiter ( MetadataName.TIMESTAMP ) ) + "Tue, 25 Oct 2016 02:11:35 -0700" ) ) ; com.google.gerrit.server.mail.Address author = new com.google.gerrit.server.mail.Address ( "Diffy" , "test@gerritcodereview.com" ) ; b.from ( author ) ; com.google.gerrit.server.mail.receive.MailMetadata meta = com.google.gerrit.server.mail.receive.MetadataParser.parse ( b.build ( ) ) ; com.google.common.truth.Truth.assertThat ( meta.author ) . isEqualTo ( author.getEmail ( ) ) ; com.google.common.truth.Truth.assertThat ( meta.changeNumber ) . isEqualTo ( 123 ) ; com.google.common.truth.Truth.assertThat ( meta.patchSet ) . isEqualTo ( 1 ) ; com.google.common.truth.Truth.assertThat ( meta.messageType ) . isEqualTo ( "comment" ) ; com.google.common.truth.Truth.assertThat ( meta.timestamp.toInstant ( ) ) . isEqualTo ( java.time.LocalDateTime.of ( 2016 , java.time.Month.OCTOBER , 25 , 9 , 11 , 35 ) . atOffset ( java.time.ZoneOffset.UTC ) . toInstant ( ) ) ; }
private com.google.inject.Injector getPluginInjector ( final java.io.File jarFile ) throws java.io.IOException { final java.lang.String pluginName = com.google.common.base.MoreObjects.firstNonNull ( com.google.gerrit.server.plugins.JarPluginProvider.getJarPluginName ( jarFile ) , com.google.gerrit.server.plugins.PluginLoader.nameOf ( jarFile ) ) ; return initInjector.createChildInjector ( new com.google.inject.AbstractModule ( ) { @ java.lang.Override protected void configure ( ) { bind ( java.lang.String.class ) . annotatedWith ( com.google.gerrit.extensions.annotations.PluginName.class ) . toInstance ( pluginName ) ; } } ) ; }
private com.google.gerrit.server.plugins.ServerPlugin loadExternalPlugin ( java.lang.String name , java.io.File scriptFile , org.eclipse.jgit.internal.storage.file.FileSnapshot snapshot ) { return externalPluginFactory.get ( name , scriptFile , pluginUserFactory.create ( name ) , snapshot ) ; }
public void postRun ( ) throws java.lang.Exception { org.eclipse.jgit.lib.Config cfg = allProjectsConfig.load ( ) . getConfig ( ) ; if ( installVerified ) { cfg.setString ( com.google.gerrit.pgm.init.InitLabels.KEY_LABEL , com.google.gerrit.pgm.init.InitLabels.LABEL_VERIFIED , com.google.gerrit.pgm.init.InitLabels.KEY_FUNCTION , "MaxWithBlock" ) ; cfg.setStringList ( com.google.gerrit.pgm.init.InitLabels.KEY_LABEL , com.google.gerrit.pgm.init.InitLabels.LABEL_VERIFIED , com.google.gerrit.pgm.init.InitLabels.KEY_VALUE , java.util.Arrays.asList ( new java.lang.String [ ] { "-1 Fails" , " 0 No score" , "+1 Verified" } ) ) ; cfg.setBoolean ( com.google.gerrit.pgm.init.InitLabels.KEY_LABEL , com.google.gerrit.pgm.init.InitLabels.LABEL_VERIFIED , com.google.gerrit.pgm.init.InitLabels.KEY_COPY_ALL_SCORES_IF_NO_CODE_CHANGE , true ) ; allProjectsConfig.save ( "Configure 'Verified' label" ) ; } }
public void onLoad ( com.google.gerrit.plugin.client.screen.Screen screen ) { java.lang.String projectName = com.google.gwt.http.client.URL.decode ( screen.getToken ( 1 ) ) ; java.lang.String path = com.google.gwt.http.client.URL.decode ( screen.getToken ( 2 ) ) ; screen.show ( new com.googlesource.gerrit.plugins.xdocs.client.XDocScreen ( projectName , "HEAD" , path ) ) ; screen.setWindowTitle ( com.googlesource.gerrit.plugins.xdocs.client.FileInfo.getFileName ( path ) ) ; }
public void testUpsertTwoFirstExistsing ( ) throws com.google.gwtorm.client.OrmException , java.sql.SQLException { stubExecuteBatchOK ( com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE , 1 , 0 ) ; java.sql.PreparedStatement insert = stubExecuteBatchOK ( com.google.gwtorm.jdbc.TestJdbcAccess.INSERT , 1 ) ; createClassUnderTest ( ) . upsert ( com.google.gwtorm.jdbc.TestJdbcAccess.TWO_ROWS ) ; verifyIds ( insert , 2 ) ; }
public void testPushForMasterAsDraft ( ) throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = pushTo ( "refs/drafts/master" ) ; r.assertOkStatus ( ) ; r.assertChange ( Change.Status.DRAFT , null ) ; r = pushTo ( "refs/for/master%draft" ) ; r.assertOkStatus ( ) ; r.assertChange ( Change.Status.DRAFT , null ) ; }
public void repositoryIndex ( ) throws java.lang.Exception { com.google.gitiles.GitilesView view = getView ( "/repo" ) ; org.junit.Assert.assertEquals ( Type.REPOSITORY_INDEX , view.getType ( ) ) ; org.junit.Assert.assertEquals ( "repo" , view.getRepositoryName ( ) ) ; org.junit.Assert.assertEquals ( Revision.NULL , view.getRevision ( ) ) ; org.junit.Assert.assertEquals ( Revision.NULL , view.getOldRevision ( ) ) ; org.junit.Assert.assertNull ( view.getPathPart ( ) ) ; }
public static void assertAccountInfo ( com.google.gerrit.acceptance.TestAccount a , com.google.gerrit.server.account.AccountInfo ai ) { org.junit.Assert.assertTrue ( ( ( a.id.get ( ) ) == ( ai._account_id ) ) ) ; org.junit.Assert.assertEquals ( a.fullName , ai.name ) ; org.junit.Assert.assertEquals ( a.email , ai.email ) ; }
public boolean evict ( java.lang.String cacheName , java.lang.Object key ) { try { java.lang.String json = com.ericsson.gerrit.plugins.highavailability.forwarder.rest.GsonParser.toJson ( cacheName , key ) ; return httpSession.post ( com.google.common.base.Joiner.on ( "/" ) . join ( pluginRelativePath , "cache" , cacheName ) , json ) . isSuccessful ( ) ; } catch ( java.io.IOException e ) { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.RestForwarder.log.error ( ( "Error trying to evict for cache " + cacheName ) , e ) ; return false ; } }
protected void populate ( final int row , final com.google.gerrit.reviewdb.client.Project k ) { final com.google.gwt.user.client.ui.Anchor projectLink = new com.google.gwt.user.client.ui.Anchor ( k.getName ( ) ) ; projectLink.addClickHandler ( new com.google.gwt.event.dom.client.ClickHandler ( ) { @ java.lang.Override public void onClick ( com.google.gwt.event.dom.client.ClickEvent event ) { sugestParent.setText ( getRowItem ( row ) . getName ( ) ) ; } } ) ; table.setWidget ( row , 1 , projectLink ) ; table.setText ( row , 2 , k.getDescription ( ) ) ; setRowItem ( row , k ) ; }
protected void configure ( ) { bind ( com.google.gerrit.server.config.ProjectConfigEntry.class ) . annotatedWith ( com.google.gerrit.extensions.annotations.Exports.named ( com.googlesource.gerrit.plugins.uploadvalidator.ValidatorConfig.KEY_PROJECT ) ) . toInstance ( new com.google.gerrit.server.config.ProjectConfigEntry ( "Projects" , null , com.google.gerrit.extensions.api.projects.ProjectConfigEntryType.ARRAY , null , false , "Only projects that match this regex will be validated." ) ) ; bind ( com.google.gerrit.server.config.ProjectConfigEntry.class ) . annotatedWith ( com.google.gerrit.extensions.annotations.Exports.named ( com.googlesource.gerrit.plugins.uploadvalidator.ValidatorConfig.KEY_REF ) ) . toInstance ( new com.google.gerrit.server.config.ProjectConfigEntry ( "Refs" , null , com.google.gerrit.extensions.api.projects.ProjectConfigEntryType.ARRAY , null , false , "Only refs that match this regex will be validated." ) ) ; }
public void onSuccess ( com.googlesource.gerrit.plugins.serviceuser.client.GroupInfo result ) { updateValue ( ( result != null ? result.name ( ) : "" ) ) ; com.google.gerrit.plugin.client.Plugin.get ( ) . refresh ( ) ; }
private java.lang.String canCreateCommit ( org.eclipse.jgit.lib.Repository repo , org.eclipse.jgit.revwalk.RevCommit commit , com.google.gerrit.server.project.ProjectState projectState , com.google.gerrit.server.IdentifiedUser user , com.google.gerrit.server.permissions.PermissionBackend.ForRef forRef ) throws com.google.gerrit.server.permissions.PermissionBackendException { if ( projectState.controlFor ( user ) . isReachableFromHeadsOrTags ( repo , commit ) ) { return null ; } else if ( testAuditLogged ( forRef , RefPermission.UPDATE ) ) { return null ; } return ( ( ( user.getAccountId ( ) ) + " lacks permission " ) + ( com.google.gerrit.common.data.Permission.PUSH ) ) + " for creating new commit object" ; }
public void set ( final boolean s ) { if ( ( com.google.gerrit.client.Gerrit.isSignedIn ( ) ) && ( s != ( get ( ) ) ) ) { final com.google.gerrit.common.data.ToggleStarRequest req = new com.google.gerrit.common.data.ToggleStarRequest ( ) ; req.toggle ( cache.getChangeId ( ) , s ) ; com.google.gerrit.client.changes.Util.LIST_SVC.toggleStars ( req , new com.google.gerrit.client.rpc.GerritCallback < com.google.gwtjsonrpc.client.VoidResult > ( ) { public void onSuccess ( final com.google.gwtjsonrpc.client.VoidResult result ) { setStarred ( s ) ; fireEvent ( new com.google.gwt.event.logical.shared.ValueChangeEvent < java.lang.Boolean > ( s ) { } ) ; } } ) ; } }
public void patchScript ( final com.google.gerrit.reviewdb.Patch.Key patchKey , final com.google.gerrit.reviewdb.PatchSet.Id psa , final com.google.gerrit.reviewdb.PatchSet.Id psb , final com.google.gerrit.common.data.PatchScriptSettings s , final com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.common.data.PatchScript > callback ) { if ( psb == null ) { callback.onFailure ( new com.google.gerrit.common.errors.NoSuchEntityException ( ) ) ; return ; } patchScriptFactoryFactory.create ( patchKey , psa , psb , s ) . to ( callback ) ; }
public void testCreateProjectHttpWithInvalidRefName_BadRequest ( ) throws java.lang.Exception { com.google.gerrit.extensions.api.projects.ProjectInput in = new com.google.gerrit.extensions.api.projects.ProjectInput ( ) ; in.branches = java.util.Collections.singletonList ( name ( "invalid ref name" ) ) ; adminSession.put ( ( "/projects/" + ( name ( "newProject" ) ) ) , in ) . assertBadRequest ( ) ; }
public void testUnblockVisibilityByREGISTEREDUsers ( ) { com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.project.Util.ANONYMOUS , "refs/heads/*" ) . setBlock ( ) ; com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.project.Util.REGISTERED , "refs/heads/*" ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.project.Util.REGISTERED ) ; org.junit.Assert.assertTrue ( "u can read" , u.controlForRef ( "refs/heads/master" ) . isVisibleByRegisteredUsers ( ) ) ; }
private void assertNotFound ( org.eclipse.jgit.lib.ObjectId id ) throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = userSession.get ( ( ( ( "/projects/" + ( project.get ( ) ) ) + "/commits/" ) + ( id.name ( ) ) ) ) ; org.junit.Assert.assertEquals ( HttpStatus.SC_NOT_FOUND , r.getStatusCode ( ) ) ; }
public void testInheritRead_SingleBranchDoesNotOverrideInherited ( ) { inherited.add ( grant ( com.google.gerrit.reviewdb.ApprovalCategory.READ , registered , "refs/*" , 1 , 2 ) ) ; local.add ( grant ( com.google.gerrit.reviewdb.ApprovalCategory.READ , registered , "refs/heads/foobar" , 1 , 1 ) ) ; com.google.gerrit.server.project.ProjectControl u = user ( ) ; assertTrue ( "can upload" , u.canUploadToAtLeastOneRef ( ) ) ; assertTrue ( "can upload refs/heads/master" , u.controlForRef ( "refs/heads/master" ) . canUpload ( ) ) ; assertTrue ( "can upload refs/heads/foobar" , u.controlForRef ( "refs/heads/foobar" ) . canUpload ( ) ) ; }
private java.util.List < com.google.gerrit.extensions.common.SuggestedReviewerInfo > suggestReviewers ( com.google.gerrit.server.api.changes.SuggestedReviewersRequest r ) throws com.google.gerrit.extensions.restapi.RestApiException { try { suggestReviewers.setQuery ( r.getQuery ( ) ) ; suggestReviewers.setLimit ( r.getLimit ( ) ) ; return suggestReviewers.apply ( change ) ; } catch ( com.google.gwtorm.server.OrmException | java.io.IOException e ) { throw new com.google.gerrit.extensions.restapi.RestApiException ( "Cannot retrieve suggested reviewers" , e ) ; } }
public boolean rollback ( ) { java.io.File gitDirectory = destinationDirectory ; if ( ! ( gitDirectory.exists ( ) ) ) { return false ; } try { org.apache.commons.io.FileUtils.deleteDirectory ( gitDirectory ) ; return true ; } catch ( java.io.IOException e ) { com.googlesrouce.gerrit.plugins.github.git.GitCloneStep.log.error ( ( "Cannot clean-up output Git directory " + gitDirectory ) ) ; return false ; } }
public static void setReady ( com.google.gerrit.server.config.SitePaths sitePaths , int version , boolean ready ) throws java.io.IOException { try { org.eclipse.jgit.storage.file.FileBasedConfig cfg = com.google.gerrit.lucene.LuceneVersionManager.loadGerritIndexConfig ( sitePaths ) ; com.google.gerrit.lucene.LuceneVersionManager.setReady ( cfg , version , ready ) ; cfg.save ( ) ; } catch ( org.eclipse.jgit.errors.ConfigInvalidException e ) { throw new java.io.IOException ( e ) ; } }
void setEdit ( boolean edit ) { if ( edit ) { removeStyleName ( draftStyle.view ( ) ) ; addStyleName ( draftStyle.edit ( ) ) ; editArea.setText ( contentPanelMessage.getText ( ) ) ; editArea.setFocus ( true ) ; } else { removeStyleName ( draftStyle.edit ( ) ) ; addStyleName ( draftStyle.view ( ) ) ; } resizePaddingWidget ( ) ; }
private void parseUpdate ( final org.eclipse.jgit.transport.ReceiveCommand cmd ) { com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef ( cmd.getRefName ( ) ) ; if ( ctl.canUpdate ( ) ) { } else { com.google.gerrit.server.git.ReceiveCommits.reject ( cmd ) ; } }
protected void configure ( ) { factory ( RenameGroupOp.Factory.class ) ; factory ( MetaDataUpdate.InternalFactory.class ) ; bind ( MetaDataUpdate.Server.class ) ; com.google.gerrit.extensions.registration.DynamicSet.bind ( binder ( ) , org.eclipse.jgit.transport.PostUploadHook.class ) . to ( com.google.gerrit.server.git.UploadPackMetricsHook.class ) ; }
protected void configure ( ) { get ( com.google.gerrit.server.change.RevisionResource.REVISION_KIND , "verifications" ) . to ( com.googlesource.gerrit.plugins.verifystatus.server.GetVerifications.class ) ; post ( com.google.gerrit.server.change.RevisionResource.REVISION_KIND , "verifications" ) . to ( com.googlesource.gerrit.plugins.verifystatus.server.PostVerification.class ) ; }
private synchronized void runHook ( java.io.File hook , java.util.List < java.lang.String > args ) { if ( hook.exists ( ) ) { hookQueue.execute ( new com.google.gerrit.common.ChangeHookRunner.AsyncHookTask ( null , hook , args ) ) ; } }
private < T extends java.lang.Enum < ? > > void set ( org.eclipse.jgit.lib.Config cfg , java.lang.String section , java.lang.String name , T value , T def ) { if ( ( value != null ) && ( value != def ) ) { cfg.setString ( section , null , name , value.toString ( ) ) ; } else { cfg.unset ( section , null , name ) ; } }
public void parseOptionMap ( java.util.Map < java.lang.String , java.lang.String [ ] > parameters ) throws org.kohsuke.args4j.CmdLineException { parseOptionMap ( parameters , java.util.Collections.< java.lang.String > emptySet ( ) ) ; }
public void testIsEnabledRefNoParentMatchingBranchMiddleDisabled ( ) { java.lang.String [ ] branches = new java.lang.String [ ] { "^refs/heads/foo.*" , "^refs/heads/test.*" , "^refs/heads/baz.*" } ; setupIsEnabled ( "false" , null , branches ) ; com.googlesource.gerrit.plugins.its.base.its.ItsConfig itsConfig = createItsConfig ( ) ; replayMocks ( ) ; com.google.gerrit.reviewdb.client.Project.NameKey projectNK = new com.google.gerrit.reviewdb.client.Project.NameKey ( "testProject" ) ; assertFalse ( itsConfig.isEnabled ( projectNK , "refs/heads/testBranch" ) ) ; }
com.google.gerrit.client.reviewdb.ContactInformation toContactInformation ( ) { final com.google.gerrit.client.reviewdb.ContactInformation info ; if ( com.google.gerrit.client.rpc.Common.getGerritConfig ( ) . isUseContactInfo ( ) ) { info = new com.google.gerrit.client.reviewdb.ContactInformation ( ) ; info.setAddress ( addressTxt.getText ( ) ) ; info.setCountry ( countryTxt.getText ( ) ) ; info.setPhoneNumber ( phoneTxt.getText ( ) ) ; info.setFaxNumber ( faxTxt.getText ( ) ) ; } else { info = null ; } return info ; }
public com.google.gerrit.extensions.common.ChangeInfo apply ( com.google.gerrit.server.change.ChangeResource req , com.google.gerrit.extensions.api.changes.AbandonInput input ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.git.UpdateException , com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl control = req.getControl ( ) ; if ( ! ( control.canAbandon ( dbProvider.get ( ) ) ) ) { throw new com.google.gerrit.extensions.restapi.AuthException ( "abandon not permitted" ) ; } com.google.gerrit.reviewdb.client.Change change = abandon ( control , input.message , input.notify , notifyUtil.resolveAccounts ( input.notifyDetails ) ) ; return json.create ( ChangeJson.NO_OPTIONS ) . format ( change ) ; }
java.util.Map < java.lang.String , com.google.gerrit.extensions.common.FileInfo > toFileInfoMap ( com.google.gerrit.reviewdb.client.Change change , com.google.gerrit.reviewdb.client.RevId revision , @ com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.PatchSet base ) throws com.google.gerrit.server.patch.PatchListNotAvailableException { org.eclipse.jgit.lib.ObjectId a = ( base == null ) ? null : org.eclipse.jgit.lib.ObjectId.fromString ( base.getRevision ( ) . get ( ) ) ; org.eclipse.jgit.lib.ObjectId b = org.eclipse.jgit.lib.ObjectId.fromString ( revision.get ( ) ) ; return toFileInfoMap ( change , new com.google.gerrit.server.patch.PatchListKey ( a , b , com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace.IGNORE_NONE ) ) ; }
void stop ( ) throws java.lang.Exception { try { if ( com.google.gerrit.testutil.NoteDbMode.get ( ) . equals ( NoteDbMode.CHECK ) ) { testInjector.getInstance ( com.google.gerrit.testutil.NoteDbChecker.class ) . checkAllChanges ( ) ; } } finally { daemon.getLifecycleManager ( ) . stop ( ) ; if ( ( daemonService ) != null ) { java.lang.System.out.println ( "Gerrit Server Shutdown" ) ; daemonService.shutdownNow ( ) ; daemonService.awaitTermination ( java.lang.Long.MAX_VALUE , java.util.concurrent.TimeUnit.SECONDS ) ; } org.eclipse.jgit.lib.RepositoryCache.clear ( ) ; } }
protected void bccStarredBy ( ) { if ( ! ( NotifyHandling.ALL.equals ( notify ) ) ) { return ; } try { for ( com.google.gerrit.reviewdb.client.Account.Id accountId : args.starredChangesUtil.byChange ( change.getId ( ) ) ) { super . add ( RecipientType.BCC , accountId ) ; } } catch ( com.google.gwtorm.server.OrmException err ) { com.google.gerrit.server.mail.ChangeEmail.log.warn ( "Cannot BCC users that starred updated change" , err ) ; } }
protected void configure ( ) { if ( recheckMergeable ) { install ( new com.google.gerrit.pgm.Reindex.MergeabilityModule ( ) ) ; } }
protected void run ( java.lang.String [ ] args ) throws com.google.gerrit.server.ssh.Failure { final com.google.gerrit.client.data.GroupCache gc = com.google.gerrit.client.rpc.Common.getGroupCache ( ) ; if ( gc.isAdministrator ( getAccountId ( ) ) ) { gc.flush ( ) ; com.google.gerrit.client.rpc.Common.getProjectCache ( ) . flush ( ) ; } else { throw new com.google.gerrit.server.ssh.Failure ( 1 , "fatal: Not a Gerrit administrator" ) ; } }
public com.google.common.collect.Multimap < com.google.gerrit.reviewdb.client.Project.NameKey , com.google.gerrit.reviewdb.client.Project.NameKey > getProjectSubscriptionGraph ( ) { com.google.common.collect.Multimap < com.google.gerrit.reviewdb.client.Project.NameKey , com.google.gerrit.reviewdb.client.Project.NameKey > graph = com.google.common.collect.HashMultimap.create ( ) ; for ( com.google.gerrit.reviewdb.client.Branch.NameKey b : targets.keySet ( ) ) { java.util.Collection < com.google.gerrit.reviewdb.client.SubmoduleSubscription > ss = targets.get ( b ) ; for ( com.google.gerrit.reviewdb.client.SubmoduleSubscription s : ss ) { graph.put ( b.getParentKey ( ) , s.getSubmodule ( ) . getParentKey ( ) ) ; } } return graph ; }
void onValueChange ( com.google.gwt.event.logical.shared.ValueChangeEvent < java.lang.Boolean > event ) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.revision ( patchSetId ) . view ( "files" ) . id ( path ) . view ( "reviewed" ) ; if ( event.getValue ( ) ) { api.put ( com.google.gerrit.client.rpc.CallbackGroup.< com.google.gerrit.client.changes.ReviewInfo > emptyCallback ( ) ) ; } else { api.delete ( com.google.gerrit.client.rpc.CallbackGroup.< com.google.gerrit.client.changes.ReviewInfo > emptyCallback ( ) ) ; } }
public void ambiguousRelativeToNonBranchOrTagSoy ( ) throws java.lang.Exception { repo.branch ( "refs/foo" ) . commit ( ) . create ( ) ; repo.branch ( "refs/heads/foo" ) . commit ( ) . create ( ) ; repo.branch ( "refs/tags/foo" ) . commit ( ) . create ( ) ; org.junit.Assert.assertEquals ( com.google.common.collect.ImmutableList.of ( ref ( "/b/test/+/refs/heads/foo" , "foo" ) ) , buildBranchesSoyData ( ) ) ; org.junit.Assert.assertEquals ( com.google.common.collect.ImmutableList.of ( ref ( "/b/test/+/refs/tags/foo" , "foo" ) ) , buildTagsSoyData ( ) ) ; }
private com.google.gerrit.server.plugins.Plugin loadPlugin ( java.lang.String name , java.nio.file.Path srcPlugin , org.eclipse.jgit.internal.storage.file.FileSnapshot snapshot ) throws com.google.gerrit.server.plugins.InvalidPluginException { java.lang.String pluginName = srcPlugin.getFileName ( ) . toString ( ) ; if ( com.google.gerrit.server.plugins.PluginLoader.isJsPlugin ( pluginName ) ) { return loadJsPlugin ( name , srcPlugin , snapshot ) ; } else if ( serverPluginFactory.handles ( srcPlugin ) ) { return loadServerPlugin ( srcPlugin , snapshot ) ; } else { throw new com.google.gerrit.server.plugins.InvalidPluginException ( java.lang.String.format ( "Unsupported plugin type: %s" , srcPlugin.getFileName ( ) ) ) ; } }
public void doFilter ( javax.servlet.ServletRequest request , javax.servlet.ServletResponse response , javax.servlet.FilterChain chain ) throws java.io.IOException , javax.servlet.ServletException { com.googlesource.gerrit.plugins.github.oauth.GitHubLogin hubLogin = loginProvider.get ( ) ; if ( ! ( hubLogin.isLoggedIn ( Scope.USER ) ) ) { hubLogin.login ( request , response , Scope.USER ) ; return ; } else { chain.doFilter ( request , response ) ; } }
public java.lang.Iterable < com.google.gerrit.extensions.common.WebLinkInfo > getBranchLinks ( java.lang.String project , java.lang.String branch ) { java.util.List < com.google.gerrit.extensions.common.WebLinkInfo > links = com.google.common.collect.Lists.newArrayList ( ) ; for ( com.google.gerrit.extensions.webui.BranchWebLink webLink : branchLinks ) { links.add ( new com.google.gerrit.extensions.common.WebLinkInfo ( webLink.getLinkName ( ) , webLink.getImageUrl ( ) , webLink.getBranchUrl ( project , branch ) , webLink.getTarget ( ) ) ) ; } return links ; }
private void setLabelValues ( com.google.gerrit.common.data.LabelType type , com.google.gerrit.server.change.LabelInfo label ) { label.values = com.google.common.collect.Maps.newLinkedHashMap ( ) ; for ( com.google.gerrit.common.data.LabelValue v : type.getValues ( ) ) { label.values.put ( v.formatValue ( ) , v.getText ( ) ) ; } if ( com.google.gerrit.server.change.ChangeJson.isOnlyZero ( label.values.keySet ( ) ) ) { label.values = null ; } }
public void run ( ) { try { com.google.gerrit.git.PushQueue.notifyStarting ( this ) ; pushImpl ( ) ; } catch ( java.lang.RuntimeException e ) { com.google.gerrit.git.PushOp.log.error ( "Unexpected error during replication" , e ) ; } catch ( java.lang.Error e ) { com.google.gerrit.git.PushOp.log.error ( "Unexpected error during replication" , e ) ; } }
public void missingOwner ( ) throws java.lang.Exception { com.google.gerrit.acceptance.TestAccount owner = accountCreator.create ( "missing" ) ; com.google.gerrit.server.project.ChangeControl ctl = insertChange ( owner ) ; accountsUpdate.create ( ) . deleteByKey ( owner.getId ( ) ) ; assertProblems ( ctl , null , com.google.gerrit.acceptance.server.change.ConsistencyCheckerIT.problem ( ( "Missing change owner: " + ( owner.getId ( ) ) ) ) ) ; }
private void loadCommit ( final com.google.gerrit.client.changes.ChangeInfo.RevisionInfo rev , com.google.gerrit.client.rpc.CallbackGroup group ) { if ( rev.is_edit ( ) ) { return ; } com.google.gerrit.client.changes.ChangeApi.commitWithLinks ( changeId.get ( ) , rev.name ( ) , group.add ( new com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.client.changes.ChangeInfo.CommitInfo > ( ) { @ java.lang.Override public void onSuccess ( com.google.gerrit.client.changes.ChangeInfo.CommitInfo info ) { rev.set_commit ( info ) ; } @ java.lang.Override public void onFailure ( java.lang.Throwable caught ) { } } ) ) ; }
public void commentOnReviewableChangeByOwnerNotifyOwnerReviewers ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS ) ; review ( sc.owner , sc.changeId , com.google.gerrit.extensions.client.GeneralPreferencesInfo.EmailStrategy.ENABLED , com.google.gerrit.extensions.api.changes.NotifyHandling.OWNER_REVIEWERS ) ; assertThat ( sender ) . sent ( "comment" , sc ) . cc ( sc.reviewer , sc.ccer ) . cc ( sc.reviewerByEmail , sc.ccerByEmail ) . notTo ( sc.owner , sc.starrer ) . notTo ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS ) ; }
private com.google.gerrit.client.diff.DraftBox addNewDraft ( net.codemirror.lib.CodeMirror cm , int line ) { com.google.gerrit.common.changes.Side side = ( cm == ( cmA ) ) ? com.google.gerrit.common.changes.Side.PARENT : com.google.gerrit.common.changes.Side.REVISION ; com.google.gerrit.client.changes.CommentInfo info = com.google.gerrit.client.changes.CommentInfo.create ( path , side , ( line + 1 ) , null , null ) ; return addDraftBox ( info , false ) ; }
public static boolean isStale ( com.google.gerrit.server.git.GitRepositoryManager repoManager , com.google.gerrit.reviewdb.client.Change.Id id , com.google.gerrit.reviewdb.client.Change indexChange , @ com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Change reviewDbChange , com.google.common.collect.SetMultimap < com.google.gerrit.reviewdb.client.Project.NameKey , com.google.gerrit.server.index.change.StalenessChecker.RefState > states , com.google.common.collect.Multimap < com.google.gerrit.reviewdb.client.Project.NameKey , com.google.gerrit.server.index.change.StalenessChecker.RefStatePattern > patterns ) { return ( com.google.gerrit.server.index.change.StalenessChecker.reviewDbChangeIsStale ( indexChange , reviewDbChange ) ) || ( com.google.gerrit.server.index.change.StalenessChecker.refsAreStale ( repoManager , id , states , patterns ) ) ; }
public void newPatchSetByOtherOnReviewableChangeNotifyOwnerReviewersInReviewDb ( ) throws java.lang.Exception { com.google.common.truth.TruthJUnit.assume ( ) . that ( notesMigration.readChanges ( ) ) . isFalse ( ) ; com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.NEW_PATCHSETS ) ; pushTo ( sc , "refs/for/master%notify=OWNER_REVIEWERS" , other ) ; assertThat ( sender ) . sent ( "newpatchset" , sc ) . to ( sc.reviewer , sc.ccer ) . notTo ( sc.starrer , other ) . notTo ( sc.owner ) . notTo ( sc.reviewerByEmail , sc.ccerByEmail ) . notTo ( com.google.gerrit.server.account.WatchConfig.NotifyType.NEW_PATCHSETS ) ; }
public void run ( ) throws java.io.IOException { ui.header ( "Index" ) ; com.google.gerrit.server.index.IndexModule.IndexType type = index.select ( "Type" , "type" , IndexType.LUCENE ) ; if ( ( site.isNew ) && ( type == ( com.google.gerrit.server.index.IndexModule.IndexType.LUCENE ) ) ) { createLuceneIndex ( ) ; } else { ui.message ( ( "The index must be built before starting Gerrit:\n" + " java -jar gerrit.war reindex -d site_path\n" ) ) ; initFlags.autoStart = false ; } }
public java.lang.Runnable doScroll ( final net.codemirror.lib.CodeMirror cm ) { final net.codemirror.lib.CodeMirror other = ( cm == ( cmA ) ) ? cmB : cmA ; return new java.lang.Runnable ( ) { public void run ( ) { cm.scrollToY ( other.getScrollInfo ( ) . getTop ( ) ) ; } } ; }
public void manualCertificationMatchesExternalId ( ) throws java.lang.Exception { addExternalId ( "foo" , "myId" , null ) ; assertNoProblems ( com.google.gerrit.gpg.testutil.TestKey.key5 ( ) ) ; }
private void review ( java.lang.String changeId , com.google.gerrit.extensions.client.GeneralPreferencesInfo.EmailStrategy strategy , @ com.google.gerrit.common.Nullable com.google.gerrit.extensions.api.changes.NotifyHandling notify ) throws java.lang.Exception { com.google.gerrit.extensions.client.GeneralPreferencesInfo prefs = gApi.accounts ( ) . self ( ) . getPreferences ( ) ; prefs.emailStrategy = strategy ; gApi.accounts ( ) . self ( ) . setPreferences ( prefs ) ; com.google.gerrit.extensions.api.changes.ReviewInput in = com.google.gerrit.extensions.api.changes.ReviewInput.recommend ( ) ; in.notify = notify ; gApi.changes ( ) . id ( changeId ) . revision ( "current" ) . review ( in ) ; }
public com.google.gerrit.reviewdb.client.PatchSetInfo get ( com.google.gerrit.reviewdb.server.ReviewDb db , com.google.gerrit.server.notedb.ChangeNotes notes , com.google.gerrit.reviewdb.client.PatchSet.Id psId ) throws com.google.gerrit.server.patch.PatchSetInfoNotAvailableException { try { com.google.gerrit.reviewdb.client.PatchSet patchSet = psUtil.get ( db , notes , psId ) ; com.google.gerrit.reviewdb.client.Change change = db.changes ( ) . get ( psId.getParentKey ( ) ) ; return get ( change , patchSet ) ; } catch ( com.google.gwtorm.server.OrmException e ) { throw new com.google.gerrit.server.patch.PatchSetInfoNotAvailableException ( e ) ; } }
public void setUp ( ) throws java.lang.Exception { org.mockito.Mockito.when ( currentUserProviderMock.get ( ) ) . thenReturn ( currentUserMock ) ; HEAD ( 3452000.0 ) ; com.ericsson.gerrit.plugins.highavailability.health.Update bazlets ; com.ericsson.gerrit.plugins.highavailability.health.latest revision = ( stable ) - 2.15 ; org.mockito.Mockito.when ( permissionBackendMock.user ( currentUserMock ) ) . thenReturn ( withUserMock ) ; org.mockito.Mockito.when ( withUserMock.testOrFalse ( com.google.gerrit.server.permissions.GlobalPermission.ADMINISTRATE_SERVER ) ) . thenReturn ( true ) ; servlet = new com.ericsson.gerrit.plugins.highavailability.health.HealthServlet ( currentUserProviderMock , permissionBackendMock ) ; }
private void updateSubmoduleSubscriptions ( com.google.gerrit.server.git.MergeOp.OpenBranch ob , com.google.gerrit.server.git.SubmoduleOp subOp ) { com.google.gerrit.server.git.CodeReviewCommit branchTip = ob.oldTip ; com.google.gerrit.server.git.MergeTip mergeTip = ob.mergeTip ; }
public void testUpsertTwoFirstExistsing ( ) throws com.google.gwtorm.client.OrmException , java.sql.SQLException { stubExecuteBatchOK ( com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE , 1 , 0 ) ; java.sql.PreparedStatement insert = stubExecuteBatchOK ( com.google.gwtorm.jdbc.TestJdbcAccess.INSERT , 1 ) ; createClassUnderTest ( ) . upsert ( com.google.gwtorm.jdbc.TestJdbcAccess.TWO_ROWS ) ; verifyIds ( insert , 2 ) ; }
private void index ( com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid ) throws java.io.IOException { java.util.concurrent.atomic.AtomicInteger accountGroupIdLock = getAndIncrementAccountGroupIdLock ( uuid ) ; synchronized ( accountGroupIdLock ) { indexer.index ( uuid ) ; com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexGroupRestApiServlet.logger.debug ( "Group {} successfully indexed" , uuid ) ; } if ( ( accountGroupIdLock.decrementAndGet ( ) ) == 0 ) { removeAccountGroupIdLock ( uuid ) ; } }
protected void onInitUI ( ) { table = new com.google.gerrit.client.changes.DashboardTable ( params ) { @ java.lang.Override protected void onLoad ( ) { super . onLoad ( ) ; display ( ) ; } } ; super . onInitUI ( ) ; java.lang.String title = table.getTitle ( ) ; if ( title != null ) { setWindowTitle ( title ) ; setPageTitle ( title ) ; } add ( table ) ; }
public com.google.gerrit.extensions.common.EditInfo toEditInfo ( com.google.gerrit.server.edit.ChangeEdit edit , boolean downloadCommands ) throws java.io.IOException { com.google.gerrit.extensions.common.EditInfo out = new com.google.gerrit.extensions.common.EditInfo ( ) ; out.commit = com.google.gerrit.server.edit.ChangeEditJson.fillCommit ( edit.getEditCommit ( ) ) ; out.actions = com.google.gerrit.server.edit.ChangeEditJson.fillActions ( edit ) ; if ( downloadCommands ) { out.fetch = fillFetchMap ( edit ) ; } return out ; }
protected void configure ( ) { final java.lang.String cacheName = WebSessionManager.CACHE_NAME ; final com.google.inject.TypeLiteral < com.google.gerrit.server.cache.Cache < com.google.gerrit.server.http.WebSessionManager.Key , com.google.gerrit.server.http.WebSessionManager.Val > > type = new com.google.inject.TypeLiteral < com.google.gerrit.server.cache.Cache < com.google.gerrit.server.http.WebSessionManager.Key , com.google.gerrit.server.http.WebSessionManager.Val > > ( ) { } ; disk ( type , cacheName ) . timeToIdle ( 12 , java.util.concurrent.TimeUnit.HOURS ) . timeToLive ( 0 , java.util.concurrent.TimeUnit.SECONDS ) ; bind ( com.google.gerrit.server.http.WebSessionManager.class ) ; bind ( com.google.gerrit.server.http.WebSession.class ) . in ( com.google.inject.servlet.RequestScoped.class ) ; }
public void onSuccess ( final java.util.List < com.google.gerrit.common.data.AccountInfo > result ) { final java.util.ArrayList < com.google.gerrit.client.ui.AccountSuggestOracle.AccountSuggestion > r = new java.util.ArrayList ( result.size ( ) ) ; for ( final com.google.gerrit.common.data.AccountInfo p : result ) { r.add ( new com.google.gerrit.client.ui.AccountSuggestOracle.AccountSuggestion ( p ) ) ; } callback.onSuggestionsReady ( req , new com.google.gerrit.client.ui.Response ( r ) ) ; }
public com.google.gerrit.reviewdb.Project getProject ( ) { return getConfig ( ) . getProject ( ) ; }
private static java.util.List < com.google.gerrit.extensions.common.TagInfo > toTagInfoList ( com.google.gerrit.acceptance.RestResponse r ) throws java.lang.Exception { java.util.List < com.google.gerrit.extensions.common.TagInfo > result = newGson ( ) . fromJson ( r.getReader ( ) , new com.google.gson.reflect.TypeToken < java.util.List < com.google.gerrit.extensions.common.TagInfo > > ( ) { } . getType ( ) ) ; return result ; }
public void setUp ( ) throws java.lang.Exception { mergeResults = com.google.common.collect.Maps.newHashMap ( ) ; com.google.gerrit.server.CurrentUser listenerUser = factory.create ( user.id ) ; source.addEventListener ( new com.google.gerrit.common.EventListener ( ) { @ java.lang.Override public void onEvent ( com.google.gerrit.server.events.Event event ) { if ( event instanceof com.google.gerrit.server.events.ChangeMergedEvent ) { com.google.gerrit.server.events.ChangeMergedEvent changeMergedEvent = ( ( com.google.gerrit.server.events.ChangeMergedEvent ) ( event ) ) ; mergeResults.put ( changeMergedEvent.change.get ( ) . number , changeMergedEvent.newRev ) ; } } } , listenerUser ) ; }
public com.googlecode.prolog_cafe.lang.Operation exec ( com.googlecode.prolog_cafe.lang.Prolog engine ) throws com.googlecode.prolog_cafe.lang.PrologException { engine.setB0 ( ) ; com.googlecode.prolog_cafe.lang.Term a1 = arg1.dereference ( ) ; com.googlecode.prolog_cafe.lang.Term topicTerm = com.googlecode.prolog_cafe.lang.Prolog.Nil ; com.google.gerrit.reviewdb.client.Change change = StoredValues.CHANGE.get ( engine ) ; java.lang.String topic = change.getTopic ( ) ; if ( topic != null ) { topicTerm = com.googlecode.prolog_cafe.lang.SymbolTerm.create ( topic ) ; } if ( ! ( a1.unify ( topicTerm , engine.trail ) ) ) { return engine.fail ( ) ; } return cont ; }
public void addApprovals ( com.google.gerrit.server.events.PatchSetAttribute p , com.google.gerrit.reviewdb.client.PatchSet.Id id , java.util.Map < com.google.gerrit.reviewdb.client.PatchSet.Id , java.util.Collection < com.google.gerrit.reviewdb.client.PatchSetApproval > > all , com.google.gerrit.common.data.LabelTypes labelTypes ) { java.util.Collection < com.google.gerrit.reviewdb.client.PatchSetApproval > list = all.get ( id ) ; if ( list != null ) { addApprovals ( p , list , labelTypes ) ; } }
private com.google.gerrit.server.project.ProjectControl user ( com.google.gerrit.server.git.ProjectConfig local , java.lang.String name , com.google.gerrit.reviewdb.client.AccountGroup ... memberOf ) { return new com.google.gerrit.server.project.ProjectControl ( java.util.Collections.< com.google.gerrit.reviewdb.client.AccountGroup.UUID > emptySet ( ) , java.util.Collections.< com.google.gerrit.reviewdb.client.AccountGroup.UUID > emptySet ( ) , sectionSorter , changeControlFactory , permissionBackend , new com.google.gerrit.server.project.RefControlTest.MockUser ( name , memberOf ) , newProjectState ( local ) ) ; }
static < T > void invoke ( final com.google.gwtjsonrpc.client.JsonSerializer < T > resultSerializer , final com.google.gwt.user.client.rpc.AsyncCallback < T > callback , final java.lang.Object encoded ) { final T resobj ; try { resobj = ( encoded != null ) ? resultSerializer.fromJson ( encoded ) : null ; } catch ( java.lang.RuntimeException e ) { callback.onFailure ( new com.google.gwt.user.client.rpc.InvocationException ( "Invalid JSON response" , e ) ) ; return ; } callback.onSuccess ( resobj ) ; }
public void onLoad ( ) { if ( ( descriptionPanel ) == null ) { initUI ( ) ; } displayTitle ( ( ( changeInfo ) != null ? changeInfo.getSubject ( ) : null ) ) ; super . onLoad ( ) ; Util.DETAIL_SVC.changeDetail ( changeId , new com.google.gerrit.client.rpc.ScreenLoadCallback < com.google.gerrit.client.data.ChangeDetail > ( ) { public void onSuccess ( final com.google.gerrit.client.data.ChangeDetail r ) { if ( isAttached ( ) ) { display ( r ) ; } } } ) ; }
public void onSuccess ( com.google.gerrit.client.rpc.NativeString result ) { renderSubmitType ( result.asString ( ) ) ; }
private static void addDiffLink ( final com.google.gerrit.client.ui.LinkMenuBar m , final java.lang.String text , final com.google.gerrit.client.patches.PatchScreen.TopView tv ) { m.addItem ( new com.google.gerrit.client.ui.LinkMenuItem ( text , "" ) { @ java.lang.Override public void go ( ) { if ( ( com.google.gerrit.client.Gerrit.patchScreen ) != null ) { com.google.gerrit.client.Gerrit.patchScreen.setTopView ( tv ) ; } com.google.gwt.dom.client.AnchorElement.as ( getElement ( ) ) . blur ( ) ; } } ) ; }
public com.google.gerrit.extensions.restapi.Response < ? > apply ( com.google.gerrit.server.change.ChangeResource rsrc , com.google.gerrit.server.change.DeleteChangeEdit.Input input ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.extensions.restapi.BadRequestException , com.google.gerrit.server.project.InvalidChangeOperationException , java.io.IOException { com.google.common.base.Optional < com.google.gerrit.server.edit.ChangeEdit > edit = editUtil.byChange ( rsrc.getChange ( ) ) ; if ( edit.isPresent ( ) ) { editUtil.delete ( edit.get ( ) ) ; } else { throw new com.google.gerrit.extensions.restapi.BadRequestException ( "change edit doesn't exist" ) ; } return com.google.gerrit.extensions.restapi.Response.none ( ) ; }
public com.google.gerrit.extensions.common.ChangeInfo apply ( com.google.gerrit.server.change.ChangeResource req , final com.google.gerrit.extensions.api.changes.AbandonInput input ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.git.UpdateException , com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl control = req.getControl ( ) ; com.google.gerrit.server.IdentifiedUser caller = ( ( com.google.gerrit.server.IdentifiedUser ) ( control.getUser ( ) ) ) ; if ( ! ( control.canAbandon ( ) ) ) { throw new com.google.gerrit.extensions.restapi.AuthException ( "abandon not permitted" ) ; } com.google.gerrit.reviewdb.client.Change change = abandon ( control , input.message , caller.getAccount ( ) ) ; return json.create ( ChangeJson.NO_OPTIONS ) . format ( change ) ; }
public void testUpsertTwoSecondExisting ( ) throws com.google.gwtorm.server.OrmException , java.sql.SQLException { java.sql.PreparedStatement update = stubStatementWithUpdateCounts ( com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE , 0 , 1 ) ; java.sql.PreparedStatement insert = stubStatementWithUpdateCounts ( com.google.gwtorm.jdbc.TestJdbcAccess.INSERT , 1 ) ; createClassUnderTest ( ) . upsert ( twoRows ) ; com.google.gwtorm.jdbc.TestJdbcAccess.assertUsedBatchingOnly ( update ) ; com.google.gwtorm.jdbc.TestJdbcAccess.assertUsedBatchingOnly ( insert ) ; com.google.gwtorm.jdbc.TestJdbcAccess.assertExpectedIdsUsed ( insert , 1 ) ; }
public com.google.gerrit.extensions.api.projects.ChildProjectApi child ( java.lang.String name ) throws com.google.gerrit.extensions.restapi.RestApiException { try { return childApi.create ( children.parse ( checkExists ( ) , com.google.gerrit.extensions.restapi.IdString.fromDecoded ( name ) ) ) ; } catch ( java.io.IOException | com.google.gerrit.server.permissions.PermissionBackendException e ) { throw new com.google.gerrit.extensions.restapi.RestApiException ( "Cannot parse child project" , e ) ; } }
public com.google.gerrit.extensions.common.DiffInfo diff ( java.lang.String base ) throws com.google.gerrit.extensions.restapi.RestApiException { try { return getDiff.setBase ( base ) . apply ( file ) . value ( ) ; } catch ( java.io.IOException | com.google.gerrit.server.project.InvalidChangeOperationException | com.google.gwtorm.server.OrmException e ) { throw new com.google.gerrit.extensions.restapi.RestApiException ( "Cannot retrieve diff" , e ) ; } }
private static java.lang.String missingUserIds ( java.util.Set < java.lang.String > allowedUserIds ) { java.lang.StringBuilder sb = new java.lang.StringBuilder ( ( "Key must contain a valid" + " certification for one of the following identities:\n" ) ) ; java.util.Iterator < java.lang.String > sorted = allowedUserIds.stream ( ) . sorted ( ) . iterator ( ) ; while ( sorted.hasNext ( ) ) { sb.append ( " " ) . append ( sorted.next ( ) ) ; if ( sorted.hasNext ( ) ) { sb.append ( '\n' ) ; } } return sb.toString ( ) ; }
public com.google.gerrit.extensions.common.SshKeyInfo addSshKey ( java.lang.String key ) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.common.SshKeyInput in = new com.google.gerrit.extensions.common.SshKeyInput ( ) ; in.raw = com.google.gerrit.common.RawInputUtil.create ( key ) ; try { return addSshKey.apply ( account , in ) . value ( ) ; } catch ( java.lang.Exception e ) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException ( "Cannot add SSH key" , e ) ; } }
protected void run ( ) throws com.googlesource.gerrit.plugins.verifystatus.UnloggedFailure { try { checkPermission ( ) ; } catch ( com.google.gerrit.common.errors.PermissionDeniedException err ) { throw new com.googlesource.gerrit.plugins.verifystatus.UnloggedFailure ( ( "fatal: " + ( err.getMessage ( ) ) ) ) ; } final com.googlesource.gerrit.plugins.verifystatus.VerifyStatusQueryShell shell = factory.create ( in , out ) ; shell.setOutputFormat ( format ) ; if ( ( query ) != null ) { shell.execute ( query ) ; } else { shell.run ( ) ; } }
public void run ( ) { try ( com.google.gerrit.reviewdb.server.ReviewDb db = database.open ( ) ) { for ( ; ; ) { final com.google.gerrit.reviewdb.client.AccountExternalId extId = next ( ) ; if ( extId == null ) { break ; } convertLocalUserToLowerCase ( db , extId ) ; synchronized ( monitor ) { monitor.update ( 1 ) ; } } } catch ( com.google.gwtorm.server.OrmException e ) { e.printStackTrace ( ) ; } }
public void operationComplete ( org.apache.mina.core.future.IoFuture future ) { final com.google.gerrit.sshd.SshScope.Context ctx = new com.google.gerrit.sshd.SshScope.Context ( sd ) ; final com.google.gerrit.sshd.SshScope.Context old = com.google.gerrit.sshd.SshScope.set ( ctx ) ; try { log.onLogout ( ) ; } finally { com.google.gerrit.sshd.SshScope.set ( old ) ; } }
private void innerTest ( ) { try { outer ( ) ; org.junit.Assert.fail ( "should throw" ) ; } catch ( java.lang.IllegalStateException e ) { java.lang.StackTraceElement [ ] trimmed = com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.trimStack ( e.getStackTrace ( ) , java.lang.Thread.currentThread ( ) . getStackTrace ( ) [ 1 ] ) ; java.lang.String str = java.util.Arrays.toString ( trimmed ) ; com.google.common.truth.Truth.assertThat ( str ) . doesNotContain ( "trimStackTrace" ) ; com.google.common.truth.Truth.assertThat ( str ) . contains ( "innerTest" ) ; } }
public void setCommit ( org.eclipse.jgit.revwalk.RevWalk rw , org.eclipse.jgit.lib.ObjectId id , java.lang.String pushCert ) throws java.io.IOException { org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit ( id ) ; rw.parseBody ( commit ) ; this . commit = commit ; subject = commit.getShortMessage ( ) ; this . pushCert = pushCert ; }
public int getLineCount ( final int file ) throws com.google.gerrit.client.rpc.CorruptEntityException , com.google.gerrit.client.rpc.NoDifferencesException , com.google.gerrit.client.rpc.NoSuchEntityException , com.google.gwtorm.client.OrmException , java.io.IOException { final byte [ ] c = getFileContent ( file ) ; final org.spearce.jgit.util.IntList m = getLineMap ( file ) ; final int n = m.size ( ) ; if ( ( n > 0 ) && ( ( m.get ( ( n - 1 ) ) ) == ( c.length ) ) ) { return n - 1 ; } return n ; }
private int limit ( com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > s ) { int n = ( queryBuilder.hasLimit ( s ) ) ? queryBuilder.getLimit ( s ) : maxLimit ; return ( limit ) > 0 ? ( java.lang.Math.min ( n , limit ) ) + 1 : n ; }
private void streamFile ( javax.servlet.http.HttpServletRequest req , javax.servlet.http.HttpServletResponse res ) throws java.io.IOException { java.io.File f = configFile ( req ) ; res.setStatus ( HttpServletResponse.SC_OK ) ; res.setContentType ( "application/octet-stream" ) ; res.setContentLength ( ( ( int ) ( f.length ( ) ) ) ) ; java.io.OutputStream out = res.getOutputStream ( ) ; java.io.InputStream in = new java.io.FileInputStream ( f ) ; try { com.google.common.io.ByteStreams.copy ( in , out ) ; } finally { in.close ( ) ; } }
void importGit ( ) throws com.google.gwtorm.client.OrmException , java.io.IOException { if ( flags.importProjects ) { java.lang.System.err.println ( ( "Scanning " + ( repositoryManager.getBasePath ( ) ) ) ) ; gitProjectImporter.run ( new com.google.gerrit.server.git.GitProjectImporter.Messages ( ) { @ java.lang.Override public void warning ( java.lang.String msg ) { java.lang.System.err.println ( msg ) ; java.lang.System.err.flush ( ) ; } } ) ; } }
private void fireHook ( ) { final java.util.Map < com.google.gerrit.reviewdb.ApprovalCategory.Id , com.google.gerrit.reviewdb.ApprovalCategoryValue.Id > changed = new java.util.HashMap < com.google.gerrit.reviewdb.ApprovalCategory.Id , com.google.gerrit.reviewdb.ApprovalCategoryValue.Id > ( ) ; for ( com.google.gerrit.reviewdb.ApprovalCategoryValue.Id v : approvals ) { changed.put ( v.getParentKey ( ) , v ) ; } hooks.doCommentAddedHook ( change , user.getAccount ( ) , messageText , changed ) ; }
public com.google.gerrit.reviewdb.client.Change update ( com.google.gerrit.reviewdb.client.Change c ) { c.setStatus ( Change.Status.MERGED ) ; c.setSubmissionId ( submissionId ) ; if ( ! ( merged.equals ( c.currentPatchSetId ( ) ) ) ) { try { c.setCurrentPatchSet ( patchSetInfoFactory.get ( db , merged ) ) ; } catch ( com.google.gerrit.server.patch.PatchSetInfoNotAvailableException e1 ) { logError ( ( "Cannot read merged patch set " + merged ) , e1 ) ; } } com.google.gerrit.server.ChangeUtil.updated ( c ) ; return c ; }
private int getPort ( java.net.URL originalUrl ) { java.lang.String protocol = originalUrl.getProtocol ( ) . toLowerCase ( ) ; int port = originalUrl.getPort ( ) ; if ( port == ( - 1 ) ) { return protocol.equals ( "https" ) ? 443 : 80 ; } else { return port ; } }
public void mergeByOtherNotifyOwnerReviewers ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS , com.google.gerrit.server.account.WatchConfig.NotifyType.SUBMITTED_CHANGES ) ; merge ( sc.changeId , other , com.google.gerrit.extensions.api.changes.NotifyHandling.OWNER_REVIEWERS ) ; assertThat ( sender ) . sent ( "merged" , sc ) . to ( sc.owner ) . to ( sc.reviewerByEmail ) . cc ( sc.reviewer , sc.ccer ) . cc ( sc.ccerByEmail ) . notTo ( sc.starrer ) . notTo ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS , com.google.gerrit.server.account.WatchConfig.NotifyType.SUBMITTED_CHANGES ) ; }
public void testMIXED_NullUser ( ) { setFrom ( "MIXED" ) ; org.easymock.EasyMock.replay ( accountCache ) ; final com.google.gerrit.server.mail.Address r = create ( ) . from ( null ) ; assertNotNull ( r ) ; assertEquals ( ident.getName ( ) , r.name ) ; assertEquals ( ident.getEmailAddress ( ) , r.email ) ; org.easymock.EasyMock.verify ( accountCache ) ; }
public void commitTime ( ) throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit root = repo.commit ( ) . create ( ) ; org.eclipse.jgit.revwalk.RevCommit master = repo.commit ( ) . parent ( root ) . create ( ) ; org.junit.Assert.assertEquals ( ( ( start ) + 1 ) , getTime ( root ) ) ; org.junit.Assert.assertEquals ( ( ( start ) + 2 ) , getTime ( master ) ) ; }
public void deleteBranchesNotFoundContinue ( ) throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DeleteBranchesInput input = new com.google.gerrit.extensions.api.projects.DeleteBranchesInput ( ) ; java.util.List < java.lang.String > branches = com.google.common.collect.Lists.newArrayList ( "refs/heads/does-not-exist" ) ; branches.addAll ( com.google.gerrit.acceptance.rest.project.DeleteBranchesIT.BRANCHES ) ; input.branches = branches ; try { project ( ) . deleteBranches ( input ) ; org.junit.Assert.fail ( "Expected ResourceConflictException" ) ; } catch ( com.google.gerrit.extensions.restapi.ResourceConflictException e ) { com.google.common.truth.Truth.assertThat ( e ) . hasMessageThat ( ) . isEqualTo ( errorMessageForBranches ( com.google.common.collect.ImmutableList.of ( "refs/heads/does-not-exist" ) ) ) ; } assertBranchesDeleted ( ) ; }
public java.lang.String fetch ( java.lang.String projectName , java.lang.String commitId ) throws java.io.IOException { final org.eclipse.jgit.lib.Repository repo = repoManager.openRepository ( new com.google.gerrit.reviewdb.client.Project.NameKey ( projectName ) ) ; try { org.eclipse.jgit.revwalk.RevWalk revWalk = new org.eclipse.jgit.revwalk.RevWalk ( repo ) ; org.eclipse.jgit.revwalk.RevCommit commit = revWalk.parseCommit ( org.eclipse.jgit.lib.ObjectId.fromString ( commitId ) ) ; return commit.getFullMessage ( ) ; } finally { repo.close ( ) ; } }
public boolean equals ( java.lang.Object o ) { com.google.gerrit.client.change.History.AuthorRevision b = ( ( com.google.gerrit.client.change.History.AuthorRevision ) ( o ) ) ; return ( ( author ) == ( b.author ) ) && ( ( revision ) == ( b.revision ) ) ; }
public void getChildProject ( ) throws java.lang.Exception { com.google.gerrit.acceptance.SshSession sshSession = new com.google.gerrit.acceptance.SshSession ( server , admin ) ; com.google.gerrit.reviewdb.client.Project.NameKey child = new com.google.gerrit.reviewdb.client.Project.NameKey ( "p1" ) ; createProject ( child.get ( ) ) ; sshSession.close ( ) ; com.google.gerrit.extensions.common.ProjectInfo childInfo = gApi.projects ( ) . name ( allProjects.get ( ) ) . child ( child.get ( ) ) . get ( ) ; com.google.gerrit.acceptance.rest.project.ProjectAssert.assertProjectInfo ( projectCache.get ( child ) . getProject ( ) , childInfo ) ; }
public synchronized < F1 > com.google.gerrit.metrics.Timer1 < F1 > newTimer ( java.lang.String name , com.google.gerrit.metrics.Description desc , com.google.gerrit.metrics.Field < F1 > field1 ) { com.google.gerrit.metrics.dropwizard.DropWizardMetricMaker.checkTimerDescription ( desc ) ; com.google.gerrit.metrics.dropwizard.TimerImpl1 < F1 > m = new com.google.gerrit.metrics.dropwizard.TimerImpl1 ( this , name , desc , field1 ) ; define ( name , desc ) ; bucketed.put ( name , m ) ; return m.timer ( ) ; }
private static void assertSingleWord ( final java.lang.String name , final java.lang.String value , final org.antlr.runtime.tree.Tree r ) { assertEquals ( QueryParser.FIELD_NAME , r.getType ( ) ) ; assertEquals ( name , r.getText ( ) ) ; assertEquals ( 1 , r.getChildCount ( ) ) ; final org.antlr.runtime.tree.Tree c = r.getChild ( 0 ) ; assertEquals ( QueryParser.SINGLE_WORD , c.getType ( ) ) ; assertEquals ( value , c.getText ( ) ) ; assertEquals ( 0 , c.getChildCount ( ) ) ; }
public void testPrefixReducesSearchSpace ( ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.RegexFilePredicate p = com.google.gerrit.server.query.change.RegexFilePredicateTest.predicate ( "^a/b/.*\\.[ch]" ) ; assertTrue ( p.match ( com.google.gerrit.server.query.change.RegexFilePredicateTest.change ( "a/b/source.c" ) ) ) ; assertFalse ( p.match ( com.google.gerrit.server.query.change.RegexFilePredicateTest.change ( "a/b/source.res" ) ) ) ; assertFalse ( p.match ( com.google.gerrit.server.query.change.RegexFilePredicateTest.change ( "source.res" ) ) ) ; assertTrue ( p.match ( com.google.gerrit.server.query.change.RegexFilePredicateTest.change ( "a/b/a.a" , "a/b/a.d" , "a/b/a.h" ) ) ) ; }
void commitNotes ( ) throws java.io.IOException , org.eclipse.jgit.api.errors.ConcurrentRefUpdateException { try { if ( ( serviceUserNotes ) == null ) { return ; } message.insert ( 0 , "Update notes for service user commits\n\n" ) ; notesBranchUtilFactory.create ( project , git , inserter ) . commitAllNotes ( serviceUserNotes , com.googlesource.gerrit.plugins.serviceuser.CreateServiceUserNotes.REFS_NOTES_SERVICEUSER , gerritServerIdent , message.toString ( ) ) ; } finally { if ( ( inserter ) != null ) { inserter.release ( ) ; } } }
public com.google.gerrit.server.project.ChangeControl controlFor ( com.google.gerrit.reviewdb.client.Change change , com.google.gerrit.server.CurrentUser user ) throws com.google.gerrit.server.project.NoSuchChangeException { final com.google.gerrit.reviewdb.client.Project.NameKey projectKey = change.getProject ( ) ; try { return projectControl.controlFor ( projectKey , user ) . controlFor ( change ) ; } catch ( com.google.gerrit.server.project.NoSuchProjectException e ) { throw new com.google.gerrit.server.project.NoSuchChangeException ( change.getId ( ) , e ) ; } }
public void testHashCode ( ) { assertTrue ( ( ( com.google.gerrit.server.query.FieldPredicateTest.f ( "a" , "bob" ) . hashCode ( ) ) == ( com.google.gerrit.server.query.FieldPredicateTest.f ( "a" , "bob" ) . hashCode ( ) ) ) ) ; assertFalse ( ( ( com.google.gerrit.server.query.FieldPredicateTest.f ( "a" , "bob" ) . hashCode ( ) ) == ( com.google.gerrit.server.query.FieldPredicateTest.f ( "a" , "alice" ) . hashCode ( ) ) ) ) ; }
public void submitOnPushMergeConflict ( ) throws java.lang.Exception { org.eclipse.jgit.lib.ObjectId objectId = git.getRepository ( ) . getRef ( "HEAD" ) . getObjectId ( ) ; push ( "refs/heads/master" , "one change" , "a.txt" , "some content" ) ; testRepo.reset ( objectId ) ; grant ( Permission.SUBMIT , project , "refs/for/refs/heads/master" ) ; com.google.gerrit.acceptance.PushOneCommit.Result r = push ( "refs/for/master%submit" , "other change" , "a.txt" , "other content" ) ; r.assertOkStatus ( ) ; r.assertChange ( Change.Status.NEW , null , admin ) ; r.assertMessage ( CommitMergeStatus.PATH_CONFLICT.getMessage ( ) ) ; }
private static com.google.gerrit.server.change.GetRelated.ChangeAndCommit changeAndCommit ( com.google.gerrit.reviewdb.client.PatchSet.Id psId , org.eclipse.jgit.lib.ObjectId commitId , int currentRevisionNum ) { com.google.gerrit.server.change.GetRelated.ChangeAndCommit result = new com.google.gerrit.server.change.GetRelated.ChangeAndCommit ( ) ; result._changeNumber = psId.getParentKey ( ) . get ( ) ; result.commit = new com.google.gerrit.extensions.common.CommitInfo ( ) ; result.commit.commit = commitId.name ( ) ; result._revisionNumber = psId.get ( ) ; result._currentRevisionNumber = currentRevisionNum ; result.status = "NEW" ; return result ; }
protected void configure ( ) { if ( ! ( com.google.gerrit.gpg.BouncyCastleUtil.havePGP ( ) ) ) { throw new com.google.inject.ProvisionException ( "Bouncy Castle PGP not installed" ) ; } bind ( com.google.gerrit.gpg.PublicKeyChecker.class ) . to ( com.google.gerrit.gpg.GerritPublicKeyChecker.class ) ; bind ( com.google.gerrit.gpg.PublicKeyStore.class ) . toProvider ( com.google.gerrit.gpg.SignedPushModule.StoreProvider.class ) ; com.google.gerrit.extensions.registration.DynamicSet.bind ( binder ( ) , com.google.gerrit.server.git.ReceivePackInitializer.class ) . to ( com.google.gerrit.gpg.SignedPushModule.Initializer.class ) ; }
public static void put ( int id , java.lang.String path , java.lang.String content , com.google.gerrit.client.rpc.GerritCallback < com.google.gerrit.client.VoidResult > cb ) { if ( Patch.COMMIT_MSG.equals ( path ) ) { com.google.gerrit.client.changes.ChangeEditApi.putMessage ( id , content , cb ) ; } else { com.google.gerrit.client.changes.ChangeEditApi.editFile ( id , path ) . put ( content , cb ) ; } }
private java.util.Optional < com.google.gerrit.server.group.InternalGroup > toInternalGroup ( com.google.gson.JsonElement json ) { com.google.gson.JsonElement source = json.getAsJsonObject ( ) . get ( "_source" ) ; if ( source == null ) { source = json.getAsJsonObject ( ) . get ( "fields" ) ; } com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID ( source.getAsJsonObject ( ) . get ( GroupField.UUID.getName ( ) ) . getAsString ( ) ) ; return groupCache.get ( ) . getInternalGroup ( uuid ) ; }
protected com.google.gerrit.server.notedb.LoadHandle openHandle ( org.eclipse.jgit.lib.Repository repo ) throws java.io.IOException { if ( ( ( change ) != null ) && ( autoRebuild ) ) { com.google.gerrit.server.notedb.NoteDbChangeState state = com.google.gerrit.server.notedb.NoteDbChangeState.parse ( change ) ; if ( ( state == null ) || ( ! ( state.areDraftsUpToDate ( new com.google.gerrit.server.git.RepoRefCache ( repo ) , author ) ) ) ) { return rebuildAndOpen ( repo ) ; } } return super . openHandle ( repo ) ; }
private java.lang.String getRedirectUrl ( java.lang.String pathAndQuery ) throws java.io.IOException , javax.servlet.ServletException { com.google.gitiles.TestViewFilter.Result result = com.google.gitiles.TestViewFilter.service ( repo , pathAndQuery ) ; org.junit.Assert.assertEquals ( 302 , result.getResponse ( ) . getStatus ( ) ) ; return result.getResponse ( ) . getHeader ( com.google.common.net.HttpHeaders.LOCATION ) ; }
protected void configure ( ) { bind ( com.google.gerrit.server.index.IndexConfig.class ) . toInstance ( com.google.gerrit.server.index.IndexConfig.createDefault ( ) ) ; factory ( LuceneChangeIndex.Factory.class ) ; install ( new com.google.gerrit.server.index.IndexModule ( threads ) ) ; if ( ( ( singleVersion ) == null ) && ( ( base ) == null ) ) { install ( new com.google.gerrit.lucene.LuceneIndexModule.MultiVersionModule ( ) ) ; } else { install ( new com.google.gerrit.lucene.LuceneIndexModule.SingleVersionModule ( ) ) ; } }
public boolean match ( final com.google.gerrit.server.query.change.ChangeData cd ) throws com.google.gwtorm.client.OrmException { if ( cd.fastIsVisibleTo ( user ) ) { return true ; } try { com.google.gerrit.reviewdb.Change c = cd.change ( db ) ; if ( ( c != null ) && ( changeControl.controlFor ( c ) . forUser ( user ) . isVisible ( ) ) ) { cd.cacheVisibleTo ( user ) ; return true ; } else { return false ; } } catch ( com.google.gerrit.server.project.NoSuchChangeException e ) { return false ; } }
private com.google.gerrit.extensions.common.ApprovalInfo getVote ( com.google.gerrit.extensions.api.changes.ChangeApi change , java.lang.String label ) throws com.google.gerrit.extensions.restapi.RestApiException { return change.get ( java.util.EnumSet.of ( ListChangesOption.DETAILED_LABELS ) ) . labels.get ( label ) . all.get ( 0 ) ; }
private void appendFileLine ( java.lang.StringBuilder cmts , com.google.gerrit.server.patch.PatchFile fileData , short side , int line ) { java.lang.String lineStr = getLine ( fileData , side , line ) ; cmts.append ( ( ( ( ( "Line " + line ) + ": " ) + lineStr ) + "\n" ) ) ; }
public java.util.Map < java.lang.String , com.google.gerrit.extensions.common.GpgKeyInfo > putGpgKeys ( com.google.gerrit.server.account.AccountResource account , java.util.List < java.lang.String > add , java.util.List < java.lang.String > delete ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.GpgException { com.google.gerrit.gpg.server.PostGpgKeys.Input in = new com.google.gerrit.gpg.server.PostGpgKeys.Input ( ) ; in.add = add ; in.delete = delete ; try { return postGpgKeys.apply ( account , in ) ; } catch ( org.bouncycastle.openpgp.PGPException | com.google.gwtorm.server.OrmException | java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e ) { throw new com.google.gerrit.server.GpgException ( e ) ; } }
public void setUp ( ) throws java.lang.Exception { index = new com.google.gerrit.server.index.FakeIndex ( FakeIndex.V2 ) ; indexes = new com.google.gerrit.server.index.IndexCollection ( ) ; indexes.setSearchIndex ( index ) ; queryBuilder = new com.google.gerrit.server.index.FakeQueryBuilder ( indexes ) ; rewrite = new com.google.gerrit.server.index.IndexRewriteImpl ( indexes , new com.google.gerrit.server.query.change.BasicChangeRewrites ( null , indexes ) ) ; }
public void byKey ( ) throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository < com.google.gerrit.testutil.InMemoryRepositoryManager.Repo > repo = createProject ( "repo" ) ; com.google.gerrit.reviewdb.client.Change change = insert ( newChange ( repo ) ) ; java.lang.String key = change.getKey ( ) . get ( ) ; assertQuery ( "I0000000000000000000000000000000000000000" ) ; for ( int i = 0 ; i <= 36 ; i ++ ) { java.lang.String q = key.substring ( 0 , ( 41 - i ) ) ; assertQuery ( q , change ) ; } }
public static java.util.List < com.google.gitiles.blame.Region > loadBlame ( com.google.gitiles.blame.BlameCacheImpl.Key key ) throws java.io.IOException { try { org.eclipse.jgit.blame.BlameGenerator gen = new org.eclipse.jgit.blame.BlameGenerator ( key.repo , key.path ) ; try { gen.push ( null , key.commitId ) ; return com.google.gitiles.blame.BlameCacheImpl.loadRegions ( gen ) ; } finally { gen.release ( ) ; } } finally { key.repo = null ; } }
public void getRelatedNoResult ( ) throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create ( db , admin.getIdent ( ) ) ; com.google.gerrit.reviewdb.client.PatchSet.Id ps = push.to ( git , "refs/for/master" ) . getPatchSetId ( ) ; java.util.List < com.google.gerrit.server.change.GetRelated.ChangeAndCommit > related = getRelated ( ps ) ; org.junit.Assert.assertEquals ( 0 , related.size ( ) ) ; }
public void bind ( com.googlecode.prolog_cafe.lang.Term t , com.googlecode.prolog_cafe.lang.Trail trail ) { if ( t.isVariable ( ) ) { com.googlecode.prolog_cafe.lang.VariableTerm v = ( ( com.googlecode.prolog_cafe.lang.VariableTerm ) ( t ) ) ; if ( ( v.timeStamp ) >= ( this . timeStamp ) ) { v.val = this ; if ( ( v.timeStamp ) < ( trail.timeStamp ) ) trail.push ( v ) ; return ; } } val = t ; if ( ( timeStamp ) < ( trail.timeStamp ) ) trail.push ( this ) ; }
public static < T > void mapOf ( com.google.inject.Binder binder , com.google.inject.TypeLiteral < T > member ) { @ java.lang.SuppressWarnings ( value = "unchecked" ) com.google.inject.Key < com.google.gerrit.extensions.registration.DynamicMap < T > > key = ( ( com.google.inject.Key < com.google.gerrit.extensions.registration.DynamicMap < T > > ) ( com.google.inject.Key.get ( com.google.inject.util.Types.newParameterizedType ( com.google.gerrit.extensions.registration.DynamicMap.class , member.getType ( ) ) ) ) ) ; binder.bind ( key ) . toProvider ( new com.google.gerrit.extensions.registration.DynamicMapProvider < T > ( member ) ) . in ( Scopes.SINGLETON ) ; }
private void applyReview ( final com.google.gerrit.server.project.ChangeControl ctl , final com.google.gerrit.reviewdb.client.PatchSet patchSet , final com.google.gerrit.server.change.PostReview.Input review ) throws java.lang.Exception { if ( ! ( review.labels.isEmpty ( ) ) ) { reviewProvider.get ( ) . apply ( new com.google.gerrit.server.change.RevisionResource ( new com.google.gerrit.server.change.ChangeResource ( ctl ) , patchSet ) , review ) ; } }
private com.google.gerrit.extensions.restapi.BinaryResult wrapBlob ( com.google.gerrit.server.project.ProjectState project , java.lang.String path , final org.eclipse.jgit.lib.ObjectLoader obj , byte [ ] raw , eu.medsea.mimeutil.MimeType contentType , @ com.google.gerrit.common.Nullable java.lang.String suffix ) { return com.google.gerrit.server.change.FileContentUtil.asBinaryResult ( raw , obj ) . setContentType ( contentType.toString ( ) ) . setAttachmentName ( com.google.gerrit.server.change.FileContentUtil.safeFileName ( path , suffix ) ) ; }
protected Project.NameKey createProject ( java.lang.String nameSuffix , com.google.gerrit.reviewdb.client.Project.NameKey parent , boolean createEmptyCommit ) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.api.projects.ProjectInput in = new com.google.gerrit.extensions.api.projects.ProjectInput ( ) ; in.name = ( projectPrefix ) + nameSuffix ; in.parent = ( parent != null ) ? parent.get ( ) : null ; in.createEmptyCommit = createEmptyCommit ; return createProject ( in ) ; }
public com.google.gerrit.extensions.registration.DynamicMap < T > get ( ) { com.google.gerrit.extensions.registration.PrivateInternals_DynamicMapImpl < T > m = new com.google.gerrit.extensions.registration.PrivateInternals_DynamicMapImpl < T > ( ) ; java.util.List < com.google.inject.Binding < T > > bindings = injector.findBindingsByType ( type ) ; if ( bindings != null ) { for ( com.google.inject.Binding < T > b : bindings ) { if ( ( b.getKey ( ) . getAnnotation ( ) ) != null ) { m.put ( "gerrit" , b.getKey ( ) , b.getProvider ( ) ) ; } } } return m ; }
private static boolean isStaticResource ( javax.servlet.http.HttpServletRequest httpRequest ) { java.lang.String requestURI = httpRequest.getRequestURI ( ) ; java.lang.String pathExt = org.apache.commons.lang.StringUtils.substringAfterLast ( requestURI , "." ) ; if ( org.apache.commons.lang.StringUtils.isEmpty ( pathExt ) ) { return false ; } boolean staticResource = com.googlesource.gerrit.plugins.github.oauth.OAuthFilter.GERRIT_STATIC_RESOURCES_EXTS.contains ( pathExt.toLowerCase ( ) ) ; java.lang.System.out.println ( ( ( ( ( ( "requestUri: " + requestURI ) + " pathExt: " ) + pathExt ) + " static: " ) + staticResource ) ) ; return staticResource ; }
private com.google.gwtorm.client.OrmException convertError ( final java.lang.String op , final java.sql.SQLException err ) { if ( ( ( err.getCause ( ) ) == null ) && ( ( err.getNextException ( ) ) != null ) ) { err.initCause ( err.getNextException ( ) ) ; } return schema.getDialect ( ) . convertError ( op , com.google.gwtorm.jdbc.JdbcAccess.getRelationName ( ) , err ) ; }
public void testOwnerProject ( ) { com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.OWNER , com.google.gerrit.server.project.Util.ADMIN , "refs/*" ) ; com.google.gerrit.server.project.ProjectControl uBlah = util.user ( local , com.google.gerrit.server.project.Util.DEVS ) ; com.google.gerrit.server.project.ProjectControl uAdmin = util.user ( local , com.google.gerrit.server.project.Util.DEVS , com.google.gerrit.server.project.Util.ADMIN ) ; assertFalse ( "not owner" , uBlah.isOwner ( ) ) ; assertTrue ( "is owner" , uAdmin.isOwner ( ) ) ; }
private void rename ( java.lang.String path , java.lang.String newPath ) { hide ( ) ; com.google.gerrit.client.changes.ChangeEditApi.rename ( changeId.get ( ) , path , newPath , new com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.client.VoidResult > ( ) { @ java.lang.Override public void onSuccess ( com.google.gerrit.client.VoidResult result ) { com.google.gerrit.client.Gerrit.display ( com.google.gerrit.common.PageLinks.toChangeInEditMode ( changeId ) ) ; } @ java.lang.Override public void onFailure ( java.lang.Throwable caught ) { } } ) ; }
public void setUp ( ) throws java.lang.Exception { normalProject = createProject ( "normal" ) ; secretProject = createProject ( "secret" ) ; secretRefProject = createProject ( "secretRef" ) ; privilegedGroup = groupCache.get ( new com.google.gerrit.reviewdb.client.AccountGroup.NameKey ( createGroup ( "privilegedGroup" ) ) ) . orElse ( null ) ; privilegedUser = accountCreator.create ( "privilegedUser" , "snowden@nsa.gov" , "Ed Snowden" ) ; gApi.groups ( ) . id ( privilegedGroup.getGroupUUID ( ) . get ( ) ) . addMembers ( privilegedUser.username ) ; com.google.common.truth.Truth.assertThat ( gApi.groups ( ) . id ( privilegedGroup.getGroupUUID ( ) . get ( ) ) . members ( ) . get ( 0 ) . email ) . contains ( "snowden" ) ; grant ( secretProject , "refs/*" , Permission.READ , false , privilegedGroup.getGroupUUID ( ) ) ; block ( secretProject , "refs/*" , Permission.READ , SystemGroupBackend.REGISTERED_USERS ) ; deny ( secretRefProject , "refs/*" , Permission.READ , SystemGroupBackend.ANONYMOUS_USERS ) ; grant ( secretRefProject , "refs/heads/secret/*" , Permission.READ , false , privilegedGroup.getGroupUUID ( ) ) ; block ( secretRefProject , "refs/heads/secret/*" , Permission.READ , SystemGroupBackend.REGISTERED_USERS ) ; grant ( secretRefProject , "refs/heads/*" , Permission.READ , false , SystemGroupBackend.REGISTERED_USERS ) ; }
public void start ( final org.apache.sshd.server.Environment env ) { java.lang.String s = env.getEnv ( ) . get ( Environment.ENV_COLUMNS ) ; if ( ( s != null ) && ( ! ( s.isEmpty ( ) ) ) ) { try { columns = java.lang.Integer.parseInt ( s ) ; } catch ( java.lang.NumberFormatException err ) { columns = 80 ; } } startThread ( new com.google.gerrit.sshd.commands.CommandRunnable ( ) { @ java.lang.Override public void run ( ) throws java.lang.Exception { parseCommandLine ( ) ; com.google.gerrit.sshd.commands.ShowQueue.this . display ( ) ; } } ) ; }
private synchronized void runHook ( org.eclipse.jgit.lib.Repository repo , java.io.File hook , java.util.List < java.lang.String > args ) { if ( repo != null ) { if ( hook.exists ( ) ) { hookQueue.execute ( new com.google.gerrit.common.ChangeHookRunner.HookTask ( repo , hook , args ) ) ; } else { repo.close ( ) ; } } }
private void assertNotFound ( org.eclipse.jgit.lib.ObjectId id ) throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = userSession.get ( ( ( ( "/projects/" + ( project.get ( ) ) ) + "/commits/" ) + ( id.name ( ) ) ) ) ; com.google.common.truth.Truth.assertThat ( r.getStatusCode ( ) ) . isEqualTo ( HttpStatus.SC_NOT_FOUND ) ; }
public com.google.gitiles.GitilesView.Builder setRevision ( com.google.gitiles.Revision revision ) { switch ( type ) { case HOST_INDEX : case REPOSITORY_INDEX : case REFS : case DESCRIBE : throw new java.lang.IllegalStateException ( java.lang.String.format ( "cannot set revision on %s view" , type ) ) ; case ARCHIVE : case BLAME : case DIFF : case DOC : case LOG : case PATH : case REVISION : case ROOTED_DOC : case SHOW : default : this . revision = com.google.common.base.Preconditions.checkNotNull ( revision ) ; return this ; } }
public java.lang.String replace ( java.lang.String input ) { java.lang.String href = pat.replace ( input , link ) ; if ( ! ( com.google.gwtexpui.safehtml.client.LinkFindReplace.hasValidScheme ( href ) ) ) { throw new java.lang.IllegalArgumentException ( ( ( ( "Invalid scheme (" + ( toString ( ) ) ) + "): " ) + href ) ) ; } java.lang.String result = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder ( ) . openAnchor ( ) . setAttribute ( "href" , href ) . append ( com.google.gwtexpui.safehtml.client.SafeHtml.asis ( input ) ) . closeAnchor ( ) . asString ( ) ; return result ; }
private com.google.gerrit.reviewdb.client.PatchSetApproval getSubmitter ( com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change c = db.changes ( ) . get ( patchSetId.getParentKey ( ) ) ; com.google.gerrit.server.notedb.ChangeNotes notes = changeNotesFactory.create ( db , c ) . load ( ) ; return approvalsUtil.getSubmitter ( db , notes , patchSetId ) ; }
private java.lang.String toHex ( final byte [ ] b ) { final java.lang.StringBuilder sec = new java.lang.StringBuilder ( ) ; for ( int i = 0 ; i < ( b.length ) ; i ++ ) { final int u = ( ( b [ i ] ) > > 4 ) & 15 ; final int l = ( b [ i ] ) & 15 ; sec.append ( org.apache.commons.net.smtp.AuthSMTPClient.hexchar [ u ] ) ; sec.append ( org.apache.commons.net.smtp.AuthSMTPClient.hexchar [ l ] ) ; } return sec.toString ( ) ; }
public org.eclipse.jgit.lib.ObjectId findLastCommit ( org.eclipse.jgit.lib.Repository repo , org.eclipse.jgit.lib.ObjectId commitId , java.lang.String path ) throws java.io.IOException { org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk ( repo ) ; try { rw.markStart ( rw.parseCommit ( commitId ) ) ; rw.setRewriteParents ( false ) ; rw.setTreeFilter ( org.eclipse.jgit.treewalk.filter.AndTreeFilter.create ( org.eclipse.jgit.treewalk.filter.PathFilterGroup.createFromStrings ( path ) , TreeFilter.ANY_DIFF ) ) ; return rw.next ( ) ; } finally { rw.release ( ) ; } }
private void renderActionTextDate ( com.google.gerrit.client.changes.ChangeInfo info ) { java.lang.String action ; if ( info.created ( ) . equals ( info.updated ( ) ) ) { action = Util.C.changeInfoBlockUploaded ( ) ; } else { action = Util.C.changeInfoBlockUpdated ( ) ; } actionText.setInnerText ( action ) ; actionDate.setInnerText ( com.google.gerrit.client.FormatUtil.relativeFormat ( info.updated ( ) ) ) ; HEAD ( ( ( 2.0 - ( plugin ) ) - ( gwtui ( cli ) ) ) ) ; }
public com.googlecode.prolog_cafe.lang.Term arg ( int nth ) { com.googlecode.prolog_cafe.lang.Term t = this ; int old_nth = nth ; while ( ( t.isList ( ) ) && ( 0 < nth ) ) { nth -- ; t = ( ( com.googlecode.prolog_cafe.lang.ListTerm ) ( t ) ) . cdr.dereference ( ) ; } if ( t.isList ( ) ) return ( ( com.googlecode.prolog_cafe.lang.ListTerm ) ( t ) ) . car ; throw new java.lang.ArrayIndexOutOfBoundsException ( old_nth ) ; }
public org.eclipse.jgit.lib.Repository createRepository ( com.google.gerrit.reviewdb.client.Project.NameKey name ) throws com.google.gerrit.server.git.RepositoryCaseMismatchException , org.eclipse.jgit.errors.RepositoryNotFoundException { org.eclipse.jgit.lib.Repository repo = createRepository ( basePath , name ) ; if ( ( noteDbPath ) != null ) { createRepository ( noteDbPath , name ) ; } return repo ; }
private boolean canCreateServiceUser ( ) { if ( userProvider.get ( ) . isIdentifiedUser ( ) ) { com.google.gerrit.server.account.CapabilityControl ctl = userProvider.get ( ) . getCapabilities ( ) ; return ( ctl.canPerform ( ( ( ( pluginName ) + "-" ) + ( CreateServiceUserCapability.ID ) ) ) ) || ( ctl.canAdministrateServer ( ) ) ; } else { return false ; } }
public org.eclipse.jgit.lib.ObjectId commit ( ) throws com.google.gwtorm.server.OrmException , java.io.IOException { com.google.gerrit.server.notedb.NoteDbUpdateManager updateManager = updateManagerFactory.create ( getProjectName ( ) ) ; updateManager.add ( this ) ; updateManager.stageAndApplyDelta ( getChange ( ) ) ; updateManager.execute ( ) ; return getResult ( ) ; }
private void displayFile ( com.google.reviewit.widget.ScrollWithHeadingsView root , com.google.reviewit.app.Change change , java.lang.String path , com.google.gerrit.extensions.common.FileInfo file ) { java.util.Map < java.lang.String , com.google.gerrit.extensions.common.FileInfo > files = new java.util.HashMap < > ( ) ; files.put ( path , file ) ; displayFiles ( root , change , files ) ; }
public void stop ( ) { try { searcherManager.close ( ) ; } catch ( java.io.IOException e ) { com.google.gerrit.lucene.LuceneChangeIndex.log.warn ( "error closing Lucene searcher" , e ) ; } try { writer.close ( true ) ; } catch ( java.io.IOException e ) { com.google.gerrit.lucene.LuceneChangeIndex.log.warn ( "error closing Lucene writer" , e ) ; } try { dir.close ( ) ; } catch ( java.io.IOException e ) { com.google.gerrit.lucene.LuceneChangeIndex.log.warn ( "error closing Lucene directory" , e ) ; } }
private com.google.inject.Injector createWebInjector ( ) { final java.util.List < com.google.inject.Module > modules = new java.util.ArrayList < com.google.inject.Module > ( ) ; modules.add ( sshInjector.getInstance ( com.google.inject.Module.class ) ) ; modules.add ( sshInjector.getInstance ( com.google.gerrit.httpd.WebModule.class ) ) ; return sysInjector.createChildInjector ( modules ) ; }
public static void replyError ( javax.servlet.http.HttpServletRequest req , javax.servlet.http.HttpServletResponse res , int statusCode , java.lang.String msg , com.google.gerrit.extensions.restapi.CacheControl c , @ com.google.gerrit.common.Nullable java.lang.Throwable err ) throws java.io.IOException { if ( err != null ) { com.google.gerrit.util.http.RequestUtil.setErrorTraceAttribute ( req , err ) ; } com.google.gerrit.httpd.restapi.RestApiServlet.configureCaching ( req , res , null , c ) ; res.setStatus ( statusCode ) ; com.google.gerrit.httpd.restapi.RestApiServlet.replyText ( req , res , msg ) ; }
protected org.eclipse.jgit.junit.TestRepository < ? > createProjectWithPush ( java.lang.String name , @ com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey parent , boolean createEmptyCommit , com.google.gerrit.extensions.client.SubmitType submitType ) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey project = createProject ( name , parent , createEmptyCommit , submitType ) ; grant ( Permission.PUSH , project , "refs/heads/*" ) ; grant ( Permission.SUBMIT , project , "refs/for/refs/heads/*" ) ; return cloneProject ( project ) ; }
public void run ( ) { java.lang.String mode = ( ( m != null ) && ( ! ( m.isEmpty ( ) ) ) ) ? m : null ; view.getCmFromSide ( DisplaySide.A ) . setOption ( "mode" , mode ) ; view.getCmFromSide ( DisplaySide.B ) . setOption ( "mode" , mode ) ; }
public com.google.gerrit.extensions.restapi.Response < ? > apply ( com.google.gerrit.server.project.ProjectResource project , com.google.gerrit.extensions.api.projects.DeleteBranchesInput input ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gwtorm.server.OrmException , java.io.IOException { if ( ( ( input == null ) || ( ( input.branches ) == null ) ) || ( input.branches.isEmpty ( ) ) ) { throw new com.google.gerrit.extensions.restapi.BadRequestException ( "branches must be specified" ) ; } deleteRefFactory.create ( project ) . refs ( input.branches ) . delete ( ) ; return com.google.gerrit.extensions.restapi.Response.none ( ) ; HEAD ( 2 ) ; com.google.gerrit.server.project.a35a2 Merge ; }
public void extend ( com.google.gerrit.server.data.ChangeAttribute a , com.google.gerrit.reviewdb.client.Change change ) { a.createdOn = ( change.getCreatedOn ( ) . getTime ( ) ) / 1000L ; a.lastUpdated = ( change.getLastUpdatedOn ( ) . getTime ( ) ) / 1000L ; a.sortKey = change.getSortKey ( ) ; a.open = change.getStatus ( ) . isOpen ( ) ; }
public static void setAssignee ( int id , java.lang.String user , com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.client.info.AccountInfo > cb ) { com.google.gerrit.client.changes.ChangeApi.AssigneeInput input = com.google.gerrit.client.changes.ChangeApi.AssigneeInput.create ( ) ; input.assignee ( user ) ; com.google.gerrit.client.changes.ChangeApi.change ( id ) . view ( "assignee" ) . put ( input , cb ) ; }
public void testWithSubmodule ( ) throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = makeCommitWithSubmodule ( ) ; java.util.List < com.google.gerrit.server.git.validators.CommitValidationMessage > m = com.googlesource.gerrit.plugins.uploadvalidator.SubmoduleValidator.performValidation ( repo , c ) ; com.google.common.truth.Truth.assertThat ( com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.transformMessages ( m ) ) . containsExactly ( "ERROR: submodules are not allowed: modules/library" ) ; }
private boolean isVisibleTo ( com.google.gerrit.reviewdb.Change change , com.google.gerrit.server.IdentifiedUser user , com.google.gerrit.reviewdb.ReviewDb db ) throws com.google.gwtorm.client.OrmException { final com.google.gerrit.server.project.ProjectState pe = projectCache.get ( change.getProject ( ) ) ; if ( pe == null ) { return false ; } final com.google.gerrit.server.project.ProjectControl pc = pe.controlFor ( user ) ; return pc.controlFor ( change ) . isVisible ( db ) ; }
public com.google.gerrit.server.notedb.ChangeNotes createChecked ( com.google.gerrit.reviewdb.server.ReviewDb db , com.google.gerrit.reviewdb.client.Project.NameKey project , com.google.gerrit.reviewdb.client.Change.Id changeId ) throws com.google.gerrit.server.project.NoSuchChangeException , com.google.gwtorm.server.OrmException { java.util.List < com.google.gerrit.server.query.change.ChangeData > changes = getChangesCorrespondingToId ( changeId ) ; if ( changes.isEmpty ( ) ) { throw new com.google.gerrit.server.project.NoSuchChangeException ( changeId ) ; } return create ( db , project , changeId ) ; }
java.lang.Runnable newDraftCallback ( final net.codemirror.lib.CodeMirror cm ) { if ( ! ( com.google.gerrit.client.Gerrit.isSignedIn ( ) ) ) { return signInCallback ( cm ) ; } return new java.lang.Runnable ( ) { @ java.lang.Override public void run ( ) { if ( cm.extras ( ) . hasActiveLine ( ) ) { newDraft ( cm ) ; } } } ; }
public void queryChangesOneTerm ( ) throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r1 = createChange ( ) ; com.google.gerrit.acceptance.PushOneCommit.Result r2 = createChange ( ) ; java.util.List < com.google.gerrit.extensions.common.ChangeInfo > results = query ( "status:open" ) ; org.junit.Assert.assertEquals ( 2 , results.size ( ) ) ; org.junit.Assert.assertEquals ( r2.getChangeId ( ) , results.get ( 0 ) . changeId ) ; org.junit.Assert.assertEquals ( r1.getChangeId ( ) , results.get ( 1 ) . changeId ) ; }
protected void configure ( ) { factory ( AgreementInfoFactory.Factory.class ) ; factory ( CreateGroup.Factory.class ) ; factory ( DeleteExternalIds.Factory.class ) ; factory ( ExternalIdDetailFactory.Factory.class ) ; factory ( GroupDetailHandler.Factory.class ) ; factory ( RegisterNewEmailSender.Factory.class ) ; factory ( RenameGroup.Factory.class ) ; }
private void updateScreenHeader ( net.codemirror.lib.ScrollInfo si ) { if ( ( ( si.getTop ( ) ) == 0 ) && ( ! ( com.google.gerrit.client.Gerrit.isHeaderVisible ( ) ) ) ) { com.google.gerrit.client.Gerrit.setHeaderVisible ( true ) ; diffTable.updateFileCommentVisibility ( false ) ; } else if ( ( ( si.getTop ( ) ) > ( 0.5 * ( si.getClientHeight ( ) ) ) ) && ( com.google.gerrit.client.Gerrit.isHeaderVisible ( ) ) ) { com.google.gerrit.client.Gerrit.setHeaderVisible ( false ) ; diffTable.updateFileCommentVisibility ( true ) ; } }
private long getEffectiveMaxObjectSizeLimit ( com.google.gerrit.server.project.ProjectState p ) { long global = cfg.getLong ( "receive" , "maxObjectSizeLimit" , 0 ) ; long local = p.getMaxObjectSizeLimit ( ) ; if ( ( global > 0 ) && ( local > 0 ) ) { return java.lang.Math.min ( global , local ) ; } else { return java.lang.Math.max ( global , local ) ; } }
private void load ( ) throws java.io.IOException { if ( ( migration.writeChanges ( ) ) && ( ( getRevision ( ) ) == null ) ) { org.eclipse.jgit.lib.Repository repo = repoManager.openMetadataRepository ( getProjectName ( ) ) ; try { load ( repo ) ; } catch ( org.eclipse.jgit.errors.ConfigInvalidException e ) { throw new java.io.IOException ( e ) ; } finally { repo.close ( ) ; } } }
public void testOneIndexPredicate ( ) throws java.lang.Exception { com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > in = parse ( "foo:a file:b" ) ; com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > out = rewrite ( in ) ; assertSame ( com.google.gerrit.server.query.change.AndSource.class , out.getClass ( ) ) ; assertEquals ( com.google.common.collect.ImmutableList.of ( query ( in.getChild ( 1 ) ) , in.getChild ( 0 ) ) , out.getChildren ( ) ) ; }
public void testToSafeHtml ( ) { final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder b = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder ( ) ; b.append ( 1 ) ; final com.google.gwtexpui.safehtml.client.SafeHtml h = b.toSafeHtml ( ) ; assertNotNull ( h ) ; assertNotSame ( h , b ) ; assertFalse ( ( h instanceof com.google.gwtexpui.safehtml.client.SafeHtmlBuilder ) ) ; assertEquals ( "1" , h.asString ( ) ) ; }
public void testListDrafts ( ) throws java.lang.Exception { com.google.gerrit.server.change.CommentsTest.assertListDrafts ( injector , revRes1 , java.util.Collections.< java.lang.String , java.util.ArrayList < com.google.gerrit.reviewdb.client.PatchLineComment > > emptyMap ( ) ) ; com.google.gerrit.server.change.CommentsTest.assertListDrafts ( injector , revRes2 , com.google.common.collect.ImmutableMap.of ( "FileOne.txt" , com.google.common.collect.Lists.newArrayList ( plc4 , plc5 ) ) ) ; }
public void testAppend_StringBuilder ( ) { final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder b = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder ( ) ; assertSame ( b , b.append ( ( ( java.lang.StringBuilder ) ( null ) ) ) ) ; assertEquals ( "" , b.asString ( ) ) ; assertSame ( b , b.append ( new java.lang.StringBuilder ( "foo" ) ) ) ; assertSame ( b , b.append ( new java.lang.StringBuilder ( "bar" ) ) ) ; assertEquals ( "foobar" , b.asString ( ) ) ; }
public void afterRefUpdates ( ) throws com.google.gerrit.extensions.restapi.ResourceConflictException { if ( failAfterRefUpdates ) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException ( "Failing after ref updates" ) ; } for ( com.google.gerrit.server.git.strategy.SubmitStrategy strategy : strategies ) { com.google.gerrit.server.git.strategy.SubmitStrategy.Arguments args = strategy.args ; if ( args.mergeTip.getCurrentTip ( ) . equals ( args.mergeTip.getInitialTip ( ) ) ) { continue ; } } }
public void banCommit_Forbidden ( ) throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = userSession.put ( ( ( "/projects/" + ( project.get ( ) ) ) + "/ban/" ) , BanCommit.Input.fromCommits ( "a8a477efffbbf3b44169bb9a1d3a334cbbd9aa96" ) ) ; org.junit.Assert.assertEquals ( HttpStatus.SC_FORBIDDEN , r.getStatusCode ( ) ) ; }
private int getInt ( com.google.gerrit.server.config.PluginConfig cfg , java.lang.String name , int defaultValue ) { try { return cfg.getInt ( name , defaultValue ) ; } catch ( java.lang.IllegalArgumentException e ) { com.googlesource.gerrit.plugins.webhooks.Configuration.log.error ( java.lang.String.format ( "invalid value for %s; using default value %d" , name , defaultValue ) ) ; com.googlesource.gerrit.plugins.webhooks.Configuration.log.debug ( ( "Failed retrieve integer value: " + ( e.getMessage ( ) ) ) , e ) ; return defaultValue ; } }
private java.util.Set < java.lang.String > allRefPatterns ( java.lang.String permissionName ) { java.util.Set < java.lang.String > all = new java.util.HashSet < java.lang.String > ( ) ; for ( com.google.gerrit.common.data.AccessSection section : access ( ) ) { com.google.gerrit.common.data.Permission permission = section.getPermission ( permissionName ) ; if ( permission != null ) { all.add ( section.getRefPattern ( ) ) ; } } return all ; }
public void testGetPeopleAccess ( ) throws java.lang.Exception { final com.google.gwtorm.data.PhoneBookDb schema = open ( ) ; assertNotNull ( schema.people ( ) ) ; assertEquals ( "people" , schema.people ( ) . getRelationName ( ) ) ; assertEquals ( 1 , schema.people ( ) . getRelationID ( ) ) ; }
protected void configure ( ) { bind ( com.google.gerrit.extensions.api.projects.Projects.class ) . to ( com.google.gerrit.server.api.projects.ProjectsImpl.class ) ; factory ( BranchApiImpl.Factory.class ) ; factory ( TagApiImpl.Factory.class ) ; factory ( ProjectApiImpl.Factory.class ) ; factory ( ChildProjectApiImpl.Factory.class ) ; factory ( AccessApiImpl.Factory.class ) ; }
private java.lang.String url ( ) { if ( ( info.hasChangeNumber ( ) ) && ( info.hasRevisionNumber ( ) ) ) { return "#" + ( com.google.gerrit.common.PageLinks.toChange ( info.patchSetId ( ) ) ) ; } return null ; }
public java.lang.String getCreateSequenceSql ( final com.google.gwtorm.schema.SequenceModel seq ) { final com.google.gwtorm.client.Sequence s = seq.getSequence ( ) ; final java.lang.StringBuilder r = new java.lang.StringBuilder ( ) ; r.append ( "CREATE TABLE " ) ; r.append ( seq.getSequenceName ( ) ) ; r.append ( "(s SERIAL)" ) ; return r.toString ( ) ; }
public com.google.gerrit.extensions.api.changes.ReviewerInfo format ( com.google.gerrit.extensions.api.changes.ReviewerInfo out , com.google.gerrit.server.permissions.PermissionBackend.ForChange perm , com.google.gerrit.server.query.change.ChangeData cd ) throws com.google.gerrit.server.permissions.PermissionBackendException , com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.PatchSet.Id psId = cd.change ( ) . currentPatchSetId ( ) ; com.google.gerrit.server.project.ChangeControl ctl = cd.changeControl ( ) . forUser ( perm.user ( ) ) ; return format ( out , perm , cd , approvalsUtil.byPatchSetUser ( db.get ( ) , cd.notes ( ) , ctl.getUser ( ) , psId , new com.google.gerrit.reviewdb.client.Account.Id ( out._accountId ) , null , null ) ) ; }
public void fire ( com.google.gerrit.extensions.common.ChangeInfo change , com.google.gerrit.extensions.common.ChangeInfo revertChange , java.sql.Timestamp when ) { if ( ! ( listeners.iterator ( ) . hasNext ( ) ) ) { return ; } com.google.gerrit.server.extensions.events.ChangeReverted.Event event = new com.google.gerrit.server.extensions.events.ChangeReverted.Event ( change , revertChange , when ) ; for ( com.google.gerrit.extensions.events.ChangeRevertedListener l : listeners ) { try { l.onChangeReverted ( event ) ; } catch ( java.lang.Exception e ) { util.logEventListenerError ( com.google.gerrit.server.extensions.events.ChangeReverted.log , e ) ; } } }
private void deleteSshKey ( com.google.gerrit.extensions.common.SshKeyInfo i ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.server.permissions.PermissionBackendException , com.google.gwtorm.server.OrmException , java.io.IOException , org.eclipse.jgit.errors.ConfigInvalidException , org.eclipse.jgit.errors.RepositoryNotFoundException { com.google.gerrit.server.account.AccountSshKey sshKey = new com.google.gerrit.server.account.AccountSshKey ( new com.google.gerrit.server.account.AccountSshKey.Id ( user.getAccountId ( ) , i.seq ) , i.sshPublicKey ) ; deleteSshKey.apply ( new com.google.gerrit.server.account.AccountResource.SshKey ( user.asIdentifiedUser ( ) , sshKey ) , null ) ; }
public com.google.gerrit.server.plugins.ServerPlugin get ( java.io.File srcFile , org.eclipse.jgit.internal.storage.file.FileSnapshot snapshot , com.googlesource.gerrit.plugins.cookbook.pluginprovider.PluginDescription pluginDescriptor ) throws com.google.gerrit.server.plugins.InvalidPluginException { java.lang.String name = getPluginName ( srcFile ) ; return new com.google.gerrit.server.plugins.ServerPlugin ( name , pluginDescriptor.canonicalUrl , pluginDescriptor.user , srcFile , snapshot , new com.googlesource.gerrit.plugins.cookbook.pluginprovider.HelloSshPluginContentScanner ( name ) , pluginDescriptor.dataDir , com.google.gerrit.server.plugins.Plugin.ApiType.PLUGIN , getClass ( ) . getClassLoader ( ) , null , com.googlesource.gerrit.plugins.cookbook.pluginprovider.HelloSshModule.class , null ) ; }
private static java.util.List < com.google.gwtorm.schema.ColumnModel > leaves ( java.util.List < com.google.gwtorm.schema.ColumnModel > in ) { java.util.ArrayList < com.google.gwtorm.schema.ColumnModel > r = new java.util.ArrayList < com.google.gwtorm.schema.ColumnModel > ( in.size ( ) ) ; for ( com.google.gwtorm.schema.ColumnModel m : in ) { if ( m.isNested ( ) ) { r.addAll ( m.getAllLeafColumns ( ) ) ; } else { r.add ( m ) ; } } return r ; }
public void deleteBranchesNotFound ( ) throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DeleteBranchesInput input = new com.google.gerrit.extensions.api.projects.DeleteBranchesInput ( ) ; java.util.List < java.lang.String > branches = com.google.common.collect.Lists.newArrayList ( com.google.gerrit.acceptance.rest.project.DeleteBranchesIT.BRANCHES ) ; branches.add ( "refs/heads/does-not-exist" ) ; input.branches = branches ; try { project ( ) . deleteBranches ( input ) ; org.junit.Assert.fail ( "Expected ResourceConflictException" ) ; } catch ( com.google.gerrit.extensions.restapi.ResourceConflictException e ) { com.google.common.truth.Truth.assertThat ( e ) . hasMessageThat ( ) . isEqualTo ( errorMessageForBranches ( com.google.common.collect.ImmutableList.of ( "refs/heads/does-not-exist" ) ) ) ; } assertBranchesDeleted ( ) ; }
private static void trimLeadingEmptyLines ( byte [ ] bytes , org.eclipse.jgit.util.MutableInteger p ) { while ( ( ( p.value ) < ( bytes.length ) ) && ( ( bytes [ p.value ] ) == '\n' ) ) { ( p.value ) ++ ; } }
public com.google.gerrit.common.data.Permission getPermission ( java.lang.String name , boolean create ) { for ( com.google.gerrit.common.data.Permission p : getPermissions ( ) ) { if ( p.getName ( ) . equalsIgnoreCase ( name ) ) { return p ; } } if ( create ) { com.google.gerrit.common.data.Permission p = new com.google.gerrit.common.data.Permission ( name ) ; permissions.add ( p ) ; return p ; } else { return null ; } }
public void updateRepo ( com.google.gerrit.server.git.BatchUpdate.RepoContext ctx ) throws com.google.gerrit.extensions.restapi.ResourceConflictException , java.io.IOException { validate ( ctx ) ; patchSetInfo = patchSetInfoFactory.get ( ctx.getRevWalk ( ) , commit , patchSet.getId ( ) ) ; change.setCurrentPatchSet ( patchSetInfo ) ; if ( ! ( updateRef ) ) { return ; } ctx.addRefUpdate ( new org.eclipse.jgit.transport.ReceiveCommand ( org.eclipse.jgit.lib.ObjectId.zeroId ( ) , commit , patchSet.getRefName ( ) ) ) ; }
public void testRelativeAlternateLocation ( ) { configMock = org.easymock.EasyMock.createNiceMock ( com.google.gerrit.server.config.RepositoryConfig.class ) ; org.easymock.EasyMock.expect ( configMock.getAllBasePaths ( ) ) . andReturn ( java.util.Arrays.asList ( java.nio.file.Paths.get ( "repos" ) ) ) . anyTimes ( ) ; org.easymock.EasyMock.replay ( configMock ) ; repoManager = new com.google.gerrit.server.git.MultiBaseLocalDiskRepositoryManager ( site , cfg , org.easymock.EasyMock.createNiceMock ( com.google.gerrit.server.notedb.NotesMigration.class ) , configMock ) ; }
public com.google.gerrit.server.CurrentUser getCurrentUser ( ) { final com.google.gerrit.server.CurrentUser user = session.getCurrentUser ( ) ; if ( user instanceof com.google.gerrit.server.IdentifiedUser ) { return userFactory.create ( user.getAccessPath ( ) , ( ( com.google.gerrit.server.IdentifiedUser ) ( user ) ) . getAccountId ( ) ) ; } return user ; }
public com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.Scope [ ] getDefaultScopes ( ) { if ( ( ( scopes ) == null ) || ( ( scopes.get ( "scopes" ) ) == null ) ) { return new com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.Scope [ 0 ] ; } else { return scopes.get ( "scopes" ) . toArray ( new com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.Scope [ 0 ] ) ; } }
public com.google.gerrit.reviewdb.client.Change reloadChange ( ) throws com.google.gwtorm.server.OrmException { if ( ( project ) == null ) { notes = notesFactory.createFromIdOnlyWhenNoteDbDisabled ( db , legacyId ) ; } else { notes = notesFactory.create ( db , project , legacyId ) ; } change = notes.getChange ( ) ; if ( ( change ) == null ) { throw new com.google.gwtorm.server.OrmException ( ( "Unable to load change " + ( legacyId ) ) ) ; } setPatchSets ( null ) ; return change ; }
public void testReadString ( ) throws java.io.IOException { assertNull ( com.google.gerrit.server.ioutil.BasicSerialization.readString ( com.google.gerrit.server.ioutil.BasicSerializationTest.r ( com.google.gerrit.server.ioutil.BasicSerializationTest.b ( 0 ) ) ) ) ; assertEquals ( "a" , com.google.gerrit.server.ioutil.BasicSerialization.readString ( com.google.gerrit.server.ioutil.BasicSerializationTest.r ( com.google.gerrit.server.ioutil.BasicSerializationTest.b ( 1 , 'a' ) ) ) ) ; assertEquals ( "coffee4" , com.google.gerrit.server.ioutil.BasicSerialization.readString ( com.google.gerrit.server.ioutil.BasicSerializationTest.r ( com.google.gerrit.server.ioutil.BasicSerializationTest.b ( 7 , 'c' , 'o' , 'f' , 'f' , 'e' , 'e' , '4' ) ) ) ) ; }
private void updateSuperProjects ( java.util.Collection < com.google.gerrit.reviewdb.client.Branch.NameKey > branches ) { logDebug ( "Updating superprojects" ) ; com.google.gerrit.server.git.SubmoduleOp subOp = subOpFactory.create ( orm ) ; try { subOp.updateSuperProjects ( branches ) ; logDebug ( "Updating superprojects done" ) ; } catch ( com.google.gerrit.server.git.SubmoduleException e ) { logError ( ( "The gitlinks were not updated according to the " + "subscriptions" ) , e ) ; } }
private < V , K > com.google.gerrit.server.cache.h2.H2CacheImpl.SqlStore < K , V > newSqlStore ( java.lang.String name , com.google.inject.TypeLiteral < K > keyType , long maxSize ) { java.io.File db = new java.io.File ( cacheDir , name ) . getAbsoluteFile ( ) ; java.lang.String url = "jdbc:h2:" + ( db.toURI ( ) . toString ( ) ) ; return new com.google.gerrit.server.cache.h2.H2CacheImpl.SqlStore < K , V > ( url , keyType , maxSize ) ; }
private static java.lang.String getUserPreference ( ) { if ( com.google.gerrit.client.Gerrit.isSignedIn ( ) ) { com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DownloadScheme pref = com.google.gerrit.client.Gerrit.getUserAccount ( ) . getGeneralPreferences ( ) . getDownloadUrl ( ) ; if ( pref != null ) { switch ( pref ) { case ANON_GIT : return "git" ; case HTTP : case ANON_HTTP : return "http" ; case SSH : case ANON_SSH : return "ssh" ; default : return null ; } } } return null ; }
private com.google.inject.Injector createDbInjector ( ) { final java.util.List < com.google.inject.Module > modules = new java.util.ArrayList < com.google.inject.Module > ( ) ; modules.add ( new com.google.gerrit.lifecycle.LifecycleModule ( ) { @ java.lang.Override protected void configure ( ) { bind ( com.google.inject.Key.get ( javax.sql.DataSource.class , com.google.inject.name.Names.named ( "ReviewDb" ) ) ) . toProvider ( com.google.gerrit.httpd.ReviewDbDataSourceProvider.class ) . in ( com.google.inject.Scopes.SINGLETON ) ; listener ( ) . to ( com.google.gerrit.httpd.ReviewDbDataSourceProvider.class ) ; } } ) ; modules.add ( new com.google.gerrit.server.config.DatabaseModule ( ) ) ; return com.google.inject.Guice.createInjector ( com.google.inject.Stage.PRODUCTION , modules ) ; }
public org.apache.sshd.common.file.FileSystemView createFileSystemView ( org.apache.sshd.common.Session session ) throws java.io.IOException { return new org.apache.sshd.common.file.FileSystemView ( ) { @ java.lang.Override public org.apache.sshd.common.file.SshFile getFile ( org.apache.sshd.common.file.SshFile baseDir , java.lang.String file ) { return null ; } @ java.lang.Override public org.apache.sshd.common.file.SshFile getFile ( java.lang.String file ) { return null ; } @ java.lang.Override public org.apache.sshd.common.file.FileSystemView getNormalizedView ( ) { return this ; } } ; }
public void doImport ( org.eclipse.jgit.lib.ProgressMonitor progress ) throws java.lang.Exception { progress.beginTask ( "Setting up Gerrit replication" , 2 ) ; java.lang.String repositoryName = ( ( getOrganisation ( ) ) + "/" ) + ( getRepositoryName ( ) ) ; progress.update ( 1 ) ; replicationConfig.addSecureCredentials ( getOrganisation ( ) , authUsername , authToken ) ; progress.update ( 1 ) ; replicationConfig.addReplicationRemote ( getOrganisation ( ) , ( ( gitHubUrl ) + "/${name}.git" ) , repositoryName ) ; progress.endTask ( ) ; }
public void close ( ) { newTree = null ; if ( ( inserter ) != null ) { inserter.release ( ) ; inserter = null ; } if ( ( reader ) != null ) { reader.release ( ) ; reader = null ; } }
public void defaultMessage ( ) throws com.google.gerrit.extensions.restapi.RestApiException , java.io.IOException , org.eclipse.jgit.api.errors.GitAPIException { java.lang.String changeId = createChange ( ) ; com.google.gerrit.extensions.common.ChangeInfo c = getChangeAll ( ( "p~master~" + changeId ) ) ; org.junit.Assert.assertNotNull ( c.messages ) ; org.junit.Assert.assertEquals ( 1 , c.messages.size ( ) ) ; org.junit.Assert.assertEquals ( "Uploaded patch set 1." , c.messages.iterator ( ) . next ( ) . message ) ; }
public void set ( com.google.gerrit.client.projects.ThemeInfo theme ) { set ( ( ( theme.css ( ) ) != null ? theme.css ( ) : cssText ) , ( ( theme.header ( ) ) != null ? theme.header ( ) : headerHtml ) , ( ( theme.footer ( ) ) != null ? theme.footer ( ) : footerHtml ) ) ; }
public void onShowView ( ) { super . onShowView ( ) ; if ( ( cmA ) != null ) { cmA.refresh ( ) ; } if ( ( cmB ) != null ) { cmB.refresh ( ) ; } com.google.gwt.user.client.Window.enableScrolling ( false ) ; com.google.gwt.core.client.Scheduler.get ( ) . scheduleDeferred ( new com.google.gwt.core.client.Scheduler.ScheduledCommand ( ) { @ java.lang.Override public void execute ( ) { for ( com.google.gerrit.client.diff.CommentBox box : initialBoxes ) { box.resizePaddingWidget ( ) ; } } } ) ; }
private java.util.List < com.google.gerrit.extensions.common.WebLinkInfo > getFileWebLinks ( com.google.gerrit.reviewdb.client.Project project , java.lang.String rev , java.lang.String file ) { com.google.common.collect.FluentIterable < com.google.gerrit.extensions.common.WebLinkInfo > links = webLinks.getFileLinks ( project.getName ( ) , rev , file ) ; return links.isEmpty ( ) ? null : links.toList ( ) ; }
public void byAfter ( ) throws java.lang.Exception { com.google.gerrit.testutil.TestTimeUtil.resetWithClockStep ( 30 , java.util.concurrent.TimeUnit.HOURS ) ; org.eclipse.jgit.junit.TestRepository < com.google.gerrit.testutil.InMemoryRepositoryManager.Repo > repo = createProject ( "repo" ) ; com.google.gerrit.reviewdb.client.Change change1 = insert ( newChange ( repo ) ) ; com.google.gerrit.reviewdb.client.Change change2 = insert ( newChange ( repo ) ) ; com.google.gerrit.testutil.TestTimeUtil.setClockStep ( 0 , java.util.concurrent.TimeUnit.MILLISECONDS ) ; assertQuery ( "after:2009-10-03" ) ; assertQuery ( "after:\"2009-10-01 20:59:59 -0400\"" , change2 ) ; assertQuery ( "after:\"2009-10-01 20:59:59 -0000\"" , change2 ) ; assertQuery ( "after:2009-10-01" , change2 ) ; assertQuery ( "after:2009-09-30" , change2 , change1 ) ; }
protected void configure ( ) { bind ( new com.google.inject.TypeLiteral < com.google.gwtorm.server.SchemaFactory < com.google.gerrit.reviewdb.server.ReviewDb > > ( ) { } ) . toInstance ( db ) ; bind ( com.google.gerrit.server.config.SitePaths.class ) . toInstance ( paths ) ; install ( new com.google.gerrit.server.schema.SchemaVersion.Module ( ) ) ; org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config ( ) ; cfg.setString ( "user" , null , "name" , "Gerrit Code Review" ) ; cfg.setString ( "user" , null , "email" , "gerrit@localhost" ) ; bind ( org.eclipse.jgit.lib.Config.class ) . annotatedWith ( com.google.gerrit.server.config.GerritServerConfig.class ) . toInstance ( cfg ) ; bind ( org.eclipse.jgit.lib.PersonIdent.class ) . annotatedWith ( com.google.gerrit.server.GerritPersonIdent.class ) . toProvider ( com.google.gerrit.server.GerritPersonIdentProvider.class ) ; bind ( com.google.gerrit.server.config.AllProjectsName.class ) . toInstance ( new com.google.gerrit.server.config.AllProjectsName ( "All-Projects" ) ) ; bind ( com.google.gerrit.server.config.AllUsersName.class ) . toInstance ( new com.google.gerrit.server.config.AllUsersName ( "All-Users" ) ) ; bind ( com.google.gerrit.server.git.GitRepositoryManager.class ) . toInstance ( new com.google.gerrit.testutil.InMemoryRepositoryManager ( ) ) ; bind ( java.lang.String.class ) . annotatedWith ( com.google.gerrit.server.config.AnonymousCowardName.class ) . toProvider ( com.google.gerrit.server.config.AnonymousCowardNameProvider.class ) ; bind ( com.google.gerrit.server.schema.DataSourceType.class ) . to ( com.google.gerrit.testutil.InMemoryH2Type.class ) ; }
public com.google.gerrit.server.patch.IntraLineDiff getIntraLineDiff ( com.google.gerrit.server.patch.IntraLineDiffKey key , com.google.gerrit.server.patch.IntraLineDiffArgs args ) { if ( computeIntraline ) { try { return intraCache.get ( key , intraLoaderFactory.create ( key , args ) ) ; } catch ( java.util.concurrent.ExecutionException | org.eclipse.jgit.errors.LargeObjectException e ) { IntraLineLoader.log.warn ( ( "Error computing " + key ) , e ) ; return new com.google.gerrit.server.patch.IntraLineDiff ( IntraLineDiff.Status.ERROR ) ; } } else { return new com.google.gerrit.server.patch.IntraLineDiff ( IntraLineDiff.Status.DISABLED ) ; } }
public void deleteBranch_Forbidden ( ) throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = userSession.delete ( ( ( ( "/projects/" + ( project.get ( ) ) ) + "/branches/" ) + ( branch.getShortName ( ) ) ) ) ; org.junit.Assert.assertEquals ( HttpStatus.SC_FORBIDDEN , r.getStatusCode ( ) ) ; r.consume ( ) ; }
private void assertReviewers ( com.google.gerrit.reviewdb.client.Change c , com.google.gerrit.acceptance.TestAccount ... expectedReviewers ) throws com.google.gwtorm.server.OrmException { java.lang.Iterable < com.google.gerrit.reviewdb.client.Account.Id > actualIds = approvalsUtil.getReviewers ( db , notesFactory.create ( db , c ) ) . values ( ) ; com.google.common.truth.Truth.assertThat ( actualIds ) . containsExactlyElementsIn ( com.google.common.collect.Sets.newHashSet ( com.google.gerrit.acceptance.TestAccount.ids ( expectedReviewers ) ) ) ; }
private java.util.List < com.google.gerrit.server.data.ChangeAttribute > executeSuccessfulQuery ( java.lang.String params ) throws java.lang.Exception { HEAD ( 414 ) ; aa2 ( "Add schema and index definitions for accounts index" ) ; java.lang.String rawResponse = adminSshSession.exec ( ( "gerrit query --format=JSON " + params ) ) ; com.google.common.truth.Truth.assert_ ( ) . withFailureMessage ( adminSshSession.getError ( ) ) . that ( adminSshSession.hasError ( ) ) . isFalse ( ) ; return com.google.gerrit.acceptance.ssh.QueryIT.getChanges ( rawResponse ) ; return executeSuccessfulQuery ( params , sshSession ) ; BRANCH ( d57655 ) ; }
public void testPreformat2 ( ) { final com.google.gwtexpui.safehtml.client.SafeHtml o = com.google.gwtexpui.safehtml.client.SafeHtml_WikifyPreformatTest.html ( "A\n\n This is pre\n formatted\n\nbut this is not" ) ; final com.google.gwtexpui.safehtml.client.SafeHtml n = o.wikify ( ) ; assertNotSame ( o , n ) ; assertEquals ( ( ( ( ( ( "<p>A</p>" + "<p>" ) + ( com.google.gwtexpui.safehtml.client.SafeHtml_WikifyPreformatTest.pre ( " This is pre" ) ) ) + ( com.google.gwtexpui.safehtml.client.SafeHtml_WikifyPreformatTest.pre ( " formatted" ) ) ) + "</p>" ) + "<p>but this is not</p>" ) , n.asString ( ) ) ; }
public void emptyExceptSubject ( ) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange ( ) ; com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate ( c , changeOwner ) ; update.commit ( ) ; org.junit.Assert.assertNull ( update.getRevision ( ) ) ; update = newUpdate ( c , changeOwner ) ; update.setSubject ( "Create change" ) ; update.commit ( ) ; org.junit.Assert.assertNotNull ( update.getRevision ( ) ) ; }
public static com.google.gerrit.common.data.GroupReference findExactSuggestion ( com.google.gerrit.server.account.GroupBackend groupBackend , java.lang.String name ) { java.util.Collection < com.google.gerrit.common.data.GroupReference > refs = groupBackend.suggest ( name ) ; for ( com.google.gerrit.common.data.GroupReference ref : refs ) { if ( com.google.gerrit.server.account.GroupBackends.isExactSuggestion ( ref , name ) ) { return ref ; } } return null ; }
public boolean canAddPatchSet ( com.google.gerrit.reviewdb.server.ReviewDb db ) throws com.google.gwtorm.server.OrmException { if ( ( ( ! ( getRefControl ( ) . canUpload ( ) ) ) || ( isPatchSetLocked ( db ) ) ) || ( ! ( isPatchVisible ( patchSetUtil.current ( db , notes ) , db ) ) ) ) { return false ; } if ( isOwner ( ) ) { return true ; } return getRefControl ( ) . canAddPatchSet ( ) ; }
private org.eclipse.jgit.revwalk.RevObject resolve ( java.lang.String name , org.eclipse.jgit.revwalk.RevWalk walk ) throws java.io.IOException { try { org.eclipse.jgit.lib.ObjectId id = repo.resolve ( name ) ; return id != null ? walk.parseAny ( id ) : null ; } catch ( org.eclipse.jgit.errors.AmbiguousObjectException e ) { return null ; } catch ( org.eclipse.jgit.errors.RevisionSyntaxException e ) { return null ; } catch ( org.eclipse.jgit.errors.MissingObjectException e ) { return null ; } }
public void checkTrustChainWithExpiredKey ( ) throws java.lang.Exception { com.google.gerrit.gpg.testutil.TestKey keyA = add ( com.google.gerrit.gpg.testutil.TestTrustKeys.keyA ( ) , user ) ; com.google.gerrit.gpg.testutil.TestKey keyB = add ( com.google.gerrit.gpg.testutil.TestTrustKeys.keyB ( ) , addUser ( "userB" ) ) ; com.google.gerrit.gpg.PublicKeyChecker checker = checkerFactory.create ( ) . setExpectedUser ( user ) . setStore ( store ) ; assertProblems ( checker.check ( keyA.getPublicKey ( ) ) , Status.OK , "No path to a trusted key" , ( ( "Certification by " + ( com.google.gerrit.gpg.PublicKeyStore.keyToString ( keyB.getPublicKey ( ) ) ) ) + " is valid, but key is not trusted" ) , "Key D24FE467 used for certification is not in store" ) ; }
private java.lang.String getHtml ( java.lang.String formatterName , com.googlesource.gerrit.plugins.xdocs.formatter.StreamFormatter f , org.eclipse.jgit.lib.Repository repo , org.eclipse.jgit.lib.ObjectLoader loader , com.google.gerrit.reviewdb.client.Project.NameKey project , org.eclipse.jgit.lib.ObjectId revId ) throws java.io.IOException { try ( java.io.InputStream raw = loader.openStream ( ) ) { return ( ( com.googlesource.gerrit.plugins.xdocs.formatter.StreamFormatter ) ( f ) ) . format ( project.get ( ) , com.googlesource.gerrit.plugins.xdocs.XDocLoader.getAbbrRevId ( repo , revId ) , getFormatterConfig ( formatterName ) , raw ) ; } }
private void update ( ) { if ( ( ( currentCommand ) != null ) && ( ( currentUrl ) != null ) ) { currentCommand.setCurrentUrl ( currentUrl ) ; } else if ( ( ( currentCommand ) != null ) && ( currentCommand.getCmdType ( ) . equals ( DownloadCommand.REPO_DOWNLOAD ) ) ) { currentCommand.setCurrentUrl ( null ) ; } }
public void remove ( final com.google.gerrit.reviewdb.client.Project p ) { listLock.lock ( ) ; try { java.util.SortedSet < com.google.gerrit.reviewdb.client.Project.NameKey > n = com.google.common.collect.Sets.newTreeSet ( list.get ( com.google.gerrit.server.project.ProjectCacheImpl.ListKey.ALL ) ) ; n.remove ( p.getNameKey ( ) ) ; list.put ( com.google.gerrit.server.project.ProjectCacheImpl.ListKey.ALL , java.util.Collections.unmodifiableSortedSet ( n ) ) ; } catch ( java.util.concurrent.ExecutionException e ) { com.google.gerrit.server.project.ProjectCacheImpl.log.warn ( "Cannot list avaliable projects" , e ) ; } finally { listLock.unlock ( ) ; } evict ( p ) ; }
public void execute ( ) { com.google.gwt.user.client.Window.scrollTo ( 0 , 0 ) ; for ( int i = 0 ; i < ( labelsTable.getColumnCount ( ) ) ; i ++ ) { com.google.gwt.user.client.ui.RadioButton b = ( ( com.google.gwt.user.client.ui.RadioButton ) ( labelsTable.getWidget ( 1 , i ) ) ) ; if ( ( b != null ) && ( b.getValue ( ) ) ) { b.setFocus ( true ) ; break ; } } }
public void onSuccess ( com.google.gerrit.client.diff.DiffInfo diffInfo ) { diff = diffInfo ; new net.codemirror.lib.ModeInjector ( ) . add ( com.google.gerrit.client.diff.SideBySide2.getContentType ( diff.meta_a ( ) ) ) . add ( com.google.gerrit.client.diff.SideBySide2.getContentType ( diff.meta_b ( ) ) ) . inject ( modeInjectorCb ) ; }
public void emptyContextPath ( ) { org.junit.Assert.assertEquals ( "/foo/bar" , com.google.gerrit.util.http.RequestUtil.getEncodedPathInfo ( mockRequest ( "/s/foo/bar" , "" , "/s" ) ) ) ; org.junit.Assert.assertEquals ( "/foo%2Fbar" , com.google.gerrit.util.http.RequestUtil.getEncodedPathInfo ( mockRequest ( "/s/foo%2Fbar" , "" , "/s" ) ) ) ; }
public void onLoad ( ) { if ( ( diffTable ) == null ) { initUI ( ) ; } super . onLoad ( ) ; PatchUtil.DETAIL_SVC.unifiedPatchDetail ( patchId , new com.google.gerrit.client.rpc.ScreenLoadCallback < com.google.gerrit.client.data.UnifiedPatchDetail > ( this ) { @ java.lang.Override protected void preDisplay ( final com.google.gerrit.client.data.UnifiedPatchDetail r ) { display ( r ) ; } } ) ; }
private static com.google.gerrit.server.query.change.LabelPredicate.Test op ( java.lang.String op ) { if ( "=" . equals ( op ) ) { return com.google.gerrit.server.query.change.LabelPredicate.Test.EQ ; } else if ( ">=" . equals ( op ) ) { return com.google.gerrit.server.query.change.LabelPredicate.Test.GT_EQ ; } else if ( "<=" . equals ( op ) ) { return com.google.gerrit.server.query.change.LabelPredicate.Test.LT_EQ ; } else { throw new java.lang.IllegalArgumentException ( ( "Unsupported operation " + op ) ) ; } }
public void testCarriageReturn ( ) throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = makeCommit ( ) ; com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator validator = new com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator ( null , new com.googlesource.gerrit.plugins.uploadvalidator.ContentTypeUtil ( com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.PATTERN_CACHE ) , null , null , null ) ; java.util.List < com.google.gerrit.server.git.validators.CommitValidationMessage > m = validator.performValidation ( repo , c , com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.EMPTY_PLUGIN_CONFIG ) ; com.google.common.truth.Truth.assertThat ( com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.transformMessages ( m ) ) . containsExactly ( "ERROR: found carriage return (CR) character in file: foo.txt" ) ; }
public void onLoad ( ) { super . onLoad ( ) ; if ( ( regFocus ) == null ) { regFocus = com.google.gwtexpui.globalkey.client.GlobalKey.addApplication ( new com.google.gwtexpui.globalkey.client.KeyCommand ( 0 , '/' , Gerrit.C.keySearch ( ) ) { @ java.lang.Override public void onKeyPress ( final com.google.gwt.event.dom.client.KeyPressEvent event ) { event.preventDefault ( ) ; searchBox.setFocus ( true ) ; searchBox.selectAll ( ) ; } } ) ; } }
public void setUp ( ) throws java.lang.Exception { mergeResults = com.google.common.collect.Maps.newHashMap ( ) ; com.google.gerrit.server.CurrentUser listenerUser = factory.create ( user.id ) ; source.addEventListener ( new com.google.gerrit.common.EventListener ( ) { @ java.lang.Override public void onEvent ( com.google.gerrit.server.events.Event event ) { if ( event instanceof com.google.gerrit.server.events.ChangeMergedEvent ) { com.google.gerrit.server.events.ChangeMergedEvent changeMergedEvent = ( ( com.google.gerrit.server.events.ChangeMergedEvent ) ( event ) ) ; mergeResults.put ( changeMergedEvent.change.number , changeMergedEvent.newRev ) ; } } } , listenerUser ) ; project = new com.google.gerrit.reviewdb.client.Project.NameKey ( "p2" ) ; }
public java.lang.String toString ( ) { if ( isError ( ) ) { return ( ( ( ( ( "Error AccessToken [error=" + ( error ) ) + ", error_description=" ) + ( errorDescription ) ) + ", error_uri=" ) + ( errorUri ) ) + "]" ; } else { return ( ( ( "AccessToken [access_token=" + ( accessToken ) ) + ", token_type=" ) + ( tokenType ) ) + "]" ; } }
public boolean equals ( java.lang.Object other ) { if ( other instanceof com.google.gerrit.extensions.restapi.IdString ) { return urlEncoded.equals ( ( ( com.google.gerrit.extensions.restapi.IdString ) ( other ) ) . urlEncoded ) ; } else if ( other instanceof java.lang.String ) { return urlEncoded.equals ( other ) ; } return false ; }
protected com.google.gerrit.server.notedb.ChangeUpdate newUpdate ( com.google.gerrit.reviewdb.client.Change c , com.google.gerrit.server.IdentifiedUser user ) throws java.lang.Exception { com.google.gerrit.server.notedb.ChangeUpdate update = com.google.gerrit.testutil.TestChanges.newUpdate ( injector , repoManager , com.google.gerrit.server.notedb.AbstractChangeNotesTest.MIGRATION , c , allUsers , user ) ; try ( org.eclipse.jgit.lib.Repository repo = repoManager.openMetadataRepository ( c.getProject ( ) ) ) { update.load ( repo ) ; } return update ; }
private static boolean needsSuperSerializer ( com.google.gwt.core.ext.typeinfo.JClassType type ) { com.google.gwt.core.ext.typeinfo.JClassType t = type.getSuperclass ( ) ; while ( ! ( java.lang.Object.class . getName ( ) . equals ( t.getQualifiedSourceName ( ) ) ) ) { if ( ( com.google.gwtjsonrpc.rebind.SerializerCreator.sortFields ( t ) . length ) > 0 ) { return true ; } t = type.getSuperclass ( ) ; } return false ; }
private static void export ( org.spearce.jgit.lib.RepositoryConfig config , java.sql.ResultSet rs ) throws java.sql.SQLException { com.google.gerrit.pgm.ConvertSystemConfig.sshd ( config , rs ) ; com.google.gerrit.pgm.ConvertSystemConfig.contactstore ( config , rs ) ; com.google.gerrit.pgm.ConvertSystemConfig.user ( config , rs ) ; }
private org.eclipse.jgit.lib.Repository openRepository ( final com.google.gerrit.reviewdb.Change change ) { com.google.gerrit.reviewdb.Project.NameKey name = change.getProject ( ) ; try { return repoManager.openRepository ( name.get ( ) ) ; } catch ( org.eclipse.jgit.errors.RepositoryNotFoundException err ) { com.google.gerrit.common.ChangeHookRunner.log.warn ( ( "Cannot open repository " + ( name.get ( ) ) ) , err ) ; return null ; } }
public void onSuccess ( com.google.gerrit.client.changes.ChangeInfo info ) { info.revisions ( ) . copyKeysIntoChildren ( "name" ) ; com.google.gwt.core.client.JsArray < com.google.gerrit.client.changes.ChangeInfo.RevisionInfo > list = info.revisions ( ) . values ( ) ; com.google.gerrit.client.changes.ChangeInfo.RevisionInfo.sortRevisionInfoByNumber ( list ) ; diffTable.setUpPatchSetNav ( list , diff ) ; header.setChangeInfo ( info ) ; }
public static com.google.gerrit.server.query.change.ChangeData createForTest ( com.google.gerrit.reviewdb.client.Project.NameKey project , com.google.gerrit.reviewdb.client.Change.Id id , int currentPatchSetId ) { com.google.gerrit.server.query.change.ChangeData cd = new com.google.gerrit.server.query.change.ChangeData ( null , null , null , null , null , null , null , null , null , null , null , null , null , null , project , id ) ; cd.currentPatchSet = new com.google.gerrit.reviewdb.client.PatchSet ( new com.google.gerrit.reviewdb.client.PatchSet.Id ( id , currentPatchSetId ) ) ; return cd ; }
public void setUp ( ) throws java.lang.Exception { skipIfWin32Platform ( ) ; super . setUp ( ) ; final java.util.Date when = author.getWhen ( ) ; final java.util.TimeZone tz = author.getTimeZone ( ) ; author = new org.eclipse.jgit.lib.PersonIdent ( "J. Author" , "ja@example.com" ) ; author = new org.eclipse.jgit.lib.PersonIdent ( author , when , tz ) ; committer = new org.eclipse.jgit.lib.PersonIdent ( "J. Committer" , "jc@example.com" ) ; committer = new org.eclipse.jgit.lib.PersonIdent ( committer , when , tz ) ; }
private void preMerge ( ) throws com.google.gerrit.server.git.MergeException , com.google.gwtorm.client.OrmException { openBranch ( ) ; validateChangeList ( ) ; mergeTip = branchTip ; switch ( destProject.getSubmitType ( ) ) { case CHERRY_PICK : cherryPickChanges ( ) ; break ; case FAST_FORWARD_ONLY : case MERGE_ALWAYS : case MERGE_IF_NECESSARY : default : reduceToMinimalMerge ( ) ; mergeTopics ( ) ; markCleanMerges ( ) ; break ; } }
private void setDestProject ( ) throws com.google.gerrit.server.git.MergeException { final com.google.gerrit.server.project.ProjectState pe = projectCache.get ( destBranch.getParentKey ( ) ) ; if ( pe == null ) { throw new com.google.gerrit.server.git.MergeException ( ( "No such project: " + ( destBranch.getParentKey ( ) ) ) ) ; } destProject = pe.getProject ( ) ; }
protected void configure ( ) { bind ( com.google.gerrit.extensions.api.GerritApi.class ) . to ( com.google.gerrit.server.api.GerritApiImpl.class ) ; install ( new com.google.gerrit.server.api.Module ( ) ) ; install ( new com.google.gerrit.server.api.Module ( ) ) ; install ( new com.google.gerrit.server.api.Module ( ) ) ; }
private void columnStatus ( com.google.gwtexpui.safehtml.client.SafeHtmlBuilder sb , com.google.gerrit.client.diff.FileInfo info ) { sb.openTd ( ) . setStyleName ( com.google.gerrit.client.change.FileTable.R.css ( ) . statusTypeCell ( ) ) ; if ( Patch.COMMIT_MSG.equals ( info.path ( ) ) ) { sb.nbsp ( ) ; } else { sb.append ( info.status ( ) ) ; } sb.closeTd ( ) ; }
protected void configure ( ) { com.google.gerrit.extensions.registration.DynamicMap.mapOf ( binder ( ) , com.googlesource.gerrit.plugins.imagare.ImageResource.IMAGE_KIND ) ; bind ( com.googlesource.gerrit.plugins.imagare.ImagesCollection.class ) ; child ( com.google.gerrit.server.project.ProjectResource.PROJECT_KIND , "images" ) . to ( com.googlesource.gerrit.plugins.imagare.ImagesCollection.class ) ; delete ( com.googlesource.gerrit.plugins.imagare.ImageResource.IMAGE_KIND ) . to ( com.googlesource.gerrit.plugins.imagare.DeleteImage.class ) ; get ( com.google.gerrit.server.config.ConfigResource.CONFIG_KIND , "config" ) . to ( com.googlesource.gerrit.plugins.imagare.GetConfig.class ) ; put ( com.google.gerrit.server.config.ConfigResource.CONFIG_KIND , "config" ) . to ( com.googlesource.gerrit.plugins.imagare.PutConfig.class ) ; get ( com.google.gerrit.server.account.AccountResource.ACCOUNT_KIND , "preference" ) . to ( com.googlesource.gerrit.plugins.imagare.GetPreference.class ) ; put ( com.google.gerrit.server.account.AccountResource.ACCOUNT_KIND , "preference" ) . to ( com.googlesource.gerrit.plugins.imagare.PutPreference.class ) ; }
io.searchbox.client.http.JestHttpClient build ( ) { io.searchbox.client.JestClientFactory factory = new io.searchbox.client.JestClientFactory ( ) ; factory.setHttpClientConfig ( new io.searchbox.client.config.HttpClientConfig.Builder ( url ) . multiThreaded ( true ) . discoveryEnabled ( ( ! ( refresh ) ) ) . discoveryFrequency ( 1L , java.util.concurrent.TimeUnit.MINUTES ) . build ( ) ) ; return ( ( io.searchbox.client.http.JestHttpClient ) ( factory.getObject ( ) ) ) ; }
private boolean canAbandon ( com.google.gerrit.reviewdb.server.ReviewDb db ) throws com.google.gwtorm.server.OrmException { return ( ( ( ( ( isOwner ( ) ) || ( getRefControl ( ) . isOwner ( ) ) ) || ( getProjectControl ( ) . isOwner ( ) ) ) || ( getUser ( ) . getCapabilities ( ) . canAdministrateServer ( ) ) ) || ( getRefControl ( ) . canAbandon ( ) ) ) && ( ! ( isPatchSetLocked ( db ) ) ) ; }
public void run ( ) throws java.lang.Exception { parseCommandLine ( impl ) ; if ( ( ( impl.getUser ( ) ) != null ) && ( ! ( impl.getProjects ( ) . isEmpty ( ) ) ) ) { throw new com.google.gerrit.sshd.commands.UnloggedFailure ( 1 , "fatal: --user and --project options are not compatible." ) ; } final java.io.PrintWriter stdout = toPrintWriter ( out ) ; try { impl.display ( stdout ) ; } finally { stdout.flush ( ) ; } }
public void createEmptyChange_MissingMessage ( ) throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInfo ci = new com.google.gerrit.extensions.common.ChangeInfo ( ) ; ci.project = project.get ( ) ; ci.branch = "master" ; com.google.gerrit.acceptance.RestResponse r = adminSession.post ( "/changes/" , ci ) ; org.junit.Assert.assertEquals ( HttpStatus.SC_BAD_REQUEST , r.getStatusCode ( ) ) ; org.junit.Assert.assertTrue ( r.getEntityContent ( ) . contains ( "commit message must be non-empty" ) ) ; }
protected void alias ( final com.google.gerrit.sshd.CommandName parent , final java.lang.String name , final java.lang.Class < ? extends com.google.gerrit.sshd.BaseCommand > clazz ) { com.google.gerrit.sshd.CommandMetaData meta = clazz.getAnnotation ( com.google.gerrit.sshd.CommandMetaData.class ) ; if ( meta == null ) { throw new java.lang.IllegalStateException ( "no CommandMetaData annotation found" ) ; } bind ( com.google.gerrit.sshd.Commands.key ( parent , name , com.google.gerrit.sshd.CommandModule.description ( meta ) ) ) . to ( clazz ) ; }
private com.google.gwt.user.client.ui.Widget createEditIcon ( ) { com.google.gerrit.reviewdb.client.PatchSet.Id id = ( idActive.isBaseOrAutoMerge ( ) ) ? other.idActive.asPatchSetId ( ) : idActive.asPatchSetId ( ) ; com.google.gwt.user.client.ui.Anchor anchor = new com.google.gwt.user.client.ui.Anchor ( new com.google.gwt.user.client.ui.ImageResourceRenderer ( ) . render ( Gerrit.RESOURCES.edit ( ) ) , ( "#" + ( com.google.gerrit.client.Dispatcher.toEditScreen ( id , path ) ) ) ) ; anchor.setTitle ( PatchUtil.C.edit ( ) ) ; return anchor ; }
public void testTagDiv ( ) { final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder b = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder ( ) ; assertSame ( b , b.openDiv ( ) ) ; assertSame ( b , b.append ( "d<a>ta" ) ) ; assertSame ( b , b.closeDiv ( ) ) ; assertEquals ( "<div>d&lt;a&gt;ta</div>" , b.asString ( ) ) ; }
private void insertNoneRow ( final int row ) { insertRow ( row ) ; setText ( row , 0 , Util.C.changeTableNone ( ) ) ; getFlexCellFormatter ( ) . setColSpan ( row , 0 , com.google.gerrit.client.changes.ChangeTable.COLUMNS ) ; setStyleName ( row , 0 , "gerrit-ChangeTable-EmptySectionRow" ) ; }
com.google.gerrit.client.changes.CommentInfo createReply ( com.google.gerrit.client.changes.CommentInfo replyTo ) { if ( ! ( replyTo.has_line ( ) ) ) { return com.google.gerrit.client.changes.CommentInfo.createFile ( path , replyTo.side ( ) , replyTo.id ( ) , null ) ; } else { return com.google.gerrit.client.changes.CommentInfo.createLine ( path , replyTo.side ( ) , replyTo.line ( ) , replyTo.id ( ) , null ) ; } }
public static com.google.gerrit.server.util.LabelVote parseWithEquals ( java.lang.String text ) { com.google.common.base.Preconditions.checkArgument ( ( ! ( com.google.common.base.Strings.isNullOrEmpty ( text ) ) ) , "Empty label vote" ) ; int e = text.lastIndexOf ( '=' ) ; com.google.common.base.Preconditions.checkArgument ( ( e >= 0 ) , "Label vote missing '=': %s" , text ) ; return new com.google.gerrit.server.util.LabelVote ( text.substring ( 0 , e ) , java.lang.Short.parseShort ( text.substring ( ( e + 1 ) ) , text.length ( ) ) ) ; }
public void addComment ( final java.lang.String issueKey , final java.lang.String comment ) throws java.io.IOException { execute ( new java.util.concurrent.Callable < java.lang.String > ( ) { @ java.lang.Override public java.lang.String call ( ) throws java.lang.Exception { log.debug ( "Adding comment {} to issue {}" , comment , issueKey ) ; client ( ) . addComment ( issueKey , comment ) ; log.debug ( "Added comment {} to issue {}" , comment , issueKey ) ; return issueKey ; } } ) ; }
public com.googlesource.gerrit.plugins.replication.SecureCredentialsProvider create ( java.lang.String remoteName ) { if ( needsReload ( ) ) { try { secureCredentialsFactory.compareAndSet ( secureCredentialsFactory.get ( ) , new com.googlesource.gerrit.plugins.replication.SecureCredentialsFactory ( site ) ) ; secureCredentialsFactoryLoadTs = getSecureConfigLastEditTs ( ) ; com.googlesource.gerrit.plugins.replication.AutoReloadSecureCredentialsFactoryDecorator.log.info ( "secure.config reloaded as it was updated on the file system" ) ; } catch ( java.lang.Exception e ) { com.googlesource.gerrit.plugins.replication.AutoReloadSecureCredentialsFactoryDecorator.log.error ( ( "Unexpected error while trying to reload " + "secure.config: keeping existing credentials" ) , e ) ; } } return secureCredentialsFactory.get ( ) . create ( remoteName ) ; }
public void testInheritRead_AppendWithDenyOfRef ( ) { grant ( parent , com.google.gerrit.common.data.Permission.READ , registered , "refs/*" ) ; grant ( local , com.google.gerrit.common.data.Permission.READ , registered , "refs/heads/*" ) . setDeny ( true ) ; com.google.gerrit.server.project.ProjectControl u = user ( ) ; assertTrue ( "can read" , u.isVisible ( ) ) ; assertTrue ( "can read" , u.controlForRef ( "refs/master" ) . isVisible ( ) ) ; assertTrue ( "can read" , u.controlForRef ( "refs/tags/foobar" ) . isVisible ( ) ) ; assertTrue ( "no master" , u.controlForRef ( "refs/heads/master" ) . isVisible ( ) ) ; }
com.google.gerrit.server.git.strategy.SubmitStrategy.Arguments create ( com.google.gerrit.extensions.client.SubmitType submitType , com.google.gerrit.reviewdb.client.Branch.NameKey destBranch , com.google.gerrit.server.git.MergeOp.CommitStatus commitStatus , com.google.gerrit.server.git.CodeReviewCommit.CodeReviewRevWalk rw , com.google.gerrit.server.IdentifiedUser caller , com.google.gerrit.server.git.MergeTip mergeTip , org.eclipse.jgit.lib.ObjectInserter inserter , org.eclipse.jgit.lib.Repository repo , org.eclipse.jgit.revwalk.RevFlag canMergeFlag , com.google.gerrit.reviewdb.server.ReviewDb db , java.util.Set < org.eclipse.jgit.revwalk.RevCommit > alreadyAccepted , java.util.Set < com.google.gerrit.server.git.CodeReviewCommit > incoming , com.google.gerrit.server.util.RequestId submissionId , com.google.gerrit.extensions.api.changes.NotifyHandling notifyHandling , com.google.common.collect.ListMultimap < com.google.gerrit.extensions.api.changes.RecipientType , com.google.gerrit.reviewdb.client.Account.Id > accountsToNotify , com.google.gerrit.server.git.SubmoduleOp submoduleOp , boolean dryrun ) ;
public static java.lang.String refsEditPrefix ( com.google.gerrit.reviewdb.client.Account.Id accountId , com.google.gerrit.reviewdb.client.Change.Id changeId ) { return new java.lang.StringBuilder ( com.google.gerrit.reviewdb.client.RefNames.refsUsers ( accountId ) ) . append ( '/' ) . append ( com.google.gerrit.reviewdb.client.RefNames.EDIT_PREFIX ) . append ( changeId.get ( ) ) . append ( '/' ) . toString ( ) ; }
public void testSubsequentGetReads ( ) throws com.google.gwtorm.client.OrmException { db.create ( ) ; final com.google.gerrit.reviewdb.SystemConfig exp = getSystemConfig ( ) ; final com.google.gerrit.reviewdb.SystemConfig act = getSystemConfig ( ) ; assertNotSame ( exp , act ) ; assertEquals ( exp.adminGroupId , act.adminGroupId ) ; assertEquals ( exp.anonymousGroupId , act.anonymousGroupId ) ; assertEquals ( exp.registeredGroupId , act.registeredGroupId ) ; assertEquals ( exp.sitePath , act.sitePath ) ; assertEquals ( exp.registerEmailPrivateKey , act.registerEmailPrivateKey ) ; }
public void clear ( ) { for ( com.google.reviewit.widget.ScrollWithHeadingsView.Content content : contents ) { removeView ( content.getHeading ( ) . getView ( ) ) ; scrollContent.removeView ( content.getContent ( ) ) ; } contents.clear ( ) ; scroll.getViewTreeObserver ( ) . removeOnScrollChangedListener ( onScrollListener ) ; onScrollListener = null ; }
public void abandonReviewableWipChange ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableWipChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.ABANDONED_CHANGES ) ; abandon ( sc.changeId , sc.owner ) ; assertThat ( sender ) . sent ( "abandon" , sc ) . notTo ( sc.owner ) . cc ( sc.reviewer , sc.ccer ) . cc ( sc.reviewerByEmail , sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.ABANDONED_CHANGES ) ; }
public void resetHtml ( final com.google.gwt.user.client.ui.FlexTable myTable , final com.google.gwtexpui.safehtml.client.SafeHtml bodyHtml ) { final com.google.gwt.user.client.Element oldBody = getBodyElement ( myTable ) ; final com.google.gwt.user.client.Element newBody = com.google.gerrit.client.ui.FancyFlexTableImplIE6.parseBody ( bodyHtml ) ; assert newBody != null ; final com.google.gwt.user.client.Element tableElem = com.google.gwt.user.client.DOM.getParent ( oldBody ) ; com.google.gwt.user.client.DOM.removeChild ( tableElem , oldBody ) ; com.google.gerrit.client.ui.FancyFlexTableImplIE6.setBodyElement ( myTable , newBody ) ; com.google.gwt.user.client.DOM.appendChild ( tableElem , newBody ) ; }
private org.eclipse.jgit.treewalk.AbstractTreeIterator getTreeIterator ( org.eclipse.jgit.lib.Repository repo , java.lang.String name ) throws java.io.IOException { org.eclipse.jgit.treewalk.CanonicalTreeParser p = new org.eclipse.jgit.treewalk.CanonicalTreeParser ( ) ; org.eclipse.jgit.lib.ObjectReader or = repo.newObjectReader ( ) ; try { p.reset ( or , new org.eclipse.jgit.revwalk.RevWalk ( repo ) . parseTree ( repo.resolve ( name ) ) ) ; return p ; } finally { or.release ( ) ; } }
public void byProject ( ) throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository < com.google.gerrit.testutil.InMemoryRepositoryManager.Repo > repo1 = createProject ( "repo1" ) ; org.eclipse.jgit.junit.TestRepository < com.google.gerrit.testutil.InMemoryRepositoryManager.Repo > repo2 = createProject ( "repo2" ) ; com.google.gerrit.reviewdb.client.Change change1 = insert ( newChange ( repo1 , null , null , null , null ) ) ; com.google.gerrit.reviewdb.client.Change change2 = insert ( newChange ( repo2 , null , null , null , null ) ) ; assertQuery ( "project:foo" ) ; assertQuery ( "project:repo" ) ; assertQuery ( "project:repo1" , change1 ) ; assertQuery ( "project:repo2" , change2 ) ; }
public com.google.gitiles.GitilesView.Builder copyFrom ( com.google.gitiles.GitilesView other ) { hostName = other.hostName ; servletPath = other.servletPath ; switch ( type ) { case LOG : case DIFF : oldRevision = other.oldRevision ; case PATH : path = other.path ; case REVISION : revision = other.revision ; case REPOSITORY_INDEX : repositoryName = other.repositoryName ; } return this ; }
protected void configure ( ) { propertyExtractor = createMock ( com.googlesource.gerrit.plugins.hooks.util.PropertyExtractor.class ) ; bind ( com.googlesource.gerrit.plugins.hooks.util.PropertyExtractor.class ) . toInstance ( propertyExtractor ) ; ruleBase = createMock ( com.googlesource.gerrit.plugins.hooks.workflow.RuleBase.class ) ; bind ( com.googlesource.gerrit.plugins.hooks.workflow.RuleBase.class ) . toInstance ( ruleBase ) ; actionExecutor = createMock ( com.googlesource.gerrit.plugins.hooks.workflow.ActionExecutor.class ) ; bind ( com.googlesource.gerrit.plugins.hooks.workflow.ActionExecutor.class ) . toInstance ( actionExecutor ) ; bind ( com.googlesource.gerrit.plugins.hooks.its.ItsConfig.class ) . toInstance ( new com.googlesource.gerrit.plugins.hooks.its.ItsConfig ( null , null , null ) { @ java.lang.Override public boolean isEnabled ( com.google.gerrit.server.events.ChangeEvent event ) { return true ; } } ) ; }
public com.google.gerrit.extensions.common.AccountInfo accountInfo ( com.google.gerrit.reviewdb.client.Account a ) { com.google.gerrit.extensions.common.AccountInfo ai = new com.google.gerrit.extensions.common.AccountInfo ( a.getId ( ) . get ( ) ) ; ai.email = a.getPreferredEmail ( ) ; ai.name = a.getFullName ( ) ; ai.username = a.getUserName ( ) ; return ai ; }
public boolean contains ( com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid ) { com.google.gerrit.server.account.GroupMembership m = membership ( uuid ) ; if ( m == null ) { com.google.gerrit.server.account.UniversalGroupBackend.log.warn ( ( "Unknown GroupMembership for UUID: " + uuid ) ) ; return false ; } return m.contains ( uuid ) ; }
public java.io.File get ( ) { if ( ! ( ready ) ) { synchronized ( dataDir ) { if ( ( ! ( dataDir.exists ( ) ) ) && ( ! ( dataDir.mkdirs ( ) ) ) ) { throw new com.google.inject.ProvisionException ( java.lang.String.format ( "Cannot create %s for plugin %s" , dataDir.getAbsolutePath ( ) , getName ( ) ) ) ; } ready = true ; } } return dataDir ; }
public void queryChangesNoResults ( ) throws java.lang.Exception { createChange ( ) ; java.util.List < com.google.gerrit.extensions.common.ChangeInfo > results = gApi.changes ( ) . query ( "status:open" ) . get ( ) ; org.junit.Assert.assertEquals ( 1 , results.size ( ) ) ; results = gApi.changes ( ) . query ( "status:closed" ) . get ( ) ; org.junit.Assert.assertTrue ( results.isEmpty ( ) ) ; }
public boolean match ( com.google.gerrit.server.query.change.ChangeData object ) throws com.google.gwtorm.server.OrmException { java.util.List < java.lang.String > files = object.currentFilePaths ( ) ; return ( files != null ) && ( ( java.util.Collections.binarySearch ( files , value ) ) >= 0 ) ; }
public com.google.gerrit.client.ui.InlineHyperlink getNextPatchLink ( int index , com.google.gerrit.client.patches.PatchScreen.Type patchType ) { int nextPatchIndex = getNextPatch ( index , false , PREFERENCE_VALIDATOR ) ; if ( nextPatchIndex < 0 ) { return null ; } return createLink ( nextPatchIndex , patchType , null , com.google.gwtexpui.safehtml.client.SafeHtml.asis ( Util.C.nextPatchLinkIcon ( ) ) ) ; }
private java.net.InetSocketAddress computePreferredAddress ( ) { for ( final java.net.SocketAddress addr : listen ) { if ( ! ( addr instanceof java.net.InetSocketAddress ) ) { continue ; } java.net.InetSocketAddress inetAddr = ( ( java.net.InetSocketAddress ) ( addr ) ) ; if ( inetAddr.getAddress ( ) . isLoopbackAddress ( ) ) { continue ; } return inetAddr ; } return null ; }
private void setDefaultConfig ( javax.servlet.FilterConfig filterConfig ) throws javax.servlet.ServletException { if ( ( config ) == null ) { try { config = com.google.gitiles.GitilesConfig.loadDefault ( filterConfig ) ; } catch ( java.io.IOException e ) { throw new javax.servlet.ServletException ( e ) ; } catch ( org.eclipse.jgit.errors.ConfigInvalidException e ) { throw new javax.servlet.ServletException ( e ) ; } } }
private static void assertInvalid ( final java.lang.String in ) { try { com.google.gerrit.server.mail.Address.parse ( in ) ; fail ( ( "Incorrectly accepted " + in ) ) ; } catch ( java.lang.IllegalArgumentException e ) { assertEquals ( ( "Invalid email address: " + in ) , e.getMessage ( ) ) ; } }
public static com.google.gerrit.server.index.IndexConfig fromConfig ( org.eclipse.jgit.lib.Config cfg ) { return com.google.gerrit.server.index.IndexConfig.create ( cfg.getInt ( "index" , null , "maxLimit" , 0 ) , cfg.getInt ( "index" , null , "maxPages" , 0 ) , cfg.getInt ( "index" , null , "maxTerms" , 0 ) , cfg.getInt ( "index" , null , "maxPrefixTerms" , com.google.gerrit.server.index.IndexConfig.DEFAULT_MAX_PREFIX_TERMS ) ) ; }
Project.NameKey projectName ( org.eclipse.jgit.lib.Repository repo ) { java.nio.file.Path gitDir = repo.getDirectory ( ) . toPath ( ) ; if ( gitDir.startsWith ( basePath ) ) { java.lang.String p = basePath.relativize ( gitDir ) . toString ( ) ; java.lang.String n = p.substring ( 0 , ( ( p.length ( ) ) - ( ".git" . length ( ) ) ) ) ; return new com.google.gerrit.reviewdb.client.Project.NameKey ( n ) ; } else { com.googlesource.gerrit.plugins.quota.ProjectNameResolver.log.warn ( ( "Couldn't determine the project name from " + gitDir ) ) ; return null ; } }
protected com.google.gerrit.server.GerritServer getGerritServer ( ) throws com.google.gerrit.server.ssh.AbstractCommand.Failure { try { return com.google.gerrit.server.GerritServer.getInstance ( ) ; } catch ( com.google.gwtorm.client.OrmException e ) { throw new com.google.gerrit.server.ssh.AbstractCommand.Failure ( 128 , "fatal: Gerrit is not available" ) ; } catch ( com.google.gwtjsonrpc.server.XsrfException e ) { throw new com.google.gerrit.server.ssh.AbstractCommand.Failure ( 128 , "fatal: Gerrit is not available" ) ; } }
protected void configure ( ) { bind ( com.google.gerrit.server.index.IndexConfig.class ) . toInstance ( com.google.gerrit.server.index.IndexConfig.createDefault ( ) ) ; install ( new com.google.gerrit.server.index.IndexModule ( threads ) ) ; bind ( com.google.gerrit.server.index.ChangeIndex.class ) . to ( com.google.gerrit.solr.SolrChangeIndex.class ) ; listener ( ) . to ( com.google.gerrit.solr.SolrChangeIndex.class ) ; if ( checkVersion ) { listener ( ) . to ( com.google.gerrit.solr.IndexVersionCheck.class ) ; } }
public void onClick ( final com.google.gwt.event.dom.client.ClickEvent event ) { new com.google.gerrit.client.changes.AbandonChangeDialog ( patchSet.getId ( ) , new com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.common.data.ChangeDetail > ( ) { public void onSuccess ( com.google.gerrit.common.data.ChangeDetail result ) { changeScreen.update ( result ) ; } public void onFailure ( java.lang.Throwable caught ) { b.setEnabled ( true ) ; } } ) . center ( ) ; }
public boolean isLoggedIn ( java.util.Set < com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.Scope > scopes ) { boolean loggedIn = ( ( scopesSet.equals ( scopes ) ) && ( ( token ) != null ) ) && ( ( hub ) != null ) ; if ( loggedIn ) { try { myself = hub.getMyself ( ) ; } catch ( java.lang.Throwable e ) { com.googlesource.gerrit.plugins.github.oauth.GitHubLogin.log.error ( "Connection to GitHub broken: logging out" , e ) ; logout ( ) ; loggedIn = false ; } } return loggedIn ; }
private static boolean autoReindexIfStale ( org.eclipse.jgit.lib.Config cfg ) { HEAD ( d5b111 ) ; Update ( submodules ) ; return cfg.getBoolean ( "index" , null , "testAutoReindexIfStale" , true ) ; return cfg.getBoolean ( "index" , null , "autoReindexIfStale" , true ) ; BRANCH ( auto ) ; }
public void checkRemoveReviewer ( com.google.gerrit.server.notedb.ChangeNotes notes , com.google.gerrit.server.CurrentUser currentUser , com.google.gerrit.reviewdb.client.PatchSetApproval approval ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.server.permissions.PermissionBackendException , com.google.gerrit.server.project.NoSuchChangeException { if ( canRemoveReviewerWithoutPermissionCheck ( notes , currentUser , approval.getAccountId ( ) , approval.getValue ( ) ) ) { return ; } permissionBackend.user ( currentUser ) . change ( notes ) . database ( dbProvider ) . check ( ChangePermission.REMOVE_REVIEWER ) ; }
public java.lang.String encode ( com.google.gerrit.reviewdb.client.Account.Id accountId , java.lang.String emailAddress ) { try { java.lang.String payload = java.lang.String.format ( "%s:%s" , accountId , emailAddress ) ; byte [ ] utf8 = payload.getBytes ( "UTF-8" ) ; java.lang.String base64 = org.eclipse.jgit.util.Base64.encodeBytes ( utf8 ) ; return emailRegistrationToken.newToken ( base64 ) ; } catch ( com.google.gwtjsonrpc.server.XsrfException e ) { throw new java.lang.IllegalArgumentException ( e ) ; } catch ( java.io.UnsupportedEncodingException e ) { throw new java.lang.IllegalArgumentException ( e ) ; } }
public com.google.gerrit.server.data.AccountAttribute get ( ) { HEAD ( 80 ) ; com.google.gerrit.server.events.ce3f Merge ; com.google.gerrit.server.events.into stab ; return account != null ? eventFactory.asAccountAttribute ( new com.google.gerrit.reviewdb.client.Account.Id ( account._accountId ) ) : null ; return account != null ? eventFactory.asAccountAttribute ( new com.google.gerrit.reviewdb.client.Account.Id ( account._accountId ) ) : null ; BRANCH ( 2.0F ) ; com.google.gerrit.server.events.ee1f Set ; com.google.gerrit.server.events.version to ; }
private com.google.gerrit.client.ui.Screen createScreen ( ) { return ( info ) != null ? new com.google.gerrit.client.changes.ChangeScreen ( info ) : new com.google.gerrit.client.changes.ChangeScreen ( id ) ; }
public void symlinkText ( ) throws java.lang.Exception { final org.eclipse.jgit.revwalk.RevBlob link = repo.blob ( "foo" ) ; repo.branch ( "master" ) . commit ( ) . edit ( new org.eclipse.jgit.dircache.DirCacheEditor.PathEdit ( "baz" ) { @ java.lang.Override public void apply ( org.eclipse.jgit.dircache.DirCacheEntry ent ) { ent.setFileMode ( FileMode.SYMLINK ) ; ent.setObjectId ( link ) ; } } ) . create ( ) ; java.lang.String text = buildBlob ( "/repo/+/master/baz" , "120000" ) ; org.junit.Assert.assertEquals ( "foo" , text ) ; }
public void run ( ) { synchronized ( cleanup ) { for ( final java.util.Iterator < java.lang.Runnable > i = cleanup.iterator ( ) ; i.hasNext ( ) ; ) { try { i.next ( ) . run ( ) ; } catch ( java.lang.Throwable err ) { com.google.gerrit.server.RequestCleanup.log.error ( "Failed to execute per-request cleanup" , err ) ; } i.remove ( ) ; } } }
private boolean isDraftPatchSet ( com.google.gerrit.reviewdb.PatchSet.Id id , com.google.gerrit.reviewdb.ReviewDb db ) throws com.google.gwtorm.client.OrmException { com.google.gerrit.reviewdb.PatchSet ps = db.patchSets ( ) . get ( id ) ; if ( ps == null ) { throw new com.google.gwtorm.client.OrmException ( ( ( "Patch set " + id ) + " not found" ) ) ; } return ps.isDraft ( ) ; }
private java.util.Set < java.lang.String > getRefNames ( java.lang.String prefix ) throws com.google.gwtorm.server.OrmException { try ( org.eclipse.jgit.lib.Repository repo = repoManager.openRepository ( allUsers ) ) { org.eclipse.jgit.lib.RefDatabase refDb = repo.getRefDatabase ( ) ; return refDb.getRefs ( prefix ) . keySet ( ) ; } catch ( java.io.IOException e ) { throw new com.google.gwtorm.server.OrmException ( e ) ; } }
public void visit ( org.pegdown.ast.HeaderNode node ) { java.lang.String tag = "h" + ( node.getLevel ( ) ) ; html.open ( tag ) ; if ( toc.include ( node ) ) { html.attribute ( "id" , toc.idFromHeader ( node ) ) ; } visitChildren ( node ) ; html.close ( tag ) ; }
public void setParent_Forbidden ( ) throws java.lang.Exception { java.lang.String parent = "parent" ; createProject ( parent , null , true ) ; com.google.gerrit.acceptance.RestResponse r = userSession.put ( ( ( "/projects/" + ( project.get ( ) ) ) + "/parent" ) , newParentInput ( parent ) ) ; com.google.common.truth.Truth.assertThat ( r.getStatusCode ( ) ) . isEqualTo ( HttpStatus.SC_FORBIDDEN ) ; r.consume ( ) ; }
private java.util.Optional < com.google.gerrit.reviewdb.client.Account > loadAccount ( com.google.gerrit.reviewdb.client.Account.Id accountId , org.eclipse.jgit.revwalk.RevWalk rw , org.eclipse.jgit.lib.ObjectId commit ) throws java.io.IOException , org.eclipse.jgit.errors.ConfigInvalidException { rw.reset ( ) ; com.google.gerrit.server.account.AccountConfig accountConfig = new com.google.gerrit.server.account.AccountConfig ( null , accountId ) ; accountConfig.load ( rw , commit ) ; return accountConfig.getLoadedAccount ( ) ; }
private void goUpToChange ( boolean openReplyBox ) { java.lang.String b = ( ( base ) != null ) ? java.lang.String.valueOf ( base.get ( ) ) : null ; java.lang.String rev = java.lang.String.valueOf ( revision.get ( ) ) ; com.google.gerrit.client.Gerrit.display ( com.google.gerrit.common.PageLinks.toChange ( changeId , rev ) , new com.google.gerrit.client.change.ChangeScreen2 ( changeId , b , rev , openReplyBox , false ) ) ; }
public static boolean canRebase ( com.google.gerrit.reviewdb.client.PatchSet patchSet , com.google.gerrit.reviewdb.client.Branch.NameKey dest , org.eclipse.jgit.lib.Repository git , org.eclipse.jgit.revwalk.RevWalk rw , com.google.gerrit.reviewdb.server.ReviewDb db ) { try { com.google.gerrit.server.change.RebaseUtil.findBaseRevision ( patchSet , dest , git , rw , db ) ; return true ; } catch ( com.google.gerrit.extensions.restapi.RestApiException e ) { return false ; } catch ( com.google.gwtorm.server.OrmException | java.io.IOException e ) { com.google.gerrit.server.change.RebaseUtil.log.warn ( java.lang.String.format ( "Error checking if patch set %s on %s can be rebased" , patchSet.getId ( ) , dest ) , e ) ; return false ; } }
private static java.lang.String text ( java.lang.String branch , java.lang.String topic ) { if ( ( topic != null ) && ( ! ( topic.isEmpty ( ) ) ) ) { return ( ( branch + " (" ) + topic ) + ")" ; } else { return branch ; } }
private static java.util.List < com.google.gerrit.reviewdb.client.PatchSet > toPatchSets ( com.google.gerrit.client.changes.ChangeInfo info ) { com.google.gwt.core.client.JsArray < com.google.gerrit.client.changes.ChangeInfo.RevisionInfo > all = info.revisions ( ) . values ( ) ; com.google.gerrit.client.changes.ChangeInfo.RevisionInfo.sortRevisionInfoByNumber ( all ) ; java.util.List < com.google.gerrit.reviewdb.client.PatchSet > r = new java.util.ArrayList < com.google.gerrit.reviewdb.client.PatchSet > ( all.length ( ) ) ; for ( com.google.gerrit.client.changes.ChangeInfo.RevisionInfo rev : com.google.gerrit.client.rpc.Natives.asList ( all ) ) { r.add ( com.google.gerrit.client.changes.ChangeDetailCache.toPatchSet ( info , rev ) ) ; } return r ; }
private void addDiffChunkAndPadding ( net.codemirror.lib.CodeMirror cmToPad , int lineToPad , int lineOnOther , int chunkSize ) { net.codemirror.lib.CodeMirror otherCm = otherCm ( cmToPad ) ; linePaddingOnOtherSideMap.put ( otherCm.getLineHandle ( lineOnOther ) , new com.google.gerrit.client.diff.PaddingManager.LinePaddingWidgetWrapper ( addPaddingWidget ( cmToPad , DiffTable.style.padding ( ) , lineToPad , 0 , Unit.EM , null ) , lineToPad , chunkSize ) ) ; diffChunks.add ( new com.google.gerrit.client.diff.SideBySide2.DiffChunkInfo ( getSideFromCm ( otherCm ) , ( ( lineOnOther - chunkSize ) + 1 ) , lineOnOther ) ) ; }
public com.google.gerrit.server.group.GroupInfo apply ( com.google.gerrit.server.group.GroupResource resource , com.google.gerrit.server.group.AddIncludedGroups.PutIncludedGroup.Input input ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.extensions.restapi.BadRequestException , com.google.gerrit.extensions.restapi.MethodNotAllowedException , com.google.gwtorm.server.OrmException { com.google.gerrit.server.group.AddIncludedGroups.Input in = new com.google.gerrit.server.group.AddIncludedGroups.Input ( ) ; in.groups = com.google.common.collect.ImmutableList.of ( id ) ; java.util.List < com.google.gerrit.server.group.GroupInfo > list = put.get ( ) . apply ( resource , in ) ; if ( ( list.size ( ) ) == 1 ) { return list.get ( 0 ) ; } else { throw new java.lang.IllegalStateException ( ) ; } }
private boolean canForceUpdate ( ) { if ( ! ( isProjectStatePermittingWrite ( ) ) ) { return false ; } if ( canPushWithForce ( ) ) { return true ; } switch ( getUser ( ) . getAccessPath ( ) ) { case GIT : return false ; case JSON_RPC : case REST_API : case SSH_COMMAND : case UNKNOWN : case WEB_BROWSER : default : return ( ( isOwner ( ) ) && ( ! ( isForceBlocked ( Permission.PUSH ) ) ) ) || ( projectControl.isAdmin ( ) ) ; } }
private static void recursivelyDelete ( java.io.File dir ) throws java.io.IOException { if ( ! ( dir.getPath ( ) . equals ( dir.getCanonicalPath ( ) ) ) ) { return ; } java.io.File [ ] contents = dir.listFiles ( ) ; if ( contents != null ) { for ( java.io.File d : contents ) { if ( d.isDirectory ( ) ) { com.google.gerrit.testutil.TempFileUtil.recursivelyDelete ( d ) ; } else { com.google.gerrit.testutil.TempFileUtil.deleteNowOrOnExit ( d ) ; } } } com.google.gerrit.testutil.TempFileUtil.deleteNowOrOnExit ( dir ) ; }
public long getEffectiveMaxObjectSizeLimit ( com.google.gerrit.server.project.ProjectState p ) { long global = getMaxObjectSizeLimit ( ) ; long local = p.getMaxObjectSizeLimit ( ) ; if ( ( global > 0 ) && ( local > 0 ) ) { return java.lang.Math.min ( global , local ) ; } else { return java.lang.Math.max ( global , local ) ; } }
private com.google.gerrit.extensions.common.CommentInfo addDraft ( java.lang.String changeId , java.lang.String revId , com.google.gerrit.extensions.api.changes.ReviewInput.CommentInput c ) throws java.io.IOException { com.google.gerrit.acceptance.RestResponse r = userSession.put ( ( ( ( ( "/changes/" + changeId ) + "/revisions/" ) + revId ) + "/drafts" ) , c ) ; org.junit.Assert.assertEquals ( HttpStatus.SC_CREATED , r.getStatusCode ( ) ) ; return newGson ( ) . fromJson ( r.getReader ( ) , com.google.gerrit.extensions.common.CommentInfo.class ) ; }
private void addRanges ( java.util.Map < java.lang.String , java.lang.Object > have , com.google.gerrit.server.account.AccountResource rsrc ) { com.google.gerrit.server.account.CapabilityControl cc = rsrc.getUser ( ) . getCapabilities ( ) ; for ( java.lang.String name : com.google.gerrit.common.data.GlobalCapability.getRangeNames ( ) ) { if ( ( want ( name ) ) && ( cc.hasExplicitRange ( name ) ) ) { have.put ( name , new com.google.gerrit.server.account.GetCapabilities.Range ( cc.getRange ( name ) ) ) ; } } }
private void offer ( final com.google.gerrit.server.events.Event event ) { synchronized ( taskLock ) { if ( ! ( queue.offer ( event ) ) ) { dropped = true ; } if ( ( ( task ) == null ) && ( ! ( done ) ) ) { task = pool.submit ( writer ) ; } } }
public void onSuccess ( com.google.gwt.core.client.JsArray < com.google.gerrit.client.changes.ChangeList > result ) { java.util.List < com.google.gerrit.client.changes.ChangeList > cls = com.google.gerrit.client.rpc.Natives.asList ( result ) ; updateColumnsForLabels ( cls.toArray ( new com.google.gerrit.client.changes.ChangeList [ cls.size ( ) ] ) ) ; for ( int i = 0 ; i < ( cls.size ( ) ) ; i ++ ) { sections.get ( i ) . display ( cls.get ( i ) ) ; } finishDisplay ( ) ; }
public int shutdown ( ) { int cnt = 0 ; if ( ( pool ) != null ) { HEAD ( ( 5723.0F - 2.15 ) ) ; com.googlesource.gerrit.plugins.replication.Destination.repLog.warn ( java.lang.String.format ( "Cancelling replication events" ) ) ; for ( java.lang.Runnable r : pool.getQueue ( ) ) { com.googlesource.gerrit.plugins.replication.Destination.repLog.warn ( "Cancelling replication event {}" , r ) ; } BRANCH ( 454 ) ; com.googlesource.gerrit.plugins.replication.bfe Fix ; com.googlesource.gerrit.plugins.replication.deletion logs ; cnt = pool.shutdownNow ( ) . size ( ) ; pool = null ; } return cnt ; }
public void go ( ) { if ( ( com.google.gerrit.client.Gerrit.patchScreen ) != null ) { if ( type == ( com.google.gerrit.client.Gerrit.patchScreen.getPatchScreenType ( ) ) ) { com.google.gerrit.client.Gerrit.patchScreen.setTopView ( PatchScreen.TopView.MAIN ) ; com.google.gwt.dom.client.AnchorElement.as ( getElement ( ) ) . blur ( ) ; } else { new com.google.gerrit.client.ui.PatchLink ( "" , type , com.google.gerrit.client.Gerrit.patchScreen ) . go ( ) ; } } }
private static com.google.gerrit.extensions.restapi.BinaryResult base64 ( com.google.gerrit.extensions.restapi.BinaryResult bin ) throws java.io.IOException { int maxSize = com.google.gerrit.httpd.restapi.RestApiServlet.base64MaxSize ( bin.getContentLength ( ) ) ; int estSize = java.lang.Math.min ( com.google.gerrit.httpd.restapi.RestApiServlet.base64MaxSize ( com.google.gerrit.httpd.restapi.RestApiServlet.HEAP_EST_SIZE ) , maxSize ) ; org.eclipse.jgit.util.TemporaryBuffer.Heap buf = com.google.gerrit.httpd.restapi.RestApiServlet.heap ( estSize , maxSize ) ; java.io.OutputStream encoded = com.google.common.io.BaseEncoding.base64 ( ) . encodingStream ( new java.io.OutputStreamWriter ( buf , java.nio.charset.StandardCharsets.ISO_8859_1 ) ) ; bin.writeTo ( encoded ) ; encoded.close ( ) ; return com.google.gerrit.httpd.restapi.RestApiServlet.asBinaryResult ( buf ) ; }
protected void preDisplay ( com.google.gerrit.client.projects.ConfigInfoCache.Entry result ) { commentManager = new com.google.gerrit.client.diff.SideBySideCommentManager ( this , getBase ( ) , getRevision ( ) , getPath ( ) , result.getCommentLinkProcessor ( ) , getChangeStatus ( ) . isOpen ( ) ) ; setTheme ( result.getTheme ( ) ) ; display ( comments ) ; }
private void fireCommentAddedHook ( com.google.gerrit.server.change.RevisionResource rsrc ) { com.google.gerrit.server.IdentifiedUser user = ( ( com.google.gerrit.server.IdentifiedUser ) ( rsrc.getControl ( ) . getCurrentUser ( ) ) ) ; try { hooks.doCommentAddedHook ( change , user.getAccount ( ) , rsrc.getPatchSet ( ) , message.getMessage ( ) , categories , db ) ; } catch ( com.google.gwtorm.server.OrmException e ) { com.google.gerrit.server.change.PostReview.log.warn ( "ChangeHook.doCommentAddedHook delivery failed" , e ) ; } }
protected void setUseSignedOffBy ( com.google.gerrit.extensions.client.InheritableBoolean value ) throws java.lang.Exception { com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create ( project ) ; com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read ( md ) ; config.getProject ( ) . setUseSignedOffBy ( value ) ; config.commit ( md ) ; projectCache.evict ( config.getProject ( ) ) ; }
protected void configure ( ) { factory ( ChangeProjectAccess.Factory.class ) ; factory ( ReviewProjectAccess.Factory.class ) ; factory ( ChangeProjectSettings.Factory.class ) ; factory ( DeleteBranches.Factory.class ) ; factory ( ListBranches.Factory.class ) ; factory ( VisibleProjectDetails.Factory.class ) ; factory ( ProjectAccessFactory.Factory.class ) ; factory ( ProjectDetailFactory.Factory.class ) ; }
public static java.lang.String refsEditPrefix ( com.google.gerrit.reviewdb.client.Account.Id accountId , com.google.gerrit.reviewdb.client.Change.Id changeId ) { return new java.lang.StringBuilder ( com.google.gerrit.reviewdb.client.RefNames.refsUsers ( accountId ) ) . append ( '/' ) . append ( com.google.gerrit.reviewdb.client.RefNames.EDIT_PREFIX ) . append ( changeId.get ( ) ) . append ( '/' ) . toString ( ) ; }
public void funnel ( K from , com.google.common.hash.PrimitiveSink into ) { try { java.io.ObjectOutputStream ser = new java.io.ObjectOutputStream ( new com.google.gerrit.server.cache.h2.H2CacheImpl.SinkOutputStream ( into ) ) ; ser.writeObject ( from ) ; ser.flush ( ) ; } catch ( java.io.IOException err ) { throw new java.lang.RuntimeException ( "Cannot hash as Serializable" , err ) ; } }
private boolean isTrusted ( final com.google.gerrit.reviewdb.client.AccountExternalId id ) { if ( id.isScheme ( AccountExternalId.LEGACY_GAE ) ) { return isAllowGoogleAccountUpgrade ( ) ; } if ( id.isScheme ( AccountExternalId.SCHEME_MAILTO ) ) { return true ; } if ( id.isScheme ( AccountExternalId.SCHEME_UUID ) ) { return true ; } if ( id.isScheme ( AccountExternalId.SCHEME_USERNAME ) ) { return true ; } for ( final com.google.gerrit.server.auth.openid.OpenIdProviderPattern p : trustedOpenIDs ) { if ( p.matches ( id ) ) { return true ; } } return false ; }
private java.lang.Iterable < com.google.gerrit.server.query.change.ChangeData > byCommitsOnBranchNotMergedFromIndex ( com.google.gerrit.reviewdb.client.Branch.NameKey branch , java.util.List < java.lang.String > hashes ) throws com.google.gwtorm.server.OrmException { return query ( com.google.gerrit.server.query.Predicate.and ( com.google.gerrit.server.query.change.InternalChangeQuery.ref ( branch ) , com.google.gerrit.server.query.change.InternalChangeQuery.project ( branch.getParentKey ( ) ) , com.google.gerrit.server.query.Predicate.not ( com.google.gerrit.server.query.change.InternalChangeQuery.status ( Change.Status.MERGED ) ) , com.google.gerrit.server.query.Predicate.or ( com.google.gerrit.server.query.change.InternalChangeQuery.commits ( com.google.gerrit.server.query.change.InternalChangeQuery.schema ( indexes ) , hashes ) ) ) ) ; }
public void testRejectJavaScript_AnchorHref ( ) { final java.lang.String href = "javascript:window.close();" ; try { new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder ( ) . openAnchor ( ) . setAttribute ( "href" , href ) ; fail ( "accepted javascript in a href" ) ; } catch ( java.lang.RuntimeException e ) { assertEquals ( ( "javascript unsafe in href: " + href ) , e.getMessage ( ) ) ; } }
static void initLibrary ( com.google.gwt.user.client.rpc.AsyncCallback < java.lang.Void > cb ) { if ( net.codemirror.lib.Loader.isLibLoaded ( ) ) { cb.onSuccess ( null ) ; } else { net.codemirror.lib.Loader.injectCss ( Lib.I.css ( ) ) ; net.codemirror.lib.Loader.injectScript ( Lib.I.js ( ) . getSafeUri ( ) , cb ) ; } }
protected PushOneCommit.Result createChange ( org.eclipse.jgit.api.Git git , java.lang.String subject , java.lang.String fileName , java.lang.String content , java.lang.String topic ) throws java.io.IOException , org.eclipse.jgit.api.errors.GitAPIException { com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create ( db , admin.getIdent ( ) , subject , fileName , content ) ; return push.to ( git , ( "refs/for/master/" + topic ) ) ; }
private void deleteDraft ( java.lang.String changeId , java.lang.String revId , java.lang.String uuid ) throws java.io.IOException { com.google.gerrit.acceptance.RestResponse r = userSession.delete ( ( ( ( ( ( "/changes/" + changeId ) + "/revisions/" ) + revId ) + "/drafts/" ) + uuid ) ) ; org.junit.Assert.assertEquals ( HttpStatus.SC_NO_CONTENT , r.getStatusCode ( ) ) ; }
public boolean match ( com.google.gerrit.server.query.change.ChangeData object ) throws com.google.gwtorm.server.OrmException { try { for ( com.google.gerrit.server.query.change.ChangeData cData : index.getSource ( com.google.gerrit.server.query.Predicate.and ( new com.google.gerrit.server.query.change.LegacyChangeIdPredicate ( db , object.getId ( ) ) , this ) ) . read ( ) ) { if ( cData.getId ( ) . equals ( object.getId ( ) ) ) { return true ; } } } catch ( com.google.gerrit.server.query.QueryParseException e ) { throw new com.google.gwtorm.server.OrmException ( e ) ; } return false ; }
public com.google.gerrit.server.CurrentUser getCurrentUser ( ) { if ( isSignedIn ( ) ) { return identified.create ( val.getAccountId ( ) ) ; } return anonymousProvider.get ( ) ; }
public com.google.gerrit.server.patch.PatchList get ( final com.google.gerrit.client.reviewdb.Change change , final com.google.gerrit.client.reviewdb.PatchSet patchSet , final com.google.gerrit.client.data.PatchScriptSettings.Whitespace whitespace ) { final com.google.gerrit.client.reviewdb.Project.NameKey projectKey = change.getProject ( ) ; final org.spearce.jgit.lib.ObjectId a = null ; final org.spearce.jgit.lib.ObjectId b = org.spearce.jgit.lib.ObjectId.fromString ( patchSet.getRevision ( ) . get ( ) ) ; return get ( new com.google.gerrit.server.patch.PatchListKey ( projectKey , a , b , whitespace ) ) ; }
private void setListBox ( final com.google.gwt.user.client.ui.ListBox f , final short defaultValue , final short currentValue ) { final int n = f.getItemCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( java.lang.Short.parseShort ( f.getValue ( i ) ) ) == currentValue ) { f.setSelectedIndex ( i ) ; return ; } } if ( currentValue != defaultValue ) { setListBox ( f , defaultValue , defaultValue ) ; } }
private com.google.gerrit.extensions.client.SubmitType getSubmitType ( com.google.gerrit.server.CurrentUser user , com.google.gerrit.server.query.change.ChangeData cd , com.google.gerrit.reviewdb.client.PatchSet patchSet ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.SubmitTypeRecord rec = submitRuleEvaluatorFactory.create ( user , cd ) . setPatchSet ( patchSet ) . getSubmitType ( ) ; if ( ( rec.status ) != ( SubmitTypeRecord.Status.OK ) ) { throw new com.google.gwtorm.server.OrmException ( ( "Submit type rule failed: " + rec ) ) ; } return rec.type ; }
public void testCreateProjectApiWithGitSuffix ( ) throws java.lang.Exception { final java.lang.String newProjectName = "newProject" ; com.google.gerrit.extensions.common.ProjectInfo p = gApi.projects ( ) . name ( ( newProjectName + ".git" ) ) . create ( ) . get ( ) ; com.google.common.truth.Truth.assertThat ( p.name ) . isEqualTo ( newProjectName ) ; com.google.gerrit.server.project.ProjectState projectState = projectCache.get ( new com.google.gerrit.reviewdb.client.Project.NameKey ( newProjectName ) ) ; com.google.common.truth.Truth.assertThat ( projectState ) . isNotNull ( ) ; com.google.gerrit.acceptance.rest.project.ProjectAssert.assertProjectInfo ( projectState.getProject ( ) , p ) ; assertHead ( newProjectName , "refs/heads/master" ) ; }
public void run ( ) { int line = ( cm.extras ( ) . hasActiveLine ( ) ) ? cm.getLineNumber ( cm.extras ( ) . activeLine ( ) ) : 0 ; int res = java.util.Collections.binarySearch ( chunks , new com.google.gerrit.client.diff.UnifiedDiffChunkInfo ( cm.side ( ) , 0 , 0 , line , false ) , getDiffChunkComparatorCmLine ( ) ) ; diffChunkNavHelper ( chunks , host , res , dir ) ; }
public void abandonReviewableChangeByOwnerCcingSelf ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.ABANDONED_CHANGES ) ; abandon ( sc.changeId , sc.owner , com.google.gerrit.extensions.client.GeneralPreferencesInfo.EmailStrategy.CC_ON_OWN_COMMENTS ) ; assertThat ( sender ) . sent ( "abandon" , sc ) . to ( sc.owner ) . cc ( sc.reviewer , sc.ccer ) . to ( sc.reviewerByEmail ) . cc ( sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.ABANDONED_CHANGES ) ; }
public void testEquals ( ) throws java.lang.Exception { com.google.common.truth.Truth.assertThat ( entry1.equals ( null ) ) . isFalse ( ) ; com.google.common.truth.Truth.assertThat ( entry1.equals ( "String object" ) ) . isFalse ( ) ; com.google.common.truth.Truth.assertThat ( entry1.equals ( entry1 ) ) . isTrue ( ) ; com.google.common.truth.Truth.assertThat ( entry1.equals ( entry2 ) ) . isFalse ( ) ; com.google.common.truth.Truth.assertThat ( entry1.equals ( entry4 ) ) . isTrue ( ) ; }
private static java.util.Set < java.lang.String > scanSectionNames ( com.google.gerrit.server.git.ProjectConfig config ) { java.util.Set < java.lang.String > names = new java.util.HashSet < java.lang.String > ( ) ; for ( com.google.gerrit.common.data.AccessSection section : config.getAccessSections ( ) ) { names.add ( section.getRefPattern ( ) ) ; } return names ; }
private org.eclipse.jgit.lib.Repository openRepository ( java.lang.String name ) throws java.io.IOException { name = com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.urlToRepoKey ( canonicalWebUrl , name ) ; if ( repos.containsKey ( name ) ) { return repos.get ( name ) ; } org.eclipse.jgit.lib.Repository repo = repoManager.openRepository ( new com.google.gerrit.reviewdb.client.Project.NameKey ( name ) ) ; repos.put ( name , repo ) ; return repo ; }
public void testThreeLevelTreeWithSomeIndexPredicates ( ) throws java.lang.Exception { com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > in = parse ( "-foo:a (file:b OR file:c)" ) ; com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > out = rewrite ( in ) ; assertEquals ( com.google.gerrit.server.query.change.AndSource.class , out.getClass ( ) ) ; assertEquals ( com.google.common.collect.ImmutableList.of ( query ( in.getChild ( 1 ) ) , in.getChild ( 0 ) ) , out.getChildren ( ) ) ; }
private void applyComment ( java.lang.String project , int number , com.google.gerrit.extensions.api.changes.ReviewInput comment ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.update.UpdateException , com.google.gwtorm.server.OrmException , java.io.IOException { BRANCH ( f1d0f4 ) ; com.criteo.gerrit.plugins.automerge.Format all ; files ( ( ( ( google ) - ( java ) ) - ( format ) ) ) ; com.google.gerrit.server.change.RevisionResource r = atomicityHelper.getRevisionResource ( project , number ) ; reviewer.get ( ) . apply ( r , comment ) ; }
public boolean isVisible ( com.google.gerrit.reviewdb.server.ReviewDb db ) throws com.google.gwtorm.server.OrmException { if ( ( ( getChange ( ) . getStatus ( ) ) == ( Change.Status.DRAFT ) ) && ( ! ( isDraftVisible ( db , null ) ) ) ) { return false ; } return isRefVisible ( ) ; }
private com.google.common.collect.FluentIterable < com.google.gerrit.server.project.ListBranches.BranchInfo > filterBranches ( java.util.List < com.google.gerrit.server.project.ListBranches.BranchInfo > branchList ) throws com.google.gerrit.extensions.restapi.BadRequestException { com.google.common.collect.FluentIterable < com.google.gerrit.server.project.ListBranches.BranchInfo > branches = com.google.common.collect.FluentIterable.from ( branchList ) ; if ( ! ( com.google.common.base.Strings.isNullOrEmpty ( matchSubstring ) ) ) { branches = branches.filter ( new com.google.gerrit.server.project.ListBranches.SubstringPredicate ( matchSubstring ) ) ; } else if ( ! ( com.google.common.base.Strings.isNullOrEmpty ( matchRegex ) ) ) { branches = branches.filter ( new com.google.gerrit.server.project.ListBranches.RegexPredicate ( matchRegex ) ) ; } return branches ; }
public void byStatus ( ) throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository < com.google.gerrit.testutil.InMemoryRepositoryManager.Repo > repo = createProject ( "repo" ) ; com.google.gerrit.server.change.ChangeInserter ins1 = newChangeWithStatus ( repo , Change.Status.NEW ) ; com.google.gerrit.reviewdb.client.Change change1 = insert ( ins1 ) ; com.google.gerrit.server.change.ChangeInserter ins2 = newChangeWithStatus ( repo , Change.Status.MERGED ) ; com.google.gerrit.reviewdb.client.Change change2 = insert ( ins2 ) ; assertQuery ( "status:new" , change1 ) ; assertQuery ( "status:NEW" , change1 ) ; assertQuery ( "is:new" , change1 ) ; assertQuery ( "status:merged" , change2 ) ; assertQuery ( "is:merged" , change2 ) ; }
public void emptyPermissionRangeOmitsResult ( ) throws java.lang.Exception { com.google.gerrit.reviewdb.client.PatchSetApproval cr = psa ( userId , "Code-Review" , 1 ) ; com.google.gerrit.reviewdb.client.PatchSetApproval v = psa ( userId , "Verified" , 1 ) ; org.junit.Assert.assertEquals ( com.google.gerrit.server.git.LabelNormalizer.Result.create ( com.google.gerrit.server.git.LabelNormalizerTest.list ( ) , com.google.gerrit.server.git.LabelNormalizerTest.list ( ) , com.google.gerrit.server.git.LabelNormalizerTest.list ( cr , v ) ) , norm.normalize ( change , com.google.gerrit.server.git.LabelNormalizerTest.list ( cr , v ) ) ) ; }
public java.util.Set < com.google.gerrit.reviewdb.client.PatchSet.Id > patchIds ( ) throws com.google.gwtorm.server.OrmException { java.util.Set < com.google.gerrit.reviewdb.client.PatchSet.Id > ret = new java.util.HashSet < > ( ) ; for ( com.google.gerrit.server.query.change.ChangeData cd : changeData ) { ret.add ( cd.change ( ) . currentPatchSetId ( ) ) ; } return ret ; }
private static void initVimKeys ( ) { net.codemirror.lib.KeyMap km = net.codemirror.lib.CodeMirror.cloneKeyMap ( "vim" ) ; for ( java.lang.String s : new java.lang.String [ ] { "A" , "C" , "O" , "R" , "U" , "Ctrl-C" } ) { km.remove ( s ) ; } net.codemirror.lib.CodeMirror.addKeyMap ( "vim_ro" , km ) ; net.codemirror.lib.CodeMirror.mapVimKey ( "j" , "gj" ) ; net.codemirror.lib.CodeMirror.mapVimKey ( "k" , "gk" ) ; net.codemirror.lib.CodeMirror.mapVimKey ( "Down" , "gj" ) ; net.codemirror.lib.CodeMirror.mapVimKey ( "Up" , "gk" ) ; }
public com.google.gerrit.extensions.common.ChangeInfo apply ( com.google.gerrit.server.change.ChangeResource req , final com.google.gerrit.extensions.api.changes.AbandonInput input ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.git.UpdateException , com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl control = req.getControl ( ) ; com.google.gerrit.server.IdentifiedUser caller = control.getUser ( ) . asIdentifiedUser ( ) ; if ( ! ( control.canAbandon ( dbProvider.get ( ) ) ) ) { throw new com.google.gerrit.extensions.restapi.AuthException ( "abandon not permitted" ) ; } com.google.gerrit.reviewdb.client.Change change = abandon ( control , input.message , caller.getAccount ( ) ) ; return json.create ( ChangeJson.NO_OPTIONS ) . format ( change ) ; }
public static com.google.gerrit.server.patch.DiffCacheContent createEmpty ( final org.spearce.jgit.lib.Repository db , final org.spearce.jgit.lib.ObjectId treeIsh , final java.lang.String path ) throws java.io.IOException , org.spearce.jgit.errors.IncorrectObjectTypeException , org.spearce.jgit.errors.MissingObjectException { final org.spearce.jgit.lib.ObjectId blob = com.google.gerrit.server.patch.DiffCacheContent.find ( db , treeIsh , path ) ; if ( blob == null ) { throw new java.io.IOException ( ( ( ( "path \"" + path ) + "\" not in " ) + ( treeIsh.name ( ) ) ) ) ; } return new com.google.gerrit.server.patch.DiffCacheContent ( blob ) ; }
public void skipWhenUserBelongsToGroupUUID ( ) throws java.lang.Exception { java.lang.String config = "[plugin \"uploadvalidator\"]\n" + ( ( "skipValidation=testOp\n" + "skipGroup=testGroup\n" ) + "skipGroup=anotherGroup" ) ; com.googlesource.gerrit.plugins.uploadvalidator.ValidatorConfig validatorConfig = new com.googlesource.gerrit.plugins.uploadvalidator.ValidatorConfig ( new com.googlesource.gerrit.plugins.uploadvalidator.FakeConfigFactory ( projectName , config ) , new com.googlesource.gerrit.plugins.uploadvalidator.FakeUserProvider ( "testGroup" , "yetAnotherGroup" ) , new com.googlesource.gerrit.plugins.uploadvalidator.FakeGroupCacheUUIDByName ( ) ) ; com.google.common.truth.Truth.assertThat ( validatorConfig.isEnabledForRef ( projectName , "anyRef" , "testOp" ) ) . isFalse ( ) ; }
public void addValue ( final java.lang.Object value ) throws org.kohsuke.args4j.CmdLineException { java.lang.Short val = ( ( java.lang.Short ) ( value ) ) ; if ( ( val < ( approvalMin ) ) || ( val > ( approvalMax ) ) ) { throw new org.kohsuke.args4j.CmdLineException ( ( ( ( ( ( name ( ) ) + " valid values are " ) + ( approvalMin.toString ( ) ) ) + ".." ) + ( approvalMax.toString ( ) ) ) ) ; } this . value = ( ( java.lang.Short ) ( value ) ) ; }
public com.google.gerrit.server.account.GroupControl controlFor ( final com.google.gerrit.reviewdb.client.AccountGroup.Id groupId ) throws com.google.gerrit.common.errors.NoSuchGroupException { final com.google.gerrit.reviewdb.client.AccountGroup group = groupCache.get ( groupId ) ; if ( group == null ) { throw new com.google.gerrit.common.errors.NoSuchGroupException ( groupId ) ; } return new com.google.gerrit.server.account.GroupControl ( groupCache , user.get ( ) , group ) ; }
private boolean shouldGet ( ) { if ( console.isBatch ( ) ) { return required ; } else { final java.lang.StringBuilder msg = new java.lang.StringBuilder ( ) ; msg.append ( "\n" ) ; msg.append ( "Gerrit Code Review is not shipped with %s\n" ) ; if ( required ) { msg.append ( "** This library is required for your configuration. **\n" ) ; } else { msg.append ( " If available, Gerrit can take advantage of features\n" ) ; msg.append ( " in the library, but will also function without it.\n" ) ; } msg.append ( "Download and install it now" ) ; return console.yesno ( msg.toString ( ) , name ) ; } }
void appendInsert ( int numLines ) { int origLineB = lineB ; lineB += numLines ; int bAheadOfA = ( lineB ) - ( lineA ) ; lineMapAtoB.add ( new com.google.gerrit.client.diff.LineMapper.LineGap ( lineA , lineA , bAheadOfA ) ) ; lineMapBtoA.add ( new com.google.gerrit.client.diff.LineMapper.LineGap ( origLineB , ( ( lineB ) - 1 ) , ( - bAheadOfA ) ) ) ; }
static java.lang.String makeKey ( int change , int patch , java.lang.String branch ) { if ( ( branch.indexOf ( com.googlesource.gerrit.plugins.findowners.Cache.REFS_HEADS ) ) == 0 ) { branch = branch.substring ( com.googlesource.gerrit.plugins.findowners.Cache.REFS_HEADS.length ( ) ) ; } return ( ( ( change + ":" ) + patch ) + ":" ) + branch ; }
public boolean canDelete ( com.google.gerrit.reviewdb.client.Change.Status status ) { switch ( status ) { case NEW : case ABANDONED : return ( ( isOwner ( ) ) && ( getRefControl ( ) . canDeleteOwnChanges ( ) ) ) || ( getProjectControl ( ) . isAdmin ( ) ) ; case MERGED : default : return false ; } }
com.google.gerrit.httpd.WebSessionManager.Val createVal ( final com.google.gerrit.httpd.WebSessionManager.Key key , final com.google.gerrit.httpd.WebSessionManager.Val val ) { final com.google.gerrit.reviewdb.client.Account.Id who = val.getAccountId ( ) ; final boolean remember = val.isPersistentCookie ( ) ; final com.google.gerrit.reviewdb.client.AccountExternalId.Key lastLogin = val.getExternalId ( ) ; return createVal ( key , who , remember , lastLogin , val.sessionId ) ; }
public void testBlockedExtensionsCaseInsensitive ( ) throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = makeCommit ( com.googlesource.gerrit.plugins.uploadvalidator.FileExtensionValidatorTest.BLOCKED_EXTENSIONS_UC ) ; java.util.List < com.google.gerrit.server.git.validators.CommitValidationMessage > m = com.googlesource.gerrit.plugins.uploadvalidator.FileExtensionValidator.performValidation ( repo , c , com.googlesource.gerrit.plugins.uploadvalidator.FileExtensionValidatorTest.BLOCKED_EXTENSIONS_LC ) ; java.util.List < java.lang.String > expected = new java.util.ArrayList < > ( ) ; for ( java.lang.String extension : com.googlesource.gerrit.plugins.uploadvalidator.FileExtensionValidatorTest.BLOCKED_EXTENSIONS_UC ) { expected.add ( ( "ERROR: blocked file: foo." + extension ) ) ; } com.google.common.truth.Truth.assertThat ( com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.transformMessages ( m ) ) . containsExactlyElementsIn ( expected ) ; }
public void doPost ( final javax.servlet.http.HttpServletRequest req , final javax.servlet.http.HttpServletResponse rsp ) throws java.io.IOException { try { doAuth ( req , rsp ) ; } catch ( java.lang.Exception e ) { getServletContext ( ) . log ( "Unexpected error during authentication" , e ) ; finishLogin ( rsp , false ) ; } }
public boolean isVisible ( ) { return ( ( ( ( ( user ) instanceof com.google.gerrit.server.InternalUser ) || ( user.memberOf ( group.getGroupUUID ( ) ) ) ) || ( isOwner ( ) ) ) || ( user.getCapabilities ( ) . canAdministrateServer ( ) ) ) || ( groupBackend.isVisibleToAll ( group.getGroupUUID ( ) ) ) ; }
public void onSuccess ( com.googlesource.gerrit.plugins.verifystatus.client.ConfigInfo info ) { if ( info.showJobsSummaryPanel ( ) ) { com.google.gerrit.plugin.client.Plugin.get ( ) . panel ( GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK , new com.googlesource.gerrit.plugins.verifystatus.client.JobsSummaryPanel.Factory ( ) ) ; } if ( info.showJobsPanel ( ) ) { com.google.gerrit.plugin.client.Plugin.get ( ) . panel ( GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK , new com.googlesource.gerrit.plugins.verifystatus.client.JobsPanel.Factory ( ) ) ; } if ( info.showJobsDropDownPanel ( ) ) { com.google.gerrit.plugin.client.Plugin.get ( ) . panel ( GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS , new com.googlesource.gerrit.plugins.verifystatus.client.JobsDropDownPanel.Factory ( ) ) ; } }
public com.google.gerrit.reviewdb.client.AccountGroup missing ( final com.google.gerrit.reviewdb.client.AccountGroup.Id key ) { final com.google.gerrit.reviewdb.client.AccountGroup.NameKey name = new com.google.gerrit.reviewdb.client.AccountGroup.NameKey ( ( "Deleted Group" + ( key.toString ( ) ) ) ) ; final com.google.gerrit.reviewdb.client.AccountGroup g = new com.google.gerrit.reviewdb.client.AccountGroup ( name , key , null ) ; g.setType ( AccountGroup.Type.SYSTEM ) ; return g ; }
public static void doSignOut ( ) { com.google.gerrit.client.Gerrit.myAccount = null ; com.google.gwt.user.client.Cookies.removeCookie ( com.google.gerrit.client.Gerrit.ACCOUNT_COOKIE ) ; com.google.gwt.user.client.Cookies.removeCookie ( com.google.gerrit.client.Gerrit.OPENIDUSER_COOKIE ) ; for ( final com.google.gerrit.client.SignedInListener l : com.google.gerrit.client.Gerrit.signedInListeners ) { l.onSignOut ( ) ; } com.google.gerrit.client.Gerrit.refreshMenuBar ( ) ; if ( ( ( com.google.gerrit.client.Gerrit.currentScreen ) != null ) && ( com.google.gerrit.client.Gerrit.currentScreen.isRequiresSignIn ( ) ) ) { com.google.gwt.user.client.History.newItem ( Link.ALL ) ; } }
public void conflictingChanges ( ) throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result change = createChange ( git , true ) ; com.google.gerrit.acceptance.PushOneCommit.Result conflictingChange1 = createChange ( git , true ) ; com.google.gerrit.acceptance.PushOneCommit.Result conflictingChange2 = createChange ( git , true ) ; createChange ( git , false ) ; java.util.Set < java.lang.String > changes = queryConflictingChanges ( change ) ; assertChanges ( changes , conflictingChange1 , conflictingChange2 ) ; }
public void commentOnReviewableChangeByReviewer ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS ) ; setApiUser ( sc.reviewer ) ; review ( sc.changeId , com.google.gerrit.extensions.client.GeneralPreferencesInfo.EmailStrategy.ENABLED ) ; assertThat ( sender ) . sent ( "comment" , sc ) . notTo ( sc.reviewer ) . to ( sc.owner ) . to ( sc.reviewerByEmail ) . cc ( sc.ccer ) . cc ( sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS ) ; }
public boolean canEditTopicName ( ) { if ( getChange ( ) . getStatus ( ) . isOpen ( ) ) { return ( ( ( ( isOwner ( ) ) || ( getRefControl ( ) . isOwner ( ) ) ) || ( getProjectControl ( ) . isOwner ( ) ) ) || ( getUser ( ) . getCapabilities ( ) . canAdministrateServer ( ) ) ) || ( getRefControl ( ) . canEditTopicName ( ) ) ; } return getRefControl ( ) . canForceEditTopicName ( ) ; }
private static java.lang.Class < ? > scanObjectOrClass ( java.lang.Object element ) { if ( java.lang.Class.class . isAssignableFrom ( element.getClass ( ) ) ) { return ( ( java.lang.Class < ? > ) ( element ) ) ; } else { return element.getClass ( ) ; } }
private void addDiffChunkAndPadding ( net.codemirror.lib.CodeMirror cmToPad , int lineToPad , int lineOnOther , int chunkSize , boolean edit ) { net.codemirror.lib.CodeMirror otherCm = otherCm ( cmToPad ) ; linePaddingOnOtherSideMap.put ( otherCm.getLineHandle ( lineOnOther ) , new com.google.gerrit.client.diff.PaddingManager.LinePaddingWidgetWrapper ( addPaddingWidget ( cmToPad , DiffTable.style.padding ( ) , lineToPad , 0 , Unit.EM , null ) , lineToPad , chunkSize ) ) ; diffChunks.add ( new com.google.gerrit.client.diff.DiffChunkInfo ( getSideFromCm ( otherCm ) , ( ( lineOnOther - chunkSize ) + 1 ) , lineOnOther , edit ) ) ; }
private static org.eclipse.jgit.lib.ObjectId emptyTree ( final org.eclipse.jgit.lib.Repository repo ) throws java.io.IOException { org.eclipse.jgit.lib.ObjectInserter oi = repo.newObjectInserter ( ) ; org.eclipse.jgit.lib.ObjectId id = oi.insert ( Constants.OBJ_TREE , new byte [ ] { } ) ; oi.flush ( ) ; return id ; HEAD ( 14422 ) ; com.google.gerrit.server.patch.a Update ; com.google.gerrit.server.patch.plugin to ; com.google.gerrit.server.patch.latest revision ; }
private void updateChange ( java.lang.String changeId , com.google.gerrit.extensions.client.ChangeKind changeKind ) throws java.lang.Exception { switch ( changeKind ) { case com.google.gerrit.extensions.client.ChangeKind.NO_CODE_CHANGE : noCodeChange ( changeId ) ; return ; case com.google.gerrit.extensions.client.ChangeKind.REWORK : rework ( changeId ) ; return ; case com.google.gerrit.extensions.client.ChangeKind.TRIVIAL_REBASE : trivialRebase ( changeId ) ; return ; case com.google.gerrit.extensions.client.ChangeKind.MERGE_FIRST_PARENT_UPDATE : updateFirstParent ( changeId ) ; return ; case com.google.gerrit.extensions.client.ChangeKind.NO_CHANGE : noChange ( changeId ) ; return ; default : org.junit.Assert.fail ( ( "unexpected change kind: " + changeKind ) ) ; } }
public void run ( ) { if ( prefs.renderEntireFile ( ) ) { return ; } net.codemirror.lib.CodeMirror.Viewport fromTo = cm.getViewport ( ) ; int size = ( ( fromTo.getTo ( ) ) - ( fromTo.getFrom ( ) ) ) + 1 ; if ( ( cm.getOldViewportSize ( ) ) == size ) { return ; } cm.setOldViewportSize ( size ) ; diffTable.sidePanel.adjustGutters ( cmB ) ; }
private static org.bouncycastle.openpgp.PGPPublicKeyRingCollection readPubRing ( final java.io.File pub ) { try ( java.io.InputStream fin = new java.io.FileInputStream ( pub ) ; java.io.InputStream in = org.bouncycastle.openpgp.PGPUtil.getDecoderStream ( fin ) ) { return new org.bouncycastle.openpgp.PGPPublicKeyRingCollection ( in ) ; } catch ( java.io.IOException e ) { throw new com.google.inject.ProvisionException ( ( "Cannot read " + pub ) , e ) ; } catch ( org.bouncycastle.openpgp.PGPException e ) { throw new com.google.inject.ProvisionException ( ( "Cannot read " + pub ) , e ) ; } }
protected java.util.List < org.eclipse.jgit.revwalk.RevCommit > getRemoteLog ( ) throws java.io.IOException { org.eclipse.jgit.lib.Repository repo = repoManager.openRepository ( project ) ; try { org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk ( repo ) ; try { rw.markStart ( rw.parseCommit ( repo.getRef ( "refs/heads/master" ) . getObjectId ( ) ) ) ; return com.google.common.collect.Lists.newArrayList ( rw ) ; } finally { rw.release ( ) ; } } finally { repo.close ( ) ; } }
public com.google.gerrit.pgm.init.api.AllProjectsConfig load ( ) throws java.io.IOException , org.eclipse.jgit.errors.ConfigInvalidException { java.io.File path = getPath ( ) ; if ( path != null ) { org.eclipse.jgit.lib.Repository repo = new org.eclipse.jgit.internal.storage.file.FileRepository ( path ) ; try { load ( repo ) ; } finally { repo.close ( ) ; } } return this ; }
private com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.AccessToken newAccessTokenFromUser ( java.lang.String username ) { com.google.gerrit.server.account.AccountState account = accountCache.getByUsername ( username ) ; java.util.Collection < com.google.gerrit.server.account.externalids.ExternalId > externalIds = account.getExternalIds ( ) ; for ( com.google.gerrit.server.account.externalids.ExternalId accountExternalId : externalIds ) { java.lang.String key = accountExternalId.asAccountExternalId ( ) . getKey ( ) . get ( ) ; if ( key.startsWith ( com.googlesource.gerrit.plugins.github.oauth.IdentifiedUserGitHubLoginProvider.EXTERNAL_ID_PREFIX ) ) { return new com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.AccessToken ( key.substring ( com.googlesource.gerrit.plugins.github.oauth.IdentifiedUserGitHubLoginProvider.EXTERNAL_ID_PREFIX.length ( ) ) ) ; } } return null ; }
public boolean equals ( final java.lang.Object other ) { if ( ( getClass ( ) ) == ( other.getClass ( ) ) ) { final com.google.gerrit.server.query.VariablePredicate < ? > v = ( ( com.google.gerrit.server.query.VariablePredicate < ? > ) ( other ) ) ; return ( getName ( ) . equals ( v.getName ( ) ) ) && ( getChildren ( ) . equals ( v.getChildren ( ) ) ) ; } return false ; }
