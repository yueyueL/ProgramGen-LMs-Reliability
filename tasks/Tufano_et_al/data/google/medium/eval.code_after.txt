public com.google.gwtjsonrpc.client.VoidResult run ( final com.google.gerrit.reviewdb.ReviewDb db ) throws com.google.gerrit.httpd.rpc.account.Failure , com.google.gwtorm.client.OrmException { final com.google.gerrit.reviewdb.AccountGroup group = db.accountGroups ( ) . get ( groupId ) ; assertAmGroupOwner ( db , group ) ; group.setExternalNameKey ( bindTo ) ; db.accountGroups ( ) . update ( java.util.Collections.singleton ( group ) ) ; groupCache.evict ( group ) ; return com.google.gwtjsonrpc.client.VoidResult.INSTANCE ; }
public void onSuccess ( com.google.gwt.core.client.JsArray < com.google.gerrit.client.info.AccountInfo > in ) { java.util.List < com.google.gerrit.client.ui.AccountSuggestOracle.AccountSuggestion > r = new java.util.ArrayList ( in.length ( ) ) ; for ( com.google.gerrit.client.info.AccountInfo p : com.google.gerrit.client.rpc.Natives.asList ( in ) ) { r.add ( new com.google.gerrit.client.ui.AccountSuggestOracle.AccountSuggestion ( p ) ) ; } cb.onSuggestionsReady ( req , new com.google.gerrit.client.ui.Response ( r ) ) ; }
public void show ( ) throws java.lang.Exception { assertGone ( com.google.gitiles.GitwebRedirectFilterTest.newRequest ( "a=commit" ) ) ; assertGone ( com.google.gitiles.GitwebRedirectFilterTest.newRequest ( "a=commit;p=test" ) ) ; org.eclipse.jgit.revwalk.RevCommit commit = repo.branch ( "refs/heads/master" ) . commit ( ) . create ( ) ; assertRedirectsTo ( com.google.gitiles.GitilesView.revision ( ) . setHostName ( com.google.gitiles.TestGitilesUrls.HOST_NAME ) . setServletPath ( com.google.gitiles.FakeHttpServletRequest.SERVLET_PATH ) . setRepositoryName ( "test" ) . setRevision ( commit ) . toUrl ( ) , com.google.gitiles.GitwebRedirectFilterTest.newRequest ( ( "a=commit;p=test&h=" + ( org.eclipse.jgit.lib.ObjectId.toString ( commit ) ) ) ) ) ; }
public com.google.gerrit.extensions.common.RevisionInfo addRevisionActions ( @ com.google.gerrit.common.Nullable com.google.gerrit.extensions.common.ChangeInfo changeInfo , com.google.gerrit.extensions.common.RevisionInfo to , com.google.gerrit.server.change.RevisionResource rsrc ) throws com.google.gwtorm.server.OrmException { java.util.List < com.google.gerrit.extensions.api.changes.ActionVisitor > visitors = visitors ( ) ; if ( ! ( visitors.isEmpty ( ) ) ) { if ( changeInfo != null ) { changeInfo = copy ( visitors , changeInfo ) ; } else { changeInfo = changeJson ( ) . format ( rsrc ) ; } } to.actions = toActionMap ( rsrc , visitors , changeInfo , copy ( visitors , to ) ) ; return to ; }
private void loadCommit ( final com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev , com.google.gerrit.client.rpc.CallbackGroup group ) { if ( rev.isEdit ( ) ) { return ; } com.google.gerrit.client.changes.ChangeApi.commitWithLinks ( changeId.get ( ) , rev.name ( ) , group.add ( new com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.client.info.ChangeInfo.CommitInfo > ( ) { @ java.lang.Override public void onSuccess ( com.google.gerrit.client.info.ChangeInfo.CommitInfo info ) { rev.setCommit ( info ) ; } @ java.lang.Override public void onFailure ( java.lang.Throwable caught ) { } } ) ) ; }
private Change.Id insertPatchSet ( org.eclipse.jgit.lib.Repository git , org.eclipse.jgit.revwalk.RevWalk revWalk , com.google.gerrit.reviewdb.client.Change change , com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId , org.eclipse.jgit.revwalk.RevCommit cherryPickCommit , com.google.gerrit.server.project.RefControl refControl ) throws com.google.gerrit.server.project.InvalidChangeOperationException , com.google.gerrit.server.project.NoSuchChangeException , com.google.gwtorm.server.OrmException , java.io.IOException { patchSetInserterFactory.create ( git , revWalk , refControl , currentUser , change , cherryPickCommit ) . setMessage ( buildChangeMessage ( patchSetId , change ) ) . insert ( ) ; return change.getId ( ) ; }
public com.google.common.util.concurrent.ListenableFuture < ? > index ( com.google.gerrit.reviewdb.client.Change change , com.google.gerrit.server.util.RequestScopePropagator prop ) { java.util.concurrent.Callable < ? > task = new com.google.gerrit.server.index.ChangeIndexerImpl.Task ( change ) ; if ( prop != null ) { task = prop.wrap ( task ) ; } return executor.submit ( task ) ; }
private java.nio.file.Path polyGerritBasePath ( ) { com.google.gerrit.httpd.raw.StaticModule.Paths p = getPaths ( ) ; if ( options.forcePolyGerritDev ( ) ) { com.google.common.base.Preconditions.checkArgument ( ( ( p.buckOut ) != null ) , "no buck-out directory found for PolyGerrit developer mode" ) ; } return isDev ( ) ? p.buckOut.getParent ( ) . resolve ( "polygerrit-ui" ) . resolve ( "app" ) : p.warFs.getPath ( "/polygerrit_ui" ) ; }
private java.lang.String extractWhat ( com.google.gerrit.sshd.DispatchCommand dcmd ) { java.lang.String commandName = dcmd.getCommandName ( ) ; java.lang.String [ ] args = dcmd.getArguments ( ) ; if ( ( args.length ) > 1 ) { return ( commandName + "." ) + ( args [ 1 ] ) ; } else { return commandName ; } }
private java.lang.String parseOneFooter ( com.google.gerrit.server.notedb.ChangeNotesCommit commit , org.eclipse.jgit.revwalk.FooterKey footerKey ) throws org.eclipse.jgit.errors.ConfigInvalidException { java.util.List < java.lang.String > footerLines = commit.getFooterLineValues ( footerKey ) ; if ( footerLines.isEmpty ( ) ) { return null ; } else if ( ( footerLines.size ( ) ) > 1 ) { throw expectedOneFooter ( footerKey , footerLines ) ; } return footerLines.get ( 0 ) ; }
public static java.util.Optional < java.util.TimeZone > getTimeZone ( org.eclipse.jgit.lib.Config config , java.lang.String section , java.lang.String subsection , java.lang.String name ) { java.lang.String id = config.getString ( section , subsection , name ) ; return id != null ? java.util.Optional.of ( java.util.TimeZone.getTimeZone ( id ) ) : java.util.Optional.empty ( ) ; }
protected java.util.List < com.google.gerrit.extensions.common.ChangeInfo > assertQuery ( com.google.gerrit.extensions.api.changes.Changes.QueryRequest query , com.google.gerrit.reviewdb.client.Change ... changes ) throws java.lang.Exception { java.util.List < com.google.gerrit.extensions.common.ChangeInfo > result = query.get ( ) ; java.lang.Iterable < java.lang.Integer > ids = com.google.gerrit.server.query.change.AbstractQueryChangesTest.ids ( result ) ; com.google.common.truth.Truth.assertThat ( ids ) . named ( ids.toString ( ) ) . containsExactlyElementsIn ( com.google.gerrit.server.query.change.AbstractQueryChangesTest.ids ( changes ) ) . inOrder ( ) ; return result ; }
public void patchScript ( final com.google.gerrit.client.reviewdb.Patch.Key patchKey , final com.google.gerrit.client.reviewdb.PatchSet.Id psa , final com.google.gerrit.client.reviewdb.PatchSet.Id psb , final com.google.gerrit.client.data.PatchScriptSettings s , final com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.client.data.PatchScript > callback ) { if ( psb == null ) { callback.onFailure ( new com.google.gerrit.client.rpc.NoSuchEntityException ( ) ) ; return ; } run ( callback , new com.google.gerrit.server.patch.PatchScriptAction ( server , registry , diffCache , patchKey , psa , psb , s ) ) ; }
private java.util.Map < java.lang.String , org.eclipse.jgit.lib.Ref > visibleTags ( com.google.gerrit.server.project.ProjectControl pctl , org.eclipse.jgit.lib.Repository repo , java.util.Map < java.lang.String , org.eclipse.jgit.lib.Ref > tags ) { return refFilterFactory.create ( pctl.getProjectState ( ) , repo ) . setShowMetadata ( false ) . filter ( tags , true ) ; }
public com.google.gerrit.server.config.GetServerInfo.ServerInfo apply ( com.google.gerrit.server.config.ConfigResource rsrc ) throws java.net.MalformedURLException { com.google.gerrit.server.config.GetServerInfo.ServerInfo info = new com.google.gerrit.server.config.GetServerInfo.ServerInfo ( ) ; info.auth = getAuthInfo ( authConfig , realm ) ; info.change = getChangeInfo ( config ) ; info.contactStore = getContactStoreInfo ( ) ; info.download = getDownloadInfo ( downloadSchemes , downloadCommands , archiveFormats ) ; info.gerrit = getGerritInfo ( config , allProjectsName , allUsersName ) ; info.gitWeb = getGitWebInfo ( gitWebConfig ) ; info.suggest = getSuggestInfo ( config ) ; info.user = getUserInfo ( anonymousCowardName ) ; return info ; }
public java.lang.String getComment ( java.lang.String projectName , java.lang.String commitId ) throws java.io.IOException { return commitMessageFetcher.fetch ( projectName , commitId ) ; }
public static void query ( com.google.gwtjsonrpc.common.AsyncCallback < com.google.gerrit.client.rpc.NativeList < com.google.gerrit.client.changes.ChangeList > > callback , java.lang.String ... queries ) { assert ( queries.length ) >= 2 ; com.google.gerrit.client.rpc.RestApi call = new com.google.gerrit.client.rpc.RestApi ( com.google.gerrit.client.changes.ChangeList.URI ) ; for ( java.lang.String q : queries ) { call.addParameterRaw ( "q" , com.google.gwtorm.client.KeyUtil.encode ( q ) ) ; } call.send ( callback ) ; }
public void add ( final com.google.gerrit.client.reviewdb.PatchSetApproval ca ) { approvals.add ( ca ) ; final java.sql.Timestamp g = ca.getGranted ( ) ; if ( ( g != null ) && ( ( g.compareTo ( sortOrder ) ) < 0 ) ) { sortOrder = g ; } if ( ( ca.getValue ( ) ) != 0 ) { hasNonZero = 1 ; } }
private java.lang.String configurationToString ( ) { java.lang.StringBuilder b = new java.lang.StringBuilder ( ) ; b.append ( ( ( "Supermanifest config (" + ( config.size ( ) ) ) + ") {\n" ) ) ; for ( com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.ConfigEntry c : config ) { b.append ( " " ) ; b.append ( c.toString ( ) ) ; b.append ( "\n" ) ; } b.append ( "}\n" ) ; return b.toString ( ) ; }
protected void configureServlets ( ) { install ( new com.google.gerrit.server.config.FactoryModule ( ) { @ java.lang.Override protected void configure ( ) { factory ( PatchScriptFactory.Factory.class ) ; factory ( SaveDraft.Factory.class ) ; } } ) ; bind ( com.google.gerrit.httpd.rpc.patch.PatchScriptBuilder.class ) ; rpc ( com.google.gerrit.httpd.rpc.patch.PatchDetailServiceImpl.class ) ; }
public void serverConfigWithPlugin ( ) throws java.lang.Exception { java.nio.file.Path plugins = tempSiteDir.newFolder ( "plugins" ) . toPath ( ) ; java.nio.file.Path jsplugin = plugins.resolve ( "js-plugin-1.js" ) ; java.nio.file.Files.write ( jsplugin , "Gerrit.install(function(self){});\n" . getBytes ( java.nio.charset.StandardCharsets.UTF_8 ) ) ; adminSshSession.exec ( "gerrit plugin reload" ) ; com.google.gerrit.acceptance.RestResponse r = adminRestSession.get ( "/config/server/info/" ) ; com.google.gerrit.server.config.GetServerInfo.ServerInfo i = newGson ( ) . fromJson ( r.getReader ( ) , com.google.gerrit.server.config.GetServerInfo.ServerInfo.class ) ; com.google.common.truth.Truth.assertThat ( i.plugin.jsResourcePaths ) . hasSize ( 1 ) ; }
private com.google.gerrit.server.notedb.ChangeUpdate newUpdate ( com.google.gerrit.reviewdb.client.Change c , com.google.gerrit.server.IdentifiedUser user ) throws java.lang.Exception { return com.google.gerrit.testutil.TestChanges.newUpdate ( injector , repoManager , c , user ) ; }
public void parseAuthor ( ) throws java.lang.Exception { assertParseSucceeds ( ( "Update change\n" + ( ( ( ( "\n" + "Branch: refs/heads/master\n" ) + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" ) + "Patch-set: 1\n" ) + "Subject: This is a test change\n" ) ) ) ; assertParseFails ( writeCommit ( ( "Update change\n" + ( "\n" + "Patch-set: 1\n" ) ) , new org.eclipse.jgit.lib.PersonIdent ( "Change Owner" , "owner@example.com" , serverIdent.getWhen ( ) , serverIdent.getTimeZone ( ) ) ) ) ; assertParseFails ( writeCommit ( ( "Update change\n" + ( "\n" + "Patch-set: 1\n" ) ) , new org.eclipse.jgit.lib.PersonIdent ( "Change Owner" , "x@gerrit" , serverIdent.getWhen ( ) , serverIdent.getTimeZone ( ) ) ) ) ; assertParseFails ( writeCommit ( ( "Update change\n" + ( "\n" + "Patch-set: 1\n" ) ) , new org.eclipse.jgit.lib.PersonIdent ( "Change\nሴ<Owner>" , "\n\nx<@>gerrit" , serverIdent.getWhen ( ) , serverIdent.getTimeZone ( ) ) ) ) ; }
public void onDialogVisible ( com.google.gwtexpui.user.client.DialogVisibleEvent event ) { diffTable.getElement ( ) . getStyle ( ) . setVisibility ( ( event.isVisible ( ) ? Style.Visibility.HIDDEN : Style.Visibility.VISIBLE ) ) ; }
private java.nio.file.Path getSiteFromReviewDb ( java.sql.Connection conn ) { try ( java.sql.Statement stmt = conn.createStatement ( ) ; java.sql.ResultSet rs = stmt.executeQuery ( "SELECT site_path FROM system_config" ) ) { if ( rs.next ( ) ) { return java.nio.file.Paths.get ( rs.getString ( 1 ) ) ; } } catch ( java.sql.SQLException e ) { return null ; } return null ; }
private void setReviewed ( com.google.gerrit.client.diff.FileInfo info , boolean r ) { com.google.gerrit.client.rpc.RestApi api = com.google.gerrit.client.changes.ChangeApi.revision ( curr ) . view ( "files" ) . id ( info.path ( ) ) . view ( "reviewed" ) ; if ( r ) { api.put ( com.google.gerrit.client.rpc.CallbackGroup.< com.google.gerrit.client.changes.ReviewInfo > emptyCallback ( ) ) ; } else { api.delete ( com.google.gerrit.client.rpc.CallbackGroup.< com.google.gerrit.client.changes.ReviewInfo > emptyCallback ( ) ) ; } }
public java.lang.Void call ( ) throws java.lang.Exception { int rc = daemon.main ( new java.lang.String [ ] { "-d" , site.getPath ( ) , "--headless" } ) ; if ( rc != 0 ) { java.lang.System.out.println ( ( ( "Failed to start Gerrit daemon. Check " + ( site.getPath ( ) ) ) + "/logs/error_log" ) ) ; serverStarted.reset ( ) ; } return null ; }
private void padLineNumberForSideB ( final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder m ) { m.openTd ( ) ; m.setStyleName ( Gerrit.RESOURCES.css ( ) . lineNumber ( ) ) ; m.closeTd ( ) ; }
public void newPatchSetOnReviewableWipChange ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableWipChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.NEW_PATCHSETS ) ; pushTo ( sc , "refs/for/master%wip" , sc.owner ) ; assertThat ( sender ) . notSent ( ) ; }
void onSave ( @ java.lang.SuppressWarnings ( value = "unused" ) com.google.gwt.event.dom.client.ClickEvent e ) { com.google.gerrit.client.changes.ChangeEditApi.put ( id.getParentKey ( ) . get ( ) , file.getText ( ) , content.getText ( ) , new com.google.gerrit.client.rpc.GerritCallback < com.google.gerrit.client.VoidResult > ( ) { @ java.lang.Override public void onSuccess ( com.google.gerrit.client.VoidResult result ) { com.google.gerrit.client.Gerrit.display ( com.google.gerrit.common.PageLinks.toChangeInEditMode ( id.getParentKey ( ) ) ) ; hide ( ) ; } } ) ; }
protected void initName ( final java.lang.String fieldName , final com.google.gwtorm.client.Column col ) throws com.google.gwtorm.client.OrmException { if ( col == null ) { throw new com.google.gwtorm.client.OrmException ( ( ( ( ( "Field " + fieldName ) + " is missing " ) + ( com.google.gwtorm.client.Column.class . getName ( ) ) ) + " annotation" ) ) ; } column = col ; origName = com.google.gwtorm.schema.Util.any ( column.name ( ) , com.google.gwtorm.schema.Util.makeSqlFriendly ( fieldName ) ) ; columnName = origName ; }
private static synchronized com.google.gerrit.git.WorkQueue.Executor getPool ( final boolean autoStart ) { if ( autoStart && ( ( com.google.gerrit.git.WorkQueue.pool ) == null ) ) { com.google.gerrit.git.WorkQueue.pool = new com.google.gerrit.git.WorkQueue.Executor ( 1 ) ; com.google.gerrit.git.WorkQueue.pool.setKeepAliveTime ( 60 , java.util.concurrent.TimeUnit.SECONDS ) ; com.google.gerrit.git.WorkQueue.pool.setMaximumPoolSize ( 5 ) ; } return com.google.gerrit.git.WorkQueue.pool ; }
private java.util.Map < org.eclipse.jgit.lib.ObjectId , org.eclipse.jgit.lib.Ref > changeRefsById ( ) throws java.io.IOException { if ( ( refsById ) == null ) { refsById = new java.util.HashMap < org.eclipse.jgit.lib.ObjectId , org.eclipse.jgit.lib.Ref > ( ) ; for ( org.eclipse.jgit.lib.Ref r : repo.getRefDatabase ( ) . getRefs ( "refs/changes/" ) . values ( ) ) { if ( com.google.gerrit.reviewdb.PatchSet.isRef ( r.getName ( ) ) ) { refsById.put ( r.getObjectId ( ) , r ) ; } } } return refsById ; }
public static com.google.gerrit.client.changes.CommentInfo create ( java.lang.String path , com.google.gerrit.extensions.client.Side side , int line , com.google.gerrit.client.diff.CommentRange range ) { com.google.gerrit.client.changes.CommentInfo n = createObject ( ) . cast ( ) ; n.path ( path ) ; n.side ( side ) ; if ( range != null ) { n.line ( range.end_line ( ) ) ; n.range ( range ) ; } else if ( line > 0 ) { n.line ( line ) ; } return n ; }
public com.google.gerrit.server.account.CapabilityCollection getCapabilityCollection ( ) { return capabilities ; }
private void stopRemovedPlugins ( java.util.List < java.io.File > jars ) { java.util.Set < java.lang.String > unload = com.google.common.collect.Sets.newHashSet ( running.keySet ( ) ) ; for ( java.io.File jar : jars ) { if ( ! ( jar.getName ( ) . endsWith ( ".disabled" ) ) ) { unload.remove ( com.google.gerrit.server.plugins.PluginLoader.nameOf ( jar ) ) ; } } for ( java.lang.String name : unload ) { com.google.gerrit.server.plugins.PluginLoader.log.info ( java.lang.String.format ( "Unloading plugin %s" , name ) ) ; running.remove ( name ) . stop ( ) ; } }
public void allRefsVisibleNoRefsMetaConfig ( ) throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet ( project ) . getConfig ( ) ; com.google.gerrit.server.project.Util.allow ( cfg , Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS , "refs/*" ) ; com.google.gerrit.server.project.Util.allow ( cfg , Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.PROJECT_OWNERS , "refs/meta/config" ) ; com.google.gerrit.server.project.Util.doNotInherit ( cfg , Permission.READ , "refs/meta/config" ) ; saveProjectConfig ( project , cfg ) ; assertRefs ( "HEAD" , "refs/changes/01/1/1" , "refs/changes/02/2/1" , "refs/heads/branch" , "refs/heads/master" ) ; }
private com.google.gerrit.server.change.ChangeJson.ChangeInfo format ( com.google.gerrit.server.query.change.ChangeData cd , com.google.common.base.Optional < com.google.gerrit.reviewdb.client.PatchSet.Id > limitToPsId ) throws com.google.gwtorm.server.OrmException { accountLoader = accountLoaderFactory.create ( has ( com.google.gerrit.common.changes.ListChangesOption.DETAILED_ACCOUNTS ) ) ; com.google.gerrit.server.change.ChangeJson.ChangeInfo res = toChangeInfo ( cd , limitToPsId ) ; accountLoader.fill ( ) ; return res ; }
protected void doDelete ( javax.servlet.http.HttpServletRequest req , javax.servlet.http.HttpServletResponse rsp ) { if ( ! ( currentUserProvider.get ( ) . getCapabilities ( ) . canAdministrateServer ( ) ) ) { sendError ( rsp , javax.servlet.http.HttpServletResponse.SC_FORBIDDEN ) ; return ; } this . healthy = false ; rsp.setStatus ( javax.servlet.http.HttpServletResponse.SC_NO_CONTENT ) ; }
private java.util.Set < com.google.gerrit.reviewdb.client.Project.NameKey > parents ( ) { java.util.Set < com.google.gerrit.reviewdb.client.Project.NameKey > parents = new java.util.HashSet < > ( ) ; for ( com.google.gerrit.reviewdb.client.Project.NameKey p : projectCache.all ( ) ) { com.google.gerrit.server.project.ProjectState ps = projectCache.get ( p ) ; if ( ps != null ) { com.google.gerrit.reviewdb.client.Project.NameKey parent = ps.getProject ( ) . getParent ( ) ; if ( parent != null ) { parents.add ( parent ) ; } } } parents.add ( allProjects ) ; return parents ; }
private void assertAdminsAreOwnersAndDevsAreNot ( ) { com.google.gerrit.server.project.ProjectControl uBlah = user ( local , com.google.gerrit.server.project.testing.Util.DEVS ) ; com.google.gerrit.server.project.ProjectControl uAdmin = user ( local , com.google.gerrit.server.project.testing.Util.DEVS , com.google.gerrit.server.project.testing.Util.ADMIN ) ; com.google.common.truth.Truth.assertThat ( uBlah.isOwner ( ) ) . named ( "not owner" ) . isFalse ( ) ; com.google.common.truth.Truth.assertThat ( uAdmin.isOwner ( ) ) . named ( "is owner" ) . isTrue ( ) ; }
public void newPatchSetByOtherOnReviewableChangeOwnerSelfCcNotifyOwner ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.NEW_PATCHSETS ) ; pushTo ( sc , "refs/for/master%notify=OWNER" , other , EmailStrategy.CC_ON_OWN_COMMENTS ) ; assertThat ( sender ) . notSent ( ) ; }
private static org.apache.lucene.store.Directory dir ( com.google.gerrit.index.Schema < com.google.gerrit.server.project.ProjectData > schema , org.eclipse.jgit.lib.Config cfg , com.google.gerrit.server.config.SitePaths sitePaths ) throws java.io.IOException { if ( com.google.gerrit.lucene.LuceneIndexModule.isInMemoryTest ( cfg ) ) { return new org.apache.lucene.store.RAMDirectory ( ) ; } java.nio.file.Path indexDir = com.google.gerrit.lucene.LuceneVersionManager.getDir ( sitePaths , com.google.gerrit.lucene.LuceneProjectIndex.PROJECTS , schema ) ; return org.apache.lucene.store.FSDirectory.open ( indexDir ) ; }
public java.lang.String toString ( ) { return ( ( ( ( ( ( ( ( ( ( ( ( ( ( "ChangeMessage{" + "key=" ) + ( key ) ) + ", author=" ) + ( author ) ) + ", realAuthor=" ) + ( realAuthor ) ) + ", writtenOn=" ) + ( writtenOn ) ) + ", patchset=" ) + ( patchset ) ) + ", tag=" ) + ( tag ) ) + ", message=[" ) + ( message ) ) + "]}" ; }
public void indexChange ( ) throws java.lang.Exception { java.lang.String changeId = createChange ( ) . getChangeId ( ) ; adminSession.post ( ( ( "/changes/" + changeId ) + "/index/" ) ) . assertNoContent ( ) ; }
public java.lang.Boolean call ( ) throws java.lang.Exception { return ( client ( ) . getBug ( bugId ) ) != null ; }
public com.google.gerrit.extensions.common.ChangeInfo format ( com.google.gerrit.reviewdb.client.Change.Id id ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change c ; try { c = db.get ( ) . changes ( ) . get ( id ) ; } catch ( com.google.gwtorm.server.OrmException e ) { if ( ! ( has ( com.google.gerrit.extensions.client.ListChangesOption.CHECK ) ) ) { throw e ; } return checkOnly ( changeDataFactory.create ( db.get ( ) , id ) ) ; } return format ( changeDataFactory.create ( db.get ( ) , c ) ) ; }
public void afterUpdateRepos ( ) throws com.google.gerrit.extensions.restapi.ResourceConflictException { try { markCleanMerges ( ) ; java.util.List < com.google.gerrit.reviewdb.client.Change.Id > alreadyMerged = checkCommitStatus ( ) ; findUnmergedChanges ( alreadyMerged ) ; } catch ( com.google.gerrit.server.submit.IntegrationException e ) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException ( e.getMessage ( ) , e ) ; } }
public com.google.gerrit.extensions.common.PushCertificateInfo checkPushCertificate ( java.lang.String certStr , com.google.gerrit.server.IdentifiedUser expectedUser ) throws com.google.gerrit.server.GpgException { try { org.eclipse.jgit.transport.PushCertificate cert = org.eclipse.jgit.transport.PushCertificateParser.fromString ( certStr ) ; com.google.gerrit.gpg.PushCertificateChecker.Result result = pushCertCheckerFactory.create ( expectedUser ) . setCheckNonce ( false ) . check ( cert ) ; com.google.gerrit.extensions.common.PushCertificateInfo info = new com.google.gerrit.extensions.common.PushCertificateInfo ( ) ; info.certificate = certStr ; info.key = com.google.gerrit.gpg.server.GpgKeys.toJson ( result.getPublicKey ( ) , result.getCheckResult ( ) ) ; return info ; } catch ( java.io.IOException e ) { throw new com.google.gerrit.server.GpgException ( e ) ; } }
public synchronized javax.servlet.ServletOutputStream getOutputStream ( ) { com.google.common.base.Preconditions.checkState ( ( ( writer ) == null ) , "getWriter() already called" ) ; if ( ( outputStream ) == null ) { final java.io.PrintWriter osWriter = new java.io.PrintWriter ( actualBody ) ; outputStream = new javax.servlet.ServletOutputStream ( ) { @ java.lang.Override public void write ( int c ) throws java.io.IOException { osWriter.write ( c ) ; osWriter.flush ( ) ; } } ; } return outputStream ; }
public synchronized < F1 , F2 > com.google.gerrit.metrics.Counter2 < F1 , F2 > newCounter ( java.lang.String name , com.google.gerrit.metrics.Description desc , com.google.gerrit.metrics.Field < F1 > field1 , com.google.gerrit.metrics.Field < F2 > field2 ) { com.google.gerrit.metrics.dropwizard.DropWizardMetricMaker.checkCounterDescription ( desc ) ; com.google.gerrit.metrics.dropwizard.CounterImplN m = new com.google.gerrit.metrics.dropwizard.CounterImplN ( this , name , desc , field1 , field2 ) ; define ( name , desc ) ; bucketed.put ( name , m ) ; return m.counter2 ( ) ; }
public static < T > void setOf ( com.google.inject.Binder binder , com.google.inject.TypeLiteral < T > member ) { @ java.lang.SuppressWarnings ( value = "unchecked" ) com.google.inject.Key < com.google.gerrit.extensions.registration.DynamicSet < T > > key = ( ( com.google.inject.Key < com.google.gerrit.extensions.registration.DynamicSet < T > > ) ( com.google.inject.Key.get ( com.google.inject.util.Types.newParameterizedType ( com.google.gerrit.extensions.registration.DynamicSet.class , member.getType ( ) ) ) ) ) ; binder.disableCircularProxies ( ) ; binder.bind ( key ) . toProvider ( new com.google.gerrit.extensions.registration.DynamicSetProvider ( member ) ) . in ( Scopes.SINGLETON ) ; }
public void testIsEnabledRefNoParentMatchingBranchEnforced ( ) { java.lang.String [ ] branches = new java.lang.String [ ] { "^refs/heads/test.*" } ; setupIsEnabled ( "enforced" , null , branches ) ; com.googlesource.gerrit.plugins.its.base.its.ItsConfig itsConfig = createItsConfig ( ) ; replayMocks ( ) ; com.google.gerrit.reviewdb.client.Project.NameKey projectNK = new com.google.gerrit.reviewdb.client.Project.NameKey ( "testProject" ) ; assertTrue ( itsConfig.isEnabled ( projectNK , "refs/heads/testBranch" ) ) ; }
public void delete ( com.google.gerrit.reviewdb.client.Change.Id id ) throws java.io.IOException { org.apache.lucene.index.Term idTerm = com.google.gerrit.lucene.LuceneChangeIndex.idTerm ( id ) ; try { com.google.common.util.concurrent.Futures.allAsList ( openIndex.delete ( idTerm ) , closedIndex.delete ( idTerm ) ) . get ( ) ; } catch ( java.util.concurrent.ExecutionException | java.lang.InterruptedException e ) { throw new java.io.IOException ( e ) ; } }
private com.google.gerrit.server.account.AuthResult byPreferredEmail ( java.lang.String email ) { try ( com.google.gerrit.reviewdb.server.ReviewDb db = schema.open ( ) ) { java.util.Optional < com.google.gerrit.server.account.AccountState > match = queryProvider.get ( ) . byPreferredEmail ( email ) . stream ( ) . findFirst ( ) ; return match.isPresent ( ) ? auth ( match.get ( ) ) : null ; } catch ( com.google.gwtorm.server.OrmException e ) { getServletContext ( ) . log ( "cannot query database" , e ) ; return null ; } }
private void initChangeAction ( com.google.gerrit.client.info.ChangeInfo info ) { if ( ( info.status ( ) ) == ( com.google.gerrit.reviewdb.client.Change.Status.DRAFT ) ) { com.google.gerrit.client.rpc.NativeMap < com.google.gerrit.client.info.ActionInfo > actions = ( info.hasActions ( ) ) ? info.actions ( ) : com.google.gerrit.client.rpc.NativeMap.< com.google.gerrit.client.info.ActionInfo > create ( ) ; actions.copyKeysIntoChildren ( "id" ) ; if ( actions.containsKey ( "/" ) ) { deleteChange.setVisible ( true ) ; deleteChange.setTitle ( actions.get ( "/" ) . title ( ) ) ; } } }
private void fakeClick ( final com.google.gerrit.client.patches.HistoryTable.HistoryRadio b ) { if ( ( ! ( b.getValue ( ) ) ) && ( b.isEnabled ( ) ) ) { for ( final com.google.gerrit.client.patches.HistoryTable.HistoryRadio a : all ) { if ( ( a.getValue ( ) ) && ( a.getName ( ) . equals ( b.getName ( ) ) ) ) { a.setValue ( false ) ; break ; } } b.setValue ( true ) ; onClick ( b ) ; } }
void setExpandAllComments ( boolean b ) { expandAll = b ; for ( com.google.gerrit.client.diff.CommentGroup g : sideA.values ( ) ) { g.setOpenAll ( b ) ; } for ( com.google.gerrit.client.diff.CommentGroup g : sideB.values ( ) ) { g.setOpenAll ( b ) ; } }
public void testUpdateOneConcurrentlyModifiedException ( ) throws com.google.gwtorm.server.OrmException , java.sql.SQLException { java.sql.PreparedStatement update = stubStatementWithUpdateCounts ( com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE , 0 ) ; com.google.gwtorm.jdbc.JdbcAccess < com.google.gwtorm.jdbc.TestJdbcAccess.Data , com.google.gwtorm.jdbc.TestJdbcAccess.Data.DataKey > classUnderTest = createClassUnderTest ( ) ; try { classUnderTest.update ( oneRow ) ; org.junit.Assert.fail ( "missing OrmConcurrencyException" ) ; } catch ( com.google.gwtorm.server.OrmConcurrencyException e ) { } com.google.gwtorm.jdbc.TestJdbcAccess.assertUsedBatchingOnly ( update ) ; }
private static void error ( final com.google.gwtjsonrpc.server.ActiveCall call , final int status , final java.lang.String message ) throws java.io.IOException { final javax.servlet.http.HttpServletResponse r = call.httpResponse ; r.setStatus ( status ) ; r.setContentType ( ( "text/plain; charset=" + ( com.google.gwtjsonrpc.server.JsonServlet.ENC ) ) ) ; final java.io.Writer w = new java.io.OutputStreamWriter ( r.getOutputStream ( ) , com.google.gwtjsonrpc.server.JsonServlet.ENC ) ; try { w.write ( message ) ; } finally { w.close ( ) ; } }
private void parseDelete ( final org.eclipse.jgit.transport.ReceiveCommand cmd ) { com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef ( cmd.getRefName ( ) ) ; if ( ctl.canDelete ( ) ) { batch.addCommand ( cmd ) ; } else { if ( GitRepositoryManager.REF_CONFIG.equals ( ctl.getRefName ( ) ) ) { reject ( cmd , "cannot delete project configuration" ) ; } else { errors.put ( com.google.gerrit.server.git.ReceiveCommits.Error.DELETE , ctl.getRefName ( ) ) ; reject ( cmd , "cannot delete references" ) ; } } }
public com.google.gerrit.server.account.AccountSshKey create ( com.google.gerrit.server.account.AccountSshKey.Id id , java.lang.String encoded ) throws com.google.gerrit.common.errors.InvalidSshKeyException { try { com.google.gerrit.server.account.AccountSshKey key = new com.google.gerrit.server.account.AccountSshKey ( id , com.google.gerrit.sshd.SshUtil.toOpenSshPublicKey ( encoded ) ) ; com.google.gerrit.sshd.SshUtil.parse ( key ) ; return key ; } catch ( java.security.NoSuchAlgorithmException | java.security.spec.InvalidKeySpecException e ) { throw new com.google.gerrit.common.errors.InvalidSshKeyException ( ) ; } catch ( java.security.NoSuchProviderException e ) { com.google.gerrit.sshd.SshKeyCreatorImpl.log.error ( "Cannot parse SSH key" , e ) ; throw new com.google.gerrit.common.errors.InvalidSshKeyException ( ) ; } }
private void restoreSelection ( ) { if ( ( ( getFromTo ( ) ) != null ) && ( ( comment.inReplyTo ( ) ) == null ) ) { getCm ( ) . setSelection ( getFromTo ( ) . from ( ) , getFromTo ( ) . to ( ) ) ; } }
public java.lang.String apply ( com.google.gerrit.server.git.validators.CommitValidationMessage input ) { java.lang.String pre = ( input.isError ( ) ) ? "ERROR: " : "MSG: " ; return pre + ( input.getMessage ( ) ) ; }
public void postUpdate ( com.google.gerrit.server.git.BatchUpdate.Context ctx ) { if ( ( changeMessage ) == null ) { return ; } emailReviewers ( ctx.getProject ( ) , currChange , del , changeMessage ) ; try { hooks.doReviewerDeletedHook ( currChange , reviewer , currPs , changeMessage.getMessage ( ) , newApprovals , oldApprovals , dbProvider.get ( ) ) ; } catch ( com.google.gwtorm.server.OrmException e ) { com.google.gerrit.server.change.DeleteReviewer.log.warn ( "ChangeHook.doReviewerDeletedHook invocation failed" , e ) ; } }
public void onError ( com.google.gwt.http.client.Request req , java.lang.Throwable err ) { if ( ! ( background ) ) { RpcStatus.INSTANCE.onRpcComplete ( ) ; } if ( err.getMessage ( ) . contains ( "XmlHttpRequest.status" ) ) { cb.onFailure ( new com.google.gwt.user.client.rpc.StatusCodeException ( com.google.gerrit.client.rpc.RestApi.SC_UNAVAILABLE , RpcConstants.C.errorServerUnavailable ( ) ) ) ; } else { cb.onFailure ( new com.google.gwt.user.client.rpc.StatusCodeException ( com.google.gerrit.client.rpc.RestApi.SC_BAD_TRANSPORT , err.getMessage ( ) ) ) ; } }
private static void unified1 ( final java.lang.String token , final com.google.gerrit.reviewdb.client.PatchSet.Id baseId , final com.google.gerrit.reviewdb.client.Patch.Key id ) { com.google.gwt.core.client.GWT.runAsync ( new com.google.gerrit.client.Dispatcher.AsyncSplit ( token ) { @ java.lang.Override public void onSuccess ( ) { com.google.gerrit.client.patches.UnifiedPatchScreen.TopView top = com.google.gerrit.client.Gerrit.getPatchScreenTopView ( ) ; com.google.gerrit.client.Gerrit.display ( token , new com.google.gerrit.client.patches.UnifiedPatchScreen ( id , top , baseId ) ) ; } } ) ; }
public com.google.gerrit.reviewdb.client.AccountGroup get ( final com.google.gerrit.reviewdb.client.AccountGroup.Id groupId ) { try { com.google.common.base.Optional < com.google.gerrit.reviewdb.client.AccountGroup > g = byId.get ( groupId ) ; return g.isPresent ( ) ? g.get ( ) : com.google.gerrit.server.account.GroupCacheImpl.missing ( groupId ) ; } catch ( java.util.concurrent.ExecutionException e ) { com.google.gerrit.server.account.GroupCacheImpl.log.warn ( ( "Cannot load group " + groupId ) , e ) ; return com.google.gerrit.server.account.GroupCacheImpl.missing ( groupId ) ; } }
public int compare ( java.nio.file.Path a , java.nio.file.Path b ) { return com.google.common.collect.ComparisonChain.start ( ) . compare ( com.google.gerrit.common.SiteLibraryLoaderUtil.lastModified ( b ) , com.google.gerrit.common.SiteLibraryLoaderUtil.lastModified ( a ) ) . compare ( a , b ) . result ( ) ; }
private java.lang.String url ( ) { if ( ( info.hasChangeNumber ( ) ) && ( ( info._changeNumber ( ) ) == 0 ) ) { return null ; } if ( ( info.hasChangeNumber ( ) ) && ( info.hasRevisionNumber ( ) ) ) { return "#" + ( com.google.gerrit.common.PageLinks.toChange ( info.patchSetId ( ) ) ) ; } return null ; }
public void display ( final com.google.gerrit.client.reviewdb.PatchSet.Id id , final java.util.List < com.google.gerrit.client.reviewdb.Patch > list ) { psid = id ; final com.google.gerrit.client.changes.PatchTable.DisplayCommand cmd = new com.google.gerrit.client.changes.PatchTable.DisplayCommand ( list ) ; if ( cmd.execute ( ) ) { cmd.initMeter ( ) ; com.google.gwt.user.client.DeferredCommand.addCommand ( cmd ) ; } }
public void testCreate ( ) throws java.io.FileNotFoundException { final com.google.gerrit.server.config.SitePaths site = new com.google.gerrit.server.config.SitePaths ( new java.io.File ( "." ) ) ; final com.google.gerrit.pgm.init.ConsoleUI ui = org.easymock.EasyMock.createStrictMock ( com.google.gerrit.pgm.init.ConsoleUI.class ) ; org.easymock.EasyMock.replay ( ui ) ; com.google.gerrit.pgm.init.Libraries lib = new com.google.gerrit.pgm.init.Libraries ( new com.google.inject.Provider < com.google.gerrit.pgm.init.LibraryDownloader > ( ) { @ java.lang.Override public com.google.gerrit.pgm.init.LibraryDownloader get ( ) { return new com.google.gerrit.pgm.init.LibraryDownloader ( ui , site ) ; } } ) ; org.junit.Assert.assertNotNull ( lib.bouncyCastleProvider ) ; org.junit.Assert.assertNotNull ( lib.mysqlDriver ) ; org.easymock.EasyMock.verify ( ui ) ; }
public void createEdit ( org.eclipse.jgit.lib.Repository repository , com.google.gerrit.server.project.ChangeControl changeControl ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.server.permissions.PermissionBackendException , com.google.gerrit.server.project.InvalidChangeOperationException , com.google.gwtorm.server.OrmException , java.io.IOException { assertCanEdit ( changeControl ) ; java.util.Optional < com.google.gerrit.server.edit.ChangeEdit > changeEdit = lookupChangeEdit ( changeControl ) ; if ( changeEdit.isPresent ( ) ) { throw new com.google.gerrit.server.project.InvalidChangeOperationException ( java.lang.String.format ( "A change edit already exists for change %s" , changeControl.getId ( ) ) ) ; } com.google.gerrit.reviewdb.client.PatchSet currentPatchSet = lookupCurrentPatchSet ( changeControl ) ; org.eclipse.jgit.lib.ObjectId patchSetCommitId = com.google.gerrit.server.edit.ChangeEditModifier.getPatchSetCommitId ( currentPatchSet ) ; createEdit ( repository , changeControl , currentPatchSet , patchSetCommitId , com.google.gerrit.common.TimeUtil.nowTs ( ) ) ; }
private static org.eclipse.jgit.lib.ObjectId resolveBlob ( com.google.gitiles.GitilesView view , org.eclipse.jgit.revwalk.RevWalk rw , org.eclipse.jgit.revwalk.RevCommit commit ) throws java.io.IOException { try { org.eclipse.jgit.treewalk.TreeWalk tw = org.eclipse.jgit.treewalk.TreeWalk.forPath ( rw.getObjectReader ( ) , view.getPathPart ( ) , commit.getTree ( ) ) ; if ( ( ( tw.getRawMode ( 0 ) ) & ( org.eclipse.jgit.lib.FileMode.TYPE_FILE ) ) == 0 ) { return null ; } return tw.getObjectId ( 0 ) ; } catch ( org.eclipse.jgit.errors.IncorrectObjectTypeException e ) { return null ; } }
private static boolean sameUpdate ( com.google.gerrit.server.notedb.ChangeRebuilder.Event event , com.google.gerrit.server.notedb.ChangeUpdate update ) { return ( ( ( ( update != null ) && ( ( com.google.gerrit.server.notedb.ChangeRebuilder.round ( event.when ) ) == ( com.google.gerrit.server.notedb.ChangeRebuilder.round ( update.getWhen ( ) ) ) ) ) && ( event.who.equals ( update.getUser ( ) . getAccountId ( ) ) ) ) && ( event.psId.equals ( update.getPatchSetId ( ) ) ) ) && ( ! ( event instanceof com.google.gerrit.server.notedb.ChangeRebuilder.FinalUpdatesEvent ) ) ; }
private void assertChangesReadOnly ( com.google.gerrit.extensions.restapi.RestApiException e ) throws java.lang.Exception { java.lang.Throwable cause = e.getCause ( ) ; com.google.common.truth.Truth.assertThat ( cause ) . isInstanceOf ( com.google.gerrit.server.git.UpdateException.class ) ; com.google.common.truth.Truth.assertThat ( cause.getCause ( ) ) . isInstanceOf ( com.google.gwtorm.server.OrmException.class ) ; com.google.common.truth.Truth.assertThat ( cause.getCause ( ) ) . hasMessage ( NoteDbUpdateManager.CHANGES_READ_ONLY ) ; }
private com.google.inject.Injector createSshInjector ( ) { final java.util.List < com.google.inject.Module > modules = new java.util.ArrayList < > ( ) ; modules.add ( sysInjector.getInstance ( com.google.gerrit.sshd.SshModule.class ) ) ; modules.add ( new com.google.gerrit.sshd.SshHostKeyModule ( ) ) ; modules.add ( new com.google.gerrit.sshd.commands.DefaultCommandModule ( false ) ) ; return sysInjector.createChildInjector ( modules ) ; }
protected void applyDataRowStyle ( final int row ) { super . applyDataRowStyle ( row ) ; final com.google.gwt.user.client.ui.HTMLTable.CellFormatter fmt = table.getCellFormatter ( ) ; fmt.addStyleName ( row , com.google.gerrit.client.changes.ChangeTable.C_STAR , com.google.gerrit.client.changes.S_ICON_CELL ) ; for ( int i = com.google.gerrit.client.changes.ChangeTable.C_ID ; i < ( com.google.gerrit.client.changes.ChangeTable.COLUMNS ) ; i ++ ) { fmt.addStyleName ( row , i , com.google.gerrit.client.changes.S_DATA_CELL ) ; } fmt.addStyleName ( row , com.google.gerrit.client.changes.ChangeTable.C_ID , com.google.gerrit.client.changes.ChangeTable.S_C_ID ) ; fmt.addStyleName ( row , com.google.gerrit.client.changes.ChangeTable.C_SUBJECT , com.google.gerrit.client.changes.ChangeTable.S_C_SUBJECT ) ; }
public void setUp ( ) throws java.lang.Exception { repo = com.google.gerrit.acceptance.GitUtil.newTestRepository ( repoManager.openRepository ( project ) ) ; com.google.gerrit.server.git.ProjectConfig pc = projectCache.checkedGet ( allProjects ) . getConfig ( ) ; for ( com.google.gerrit.common.data.AccessSection sec : pc.getAccessSections ( ) ) { sec.removePermission ( Permission.READ ) ; } saveProjectConfig ( allProjects , pc ) ; }
public boolean apply ( com.google.gerrit.extensions.api.projects.BranchInfo in ) { if ( ! ( in.ref.startsWith ( Constants.R_HEADS ) ) ) { return a.run ( in.ref ) ; } else { return a.run ( in.ref.substring ( Constants.R_HEADS.length ( ) ) ) ; } }
public void onSuccess ( com.google.gerrit.client.account.Preferences p ) { this . display ( p.my ( ) ) ; widget.setEnabled ( true ) ; }
public void onSuccess ( com.google.gwt.core.client.JsArray < com.google.gerrit.client.change.ReviewerSuggestOracle.SuggestReviewerInfo > result ) { java.util.List < com.google.gerrit.client.change.ReviewerSuggestOracle.RestReviewerSuggestion > r = new java.util.ArrayList ( result.length ( ) ) ; for ( com.google.gerrit.client.change.ReviewerSuggestOracle.SuggestReviewerInfo reviewer : com.google.gerrit.client.rpc.Natives.asList ( result ) ) { r.add ( new com.google.gerrit.client.change.ReviewerSuggestOracle.RestReviewerSuggestion ( reviewer ) ) ; } cb.onSuggestionsReady ( req , new com.google.gerrit.client.change.Response ( r ) ) ; }
public void testUnblockInLocalForceEditTopicName_Fails ( ) { com.google.gerrit.server.project.Util.grant ( util.getParentConfig ( ) , com.google.gerrit.common.data.Permission.EDIT_TOPIC_NAME , com.google.gerrit.server.project.Util.ANONYMOUS , "refs/heads/*" ) . setBlock ( ) ; com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.EDIT_TOPIC_NAME , com.google.gerrit.server.project.Util.DEVS , "refs/heads/*" ) . setForce ( true ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.project.Util.REGISTERED ) ; assertFalse ( "u can't edit topic name" , u.controlForRef ( "refs/heads/master" ) . canForceEditTopicName ( ) ) ; }
private static void deleteLocally ( org.eclipse.jgit.transport.URIish uri ) { try { com.googlesource.gerrit.plugins.replication.ReplicationQueue.recursivelyDelete ( new java.io.File ( uri.getPath ( ) ) ) ; com.googlesource.gerrit.plugins.replication.ReplicationQueue.repLog.info ( "Deleted local repository: {}" , uri ) ; } catch ( java.io.IOException e ) { com.googlesource.gerrit.plugins.replication.ReplicationQueue.repLog.error ( "Error deleting local repository {}:\n" , uri.getPath ( ) , e ) ; } }
protected void configure ( ) { factory ( AbandonChange.Factory.class ) ; factory ( RestoreChange.Factory.class ) ; factory ( ChangeDetailFactory.Factory.class ) ; factory ( IncludedInDetailFactory.Factory.class ) ; factory ( PatchSetDetailFactory.Factory.class ) ; factory ( PatchSetPublishDetailFactory.Factory.class ) ; factory ( SubmitAction.Factory.class ) ; }
private void initMode ( ) { mode.addItem ( "" , "" ) ; for ( net.codemirror.mode.ModeInfo m : com.google.gerrit.client.rpc.Natives.asList ( net.codemirror.mode.ModeInfo.all ( ) ) ) { mode.addItem ( m.name ( ) , m.mime ( ) ) ; } }
public com.google.gerrit.extensions.registration.DynamicMap < T > get ( ) { com.google.gerrit.extensions.registration.PrivateInternals_DynamicMapImpl < T > m = new com.google.gerrit.extensions.registration.PrivateInternals_DynamicMapImpl < T > ( ) ; java.util.List < com.google.inject.Binding < T > > bindings = injector.findBindingsByType ( type ) ; if ( bindings != null ) { for ( com.google.inject.Binding < T > b : bindings ) { if ( ( b.getKey ( ) . getAnnotation ( ) ) != null ) { m.put ( "gerrit" , b.getKey ( ) , b.getProvider ( ) ) ; } } } return m ; }
com.googlesource.gerrit.plugins.findowners.OwnersDb get ( com.google.gerrit.server.project.ProjectState projectState , com.google.gerrit.server.account.AccountCache accountCache , com.google.gerrit.server.account.Emails emails , org.eclipse.jgit.lib.Repository repository , com.google.gerrit.server.query.change.ChangeData changeData , int patchset ) throws com.google.gwtorm.server.OrmException , java.io.IOException { java.lang.String branch = changeData.change ( ) . getDest ( ) . get ( ) ; java.lang.String dbKey = com.googlesource.gerrit.plugins.findowners.Cache.makeKey ( changeData.getId ( ) . get ( ) , patchset , branch ) ; return get ( projectState , accountCache , emails , dbKey , repository , changeData , branch , changeData.currentFilePaths ( ) ) ; }
public void configure ( ) { factory ( ChangeUpdate.Factory.class ) ; factory ( ChangeDraftUpdate.Factory.class ) ; factory ( DraftCommentNotes.Factory.class ) ; factory ( NoteDbUpdateManager.Factory.class ) ; if ( ! ( useTestBindings ) ) { bind ( com.google.gerrit.server.notedb.ChangeRebuilder.class ) . to ( com.google.gerrit.server.notedb.ChangeRebuilderImpl.class ) ; } else { bind ( com.google.gerrit.server.notedb.ChangeRebuilder.class ) . toInstance ( new com.google.gerrit.server.notedb.ChangeRebuilder ( null ) { @ java.lang.Override public com.google.gerrit.server.notedb.NoteDbChangeState rebuild ( com.google.gerrit.reviewdb.server.ReviewDb db , com.google.gerrit.reviewdb.client.Change.Id changeId ) throws com.google.gwtorm.server.OrmException { return null ; } } ) ; } }
protected void configureServlets ( ) { install ( new com.google.gerrit.extensions.config.FactoryModule ( ) { @ java.lang.Override protected void configure ( ) { factory ( AgreementInfoFactory.Factory.class ) ; factory ( DeleteExternalIds.Factory.class ) ; factory ( ExternalIdDetailFactory.Factory.class ) ; } } ) ; rpc ( com.google.gerrit.httpd.rpc.account.AccountSecurityImpl.class ) ; rpc ( com.google.gerrit.httpd.rpc.account.AccountServiceImpl.class ) ; }
protected void doGet ( javax.servlet.http.HttpServletRequest req , javax.servlet.http.HttpServletResponse rsp ) { if ( healthy ) { rsp.setStatus ( javax.servlet.http.HttpServletResponse.SC_NO_CONTENT ) ; } else { sendError ( rsp , javax.servlet.http.HttpServletResponse.SC_SERVICE_UNAVAILABLE ) ; } }
private static void validateLabels ( java.util.Set < java.lang.String > labels ) { if ( labels == null ) { return ; } java.util.SortedSet < java.lang.String > invalidLabels = new java.util.TreeSet < > ( ) ; for ( java.lang.String label : labels ) { if ( com.google.common.base.CharMatcher.whitespace ( ) . matchesAnyOf ( label ) ) { invalidLabels.add ( label ) ; } } if ( ! ( invalidLabels.isEmpty ( ) ) ) { throw com.google.gerrit.server.StarredChangesUtil.IllegalLabelException.invalidLabels ( invalidLabels ) ; } }
private void addExtensionPoint ( com.google.gerrit.client.GerritUiExtensionPoint extensionPoint , com.google.gwt.user.client.ui.Panel p , com.google.gerrit.client.info.ChangeInfo change , com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev ) { com.google.gerrit.client.api.ExtensionPanel extensionPanel = new com.google.gerrit.client.api.ExtensionPanel ( extensionPoint ) ; extensionPanel.putObject ( GerritUiExtensionPoint.Key.CHANGE_INFO , change ) ; extensionPanel.putObject ( GerritUiExtensionPoint.Key.REVISION_INFO , rev ) ; p.add ( extensionPanel ) ; }
private boolean isParent ( java.nio.file.Path parent , java.nio.file.Path child ) throws java.io.IOException { java.nio.file.Path p = child ; for ( ; ; ) { p = p.getParent ( ) ; if ( p == null ) { return false ; } if ( java.nio.file.Files.isSameFile ( p , parent ) ) { return true ; } } }
public java.util.List < com.google.gerrit.extensions.common.ProjectInfo > apply ( com.google.gerrit.server.project.ProjectResource rsrc ) { if ( recursive ) { return getChildProjectsRecursively ( rsrc.getNameKey ( ) , rsrc.getControl ( ) . getUser ( ) ) ; } else { return getDirectChildProjects ( rsrc.getNameKey ( ) ) ; } }
public com.google.gerrit.server.git.MergeSuperSet setMergeOpRepoManager ( com.google.gerrit.server.git.MergeOpRepoManager orm ) { com.google.common.base.Preconditions.checkState ( ( ( this . orm ) == null ) ) ; this . orm = com.google.common.base.Preconditions.checkNotNull ( orm ) ; closeOrm = false ; return this ; }
public static com.google.gerrit.server.index.IndexConfig create ( int maxLimit , int maxPages , int maxTerms , int maxPrefixTerms ) { return new com.google.gerrit.server.index.AutoValue_IndexConfig ( com.google.gerrit.server.index.IndexConfig.checkLimit ( maxLimit , "maxLimit" , java.lang.Integer.MAX_VALUE ) , com.google.gerrit.server.index.IndexConfig.checkLimit ( maxPages , "maxPages" , java.lang.Integer.MAX_VALUE ) , com.google.gerrit.server.index.IndexConfig.checkLimit ( maxTerms , "maxTerms" , com.google.gerrit.server.index.IndexConfig.DEFAULT_MAX_TERMS ) , com.google.gerrit.server.index.IndexConfig.checkLimit ( maxPrefixTerms , "maxPrefixTerms" , com.google.gerrit.server.index.IndexConfig.DEFAULT_MAX_PREFIX_TERMS ) ) ; }
public java.lang.String newToken ( final java.lang.String text ) throws com.google.gwtjsonrpc.server.XsrfException { final int q = rng.nextInt ( ) ; final byte [ ] buf = new byte [ tokenLength ] ; com.google.gwtjsonrpc.server.SignedToken.encodeInt ( buf , 0 , q ) ; com.google.gwtjsonrpc.server.SignedToken.encodeInt ( buf , com.google.gwtjsonrpc.server.SignedToken.INT_SZ , ( ( com.google.gwtjsonrpc.server.SignedToken.now ( ) ) ^ q ) ) ; computeToken ( buf , text ) ; return ( ( com.google.gwtjsonrpc.server.SignedToken.encodeBase64 ( buf ) ) + '$' ) + text ; }
private com.google.gerrit.sshd.SshSession newSession ( ) { final java.net.SocketAddress peer ; if ( ( peerAddress ) == null ) { peer = session.get ( ) . getRemoteAddress ( ) ; } else { peer = peerAddress ; } com.google.gerrit.server.CurrentUser self = caller.get ( ) ; if ( self instanceof com.google.gerrit.server.PeerDaemonUser ) { self = null ; } return new com.google.gerrit.sshd.SshSession ( session.get ( ) , peer , userFactory.runAs ( peer , accountId , self ) ) ; }
public com.google.common.collect.ImmutableSet < com.google.gerrit.reviewdb.client.Branch.NameKey > getBranchesInOrder ( ) { java.util.LinkedHashSet < com.google.gerrit.reviewdb.client.Branch.NameKey > branches = new java.util.LinkedHashSet < > ( ) ; if ( ( sortedBranches ) != null ) { branches.addAll ( sortedBranches ) ; } branches.addAll ( updatedBranches ) ; return com.google.common.collect.ImmutableSet.copyOf ( branches ) ; }
private com.google.gerrit.index.query.Predicate < com.google.gerrit.server.query.change.ChangeData > rewriteImpl ( com.google.gerrit.index.query.Predicate < com.google.gerrit.server.query.change.ChangeData > in , com.google.gerrit.index.QueryOptions opts ) throws com.google.gerrit.index.query.QueryParseException { com.google.gerrit.server.index.change.ChangeIndex index = indexes.getSearchIndex ( ) ; org.eclipse.jgit.util.MutableInteger leafTerms = new org.eclipse.jgit.util.MutableInteger ( ) ; com.google.gerrit.index.query.Predicate < com.google.gerrit.server.query.change.ChangeData > out = rewriteImpl ( in , index , opts , leafTerms ) ; if ( ( in == out ) || ( out instanceof com.google.gerrit.index.query.IndexPredicate ) ) { return new com.google.gerrit.server.index.change.IndexedChangeQuery ( index , out , opts ) ; } else if ( out == null ) { return in ; } else { return out ; } }
static void initLibrary ( final com.google.gwt.user.client.rpc.AsyncCallback < java.lang.Void > cb ) { if ( net.codemirror.lib.Loader.isLibLoaded ( ) ) { cb.onSuccess ( null ) ; } else { net.codemirror.lib.Loader.injectCss ( Lib.I.css ( ) ) ; net.codemirror.lib.Loader.injectScript ( Lib.I.js ( ) . getSafeUri ( ) , new com.google.gerrit.client.rpc.GerritCallback < java.lang.Void > ( ) { @ java.lang.Override public void onSuccess ( java.lang.Void result ) { net.codemirror.lib.Loader.initDisableUnwantedKeys ( ) ; cb.onSuccess ( null ) ; } } ) ; } }
public void testAppend_String ( ) { final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder b = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder ( ) ; org.junit.Assert.assertSame ( b , b.append ( ( ( java.lang.String ) ( null ) ) ) ) ; org.junit.Assert.assertEquals ( "" , b.asString ( ) ) ; org.junit.Assert.assertSame ( b , b.append ( "foo" ) ) ; org.junit.Assert.assertSame ( b , b.append ( "bar" ) ) ; org.junit.Assert.assertEquals ( "foobar" , b.asString ( ) ) ; }
private org.eclipse.jgit.revwalk.RevCommit getCurrentCommit ( com.google.gerrit.acceptance.PushOneCommit.Result change ) throws java.lang.Exception { testRepo.git ( ) . fetch ( ) . setRemote ( "origin" ) . call ( ) ; com.google.gerrit.extensions.common.ChangeInfo info = get ( change.getChangeId ( ) , com.google.gerrit.extensions.client.ListChangesOption.CURRENT_REVISION ) ; org.eclipse.jgit.revwalk.RevCommit c = testRepo.getRevWalk ( ) . parseCommit ( org.eclipse.jgit.lib.ObjectId.fromString ( info.currentRevision ) ) ; testRepo.getRevWalk ( ) . parseBody ( c ) ; return c ; }
static com.google.gerrit.server.query.change.ChangeData createForTest ( com.google.gerrit.reviewdb.client.Change.Id id , int currentPatchSetId ) { com.google.gerrit.server.query.change.ChangeData cd = new com.google.gerrit.server.query.change.ChangeData ( null , null , null , null , null , null , null , null , id ) ; cd.currentPatchSet = new com.google.gerrit.reviewdb.client.PatchSet ( new com.google.gerrit.reviewdb.client.PatchSet.Id ( id , currentPatchSetId ) ) ; return cd ; }
, @ com.google.gerrit.acceptance.GerritConfig ( name = "suggest.from" , value = "1" ) , @ com.google.gerrit.acceptance.GerritConfig ( name = "accounts.visibility" , value = "NONE" ) } ) public void suggestReviewersNoResult2 ( ) throws java.lang.Exception { java.lang.String changeId = createChange ( ) . getChangeId ( ) ; java.util.List < com.google.gerrit.extensions.common.SuggestedReviewerInfo > reviewers = suggestReviewers ( changeId , "u" , 6 ) ; com.google.common.truth.Truth.assertThat ( reviewers ) . isEmpty ( ) ; }
public int compare ( com.google.gerrit.client.projects.ProjectInfo a , com.google.gerrit.client.projects.ProjectInfo b ) { return a.name ( ) . compareTo ( b.name ( ) ) ; }
public void onKeyPress ( final com.google.gwt.event.dom.client.KeyPressEvent event ) { int row = getCurrentRow ( ) ; com.google.gerrit.client.changes.ChangeInfo c = getRowItem ( row ) ; if ( ( c != null ) && ( com.google.gerrit.client.Gerrit.isSignedIn ( ) ) ) { ( ( com.google.gerrit.client.changes.StarredChanges.Icon ) ( table.getWidget ( row , com.google.gerrit.client.changes.ChangeTable2.C_STAR ) ) ) . toggleStar ( ) ; } }
public com.google.gerrit.server.plugins.InstallPlugin create ( com.google.gerrit.extensions.restapi.TopLevelResource parent , com.google.gerrit.extensions.restapi.IdString id ) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException , com.google.gerrit.extensions.restapi.ResourceNotFoundException { if ( ! ( loader.isRemoteAdminEnabled ( ) ) ) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException ( "remote installation is disabled" ) ; } return install.get ( ) . setName ( id.get ( ) ) . setCreated ( true ) ; }
private void display ( final com.google.gerrit.reviewdb.AccountGeneralPreferences p ) { showSiteHeader.setValue ( p.isShowSiteHeader ( ) ) ; useFlashClipboard.setValue ( p.isUseFlashClipboard ( ) ) ; copySelfOnEmails.setValue ( p.isCopySelfOnEmails ( ) ) ; displayPatchSetsInReverseOrder.setValue ( p.isDisplayPatchSetsInReverseOrder ( ) ) ; setListBox ( maximumPageSize , com.google.gerrit.reviewdb.AccountGeneralPreferences.DEFAULT_PAGESIZE , p.getMaximumPageSize ( ) ) ; setListBox ( dateFormat , AccountGeneralPreferences.DateFormat.STD , p.getDateFormat ( ) ) ; setListBox ( timeFormat , AccountGeneralPreferences.TimeFormat.HHMM_12 , p.getTimeFormat ( ) ) ; }
protected com.google.gerrit.prettify.client.SparseHtmlFile getSparseHtmlFileA ( com.google.gerrit.common.data.PatchScript s ) { com.google.gerrit.extensions.client.DiffPreferencesInfo dp = s.getDiffPrefs ( ) ; dp.showWhitespaceErrors = false ; com.google.gerrit.prettify.client.PrettyFormatter f = ClientSideFormatter.FACTORY.get ( ) ; f.setDiffPrefs ( dp ) ; f.setFileName ( s.getA ( ) . getPath ( ) ) ; f.setEditFilter ( PrettyFormatter.A ) ; f.setEditList ( s.getEdits ( ) ) ; f.format ( s.getA ( ) ) ; return f ; }
public java.util.List < com.google.gerrit.server.notedb.ChangeNotes > scan ( org.eclipse.jgit.lib.Repository repo , com.google.gerrit.reviewdb.server.ReviewDb db , com.google.gerrit.reviewdb.client.Project.NameKey project ) throws com.google.gwtorm.server.OrmException , java.io.IOException { if ( ! ( migration.readChanges ( ) ) ) { return scanDb ( repo , db ) ; } return scanNoteDb ( repo , db , project ) ; }
void onSave ( com.google.gwt.event.dom.client.ClickEvent e ) { com.google.gerrit.client.changes.ChangeFileApi.putContent ( id , file.getText ( ) , content.getText ( ) , new com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.client.VoidResult > ( ) { @ java.lang.Override public void onSuccess ( com.google.gerrit.client.VoidResult result ) { com.google.gerrit.client.Gerrit.display ( com.google.gerrit.common.PageLinks.toChange ( id.getParentKey ( ) ) ) ; hide ( ) ; } @ java.lang.Override public void onFailure ( java.lang.Throwable caught ) { } } ) ; }
public void testNonIndexPredicates ( ) throws java.lang.Exception { com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > in = parse ( "foo:a OR foo:b" ) ; com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > out = rewrite ( in ) ; com.google.common.truth.Truth.assertThat ( com.google.gerrit.server.query.change.AndSource.class ) . isSameAs ( out.getClass ( ) ) ; com.google.common.truth.Truth.assertThat ( out.getChildren ( ) ) . containsExactly ( query ( com.google.gerrit.server.query.change.ChangeStatusPredicate.open ( ) ) , in ) . inOrder ( ) ; }
private boolean authLogin ( java.lang.String smtpUser , java.lang.String smtpPass ) throws java.io.IOException , java.io.UnsupportedEncodingException { if ( ( sendCommand ( "AUTH" , "LOGIN" ) ) != 334 ) { return false ; } java.lang.String cmd = org.apache.commons.net.smtp.AuthSMTPClient.encodeBase64 ( smtpUser.getBytes ( java.nio.charset.StandardCharsets.UTF_8 ) ) ; if ( ( sendCommand ( cmd ) ) != 334 ) { return false ; } cmd = org.apache.commons.net.smtp.AuthSMTPClient.encodeBase64 ( smtpPass.getBytes ( java.nio.charset.StandardCharsets.UTF_8 ) ) ; return org.apache.commons.net.smtp.SMTPReply.isPositiveCompletion ( sendCommand ( cmd ) ) ; }
protected void configure ( ) { com.google.gerrit.extensions.registration.DynamicSet.bind ( binder ( ) , com.google.gerrit.server.validators.ProjectCreationValidationListener.class ) . to ( com.googlesource.gerrit.plugins.quota.MaxRepositoriesQuotaValidator.class ) ; com.google.gerrit.extensions.registration.DynamicSet.bind ( binder ( ) , com.google.gerrit.server.git.ReceivePackInitializer.class ) . to ( com.googlesource.gerrit.plugins.quota.MaxRepositorySizeQuota.class ) ; com.google.gerrit.extensions.registration.DynamicSet.bind ( binder ( ) , org.eclipse.jgit.transport.PostReceiveHook.class ) . to ( com.googlesource.gerrit.plugins.quota.MaxRepositorySizeQuota.class ) ; install ( com.googlesource.gerrit.plugins.quota.MaxRepositorySizeQuota.module ( ) ) ; install ( new com.google.gerrit.extensions.restapi.RestApiModule ( ) { @ java.lang.Override protected void configure ( ) { get ( com.google.gerrit.server.project.ProjectResource.PROJECT_KIND , "quota" ) . to ( com.googlesource.gerrit.plugins.quota.GetQuota.class ) ; } } ) ; }
private java.lang.String getAccessTokenAttribute ( java.lang.String tokenResponse ) throws com.googlesource.gerrit.plugins.cfoauth.UAAClientException { com.google.gson.JsonObject json = getAsJsonObject ( tokenResponse ) ; java.lang.String accessToken = getAttribute ( json , com.googlesource.gerrit.plugins.cfoauth.UAAClient.ACCESS_TOKEN_ATTRIBUTE ) ; if ( accessToken == null ) { throw new com.googlesource.gerrit.plugins.cfoauth.UAAClientException ( "Can't extract a token: missing or invalid 'access_token' attribute" ) ; } return accessToken ; }
public void createEmptyEditRest ( ) throws java.lang.Exception { adminSession.post ( urlEdit ( ) ) . assertNoContent ( ) ; com.google.common.base.Optional < com.google.gerrit.server.edit.ChangeEdit > edit = editUtil.byChange ( change ) ; com.google.gerrit.acceptance.edit.ChangeEditIT.assertByteArray ( fileUtil.getContent ( projectCache.get ( edit.get ( ) . getChange ( ) . getProject ( ) ) , org.eclipse.jgit.lib.ObjectId.fromString ( edit.get ( ) . getRevision ( ) . get ( ) ) , com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME ) , com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_OLD ) ; }
public final com.google.gerrit.gpg.CheckResult check ( org.bouncycastle.openpgp.PGPPublicKey key ) { if ( ( ( store ) == null ) && ( ( trusted ) != null ) ) { throw new java.lang.IllegalStateException ( "PublicKeyStore is required" ) ; } return check ( key , 0 , true , ( ( trusted ) != null ? new java.util.HashSet < com.google.gerrit.gpg.Fingerprint > ( ) : null ) ) ; }
void selectMax ( ) { for ( int i = 0 ; i < ( ( buttons.size ( ) ) - 1 ) ; i ++ ) { buttons.get ( i ) . setValue ( false , false ) ; } com.google.gerrit.client.change.ReplyBox.LabelRadioButton max = buttons.get ( ( ( buttons.size ( ) ) - 1 ) ) ; max.setValue ( true , true ) ; max.select ( ) ; }
private void merge ( com.google.gerrit.acceptance.PushOneCommit.Result r ) throws java.lang.Exception { revision ( r ) . review ( com.google.gerrit.extensions.api.changes.ReviewInput.approve ( ) ) ; revision ( r ) . submit ( ) ; try ( org.eclipse.jgit.lib.Repository repo = repoManager.openRepository ( project ) ) { com.google.common.truth.Truth.assertThat ( repo.exactRef ( "refs/heads/master" ) . getObjectId ( ) ) . isEqualTo ( r.getCommit ( ) ) ; } }
protected void run ( ) throws com.google.gerrit.sshd.commands.UnloggedFailure { boolean ok = true ; for ( com.google.gerrit.reviewdb.client.Change.Id changeId : changes ) { try { ok &= modifyOne ( changeId ) ; } catch ( java.lang.Exception err ) { ok = false ; com.google.gerrit.sshd.commands.SetReviewersCommand.log.error ( ( "Error updating reviewers on change " + changeId ) , err ) ; writeError ( "fatal" , ( "internal error while updating " + changeId ) ) ; } } if ( ! ok ) { throw com.google.gerrit.sshd.commands.SetReviewersCommand.error ( "fatal: one or more updates failed; review output above" ) ; } }
public void parseBranch ( ) throws java.lang.Exception { assertParseSucceeds ( ( "Update change\n" + ( ( ( ( "\n" + "Branch: refs/heads/master\n" ) + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" ) + "Patch-Set: 1\n" ) + "Subject: This is a test change\n" ) ) ) ; assertParseSucceeds ( ( "Update change\n" + ( ( ( ( "\n" + "Branch: master\n" ) + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" ) + "Patch-Set: 1\n" ) + "Subject: This is a test change\n" ) ) ) ; assertParseFails ( ( "Update change\n" + ( ( ( "\n" + "Patch-Set: 1\n" ) + "Branch: refs/heads/master\n" ) + "Branch: refs/heads/stable" ) ) ) ; }
public com.googlecode.prolog_cafe.lang.Operation exec ( com.googlecode.prolog_cafe.lang.Prolog engine ) throws com.googlecode.prolog_cafe.exceptions.PrologException { engine.cont = cont ; engine.setB0 ( ) ; com.vmware.gerrit.owners.common.PathOwners owners = OwnersStoredValues.PATH_OWNERS.get ( engine ) ; engine.r1 = arg1 ; engine.r2 = new com.googlecode.prolog_cafe.lang.JavaObjectTerm ( owners.get ( ) . keys ( ) . iterator ( ) ) ; return engine.jtry2 ( gerrit_owners.PRED_owner_path_1.OWNER_PATH_CHECK , gerrit_owners.PRED_owner_path_1.OWNER_PATH_NEXT ) ; }
private void configureMainSection ( ) { ui.header ( "Main section" ) ; java.lang.String sharedDirDefault = ( ui.isBatch ( ) ) ? com.ericsson.gerrit.plugins.highavailability.Configuration.DEFAULT_SHARED_DIRECTORY : null ; java.lang.String shared = promptAndSetString ( "Shared directory" , com.ericsson.gerrit.plugins.highavailability.Configuration.MAIN_SECTION , com.ericsson.gerrit.plugins.highavailability.Configuration.SHARED_DIRECTORY_KEY , sharedDirDefault ) ; if ( ! ( com.google.common.base.Strings.isNullOrEmpty ( shared ) ) ) { java.nio.file.Path resolved = site.site_path.resolve ( java.nio.file.Paths.get ( shared ) ) ; com.google.gerrit.common.FileUtil.mkdirsOrDie ( resolved , ( "cannot create " + resolved ) ) ; } }
private com.google.gerrit.server.git.TagSet rebuild ( com.google.gerrit.server.git.TagCache cache , org.eclipse.jgit.lib.Repository db , com.google.gerrit.server.git.TagSet old , com.google.gerrit.server.git.TagMatcher m ) { synchronized ( buildLock ) { com.google.gerrit.server.git.TagSet cur = this . tags ; if ( cur == old ) { cur = new com.google.gerrit.server.git.TagSet ( projectName ) ; cur.build ( db , old , m ) ; this . tags = cur ; cache.put ( projectName , this ) ; } return cur ; } }
void display ( final java.util.List < com.google.gerrit.client.reviewdb.Project > result ) { while ( 1 < ( table.getRowCount ( ) ) ) table.removeRow ( ( ( table.getRowCount ( ) ) - 1 ) ) ; for ( final com.google.gerrit.client.reviewdb.Project k : result ) { final int row = table.getRowCount ( ) ; table.insertRow ( row ) ; applyDataRowStyle ( row ) ; populate ( row , k ) ; } }
private com.google.gwt.dom.client.Element getRow ( com.google.gwt.dom.client.Element e ) { for ( com.google.gwt.dom.client.Element prev = e ; e != null ; prev = e ) { if ( ( e = com.google.gwt.user.client.DOM.getParent ( e ) ) == ( body ) ) { return prev ; } } return null ; }
private void padLineNumberForSideB ( final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder m ) { m.openTd ( ) ; m.setStyleName ( Gerrit.RESOURCES.css ( ) . lineNumber ( ) ) ; m.closeTd ( ) ; }
public void setUp ( ) throws java.lang.Exception { index = new com.google.gerrit.server.index.change.FakeChangeIndex ( FakeChangeIndex.V2 ) ; indexes = new com.google.gerrit.server.index.change.ChangeIndexCollection ( ) ; indexes.setSearchIndex ( index ) ; queryBuilder = new com.google.gerrit.server.index.change.FakeQueryBuilder ( indexes ) ; rewrite = new com.google.gerrit.server.index.change.ChangeIndexRewriter ( indexes , com.google.gerrit.server.index.IndexConfig.builder ( ) . maxTerms ( 3 ) . build ( ) ) ; }
public void addAllReviewers ( com.google.gerrit.server.data.ChangeAttribute a , com.google.gerrit.server.notedb.ChangeNotes notes ) throws com.google.gwtorm.server.OrmException { java.util.Collection < com.google.gerrit.reviewdb.client.Account.Id > reviewers = approvalsUtil.getReviewers ( db.get ( ) , notes ) . values ( ) ; if ( ! ( reviewers.isEmpty ( ) ) ) { a.allReviewers = com.google.common.collect.Lists.newArrayListWithCapacity ( reviewers.size ( ) ) ; for ( com.google.gerrit.reviewdb.client.Account.Id id : reviewers ) { a.allReviewers.add ( asAccountAttribute ( id ) ) ; } } }
public void setUp ( ) { listenerMock = org.mockito.Mockito.mock ( com.google.gerrit.common.EventListener.class ) ; com.google.gerrit.extensions.registration.DynamicSet < com.google.gerrit.common.EventListener > listeners = com.google.gerrit.extensions.registration.DynamicSet.emptySet ( ) ; listeners.add ( listenerMock ) ; broker = new com.ericsson.gerrit.plugins.syncevents.SyncEventBroker ( null , listeners , null , null , null ) ; }
private com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DownloadScheme getSelectedScheme ( ) { java.lang.String id = scheme.getValue ( scheme.getSelectedIndex ( ) ) ; if ( "git" . equals ( id ) ) { return com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DownloadScheme.ANON_GIT ; } else if ( "anonymous http" . equals ( id ) ) { return com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DownloadScheme.ANON_HTTP ; } else if ( "http" . equals ( id ) ) { return com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DownloadScheme.HTTP ; } else if ( "ssh" . equals ( id ) ) { return com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DownloadScheme.SSH ; } else if ( "repo" . equals ( id ) ) { return com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DownloadScheme.REPO_DOWNLOAD ; } return null ; }
private com.google.common.collect.SetMultimap < org.eclipse.jgit.lib.ObjectId , org.eclipse.jgit.lib.Ref > changeRefsById ( ) { initChangeRefMaps ( ) ; return refsById ; }
private void assertAmGroupOwner ( final com.google.gerrit.client.reviewdb.ReviewDb db , final com.google.gerrit.client.reviewdb.AccountGroup group ) throws com.google.gerrit.server.rpc.Failure { try { if ( ! ( groupControlFactory.controlFor ( group.getId ( ) ) . isOwner ( ) ) ) { throw new com.google.gerrit.server.rpc.Failure ( new com.google.gerrit.server.account.NoSuchGroupException ( group.getId ( ) ) ) ; } } catch ( com.google.gerrit.server.account.NoSuchGroupException e ) { throw new com.google.gerrit.server.rpc.Failure ( new com.google.gerrit.server.account.NoSuchGroupException ( group.getId ( ) ) ) ; } }
private java.util.List < com.google.gerrit.server.project.SectionMatcher > getLocalAccessSections ( ) { java.util.List < com.google.gerrit.server.project.SectionMatcher > sm = localAccessSections ; if ( sm == null ) { java.util.Collection < com.google.gerrit.common.data.AccessSection > fromConfig = config.getAccessSections ( ) ; sm = new java.util.ArrayList < com.google.gerrit.server.project.SectionMatcher > ( fromConfig.size ( ) ) ; for ( com.google.gerrit.common.data.AccessSection section : fromConfig ) { com.google.gerrit.server.project.SectionMatcher matcher = com.google.gerrit.server.project.SectionMatcher.wrap ( section ) ; if ( matcher != null ) { sm.add ( matcher ) ; } } localAccessSections = sm ; } return sm ; }
public static void assertProjectOwners ( java.util.Set < com.google.gerrit.reviewdb.client.AccountGroup.UUID > expectedOwners , com.google.gerrit.server.project.ProjectState state ) { for ( com.google.gerrit.reviewdb.client.AccountGroup.UUID g : state.getOwners ( ) ) { com.google.common.truth.Truth.assertThat ( expectedOwners.remove ( g ) ) . isTrue ( ) ; } com.google.common.truth.Truth.assertThat ( ( ( java.lang.Iterable < ? > ) ( expectedOwners ) ) ) . isEmpty ( ) ; }
public com.google.gerrit.server.project.ChildProjectResource parse ( com.google.gerrit.server.project.ProjectResource parent , com.google.gerrit.extensions.restapi.IdString id ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.permissions.PermissionBackendException , java.io.IOException { parent.getProjectState ( ) . checkStatePermitsRead ( ) ; com.google.gerrit.server.project.ProjectResource p = projectsCollection.parse ( TopLevelResource.INSTANCE , id ) ; for ( com.google.gerrit.server.project.ProjectState pp : p.getProjectState ( ) . parents ( ) ) { if ( parent.getNameKey ( ) . equals ( pp.getProject ( ) . getNameKey ( ) ) ) { return new com.google.gerrit.server.project.ChildProjectResource ( parent , p.getProjectState ( ) ) ; } } throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException ( id ) ; }
public java.util.List < com.google.gerrit.extensions.common.WebLinkInfo > getFileLinks ( java.lang.String project , java.lang.String revision , java.lang.String file ) { java.util.List < com.google.gerrit.extensions.common.WebLinkInfo > links = new java.util.ArrayList < > ( 4 ) ; for ( com.google.gerrit.extensions.webui.FileWebLink webLink : fileLinks ) { com.google.gerrit.extensions.common.WebLinkInfo info = webLink.getFileWebLink ( project , revision , file ) ; if ( ( ! ( com.google.common.base.Strings.isNullOrEmpty ( info.name ) ) ) && ( ! ( com.google.common.base.Strings.isNullOrEmpty ( info.url ) ) ) ) { links.add ( info ) ; } } return links ; }
public void testAppend_String ( ) { final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder b = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder ( ) ; com.google.common.truth.Truth.assertThat ( b ) . isSameAs ( b.append ( ( ( java.lang.String ) ( null ) ) ) ) ; com.google.common.truth.Truth.assertThat ( b.asString ( ) ) . isEmpty ( ) ; com.google.common.truth.Truth.assertThat ( b ) . isSameAs ( b.append ( "foo" ) ) ; com.google.common.truth.Truth.assertThat ( b ) . isSameAs ( b.append ( "bar" ) ) ; com.google.common.truth.Truth.assertThat ( b.asString ( ) ) . isEqualTo ( "foobar" ) ; }
private boolean canSetPrivate ( com.google.gerrit.server.change.ChangeResource rsrc ) { com.google.gerrit.server.permissions.PermissionBackend.WithUser user = permissionBackend.user ( rsrc.getUser ( ) ) ; return ( user.testOrFalse ( GlobalPermission.ADMINISTRATE_SERVER ) ) || ( ( rsrc.isUserOwner ( ) ) && ( ( rsrc.getChange ( ) . getStatus ( ) ) != ( Change.Status.MERGED ) ) ) ; }
public void setUp ( ) throws java.lang.Exception { anonRestSession = new com.google.gerrit.acceptance.RestSession ( server , null ) ; admin2 = accounts.admin2 ( ) ; com.google.gerrit.extensions.api.groups.GroupInput gi = new com.google.gerrit.extensions.api.groups.GroupInput ( ) ; gi.name = name ( "New-Group" ) ; gi.members = com.google.common.collect.ImmutableList.of ( user.id.toString ( ) ) ; newGroup = gApi.groups ( ) . create ( gi ) . get ( ) ; }
private void initProviderBouncyCastle ( org.eclipse.jgit.lib.Config cfg ) { org.apache.sshd.common.NamedFactory < org.apache.sshd.common.random.Random > factory ; if ( cfg.getBoolean ( "sshd" , null , "testUseInsecureRandom" , false ) ) { factory = new com.google.gerrit.sshd.SshDaemon.InsecureBouncyCastleRandom.Factory ( ) ; } else { factory = org.apache.sshd.common.util.SecurityUtils.getRandomFactory ( ) ; } setRandomFactory ( new org.apache.sshd.common.random.SingletonRandomFactory ( factory ) ) ; }
public void testThreeLevelTreeWithSomeIndexPredicates ( ) throws java.lang.Exception { com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > in = parse ( "-foo:a (file:b OR file:c)" ) ; com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > out = rewrite ( in ) ; com.google.common.truth.Truth.assertThat ( out.getClass ( ) ) . isSameAs ( com.google.gerrit.server.query.change.AndChangeSource.class ) ; com.google.common.truth.Truth.assertThat ( out.getChildren ( ) ) . containsExactly ( query ( in.getChild ( 1 ) ) , in.getChild ( 0 ) ) . inOrder ( ) ; }
public com.google.gerrit.common.data.Capable canPushToAtLeastOneRef ( ) { if ( ( ( ! ( canPerformOnAnyRef ( Permission.PUSH ) ) ) && ( ! ( canPerformOnAnyRef ( Permission.CREATE_TAG ) ) ) ) && ( ! ( isOwner ( ) ) ) ) { java.lang.String pName = state.getProject ( ) . getName ( ) ; return new com.google.gerrit.common.data.Capable ( ( ( "Upload denied for project '" + pName ) + "'" ) ) ; } if ( state.isUseContributorAgreements ( ) ) { return verifyActiveContributorAgreement ( ) ; } return com.google.gerrit.common.data.Capable.OK ; }
public void onShowView ( ) { super . onShowView ( ) ; java.lang.String prior = com.google.gerrit.client.Gerrit.getPriorView ( ) ; if ( ( prior != null ) && ( prior.startsWith ( "/c/" ) ) ) { scrollToPath ( prior.substring ( 3 ) ) ; } startPoller ( ) ; }
public boolean get ( ) { com.google.gerrit.common.data.ChangeDetail detail = cache.getChangeDetailCache ( ) . get ( ) ; if ( detail != null ) { return detail.isStarred ( ) ; } com.google.gerrit.common.data.ChangeInfo info = cache.getChangeInfoCache ( ) . get ( ) ; if ( info != null ) { return info.isStarred ( ) ; } return false ; }
public void add ( com.google.gerrit.extensions.registration.RegistrationHandle handle ) { if ( handle instanceof com.google.gerrit.extensions.registration.ReloadableRegistrationHandle ) { if ( ( reloadableHandles ) == null ) { reloadableHandles = com.google.common.collect.Lists.newArrayList ( ) ; } reloadableHandles.add ( ( ( com.google.gerrit.extensions.registration.ReloadableRegistrationHandle < ? > ) ( handle ) ) ) ; } manager.add ( handle ) ; }
private java.util.Set < com.google.gerrit.reviewdb.client.Account > listAccounts ( final com.google.gerrit.reviewdb.client.AccountGroup.UUID groupUUID , final com.google.gerrit.reviewdb.client.Project.NameKey project , final java.util.Set < com.google.gerrit.reviewdb.client.AccountGroup.UUID > seen ) throws com.google.gerrit.common.errors.NoSuchGroupException , com.google.gerrit.server.project.NoSuchProjectException , com.google.gwtorm.server.OrmException , java.io.IOException { if ( SystemGroupBackend.PROJECT_OWNERS.equals ( groupUUID ) ) { return getProjectOwners ( project , seen ) ; } else { com.google.gerrit.reviewdb.client.AccountGroup group = groupCache.get ( groupUUID ) ; if ( group != null ) { return getGroupMembers ( group , project , seen ) ; } else { return java.util.Collections.emptySet ( ) ; } } }
public java.util.List < com.google.gerrit.extensions.common.ProjectInfo > list ( com.google.gerrit.reviewdb.client.Project.NameKey parent ) throws com.google.gerrit.server.permissions.PermissionBackendException { java.util.Map < com.google.gerrit.reviewdb.client.Project.NameKey , com.google.gerrit.reviewdb.client.Project > projects = readAllReadableProjects ( ) ; com.google.common.collect.Multimap < com.google.gerrit.reviewdb.client.Project.NameKey , com.google.gerrit.reviewdb.client.Project.NameKey > children = parentToChildren ( projects ) ; com.google.gerrit.server.permissions.PermissionBackend.WithUser perm = permissionBackend.currentUser ( ) ; java.util.List < com.google.gerrit.extensions.common.ProjectInfo > results = new java.util.ArrayList < > ( ) ; depthFirstFormat ( results , perm , projects , children , parent ) ; return results ; }
public void myStarredChangeIds ( final com.google.gwt.user.client.rpc.AsyncCallback < java.util.Set < com.google.gerrit.client.reviewdb.Change.Id > > callback ) { callback.onSuccess ( currentUser.get ( ) . getStarredChanges ( ) ) ; }
void clearLine ( com.google.gerrit.client.diff.DisplaySide side , int line ) { map ( side ) . remove ( line ) ; }
public void setExisting_Conflict ( ) throws java.lang.Exception { com.google.gerrit.extensions.common.UsernameInput in = new com.google.gerrit.extensions.common.UsernameInput ( ) ; in.username = admin.username ; adminRestSession.put ( ( ( "/accounts/" + ( accountCreator.create ( ) . id.get ( ) ) ) + "/username" ) , in ) . assertConflict ( ) ; }
boolean match ( final java.security.PublicKey inkey ) { if ( ( publicKey ) == null ) { try { publicKey = com.google.gerrit.sshd.SshUtil.parse ( key ) ; } catch ( java.lang.OutOfMemoryError e ) { throw e ; } catch ( java.lang.Throwable e ) { publicKey = com.google.gerrit.sshd.SshKeyCacheEntry.INVALID_KEY ; } } return publicKey.equals ( inkey ) ; }
protected void configure ( ) { bind ( com.google.gerrit.git.PushReplication.ReplicationConfig.class ) . toInstance ( this ) ; bind ( org.spearce.jgit.transport.RemoteConfig.class ) . toInstance ( remote ) ; bind ( PushOp.Factory.class ) . toProvider ( com.google.inject.assistedinject.FactoryProvider.newFactory ( PushOp.Factory.class , com.google.gerrit.git.PushOp.class ) ) ; }
public void defaultMessage ( ) throws java.lang.Exception { java.lang.String changeId = createChange ( ) . getChangeId ( ) ; com.google.gerrit.extensions.common.ChangeInfo c = get ( changeId ) ; com.google.common.truth.Truth.assertThat ( ( ( java.lang.Iterable < ? > ) ( c.messages ) ) ) . isNotNull ( ) ; com.google.common.truth.Truth.assertThat ( ( ( java.lang.Iterable < ? > ) ( c.messages ) ) ) . hasSize ( 1 ) ; com.google.common.truth.Truth.assertThat ( c.messages.iterator ( ) . next ( ) . message ) . isEqualTo ( "Uploaded patch set 1." ) ; }
public com.google.gerrit.extensions.common.GroupInfo format ( com.google.gerrit.common.data.GroupDescription.Basic group ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.extensions.common.GroupInfo info = init ( group ) ; if ( ( options.contains ( com.google.gerrit.extensions.client.ListGroupsOption.MEMBERS ) ) || ( options.contains ( com.google.gerrit.extensions.client.ListGroupsOption.INCLUDES ) ) ) { com.google.gerrit.server.group.GroupResource rsrc = new com.google.gerrit.server.group.GroupResource ( groupControlFactory.controlFor ( group ) ) ; initMembersAndIncludes ( rsrc , info ) ; } return info ; }
public void withValidGroupName ( ) throws java.lang.Exception { java.lang.String newGroupName = "newGroup" ; adminRestSession.put ( ( "/groups/" + newGroupName ) ) ; java.lang.String newProjectName = "newProject" ; adminSshSession.exec ( ( ( ( "gerrit create-project --branch master --owner " + newGroupName ) + " " ) + newProjectName ) ) ; com.google.common.truth.Truth.assert_ ( ) . withMessage ( adminSshSession.getError ( ) ) . that ( adminSshSession.hasError ( ) ) . isFalse ( ) ; com.google.gerrit.server.project.ProjectState projectState = projectCache.get ( new com.google.gerrit.reviewdb.client.Project.NameKey ( newProjectName ) ) ; com.google.common.truth.Truth.assertThat ( projectState ) . isNotNull ( ) ; }
com.ericsson.gerrit.plugins.eventslog.sql.SQLClient provideLocalSqlClient ( com.ericsson.gerrit.plugins.eventslog.EventsLogConfig cfg ) { java.lang.String path = cfg.getLocalStorePath ( ) . toString ( ) ; path = ( path.endsWith ( "/" ) ) ? path : path + "/" ; com.ericsson.gerrit.plugins.eventslog.sql.SQLClient sqlClient = new com.ericsson.gerrit.plugins.eventslog.sql.SQLClient ( cfg.getLocalStoreDriver ( ) , ( ( ( com.ericsson.gerrit.plugins.eventslog.sql.SQLModule.H2_DB_PREFIX ) + path ) + ( SQLTable.TABLE_NAME ) ) , cfg.getUrlOptions ( ) ) ; sqlClient.setEvictIdleTime ( cfg.getEvictIdleTime ( ) ) ; return sqlClient ; }
public void parseAuthor ( ) throws java.lang.Exception { assertParseSucceeds ( ( "Update change\n" + ( ( ( ( "\n" + "Branch: refs/heads/master\n" ) + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" ) + "Patch-set: 1\n" ) + "Subject: This is a test change\n" ) ) ) ; assertParseFails ( writeCommit ( ( "Update change\n" + ( "\n" + "Patch-set: 1\n" ) ) , new org.eclipse.jgit.lib.PersonIdent ( "Change Owner" , "owner@example.com" , serverIdent.getWhen ( ) , serverIdent.getTimeZone ( ) ) ) ) ; assertParseFails ( writeCommit ( ( "Update change\n" + ( "\n" + "Patch-set: 1\n" ) ) , new org.eclipse.jgit.lib.PersonIdent ( "Change Owner" , "x@gerrit" , serverIdent.getWhen ( ) , serverIdent.getTimeZone ( ) ) ) ) ; }
protected void configure ( ) { install ( new com.google.inject.assistedinject.FactoryModuleBuilder ( ) . implement ( com.google.gerrit.server.index.account.AccountIndex.class , com.google.gerrit.lucene.LuceneAccountIndex.class ) . build ( AccountIndex.Factory.class ) ) ; install ( new com.google.inject.assistedinject.FactoryModuleBuilder ( ) . implement ( com.google.gerrit.server.index.group.GroupIndex.class , com.google.gerrit.lucene.LuceneGroupIndex.class ) . build ( GroupIndex.Factory.class ) ) ; install ( new com.google.gerrit.pgm.init.index.IndexModuleOnInit ( ) ) ; }
public void testUnblockForce ( ) { com.google.gerrit.common.data.PermissionRule r = com.google.gerrit.server.project.Util.block ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/heads/*" ) ; r.setForce ( true ) ; com.google.gerrit.server.project.Util.allow ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.Util.DEVS , "refs/heads/*" ) . setForce ( true ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.project.Util.DEVS ) ; org.junit.Assert.assertTrue ( "u can force push" , u.controlForRef ( "refs/heads/master" ) . canForceUpdate ( ) ) ; }
public void setUp ( ) throws java.lang.Exception { super . setUp ( ) ; schemaFactory = org.easymock.EasyMock.createStrictMock ( com.google.gwtorm.server.SchemaFactory.class ) ; schema = org.easymock.EasyMock.createStrictMock ( com.google.gerrit.reviewdb.server.ReviewDb.class ) ; subscriptions = org.easymock.EasyMock.createStrictMock ( com.google.gerrit.reviewdb.server.SubmoduleSubscriptionAccess.class ) ; urlProvider = org.easymock.EasyMock.createStrictMock ( com.google.inject.Provider.class ) ; repoManager = org.easymock.EasyMock.createStrictMock ( com.google.gerrit.server.git.GitRepositoryManager.class ) ; replication = org.easymock.EasyMock.createStrictMock ( com.google.gerrit.server.extensions.events.GitReferenceUpdated.class ) ; }
public void testPostResponseOK ( ) throws java.lang.Exception { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.wireMockRule.givenThat ( com.github.tomakehurst.wiremock.client.WireMock.post ( com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo ( com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.ENDPOINT ) ) . willReturn ( com.github.tomakehurst.wiremock.client.WireMock.aResponse ( ) . withStatus ( com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.NO_CONTENT ) ) ) ; com.google.common.truth.Truth.assertThat ( httpSession.post ( com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.ENDPOINT ) . isSuccessful ( ) ) . isTrue ( ) ; }
private java.lang.String createServiceUserNote ( java.lang.String branch , com.googlesource.gerrit.plugins.serviceuser.GetServiceUser.ServiceUserInfo serviceUser ) throws com.google.gwtorm.server.OrmException { com.googlesource.gerrit.plugins.serviceuser.HeaderFormatter fmt = new com.googlesource.gerrit.plugins.serviceuser.HeaderFormatter ( gerritServerIdent.getTimeZone ( ) , anonymousCowardName ) ; fmt.appendDate ( ) ; fmt.append ( "Project" , project.get ( ) ) ; fmt.append ( "Branch" , branch ) ; fmt.appendUser ( com.googlesource.gerrit.plugins.serviceuser.CreateServiceUser.KEY_CREATED_BY , serviceUser.createdBy ) ; for ( com.google.gerrit.server.account.AccountInfo owner : serviceUserResolver.listOwners ( serviceUser ) ) { fmt.appendUser ( com.googlesource.gerrit.plugins.serviceuser.CreateServiceUser.KEY_OWNER , owner ) ; } return fmt.toString ( ) ; }
protected void configure ( ) { com.google.gerrit.extensions.registration.DynamicSet.bind ( binder ( ) , com.google.gerrit.common.ChangeListener.class ) . to ( com.googlesource.gerrit.plugins.reviewers.ChangeEventListener.class ) ; factory ( DefaultReviewers.Factory.class ) ; factory ( ReviewersConfig.Factory.class ) ; }
private static void sendError ( javax.servlet.http.HttpServletResponse rsp , int statusCode , java.lang.String message ) { try { rsp.sendError ( statusCode , message ) ; } catch ( java.io.IOException e ) { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.EventRestApiServlet.logger.error ( ( "Failed to send error messsage: " + ( e.getMessage ( ) ) ) , e ) ; } }
protected void add ( final com.google.gerrit.server.mail.RecipientType rt , final com.google.gerrit.reviewdb.Account.Id to ) { if ( ( ! ( emailOnlyAuthors ) ) || ( authors.contains ( to ) ) ) { super . add ( rt , to ) ; } }
public void testUnblockForceWithAllowNoForce_NotPossible ( ) { com.google.gerrit.common.data.PermissionRule r = com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/heads/*" ) ; r.setBlock ( ) ; r.setForce ( true ) ; com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.Util.DEVS , "refs/heads/*" ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.project.Util.DEVS ) ; org.junit.Assert.assertFalse ( "u can't force push" , u.controlForRef ( "refs/heads/master" ) . canForceUpdate ( ) ) ; }
public void onSuccess ( com.google.gerrit.client.changes.ChangeInfo info ) { info.revisions ( ) . copyKeysIntoChildren ( "name" ) ; com.google.gwt.core.client.JsArray < com.google.gerrit.client.changes.ChangeInfo.RevisionInfo > list = info.revisions ( ) . values ( ) ; com.google.gerrit.client.changes.ChangeInfo.RevisionInfo.sortRevisionInfoByNumber ( list ) ; diffTable.setUpPatchSetNav ( list , diff ) ; header.setChangeInfo ( info ) ; }
public void keyRevokedByExpiredKeyAfterExpirationIsNotRevoked ( ) throws java.lang.Exception { com.google.gerrit.gpg.testing.TestKey k = add ( com.google.gerrit.gpg.testing.TestKeys.keyRevokedByExpiredKeyAfterExpiration ( ) ) ; add ( com.google.gerrit.gpg.testing.TestKeys.expiredKey ( ) ) ; save ( ) ; com.google.gerrit.gpg.PublicKeyChecker checker = new com.google.gerrit.gpg.PublicKeyChecker ( ) . setStore ( store ) ; assertNoProblems ( checker , k ) ; }
public void inheritRead_AppendWithDenyOfRef ( ) { com.google.gerrit.server.project.Util.allow ( parent , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS , "refs/*" ) ; com.google.gerrit.server.project.Util.deny ( local , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS , "refs/heads/*" ) ; com.google.gerrit.server.project.ProjectControl u = user ( local ) ; assertCanAccess ( u ) ; assertCanRead ( "refs/master" , u ) ; assertCanRead ( "refs/tags/foobar" , u ) ; assertCanRead ( "refs/heads/master" , u ) ; }
private com.google.gerrit.server.mail.Address toAddress ( final com.google.gerrit.client.reviewdb.Account.Id id ) { final com.google.gerrit.client.reviewdb.Account a = accountCache.get ( id ) . getAccount ( ) ; final java.lang.String e = a.getPreferredEmail ( ) ; if ( e == null ) { return null ; } return new com.google.gerrit.server.mail.Address ( a.getFullName ( ) , e ) ; }
public int weigh ( com.google.gerrit.server.diff.PatchListKey key , com.google.gerrit.server.diff.PatchList value ) { int size = ( ( ( ( ( ( 16 + ( 4 * 8 ) ) + ( 2 * 36 ) ) + 8 ) + 16 ) + ( 3 * 8 ) ) + ( 3 * 4 ) ) + 20 ; for ( com.google.gerrit.server.diff.PatchListEntry e : value.getPatches ( ) ) { size += e.weigh ( ) ; } return size ; }
private com.google.gerrit.reviewdb.client.Change newChange ( ) { return com.google.gerrit.testutil.TestChanges.newChange ( project , changeOwner ) ; }
private void appendHunkHeader ( final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder m , final com.google.gerrit.common.data.EditList.Hunk hunk ) { openLine ( m ) ; padLineNumber ( m ) ; padLineNumber ( m ) ; m.openTd ( ) ; m.addStyleName ( Gerrit.RESOURCES.css ( ) . diffText ( ) ) ; m.addStyleName ( Gerrit.RESOURCES.css ( ) . diffTextHunkHeader ( ) ) ; m.append ( "@@ -" ) ; appendRange ( m , ( ( hunk.getCurA ( ) ) + 1 ) , ( ( hunk.getEndA ( ) ) - ( hunk.getCurA ( ) ) ) ) ; m.append ( " +" ) ; appendRange ( m , ( ( hunk.getCurB ( ) ) + 1 ) , ( ( hunk.getEndB ( ) ) - ( hunk.getCurB ( ) ) ) ) ; m.append ( " @@" ) ; m.closeTd ( ) ; closeLine ( m ) ; }
public boolean exists ( final java.lang.String bugId ) throws java.io.IOException { return execute ( new java.util.concurrent.Callable < java.lang.Boolean > ( ) { @ java.lang.Override public java.lang.Boolean call ( ) throws java.lang.Exception { return ( client ( ) . getBug ( bugId ) ) != null ; } } ) ; }
private static void initLogSystem ( java.nio.file.Path logdir ) { org.apache.log4j.Logger gcLogger = org.apache.log4j.LogManager.getLogger ( GarbageCollection.LOG_NAME ) ; gcLogger.removeAllAppenders ( ) ; gcLogger.addAppender ( com.google.gerrit.server.util.SystemLog.createAppender ( logdir , GarbageCollection.LOG_NAME , new org.apache.log4j.PatternLayout ( "[%d] %-5p %x: %m%n" ) ) ) ; gcLogger.setAdditivity ( false ) ; }
private void login ( javax.servlet.ServletRequest request , javax.servlet.http.HttpServletRequest httpRequest , javax.servlet.http.HttpServletResponse httpResponse , com.googlesource.gerrit.plugins.github.oauth.GitHubLogin ghLogin ) throws java.io.IOException { if ( ghLogin.login ( httpRequest , httpResponse , oauth ) ) { org.kohsuke.github.GHMyself myself = ghLogin.getMyself ( ) ; java.lang.String user = myself.getLogin ( ) ; updateSecureConfigWithRetry ( ghLogin.getHub ( ) . getMyOrganizations ( ) . keySet ( ) , user , ghLogin.getToken ( ) . accessToken ) ; } }
private static java.util.Collection < java.security.PublicKey > computeHostKeys ( ) { final org.apache.sshd.common.KeyPairProvider p = com.google.gerrit.server.ssh.GerritSshDaemon.sshd.getKeyPairProvider ( ) ; final java.util.List < java.security.PublicKey > keys = new java.util.ArrayList < java.security.PublicKey > ( 2 ) ; com.google.gerrit.server.ssh.GerritSshDaemon.addPublicKey ( keys , p , KeyPairProvider.SSH_DSS ) ; com.google.gerrit.server.ssh.GerritSshDaemon.addPublicKey ( keys , p , KeyPairProvider.SSH_RSA ) ; return java.util.Collections.unmodifiableList ( keys ) ; }
public void setUp ( ) throws java.lang.Exception { index = new com.google.gerrit.server.index.change.FakeChangeIndex ( FakeChangeIndex.V2 ) ; indexes = new com.google.gerrit.server.index.change.ChangeIndexCollection ( ) ; indexes.setSearchIndex ( index ) ; queryBuilder = new com.google.gerrit.server.index.change.FakeQueryBuilder ( indexes ) ; rewrite = new com.google.gerrit.server.index.change.ChangeIndexRewriter ( indexes , com.google.gerrit.index.IndexConfig.builder ( ) . maxTerms ( 3 ) . build ( ) ) ; }
public com.google.gerrit.extensions.common.GroupInfo format ( com.google.gerrit.server.group.GroupResource rsrc ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.extensions.common.GroupInfo info = init ( rsrc.getGroup ( ) ) ; initMembersAndIncludes ( rsrc , info ) ; return info ; }
public void configure ( ) { factory ( ChangeUpdate.Factory.class ) ; bind ( com.google.gerrit.server.IdentifiedUser.class ) . toInstance ( user ) ; }
public void createdOnIsPopulatedForGroupsCreatedAfterAudit ( ) throws java.lang.Exception { java.sql.Timestamp testStartTime = com.google.gerrit.common.TimeUtil.nowTs ( ) ; com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = createGroup ( "Group for schema migration" ) ; setCreatedOnToVeryOldTimestamp ( groupId ) ; schema151.migrateData ( db , new com.google.gerrit.testutil.TestUpdateUI ( ) ) ; java.sql.Timestamp createdOn = getCreatedOn ( groupId ) ; com.google.common.truth.Truth.assertThat ( createdOn ) . isAtLeast ( testStartTime ) ; }
public com.google.gerrit.server.account.GroupControl controlFor ( final com.google.gerrit.reviewdb.client.AccountGroup.Id groupId ) throws com.google.gerrit.common.errors.NoSuchGroupException { final com.google.gerrit.reviewdb.client.AccountGroup group = groupCache.get ( groupId ) ; if ( group == null ) { throw new com.google.gerrit.common.errors.NoSuchGroupException ( groupId ) ; } return controlFor ( com.google.gerrit.common.data.GroupDescriptions.forAccountGroup ( group ) ) ; }
java.util.List < com.google.gerrit.extensions.common.AccountInfo > listActiveOwners ( com.googlesource.gerrit.plugins.serviceuser.GetServiceUser.ServiceUserInfo serviceUser ) throws com.google.gwtorm.server.OrmException { java.util.List < com.google.gerrit.extensions.common.AccountInfo > activeOwners = new java.util.ArrayList < > ( ) ; for ( com.google.gerrit.extensions.common.AccountInfo owner : listOwners ( serviceUser ) ) { com.google.gerrit.server.account.AccountState accountState = accountCache.get ( new com.google.gerrit.reviewdb.client.Account.Id ( owner._accountId ) ) ; if ( ( accountState != null ) && ( accountState.getAccount ( ) . isActive ( ) ) ) { activeOwners.add ( owner ) ; } } return activeOwners ; }
protected void setPageTitle ( final java.lang.String text ) { final java.lang.String old = headerText.getText ( ) ; if ( text.isEmpty ( ) ) { header.setVisible ( false ) ; } else { headerText.setText ( text ) ; header.setVisible ( true ) ; } if ( ( ( windowTitle ) == null ) || ( ( windowTitle ) == old ) ) { setWindowTitle ( text ) ; } }
public void testInheritRead_OverrideWithDeny ( ) { grant ( parent , com.google.gerrit.common.data.Permission.READ , registered , "refs/*" ) ; grant ( local , com.google.gerrit.common.data.Permission.READ , registered , "refs/*" ) . setDeny ( true ) ; com.google.gerrit.server.project.ProjectControl u = user ( ) ; assertFalse ( "can't read" , u.isVisible ( ) ) ; }
private void fireEvent ( com.google.gerrit.reviewdb.client.Change change , com.google.gerrit.server.events.ChangeEvent event , com.google.gerrit.reviewdb.server.ReviewDb db ) throws com.google.gwtorm.server.OrmException { for ( com.google.gerrit.common.UserScopedEventListener listener : listeners ) { if ( isVisibleTo ( change , listener.getUser ( ) , db ) ) { listener.onEvent ( event ) ; } } fireEventForUnrestrictedListeners ( event ) ; }
public com.googlesource.gerrit.plugins.verifystatus.server.GetConfig.ConfigInfo apply ( com.google.gerrit.server.config.ConfigResource resource ) { com.googlesource.gerrit.plugins.verifystatus.server.GetConfig.ConfigInfo info = new com.googlesource.gerrit.plugins.verifystatus.server.GetConfig.ConfigInfo ( ) ; info.showJobsPanel = cfg.getBoolean ( "showJobsPanel" , true ) ; info.showJobsDropDownPanel = cfg.getBoolean ( "showJobsDropDownPanel" , true ) ; info.showJobsSummaryPanel = cfg.getBoolean ( "showJobsSummaryPanel" , true ) ; info.sortJobsPanel = cfg.getEnum ( com.googlesource.gerrit.plugins.verifystatus.server.JobsSorting.values ( ) , "sortJobsPanel" , JobsSorting.REPORTER ) ; info.sortJobsDropDownPanel = cfg.getEnum ( com.googlesource.gerrit.plugins.verifystatus.server.JobsSorting.values ( ) , "sortJobsDropDownPanel" , JobsSorting.REPORTER ) ; return info ; }
void onDiscard ( com.google.gwt.event.dom.client.ClickEvent e ) { e.stopPropagation ( ) ; if ( isNew ( ) ) { removeUI ( ) ; restoreSelection ( ) ; } else { setEdit ( false ) ; com.google.gerrit.client.changes.CommentApi.deleteDraft ( psId , comment.id ( ) , new com.google.gerrit.client.rpc.GerritCallback < com.google.gwt.core.client.JavaScriptObject > ( ) { @ java.lang.Override public void onSuccess ( com.google.gwt.core.client.JavaScriptObject result ) { removeUI ( ) ; } } ) ; } }
private void createFileCommentBorderRow ( ) { if ( ! ( isFileCommentBorderRowExist ) ) { isFileCommentBorderRowExist = true ; table.insertRow ( borderRowOfFileComment ) ; final com.google.gwt.user.client.ui.HTMLTable.CellFormatter fmt = table.getCellFormatter ( ) ; fmt.addStyleName ( borderRowOfFileComment , com.google.gerrit.client.patches.C_ARROW , Gerrit.RESOURCES.css ( ) . iconCellOfFileCommentRow ( ) ) ; defaultStyle ( borderRowOfFileComment , fmt ) ; final com.google.gwt.user.client.Element iconCell = fmt.getElement ( borderRowOfFileComment , com.google.gerrit.client.patches.C_ARROW ) ; com.google.gwt.user.client.ui.UIObject.setStyleName ( com.google.gwt.user.client.DOM.getParent ( iconCell ) , Gerrit.RESOURCES.css ( ) . fileCommentBorder ( ) , true ) ; } }
protected void insertRow ( final int row ) { super . insertRow ( row ) ; final com.google.gwt.user.client.ui.HTMLTable.CellFormatter fmt = table.getCellFormatter ( ) ; fmt.addStyleName ( row , ( ( com.google.gerrit.client.patches.UnifiedDiffTable.PC ) - 2 ) , Gerrit.RESOURCES.css ( ) . lineNumber ( ) ) ; fmt.addStyleName ( row , ( ( com.google.gerrit.client.patches.UnifiedDiffTable.PC ) - 1 ) , Gerrit.RESOURCES.css ( ) . lineNumber ( ) ) ; fmt.addStyleName ( row , com.google.gerrit.client.patches.UnifiedDiffTable.PC , Gerrit.RESOURCES.css ( ) . diffText ( ) ) ; }
void display ( final java.util.Map < com.google.gerrit.reviewdb.AccountGroup.Id , com.google.gerrit.reviewdb.AccountGroup > groups , final java.util.List < com.google.gerrit.common.data.InheritedRefRight > refRights ) { while ( 1 < ( table.getRowCount ( ) ) ) table.removeRow ( ( ( table.getRowCount ( ) ) - 1 ) ) ; for ( final com.google.gerrit.common.data.InheritedRefRight r : refRights ) { final int row = table.getRowCount ( ) ; table.insertRow ( row ) ; applyDataRowStyle ( row ) ; populate ( row , groups , r ) ; } }
void cleanup ( ) { try { jarFile.close ( ) ; } catch ( java.io.IOException err ) { } if ( ( ! ( tmpFile.delete ( ) ) ) && ( tmpFile.exists ( ) ) ) { PluginLoader.log.warn ( ( "Cannot delete " + ( tmpFile.getAbsolutePath ( ) ) ) ) ; } else { PluginLoader.log.info ( ( "Cleaned plugin " + ( tmpFile.getName ( ) ) ) ) ; } }
public void updateSchema ( final com.google.gwtorm.server.StatementExecutor e ) throws com.google.gwtorm.server.OrmException { try { createSequences ( e ) ; createRelations ( e ) ; for ( final com.google.gwtorm.schema.RelationModel rel : dbDef.getSchemaModel ( ) . getRelations ( ) ) { addColumns ( e , rel ) ; } } catch ( java.sql.SQLException err ) { throw new com.google.gwtorm.server.OrmException ( "Cannot update schema" , err ) ; } }
public void execute ( ) { int h = ( com.google.gerrit.client.Gerrit.getHeaderFooterHeight ( ) ) + ( reviewed.getOffsetHeight ( ) ) ; if ( ( cmA ) != null ) { cmA.setHeight ( ( ( com.google.gwt.user.client.Window.getClientHeight ( ) ) - h ) ) ; cmA.setOption ( "viewportMargin" , 10 ) ; } if ( ( cmB ) != null ) { cmB.setHeight ( ( ( com.google.gwt.user.client.Window.getClientHeight ( ) ) - h ) ) ; cmB.setOption ( "viewportMargin" , 10 ) ; } }
private void populateReviewAction ( ) { final com.google.gwt.user.client.ui.Button b = new com.google.gwt.user.client.ui.Button ( Util.C.buttonReview ( ) ) ; b.addClickHandler ( new com.google.gwt.event.dom.client.ClickHandler ( ) { @ java.lang.Override public void onClick ( final com.google.gwt.event.dom.client.ClickEvent event ) { com.google.gerrit.client.Gerrit.display ( ( "change,publish," + ( patchSet.getId ( ) . toString ( ) ) ) , new com.google.gerrit.client.changes.PublishCommentScreen ( patchSet.getId ( ) ) ) ; } } ) ; actionsPanel.add ( b ) ; }
public com.google.gerrit.server.account.AccountInfo get ( com.google.gerrit.reviewdb.client.Account.Id id ) { if ( id == null ) { return null ; } com.google.gerrit.server.account.AccountInfo info = created.get ( id ) ; if ( info == null ) { info = new com.google.gerrit.server.account.AccountInfo ( id ) ; if ( detailed ) { info._accountId = id.get ( ) ; } created.put ( id , info ) ; } return info ; }
public java.lang.String toString ( ) { return predicate.toString ( ) ; }
protected PushOneCommit.Result amendChange ( java.lang.String changeId , java.lang.String ref ) throws java.lang.Exception { return amendChange ( changeId , ref , admin , testRepo ) ; }
private void cleanInBackground ( ) { int cnt = java.lang.Math.max ( 0 , ( ( cleanupHandles.size ( ) ) - ( running.size ( ) ) ) ) ; if ( 0 < cnt ) { cleaner.get ( ) . clean ( cnt ) ; } }
private void assertParseFails ( org.eclipse.jgit.revwalk.RevCommit commit ) throws java.lang.Exception { try ( com.google.gerrit.server.notedb.ChangeNotesParser parser = newParser ( commit ) ) { parser.parseAll ( ) ; org.junit.Assert.fail ( ( "Expected parse to fail:\n" + ( commit.getFullMessage ( ) ) ) ) ; } catch ( org.eclipse.jgit.errors.ConfigInvalidException e ) { } }
void set ( com.google.gerrit.client.info.ChangeInfo info ) { this . changeId = info.legacyId ( ) ; this . project = info.projectNameKey ( ) ; display ( info ) ; reviewerSuggestOracle.setChange ( project , changeId ) ; addReviewerIcon.setVisible ( com.google.gerrit.client.Gerrit.isSignedIn ( ) ) ; }
public void setUp ( ) throws java.lang.Exception { super . setUp ( ) ; final com.google.gerrit.common.data.ApprovalTypes types = new com.google.gerrit.common.data.ApprovalTypes ( java.util.Arrays.asList ( com.google.gerrit.rules.GerritCommonTest.codeReviewCategory ( ) , com.google.gerrit.rules.GerritCommonTest.verifiedCategory ( ) ) ) ; load ( "gerrit" , "gerrit_common_test.pl" , new com.google.inject.AbstractModule ( ) { @ java.lang.Override protected void configure ( ) { bind ( com.google.gerrit.common.data.ApprovalTypes.class ) . toInstance ( types ) ; } } ) ; }
public java.util.Collection < com.google.gerrit.reviewdb.PatchSetApproval > currentApprovals ( com.google.inject.Provider < com.google.gerrit.reviewdb.ReviewDb > db ) throws com.google.gwtorm.client.OrmException { if ( ( currentApprovals ) == null ) { com.google.gerrit.reviewdb.Change c = change ( db ) ; if ( c == null ) { currentApprovals = java.util.Collections.emptyList ( ) ; } else { currentApprovals = approvalsFor ( db , c.currentPatchSetId ( ) ) ; } } return currentApprovals ; }
protected void onRequestSuggestions ( com.google.gerrit.client.ui.Request req , com.google.gerrit.client.ui.Callback cb ) { if ( ( req.getQuery ( ) . length ( ) ) >= ( com.google.gerrit.client.Gerrit.info ( ) . suggest ( ) . from ( ) ) ) { _onRequestSuggestions ( req , cb ) ; } else { java.util.List < com.google.gerrit.client.ui.Suggestion > none = java.util.Collections.emptyList ( ) ; cb.onSuggestionsReady ( req , new com.google.gerrit.client.ui.Response ( none ) ) ; } }
private void addPermission ( final java.lang.String permissionName , final java.util.List < java.lang.String > permissionList ) { if ( ( value.getPermission ( permissionName ) ) != null ) { return ; } if ( ( com.google.gerrit.client.Gerrit.info ( ) . gerrit ( ) . isAllProjects ( projectAccess.getProjectName ( ) ) ) && ( ! ( com.google.gerrit.common.data.Permission.canBeOnAllProjects ( value.getName ( ) , permissionName ) ) ) ) { return ; } permissionList.add ( permissionName ) ; }
public void setParent_Forbidden ( ) throws com.jcraft.jsch.JSchException , java.io.IOException { java.lang.String parent = "parent" ; com.google.gerrit.acceptance.GitUtil.createProject ( sshSession , parent , null , true ) ; com.google.gerrit.acceptance.RestResponse r = userSession.put ( ( ( "/projects/" + ( project ) ) + "/parent" ) , new com.google.gerrit.acceptance.rest.project.SetParentIT.ParentInput ( parent ) ) ; org.junit.Assert.assertEquals ( HttpStatus.SC_FORBIDDEN , r.getStatusCode ( ) ) ; r.consume ( ) ; }
void addHashtag ( java.lang.String token ) throws org.kohsuke.args4j.CmdLineException { if ( ! ( notesMigration.readChanges ( ) ) ) { throw clp.reject ( "cannot add hashtags; noteDb is disabled" ) ; } java.lang.String hashtag = com.google.gerrit.server.change.HashtagsUtil.cleanupHashtag ( token ) ; if ( ! ( hashtag.isEmpty ( ) ) ) { hashtags.add ( hashtag ) ; } }
private void initIgnoreWhitespace ( com.google.gwt.user.client.ui.ListBox ws ) { ws.addItem ( PatchUtil.C.whitespaceIGNORE_NONE ( ) , Whitespace.IGNORE_NONE.name ( ) ) ; ws.addItem ( PatchUtil.C.whitespaceIGNORE_TRAILING ( ) , Whitespace.IGNORE_TRAILING.name ( ) ) ; ws.addItem ( PatchUtil.C.whitespaceIGNORE_LEADING_AND_TRAILING ( ) , Whitespace.IGNORE_LEADING_AND_TRAILING.name ( ) ) ; ws.addItem ( PatchUtil.C.whitespaceIGNORE_ALL ( ) , Whitespace.IGNORE_ALL.name ( ) ) ; }
private com.google.gerrit.extensions.api.changes.AddReviewerResult putAccount ( java.lang.String reviewer , com.google.gerrit.server.change.ReviewerResource rsrc , com.google.gerrit.extensions.client.ReviewerState state ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.git.UpdateException , com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Account member = rsrc.getReviewerUser ( ) . getAccount ( ) ; com.google.gerrit.server.project.ChangeControl control = rsrc.getReviewerControl ( ) ; com.google.gerrit.extensions.api.changes.AddReviewerResult result = new com.google.gerrit.extensions.api.changes.AddReviewerResult ( reviewer ) ; if ( isValidReviewer ( member , control ) ) { addReviewers ( rsrc.getChangeResource ( ) , result , com.google.common.collect.ImmutableMap.of ( member.getId ( ) , control ) , state ) ; } return result ; }
static com.google.gerrit.reviewdb.server.ReviewDb unwrap ( com.google.gerrit.reviewdb.server.ReviewDb db ) { if ( db instanceof com.google.gerrit.server.git.BatchUpdateReviewDb ) { db = ( ( com.google.gerrit.server.git.BatchUpdateReviewDb ) ( db ) ) . unsafeGetDelegate ( ) ; } return com.google.gerrit.reviewdb.server.ReviewDbUtil.unwrapDb ( db ) ; }
public java.lang.Boolean call ( ) throws com.google.gerrit.server.permissions.PermissionBackendException , com.google.gerrit.server.project.NoSuchProjectException { com.google.gerrit.server.project.ProjectControl projectControl = controlFor ( project ) ; if ( ! ( shouldReplicate ( projectControl ) ) ) { return false ; } if ( PushOne.ALL_REFS.equals ( ref ) ) { return true ; } try { permissionBackend.user ( projectControl.getUser ( ) ) . project ( project ) . ref ( ref ) . check ( RefPermission.READ ) ; } catch ( com.google.gerrit.extensions.restapi.AuthException e ) { return false ; } return true ; }
private synchronized void runHook ( com.google.common.base.Optional < java.nio.file.Path > hook , java.util.List < java.lang.String > args ) { if ( hook.isPresent ( ) ) { hookQueue.execute ( new com.google.gerrit.common.ChangeHookRunner.AsyncHookTask ( null , hook.get ( ) , args ) ) ; } }
void select ( ) { copyLabel.setText ( command ) ; com.google.gerrit.client.download.DownloadCommandPanel parent = ( ( com.google.gerrit.client.download.DownloadCommandPanel ) ( getParent ( ) ) ) ; for ( com.google.gwt.user.client.ui.Widget w : parent ) { if ( ( w != ( this ) ) && ( w instanceof com.google.gerrit.client.download.DownloadCommandLink ) ) { w.removeStyleName ( Gerrit.RESOURCES.css ( ) . downloadLink_Active ( ) ) ; } } parent.setCurrentCommand ( this ) ; addStyleName ( Gerrit.RESOURCES.css ( ) . downloadLink_Active ( ) ) ; }
public void missingGroupNameRef ( ) throws java.lang.Exception { try ( org.eclipse.jgit.lib.Repository repo = repoManager.openRepository ( allUsers ) ) { org.eclipse.jgit.lib.RefUpdate ru = repo.updateRef ( RefNames.REFS_GROUPNAMES ) ; ru.setForceUpdate ( true ) ; org.eclipse.jgit.lib.RefUpdate.Result result = ru.delete ( ) ; com.google.common.truth.Truth.assertThat ( result ) . isEqualTo ( Result.FORCED ) ; } assertError ( "refs/meta/group-names does not exist" ) ; }
private void addSuggestion ( java.util.Map < com.google.gerrit.reviewdb.Account.Id , com.google.gerrit.common.data.AccountInfo > map , com.google.gerrit.reviewdb.Account account , com.google.gerrit.common.data.AccountInfo info , java.lang.Boolean active ) { if ( ( active == null ) || ( active == ( account.isActive ( ) ) ) ) { map.put ( account.getId ( ) , info ) ; } }
public java.util.Collection < com.google.gwtorm.schema.ColumnModel > getDependentFields ( ) { final java.util.ArrayList < com.google.gwtorm.schema.ColumnModel > r = new java.util.ArrayList < com.google.gwtorm.schema.ColumnModel > ( ) ; for ( final com.google.gwtorm.schema.ColumnModel c : fieldsByFieldName.values ( ) ) { if ( ( ! ( c.rowVersion ) ) && ( ( ( primaryKey ) == null ) || ( ( primaryKey.getField ( ) ) != c ) ) ) { r.add ( c ) ; } } return r ; }
public void testParseWComments ( ) throws java.lang.Exception { com.google.gerrit.server.account.DestinationList dl = new com.google.gerrit.server.account.DestinationList ( ) ; dl.parseLabel ( com.google.gerrit.server.account.DestinationListTest.LABEL , ( ( ( com.google.gerrit.server.account.DestinationListTest.C1 ) + ( com.google.gerrit.server.account.DestinationListTest.F_SIMPLE ) ) + ( com.google.gerrit.server.account.DestinationListTest.C2 ) ) , null ) ; java.util.Set < com.google.gerrit.reviewdb.client.Branch.NameKey > branches = dl.getDestinations ( com.google.gerrit.server.account.DestinationListTest.LABEL ) ; com.google.common.truth.Truth.assertThat ( branches ) . containsExactlyElementsIn ( com.google.gerrit.server.account.DestinationListTest.D_SIMPLE ) ; }
public void insertComment ( com.google.gerrit.reviewdb.client.PatchLineComment comment ) throws com.google.gwtorm.server.OrmException { if ( ( comment.getStatus ( ) ) == ( com.google.gerrit.reviewdb.client.PatchLineComment.Status.DRAFT ) ) { insertDraftComment ( comment ) ; } else { insertPublishedComment ( comment ) ; } }
protected void run ( java.lang.String [ ] args ) throws com.google.gerrit.server.ssh.Failure { final com.google.gerrit.client.data.GroupCache gc = com.google.gerrit.client.rpc.Common.getGroupCache ( ) ; if ( gc.isAdministrator ( getAccountId ( ) ) ) { gc.flush ( ) ; com.google.gerrit.client.rpc.Common.getProjectCache ( ) . flush ( ) ; } else { throw new com.google.gerrit.server.ssh.Failure ( 1 , "fatal: Not a Gerrit administrator" ) ; } }
public void run ( ) { net.codemirror.lib.CodeMirror.LineHandle handle = cm.extras ( ) . activeLine ( ) ; int line = ( cm.getLineNumber ( handle ) ) + 1 ; if ( Patch.COMMIT_MSG.equals ( path ) ) { line = adjustCommitMessageLine ( line ) ; } java.lang.String token = com.google.gerrit.client.Dispatcher.toEditScreen ( revision , path , line ) ; if ( ! ( com.google.gerrit.client.Gerrit.isSignedIn ( ) ) ) { com.google.gerrit.client.Gerrit.doSignIn ( token ) ; } else { com.google.gerrit.client.Gerrit.display ( token ) ; } }
void onReply ( com.google.gwt.event.dom.client.ClickEvent e ) { e.stopPropagation ( ) ; if ( ! ( com.google.gerrit.client.Gerrit.isSignedIn ( ) ) ) { com.google.gerrit.client.Gerrit.doSignIn ( parent.getToken ( ) ) ; } else if ( ( replyBox ) == null ) { registerReplyBox ( parent.addDraftBox ( parent.createReply ( comment ) ) ) ; } else { openReplyBox ( ) ; } }
public static synchronized java.nio.file.FileSystem getZipFileSystem ( java.nio.file.Path zip ) throws java.io.IOException { zip = zip.toRealPath ( ) ; java.nio.file.FileSystem zipFs = com.google.gerrit.launcher.GerritLauncher.zipFileSystems.get ( zip ) ; if ( zipFs == null ) { zipFs = com.google.gerrit.launcher.GerritLauncher.newZipFileSystem ( zip ) ; com.google.gerrit.launcher.GerritLauncher.zipFileSystems.put ( zip , zipFs ) ; } return zipFs ; }
public void createNewChangeWithChangeId ( ) throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInput ci = newChangeInput ( ChangeStatus.NEW ) ; java.lang.String changeId = "I1234000000000000000000000000000000000000" ; java.lang.String changeIdLine = "Change-Id: " + changeId ; ci.subject = "Subject\n\n" + changeIdLine ; com.google.gerrit.extensions.common.ChangeInfo info = assertCreateSucceeds ( ci ) ; com.google.common.truth.Truth.assertThat ( info.changeId ) . isEqualTo ( changeId ) ; com.google.common.truth.Truth.assertThat ( info.revisions.get ( info.currentRevision ) . commit.message ) . contains ( changeIdLine ) ; }
public UiAction.Description getDescription ( com.google.gerrit.server.change.ChangeResource rsrc ) { try { return new com.google.gerrit.extensions.webui.UiAction.Description ( ) . setTitle ( java.lang.String.format ( "Delete draft change %d" , rsrc.getChange ( ) . getChangeId ( ) ) ) . setVisible ( ( ( ( rsrc.getChange ( ) . getStatus ( ) ) == ( com.google.gerrit.reviewdb.client.Change.Status.DRAFT ) ) && ( rsrc.getControl ( ) . canDeleteDraft ( dbProvider.get ( ) ) ) ) ) ; } catch ( com.google.gwtorm.server.OrmException e ) { throw new java.lang.IllegalStateException ( e ) ; } }
void updateMeter ( ) { if ( ( meter ) != null ) { final int n = list.size ( ) ; meter.setValue ( ( ( 100 * ( ( ( stage ) * n ) + ( row ) ) ) / ( 2 * n ) ) ) ; } }
private java.lang.String buildJsonRaw ( java.lang.String path ) throws java.lang.Exception { com.google.gitiles.FakeHttpServletResponse res = buildResponse ( path , "format=json" , javax.servlet.http.HttpServletResponse.SC_OK ) ; com.google.common.truth.Truth.assertThat ( res.getHeader ( com.google.common.net.HttpHeaders.CONTENT_TYPE ) ) . isEqualTo ( "application/json" ) ; java.lang.String body = res.getActualBodyString ( ) ; java.lang.String magic = ")]}\'\n" ; com.google.common.truth.Truth.assertThat ( body ) . startsWith ( magic ) ; return body.substring ( magic.length ( ) ) ; }
private boolean match ( org.eclipse.jgit.lib.Repository repo , java.util.Set < com.google.gerrit.server.index.RefState > expected ) throws java.io.IOException { for ( org.eclipse.jgit.lib.Ref r : repo.getRefDatabase ( ) . getRefs ( prefix ( ) ) . values ( ) ) { if ( ! ( match ( r.getName ( ) ) ) ) { continue ; } if ( ! ( expected.contains ( com.google.gerrit.server.index.RefState.of ( r ) ) ) ) { return false ; } } return true ; }
public void commentOnReviewableChangeByOwner ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange ( ) ; review ( sc.owner , sc.changeId , com.google.gerrit.extensions.client.GeneralPreferencesInfo.EmailStrategy.ENABLED ) ; assertThat ( sender ) . sent ( "comment" , sc ) . cc ( sc.reviewer , sc.ccer ) . cc ( sc.reviewerByEmail , sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS ) . noOneElse ( ) ; }
protected void configure ( ) { itsConfig = createMock ( com.googlesource.gerrit.plugins.its.base.its.ItsConfig.class ) ; bind ( com.googlesource.gerrit.plugins.its.base.its.ItsConfig.class ) . toInstance ( itsConfig ) ; commitMessageFetcher = createMock ( com.googlesource.gerrit.plugins.its.base.util.CommitMessageFetcher.class ) ; bind ( com.googlesource.gerrit.plugins.its.base.util.CommitMessageFetcher.class ) . toInstance ( commitMessageFetcher ) ; db = createMock ( com.googlesource.gerrit.plugins.its.base.util.IssueExtractor.PatchSetDb.class ) ; bind ( com.googlesource.gerrit.plugins.its.base.util.IssueExtractor.PatchSetDb.class ) . toInstance ( db ) ; }
public java.util.Set < com.google.gerrit.reviewdb.client.AccountGroup.UUID > guessRelevantGroupUUIDs ( ) { java.util.Set < com.google.gerrit.reviewdb.client.AccountGroup.UUID > groups = new java.util.HashSet < > ( ) ; for ( com.google.gerrit.reviewdb.client.Project.NameKey n : all ( ) ) { com.google.gerrit.server.project.ProjectState p = byName.getIfPresent ( n.get ( ) ) ; if ( p != null ) { groups.addAll ( p.getConfig ( ) . getAllGroupUUIDs ( ) ) ; } } return groups ; }
private boolean isChangeReviewed ( com.google.gerrit.reviewdb.client.Account.Id self , com.google.gerrit.server.query.change.ChangeData cd , java.lang.Iterable < com.google.gerrit.reviewdb.client.ChangeMessage > msgs ) throws com.google.gwtorm.server.OrmException { java.util.List < com.google.gerrit.reviewdb.client.ChangeMessage > reversed = ChangeNotes.MESSAGE_BY_TIME.reverse ( ) . sortedCopy ( msgs ) ; com.google.gerrit.reviewdb.client.Account.Id changeOwnerId = cd.change ( ) . getOwner ( ) ; for ( com.google.gerrit.reviewdb.client.ChangeMessage cm : reversed ) { if ( self.equals ( cm.getAuthor ( ) ) ) { return true ; } else if ( changeOwnerId.equals ( cm.getAuthor ( ) ) ) { return false ; } } return false ; }
private static boolean sameUpdate ( com.google.gerrit.server.notedb.ChangeRebuilder.Event event , com.google.gerrit.server.notedb.AbstractChangeUpdate update ) { return ( ( ( ( update != null ) && ( ( com.google.gerrit.server.notedb.ChangeRebuilder.round ( event.when ) ) == ( com.google.gerrit.server.notedb.ChangeRebuilder.round ( update.getWhen ( ) ) ) ) ) && ( event.who.equals ( update.getUser ( ) . getAccountId ( ) ) ) ) && ( event.psId.equals ( update.getPatchSetId ( ) ) ) ) && ( ! ( event instanceof com.google.gerrit.server.notedb.ChangeRebuilder.FinalUpdatesEvent ) ) ; }
public void addMultipleIncludes ( ) throws java.lang.Exception { java.lang.String p = createGroup ( "parent" ) ; java.lang.String g1 = createGroup ( "newGroup1" ) ; java.lang.String g2 = createGroup ( "newGroup2" ) ; java.util.List < java.lang.String > groups = com.google.common.collect.Lists.newLinkedList ( ) ; groups.add ( g1 ) ; groups.add ( g2 ) ; gApi.groups ( ) . id ( p ) . addGroups ( g1 , g2 ) ; assertIncludes ( p , g1 , g2 ) ; }
void onRefReplicatedToOneNode ( java.lang.String project , java.lang.String ref , org.eclipse.jgit.transport.URIish uri , com.googlesource.gerrit.plugins.replication.ReplicationState.RefPushResult status , org.eclipse.jgit.transport.RemoteRefUpdate.Status refStatus ) { com.googlesource.gerrit.plugins.replication.RefReplicatedEvent event = new com.googlesource.gerrit.plugins.replication.RefReplicatedEvent ( project , ref , com.googlesource.gerrit.plugins.replication.PushResultProcessing.resolveNodeName ( uri ) , status , refStatus ) ; postEvent ( project , ref , event ) ; }
public void mergeByOtherCcingSelfNotifyOwner ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageChange ( ) ; setEmailStrategy ( other , EmailStrategy.CC_ON_OWN_COMMENTS ) ; merge ( sc.changeId , other , com.google.gerrit.extensions.api.changes.NotifyHandling.OWNER ) ; assertThat ( sender ) . sent ( "merged" , sc ) . to ( sc.owner ) . noOneElse ( ) ; }
public static java.lang.String getTargetOAuthFinal ( javax.servlet.http.HttpServletRequest httpRequest ) { java.lang.String targetUrl = com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.getTargetUrl ( httpRequest ) ; java.lang.String code = com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.getURLEncoded ( httpRequest.getParameter ( "code" ) ) ; java.lang.String state = com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.getURLEncoded ( httpRequest.getParameter ( "state" ) ) ; return ( ( ( ( targetUrl + ( ( targetUrl.indexOf ( '?' ) ) < 0 ? '?' : '&' ) ) + "code=" ) + code ) + "&state=" ) + state ; }
private boolean canCreateChanges ( ) { for ( com.google.gerrit.server.project.SectionMatcher matcher : access ( ) ) { com.google.gerrit.common.data.AccessSection section = matcher.section ; if ( section.getName ( ) . startsWith ( "refs/for/" ) ) { com.google.gerrit.common.data.Permission permission = section.getPermission ( Permission.PUSH ) ; if ( ( permission != null ) && ( controlForRef ( section.getName ( ) ) . canPerform ( Permission.PUSH ) ) ) { return true ; } } } return false ; }
private boolean eq ( com.google.gerrit.reviewdb.AccountGroup.UUID a , com.google.gerrit.reviewdb.AccountGroup.UUID b ) { return ( ( a != null ) && ( b != null ) ) && ( a.equals ( b ) ) ; }
public void queryChangesOwnerWithDifferentUsers ( ) throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange ( ) ; com.google.common.truth.Truth.assertThat ( com.google.common.collect.Iterables.getOnlyElement ( query ( "owner:self" ) ) . changeId ) . isEqualTo ( r.getChangeId ( ) ) ; setApiUser ( user ) ; com.google.common.truth.Truth.assertThat ( query ( "owner:self" ) . isEmpty ( ) ) . isTrue ( ) ; }
public byte [ ] encodeToByteArray ( T obj ) { byte [ ] data = new byte [ sizeof ( obj ) ] ; encode ( obj , data ) ; return data ; }
protected void init ( ) throws com.google.gerrit.common.errors.EmailException { super . init ( ) ; if ( ( fromId ) != null ) { reviewers.remove ( fromId ) ; } add ( RecipientType.TO , reviewers ) ; add ( RecipientType.CC , extraCC ) ; rcptToAuthors ( RecipientType.CC ) ; bccStarredBy ( ) ; removeUsersThatIgnoredTheChange ( ) ; includeWatchers ( NotifyType.NEW_PATCHSETS , ( ( ! ( patchSet.isDraft ( ) ) ) && ( ! ( change.isPrivate ( ) ) ) ) ) ; removeUsersThatIgnoredTheChange ( ) ; }
private void setLineNumber ( com.google.gerrit.client.diff.DisplaySide side , int cmLine , java.lang.Integer line , java.lang.String styleName ) { com.google.gwtexpui.safehtml.client.SafeHtml html = com.google.gwtexpui.safehtml.client.SafeHtml.asis ( ( line != null ? line.toString ( ) : "&nbsp;" ) ) ; com.google.gwt.user.client.ui.InlineHTML gutter = new com.google.gwt.user.client.ui.InlineHTML ( html ) ; diffTable.add ( gutter ) ; gutter.setStyleName ( styleName ) ; cm.setGutterMarker ( cmLine , ( side == ( DisplaySide.A ) ? UnifiedTable.style.lineNumbersLeft ( ) : UnifiedTable.style.lineNumbersRight ( ) ) , gutter.getElement ( ) ) ; }
public com.google.gitiles.GitilesView.Builder setExtension ( java.lang.String extension ) { switch ( type ) { default : com.google.common.base.Preconditions.checkState ( ( extension == null ) , "cannot set path on %s view" , type ) ; case ARCHIVE : this . extension = extension ; break ; } return this ; }
private synchronized com.google.gerrit.testutil.InMemoryRepositoryManager.Repo get ( com.google.gerrit.reviewdb.client.Project.NameKey name ) throws org.eclipse.jgit.errors.RepositoryNotFoundException { com.google.gerrit.testutil.InMemoryRepositoryManager.Repo repo = repos.get ( com.google.gerrit.testutil.InMemoryRepositoryManager.normalize ( name ) ) ; if ( repo != null ) { return repo ; } throw new org.eclipse.jgit.errors.RepositoryNotFoundException ( name.get ( ) ) ; }
com.google.gerrit.client.diff.SkipManager getSkipManager ( ) { return skipManager ; }
public void testCopy ( ) { final com.google.gerrit.server.query.OperatorPredicate < java.lang.String > f = f ( "author" , "alice" ) ; org.junit.Assert.assertSame ( f , f.copy ( java.util.Collections.< com.google.gerrit.server.query.Predicate < java.lang.String > > emptyList ( ) ) ) ; org.junit.Assert.assertSame ( f , f.copy ( f.getChildren ( ) ) ) ; exception.expect ( java.lang.IllegalArgumentException.class ) ; exception.expectMessage ( "Expected 0 children" ) ; f.copy ( java.util.Collections.singleton ( f ( "owner" , "bob" ) ) ) ; }
public com.google.gerrit.server.patch.IntraLineDiff getIntraLineDiff ( com.google.gerrit.server.patch.IntraLineDiffKey key ) { if ( computeIntraline ) { try { return intraCache.get ( key ) ; } catch ( java.util.concurrent.ExecutionException | org.eclipse.jgit.errors.LargeObjectException e ) { IntraLineLoader.log.warn ( ( "Error computing " + key ) , e ) ; return new com.google.gerrit.server.patch.IntraLineDiff ( IntraLineDiff.Status.ERROR ) ; } } else { return new com.google.gerrit.server.patch.IntraLineDiff ( IntraLineDiff.Status.DISABLED ) ; } }
public void start ( ) { long interval = scheduleConfig.getInterval ( ) ; long delay = scheduleConfig.getInitialDelay ( ) ; if ( ( delay == ( com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG ) ) && ( interval == ( com.google.gerrit.server.config.ScheduleConfig.MISSING_CONFIG ) ) ) { com.googlesource.gerrit.plugins.quota.PublisherScheduler.log.info ( "Ignoring missing schedule configuration" ) ; } else if ( ( delay < 0 ) || ( interval <= 0 ) ) { com.googlesource.gerrit.plugins.quota.PublisherScheduler.log.warn ( "Ignoring invalid schedule configuration" ) ; } else { workQueue.getDefaultQueue ( ) . scheduleAtFixedRate ( publisher , delay , interval , java.util.concurrent.TimeUnit.MILLISECONDS ) ; } }
private GitilesView.Builder parseDescribeCommand ( javax.servlet.http.HttpServletRequest req , java.lang.String repoName , java.lang.String path ) { if ( com.google.gitiles.ViewFilter.isEmptyOrSlash ( path ) ) { return null ; } return com.google.gitiles.GitilesView.describe ( ) . setRepositoryName ( repoName ) . setPathPart ( path ) ; }
protected void resetHtml ( final java.lang.String body ) { for ( final java.util.Iterator < com.google.gwt.user.client.ui.Widget > i = table.iterator ( ) ; i.hasNext ( ) ; ) { i.next ( ) ; i.remove ( ) ; } com.google.gwt.user.client.DOM.setInnerHTML ( table.getBodyElement ( ) , body ) ; }
public void onClick ( final com.google.gwt.event.dom.client.ClickEvent event ) { b.setEnabled ( false ) ; Util.MANAGE_SVC.publish ( patchSet.getId ( ) , new com.google.gerrit.client.rpc.GerritCallback < com.google.gerrit.common.data.ChangeDetail > ( ) { public void onSuccess ( com.google.gerrit.common.data.ChangeDetail result ) { detailCache.set ( result ) ; } @ java.lang.Override public void onFailure ( java.lang.Throwable caught ) { b.setEnabled ( true ) ; super . onFailure ( caught ) ; } } ) ; }
public static com.google.gerrit.extensions.client.EditPreferencesInfo defaults ( ) { com.google.gerrit.extensions.client.EditPreferencesInfo i = new com.google.gerrit.extensions.client.EditPreferencesInfo ( ) ; i.tabSize = 8 ; i.lineLength = 100 ; i.hideTopMenu = false ; i.showTabs = true ; i.showWhitespaceErrors = false ; i.syntaxHighlighting = true ; i.hideLineNumbers = false ; i.theme = Theme.DEFAULT ; i.keyMapType = KeyMapType.DEFAULT ; return i ; }
public void addPatchSets ( com.google.gerrit.reviewdb.server.ReviewDb db , org.eclipse.jgit.revwalk.RevWalk revWalk , com.google.gerrit.server.data.ChangeAttribute ca , java.util.Collection < com.google.gerrit.reviewdb.client.PatchSet > ps , java.util.Map < com.google.gerrit.reviewdb.client.PatchSet.Id , java.util.Collection < com.google.gerrit.reviewdb.client.PatchSetApproval > > approvals , com.google.gerrit.common.data.LabelTypes labelTypes ) { addPatchSets ( db , revWalk , ca , ps , approvals , false , null , labelTypes ) ; }
protected java.util.List < com.google.gerrit.reviewdb.client.Change > impl ( com.google.gerrit.server.util.RequestContext ctx ) throws com.google.gwtorm.server.OrmException { java.lang.String ref = event.getRefName ( ) ; com.google.gerrit.reviewdb.client.Project.NameKey project = new com.google.gerrit.reviewdb.client.Project.NameKey ( event.getProjectName ( ) ) ; if ( ref.equals ( RefNames.REFS_CONFIG ) ) { return com.google.gerrit.server.query.change.ChangeData.asChanges ( queryProvider.get ( ) . byProjectOpen ( project ) ) ; } return com.google.gerrit.server.query.change.ChangeData.asChanges ( queryProvider.get ( ) . byBranchNew ( new com.google.gerrit.reviewdb.client.Branch.NameKey ( project , ref ) ) ) ; }
protected void configure ( ) { bind ( com.google.gerrit.server.index.account.AccountIndexRewriter.class ) ; bind ( com.google.gerrit.server.index.account.AccountIndexCollection.class ) ; listener ( ) . to ( com.google.gerrit.server.index.account.AccountIndexCollection.class ) ; factory ( AccountIndexer.Factory.class ) ; bind ( com.google.gerrit.server.index.change.ChangeIndexRewriter.class ) ; bind ( com.google.gerrit.server.index.change.ChangeIndexCollection.class ) ; listener ( ) . to ( com.google.gerrit.server.index.change.ChangeIndexCollection.class ) ; factory ( ChangeIndexer.Factory.class ) ; }
protected void doGet ( final javax.servlet.http.HttpServletRequest req , final javax.servlet.http.HttpServletResponse rsp ) throws java.io.IOException { try { com.google.gerrit.reviewdb.Change.Id id = Change.Id.parse ( req.getPathInfo ( ) ) ; com.google.gerrit.httpd.UrlModule.toGerrit ( com.google.gerrit.common.PageLinks.toChange ( id ) , req , rsp ) ; } catch ( java.lang.IllegalArgumentException err ) { rsp.sendError ( HttpServletResponse.SC_NOT_FOUND ) ; } }
private void writeObject ( final java.io.ObjectOutputStream out ) throws java.io.IOException { out.writeUTF ( projectKey.get ( ) ) ; org.spearce.jgit.lib.ObjectIdSerialization.write ( out , oldId ) ; org.spearce.jgit.lib.ObjectIdSerialization.write ( out , newId ) ; com.google.gerrit.server.patch.DiffCacheKey.writeString ( out , fileName ) ; com.google.gerrit.server.patch.DiffCacheKey.writeString ( out , sourceFileName ) ; com.google.gerrit.server.patch.DiffCacheKey.writeString ( out , whitespace.name ( ) ) ; }
void onDelete ( int idx ) { java.lang.String path = list.get ( idx ) . path ( ) ; com.google.gerrit.client.changes.ChangeEditApi.delete ( project.get ( ) , curr.getParentKey ( ) . get ( ) , path , new com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.client.VoidResult > ( ) { @ java.lang.Override public void onSuccess ( com.google.gerrit.client.VoidResult result ) { com.google.gerrit.client.Gerrit.display ( com.google.gerrit.common.PageLinks.toChangeInEditMode ( project , curr.getParentKey ( ) ) ) ; } @ java.lang.Override public void onFailure ( java.lang.Throwable caught ) { } } ) ; }
public com.google.gerrit.server.account.AccountState createEntry ( final com.google.gerrit.reviewdb.Account.Id key ) throws java.lang.Exception { final com.google.gerrit.reviewdb.ReviewDb db = schema.open ( ) ; try { final com.google.gerrit.server.account.AccountState state = load ( db , key ) ; if ( ( state.getUserName ( ) ) != null ) { byName.put ( new com.google.gerrit.reviewdb.Account.Username ( state.getUserName ( ) ) , state.getAccount ( ) . getId ( ) ) ; } return state ; } finally { db.close ( ) ; } }
public java.lang.Object apply ( com.google.gerrit.server.change.FileResource resource , com.google.gerrit.server.change.Reviewed.Input input ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.get ( ) ; com.google.gerrit.reviewdb.client.AccountPatchReview apr = com.google.gerrit.server.change.Reviewed.getExisting ( db , resource ) ; if ( apr == null ) { db.accountPatchReviews ( ) . insert ( java.util.Collections.singleton ( new com.google.gerrit.reviewdb.client.AccountPatchReview ( resource.getPatchKey ( ) , resource.getAccountId ( ) ) ) ) ; return com.google.gerrit.extensions.restapi.Response.created ( "" ) ; } else { return com.google.gerrit.extensions.restapi.Response.ok ( "" ) ; } }
private static java.lang.String duration ( double ns ) { if ( ns < 0.5 ) { return null ; } java.lang.String suffix = "ns" ; if ( ns >= 1000.0 ) { ns /= 1000.0 ; suffix = "us" ; } if ( ns >= 1000.0 ) { ns /= 1000.0 ; suffix = "ms" ; } if ( ns >= 1000.0 ) { ns /= 1000.0 ; suffix = "s" ; } return java.lang.String.format ( "%4.1f%s" , ns , suffix ) . trim ( ) ; }
private void appendLineNumberForSideB ( final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder m , final int idx ) { m.openTd ( ) ; m.setStyleName ( Gerrit.RESOURCES.css ( ) . lineNumber ( ) ) ; m.append ( com.google.gwtexpui.safehtml.client.SafeHtml.asis ( ( ( "<a href=\"javascript:void(0)\">" + ( idx + 1 ) ) + "</a>" ) ) ) ; m.closeTd ( ) ; }
private com.google.gwt.user.client.Element getRow ( int row ) { if ( ( ( startRow ) <= row ) && ( row < ( ( startRow ) + ( body.getChildCount ( ) ) ) ) ) { return body.getChild ( ( row - ( startRow ) ) ) . cast ( ) ; } return null ; }
boolean matches ( org.eclipse.jgit.lib.Repository git ) throws java.io.IOException { org.eclipse.jgit.lib.Ref head = git.getRef ( Constants.HEAD ) ; return ( ( head != null ) && ( head.isSymbolic ( ) ) ) && ( RefNames.REFS_CONFIG.equals ( head.getLeaf ( ) . getName ( ) ) ) ; }
private static com.google.gerrit.server.git.CodeReviewCommit failed ( final org.eclipse.jgit.revwalk.RevWalk rw , final org.eclipse.jgit.revwalk.RevFlag canMergeFlag , final com.google.gerrit.server.git.CodeReviewCommit mergeTip , final com.google.gerrit.server.git.CodeReviewCommit n , final com.google.gerrit.server.git.CommitMergeStatus failure ) throws java.io.IOException , org.eclipse.jgit.errors.IncorrectObjectTypeException , org.eclipse.jgit.errors.MissingObjectException { rw.resetRetain ( canMergeFlag ) ; rw.markStart ( n ) ; rw.markUninteresting ( mergeTip ) ; com.google.gerrit.server.git.CodeReviewCommit failed ; while ( ( failed = ( ( com.google.gerrit.server.git.CodeReviewCommit ) ( rw.next ( ) ) ) ) != null ) { failed.setStatusCode ( failure ) ; } return failed ; }
private void onCallback ( final com.google.gerrit.client.reviewdb.Account result ) { if ( result != null ) { com.google.gerrit.client.Gerrit.postSignIn ( ) ; hide ( ) ; final com.google.gwt.user.client.rpc.AsyncCallback < ? > ac = appCallback ; if ( ac != null ) { com.google.gwt.user.client.DeferredCommand.addCommand ( new com.google.gwt.user.client.Command ( ) { public void execute ( ) { ac.onSuccess ( null ) ; } } ) ; } } else { hide ( ) ; } }
protected void onInitUI ( ) { final com.google.gwt.user.client.ui.FlowPanel me = ( ( com.google.gwt.user.client.ui.FlowPanel ) ( getWidget ( ) ) ) ; me.add ( ( header = new com.google.gwt.user.client.ui.FlowPanel ( ) ) ) ; me.add ( ( body = new com.google.gwt.user.client.ui.FlowPanel ( ) ) ) ; header.setStyleName ( Gerrit.RESOURCES.css ( ) . screenHeader ( ) ) ; header.add ( ( headerText = new com.google.gwt.user.client.ui.InlineLabel ( ) ) ) ; }
private void removeUI ( ) { if ( ( replyToBox ) != null ) { replyToBox.unregisterReplyBox ( ) ; } getPaddingWidget ( ) . clear ( ) ; removeFromParent ( ) ; getSelfWidget ( ) . clear ( ) ; }
public java.lang.String getUrl ( ) { com.google.common.base.Preconditions.checkState ( ( ( session ) != null ) , "session must be opened" ) ; java.lang.StringBuilder b = new java.lang.StringBuilder ( ) ; b.append ( "ssh://" ) ; b.append ( session.getUserName ( ) ) ; b.append ( "@" ) ; b.append ( session.getHost ( ) ) ; b.append ( ":" ) ; b.append ( session.getPort ( ) ) ; return b.toString ( ) ; }
private void assertBranches ( java.util.List < java.lang.String > branches ) throws java.lang.Exception { java.util.List < java.lang.String > expected = com.google.common.collect.Lists.newArrayList ( "HEAD" , RefNames.REFS_CONFIG , "refs/heads/master" ) ; expected.addAll ( branches ) ; com.google.gerrit.acceptance.rest.project.BranchAssert.assertRefNames ( expected , project ( ) . branches ( ) . get ( ) ) ; }
private void initMessage ( final com.google.gwt.user.client.ui.Panel body ) { body.add ( new com.google.gerrit.client.ui.SmallHeading ( Util.C.headingCoverMessage ( ) ) ) ; final com.google.gwt.user.client.ui.VerticalPanel mwrap = new com.google.gwt.user.client.ui.VerticalPanel ( ) ; mwrap.setStyleName ( "gerrit-CoverMessage" ) ; body.add ( mwrap ) ; message = new com.google.gwtexpui.globalkey.client.NpTextArea ( ) ; message.setCharacterWidth ( 60 ) ; message.setVisibleLines ( 10 ) ; com.google.gwt.user.client.DOM.setElementPropertyBoolean ( message.getElement ( ) , "spellcheck" , true ) ; mwrap.add ( message ) ; }
public int compare ( com.google.gerrit.server.notedb.ChangeRebuilderImpl.Event a , com.google.gerrit.server.notedb.ChangeRebuilderImpl.Event b ) { return com.google.common.collect.ComparisonChain.start ( ) . compareTrueFirst ( a.predatesChange , b.predatesChange ) . compare ( a.when , b.when ) . compare ( a.who , b.who , com.google.gerrit.reviewdb.server.ReviewDbUtil.intKeyOrdering ( ) ) . compare ( a.psId.get ( ) , b.psId.get ( ) ) . result ( ) ; }
private void statesCleanUp ( ) { if ( ( ! ( stateMap.isEmpty ( ) ) ) && ( ! ( isRetrying ( ) ) ) ) { for ( java.util.Map.Entry < java.lang.String , com.googlesource.gerrit.plugins.replication.ReplicationState > entry : stateMap.entries ( ) ) { entry.getValue ( ) . notifyRefReplicated ( projectName.get ( ) , entry.getKey ( ) , uri , RefPushResult.FAILED , null ) ; } } }
public void execute ( ) { sp.setHeight ( "" ) ; setPosition ( getOffsetWidth ( ) , getOffsetHeight ( ) ) ; fileList.setRegisterKeys ( true ) ; fileList.movePointerTo ( callerKey ) ; }
public void requestReceived ( com.github.tomakehurst.wiremock.http.Request request , com.github.tomakehurst.wiremock.http.Response response ) { if ( request.getAbsoluteUrl ( ) . contains ( flushRequest ) ) { try { checkPoint.await ( ) ; } catch ( java.lang.InterruptedException | java.util.concurrent.BrokenBarrierException e ) { org.junit.Assert.fail ( ) ; } } }
public void restoreFile ( java.lang.String filePath ) throws com.google.gerrit.extensions.restapi.RestApiException { try { com.google.gerrit.server.restapi.change.ChangeEdits.Post.Input restoreInput = new com.google.gerrit.server.restapi.change.ChangeEdits.Post.Input ( ) ; restoreInput.restorePath = filePath ; changeEditsPost.apply ( changeResource , restoreInput ) ; } catch ( java.lang.Exception e ) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException ( "Cannot restore file of change edit" , e ) ; } }
private com.google.gerrit.server.project.ProjectConfig parseConfig ( com.google.gerrit.reviewdb.client.Project.NameKey p , java.lang.String idStr ) throws java.io.IOException , org.eclipse.jgit.errors.ConfigInvalidException , org.eclipse.jgit.errors.RepositoryNotFoundException { org.eclipse.jgit.lib.ObjectId id = org.eclipse.jgit.lib.ObjectId.fromString ( idStr ) ; if ( org.eclipse.jgit.lib.ObjectId.zeroId ( ) . equals ( id ) ) { return null ; } try ( org.eclipse.jgit.lib.Repository repo = repoManager.openRepository ( p ) ) { com.google.gerrit.server.project.ProjectConfig pc = new com.google.gerrit.server.project.ProjectConfig ( p ) ; pc.load ( repo , id ) ; return pc ; } }
public boolean isOwner ( ) { if ( canPerform ( com.google.gerrit.reviewdb.ApprovalCategory.OWN , ( ( short ) ( 1 ) ) ) ) { return true ; } if ( ( ! ( RefRight.ALL.equals ( getRefName ( ) ) ) ) && ( getProjectControl ( ) . isOwner ( ) ) ) { return true ; } return false ; }
private com.google.gerrit.extensions.api.changes.RevisionApi revisionApi ( com.google.gerrit.reviewdb.client.PatchSet patchSet ) throws com.google.gerrit.extensions.restapi.RestApiException { return changeApi ( patchSet ) . revision ( patchSet.getRevision ( ) . get ( ) ) ; }
public void run ( ) { try { final com.google.gerrit.server.mail.CreateChangeSender cm ; cm = createChangeSenderFactory.create ( change ) ; cm.setFrom ( me ) ; cm.setPatchSet ( ps , info ) ; cm.addReviewers ( reviewers ) ; cm.addExtraCC ( cc ) ; cm.send ( ) ; } catch ( java.lang.Exception e ) { com.google.gerrit.server.git.ReceiveCommits.log.error ( ( "Cannot send email for new change " + ( change.getId ( ) ) ) , e ) ; } }
public void testEntityNbsp ( ) { final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder b = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder ( ) ; org.junit.Assert.assertSame ( b , b.nbsp ( ) ) ; org.junit.Assert.assertEquals ( "&nbsp;" , b.asString ( ) ) ; }
protected byte [ ] dataRowKey ( K key ) { com.google.gwtorm.nosql.IndexKeyBuilder b = new com.google.gwtorm.nosql.IndexKeyBuilder ( ) ; b.add ( com.google.gwtorm.nosql.generic.GenericAccess.getRelationName ( ) ) ; b.delimiter ( ) ; encodePrimaryKey ( b , key ) ; return b.toByteArray ( ) ; }
public void emptyServletPath ( ) { com.google.common.truth.Truth.assertThat ( com.google.gerrit.util.http.RequestUtil.getEncodedPathInfo ( fakeRequest ( "" , "/c" , "/foo/bar" ) ) ) . isEqualTo ( "/foo/bar" ) ; com.google.common.truth.Truth.assertThat ( com.google.gerrit.util.http.RequestUtil.getEncodedPathInfo ( fakeRequest ( "" , "/c" , "/foo%2Fbar" ) ) ) . isEqualTo ( "/foo%2Fbar" ) ; }
private com.google.gerrit.server.account.AuthResult bySshUserName ( final javax.servlet.http.HttpServletResponse rsp , final java.lang.String userName ) { try { final com.google.gerrit.reviewdb.ReviewDb db = schema.open ( ) ; try { return auth ( db.accounts ( ) . bySshUserName ( userName ) ) ; } finally { db.close ( ) ; } } catch ( com.google.gwtorm.client.OrmException e ) { getServletContext ( ) . log ( "cannot query database" , e ) ; return null ; } }
protected void configure ( ) { if ( ! ( com.google.gerrit.server.util.BouncyCastleUtil.havePGP ( ) ) ) { com.google.gerrit.server.git.gpg.SignedPushModule.log.info ( ( "BouncyCastle PGP not installed; signed push verification is" + " disabled" ) ) ; return ; } bind ( com.google.gerrit.server.git.gpg.PublicKeyChecker.class ) . to ( com.google.gerrit.server.git.gpg.GerritPublicKeyChecker.class ) ; bind ( com.google.gerrit.server.git.gpg.PublicKeyStore.class ) . toProvider ( com.google.gerrit.server.git.gpg.SignedPushModule.StoreProvider.class ) ; com.google.gerrit.extensions.registration.DynamicSet.bind ( binder ( ) , com.google.gerrit.server.git.ReceivePackInitializer.class ) . to ( com.google.gerrit.server.git.gpg.SignedPushModule.Initializer.class ) ; }
protected void configure ( ) { bind ( com.google.gerrit.pgm.init.ConsoleUI.class ) . toInstance ( ui ) ; bind ( java.io.File.class ) . annotatedWith ( com.google.gerrit.server.config.SitePath.class ) . toInstance ( sitePath ) ; java.util.List < java.lang.String > plugins = com.google.common.base.Objects.firstNonNull ( getInstallPlugins ( ) , com.google.common.collect.Lists.< java.lang.String > newArrayList ( ) ) ; bind ( new com.google.inject.TypeLiteral < java.util.List < java.lang.String > > ( ) { } ) . annotatedWith ( com.google.gerrit.pgm.init.InstallPlugins.class ) . toInstance ( plugins ) ; bind ( com.google.gerrit.pgm.init.PluginsDistribution.class ) . toInstance ( pluginsDistribution ) ; }
public com.google.gerrit.reviewdb.client.PatchSet currentPatchSet ( com.google.inject.Provider < com.google.gerrit.reviewdb.server.ReviewDb > db ) throws com.google.gwtorm.server.OrmException { if ( ( currentPatchSet ) == null ) { com.google.gerrit.reviewdb.client.Change c = change ( db ) ; if ( c == null ) { return null ; } for ( com.google.gerrit.reviewdb.client.PatchSet p : patches ( db ) ) { if ( p.getId ( ) . equals ( c.currentPatchSetId ( ) ) ) { currentPatchSet = p ; return p ; } } } return currentPatchSet ; }
public void testIsEnabledRefNoParentMatchingBranchMiddleDisabled ( ) { java.lang.String [ ] branches = new java.lang.String [ ] { "^refs/heads/foo.*" , "^refs/heads/test.*" , "^refs/heads/baz.*" } ; setupIsEnabled ( "false" , null , branches ) ; com.googlesource.gerrit.plugins.its.base.its.ItsConfig itsConfig = createItsConfig ( ) ; replayMocks ( ) ; com.google.gerrit.reviewdb.client.Project.NameKey projectNK = new com.google.gerrit.reviewdb.client.Project.NameKey ( "testProject" ) ; assertFalse ( itsConfig.isEnabled ( projectNK , "refs/heads/testBranch" ) ) ; }
public com.google.gerrit.client.reviewdb.AccountGroup lookup ( final java.lang.String groupName ) { return byName.get ( new com.google.gerrit.client.reviewdb.AccountGroup.NameKey ( groupName ) ) ; }
public void updateSchema ( final com.google.gwtorm.client.StatementExecutor e ) throws com.google.gwtorm.client.OrmException { try { createSequences ( e ) ; createRelations ( e ) ; for ( final com.google.gwtorm.schema.RelationModel rel : dbDef.getSchemaModel ( ) . getRelations ( ) ) { addColumns ( e , rel ) ; } } catch ( java.sql.SQLException err ) { throw new com.google.gwtorm.client.OrmException ( "Cannot update schema" , err ) ; } }
private void assertCreateFails ( com.google.gerrit.extensions.common.ChangeInfo in , java.lang.Class < ? extends com.google.gerrit.extensions.restapi.RestApiException > errType , java.lang.String errSubstring ) throws java.lang.Exception { try { gApi.changes ( ) . create ( in ) ; org.junit.Assert.fail ( ( "Expected " + ( errType.getSimpleName ( ) ) ) ) ; } catch ( com.google.gerrit.extensions.restapi.RestApiException expected ) { com.google.common.truth.Truth.assertThat ( expected ) . isInstanceOf ( errType ) ; com.google.common.truth.Truth.assertThat ( expected.getMessage ( ) ) . contains ( errSubstring ) ; } }
public void testInsertOneException ( ) throws com.google.gwtorm.server.OrmException , java.sql.SQLException { sqlException = new java.sql.BatchUpdateException ( ) ; java.sql.PreparedStatement insert = stubStatementThrowExceptionOnExecute ( com.google.gwtorm.jdbc.AbstractTestJdbcAccess.INSERT , sqlException ) ; try { classUnderTest.insert ( oneRow ) ; org.junit.Assert.fail ( "missingException" ) ; } catch ( com.google.gwtorm.server.OrmException e ) { org.junit.Assert.assertSame ( e.getCause ( ) , sqlException ) ; } assertCorrectUpdating ( insert , 1 ) ; }
public boolean canUpdate ( ) { if ( ( RefNames.REFS_CONFIG.equals ( refName ) ) && ( ! ( projectControl.isOwner ( ) ) ) ) { if ( ! ( ( projectControl.getProjectState ( ) . isAllProjects ( ) ) && ( getUser ( ) . getCapabilities ( ) . canAdministrateServer ( ) ) ) ) { return false ; } } return ( canPerform ( Permission.PUSH ) ) && ( canWrite ( ) ) ; }
public void setParent_Forbidden ( ) throws java.lang.Exception { java.lang.String parent = createProject ( "parent" , null , true ) . get ( ) ; com.google.gerrit.acceptance.RestResponse r = userSession.put ( ( ( "/projects/" + ( project.get ( ) ) ) + "/parent" ) , newParentInput ( parent ) ) ; r.assertForbidden ( ) ; r.consume ( ) ; }
public void onClick ( com.google.gwt.event.dom.client.ClickEvent event ) { event.preventDefault ( ) ; event.stopPropagation ( ) ; select ( ) ; if ( ( com.google.gerrit.client.Gerrit.isSignedIn ( ) ) && ( ( urlType ) != null ) ) { com.google.gerrit.reviewdb.client.AccountGeneralPreferences pref = com.google.gerrit.client.Gerrit.getUserAccount ( ) . getGeneralPreferences ( ) ; pref.setDownloadUrl ( urlType ) ; com.google.gerrit.client.account.Util.ACCOUNT_SVC.changePreferences ( pref , new com.google.gwtjsonrpc.common.AsyncCallback < com.google.gwtjsonrpc.common.VoidResult > ( ) { @ java.lang.Override public void onFailure ( java.lang.Throwable caught ) { } @ java.lang.Override public void onSuccess ( com.google.gwtjsonrpc.common.VoidResult result ) { } } ) ; } }
void setOpen ( boolean open ) { com.google.gwt.user.client.ui.UIObject.setVisible ( summary , ( ! open ) ) ; com.google.gwt.user.client.ui.UIObject.setVisible ( message , open ) ; com.google.gwt.user.client.ui.UIObject.setVisible ( buttons , ( open && ( ( replyBox ) == null ) ) ) ; if ( open ) { removeStyleName ( style.closed ( ) ) ; } else { addStyleName ( style.closed ( ) ) ; } super . setOpen ( open ) ; }
public java.lang.String render ( java.lang.String varName ) { if ( com.google.gerrit.common.data.Permission.isLabelAs ( varName ) ) { return Util.M.labelAs ( com.google.gerrit.common.data.Permission.extractLabel ( varName ) ) ; } else if ( com.google.gerrit.common.data.Permission.isLabel ( varName ) ) { return Util.M.label ( com.google.gerrit.common.data.Permission.extractLabel ( varName ) ) ; } java.lang.String desc = com.google.gerrit.client.admin.PermissionNameRenderer.all.get ( varName ) ; if ( desc == null ) { desc = com.google.gerrit.client.admin.PermissionNameRenderer.all.get ( varName.toLowerCase ( ) ) ; } return desc != null ? desc : varName ; }
public void onScreenLoad ( com.google.gerrit.client.ui.ScreenLoadEvent event ) { com.google.gerrit.client.ui.Screen screen = event.getScreen ( ) ; com.google.gerrit.reviewdb.client.Project.NameKey projectKey ; if ( screen instanceof com.google.gerrit.client.admin.ProjectScreen ) { projectKey = ( ( com.google.gerrit.client.admin.ProjectScreen ) ( screen ) ) . getProjectKey ( ) ; } else { projectKey = com.google.gerrit.client.admin.ProjectScreen.getSavedKey ( ) ; } if ( projectKey != null ) { setVisible ( true ) ; setTargetHistoryToken ( com.google.gerrit.client.Dispatcher.toProjectAdmin ( projectKey , panel ) ) ; } else { setVisible ( false ) ; } super . onScreenLoad ( event ) ; }
private void initForwardingFilter ( ) { setForwardingFilter ( new org.apache.sshd.server.ForwardingFilter ( ) { @ java.lang.Override public boolean canForwardAgent ( org.apache.sshd.server.session.ServerSession session ) { return false ; } @ java.lang.Override public boolean canForwardX11 ( org.apache.sshd.server.session.ServerSession session ) { return false ; } @ java.lang.Override public boolean canConnect ( java.net.InetSocketAddress address , org.apache.sshd.server.session.ServerSession session ) { return false ; } @ java.lang.Override public boolean canListen ( java.net.InetSocketAddress address , org.apache.sshd.server.session.ServerSession session ) { return false ; } } ) ; }
void addReviewer ( java.lang.String filter , java.lang.String reviewer ) { if ( ! ( newReviewerFilterSection ( filter ) . getReviewers ( ) . contains ( reviewer ) ) ) { java.util.List < java.lang.String > values = new java.util.ArrayList ( java.util.Arrays.asList ( cfg.getStringList ( com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FILTER , filter , com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.REVIEWER ) ) ) ; values.add ( reviewer ) ; cfg.setStringList ( com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FILTER , filter , com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.REVIEWER , values ) ; } }
public void testGetIssuePatternNullMatch ( ) { com.googlesource.gerrit.plugins.its.base.its.ItsConfig itsConfig = createItsConfig ( ) ; org.easymock.EasyMock.expect ( serverConfig.getString ( "plugin" , "ItsTestName" , "commentlink" ) ) . andReturn ( null ) . atLeastOnce ( ) ; org.easymock.EasyMock.expect ( serverConfig.getString ( "commentlink" , "ItsTestName" , "match" ) ) . andReturn ( null ) . atLeastOnce ( ) ; replayMocks ( ) ; assertNull ( "Pattern for null match is not null" , itsConfig.getIssuePattern ( ) ) ; }
private org.kohsuke.github.PagedIterable < org.kohsuke.github.GHRepository > getRepositories ( com.googlesource.gerrit.plugins.github.oauth.GitHubLogin hubLogin , java.lang.String organisation ) throws java.io.IOException { if ( organisation.equals ( hubLogin.getMyself ( ) . getLogin ( ) ) ) { return hubLogin.getMyself ( ) . listRepositories ( config.repositoryListPageSize ) ; } else { org.kohsuke.github.GHOrganization ghOrganisation = hubLogin.getMyself ( ) . getOrganizations ( ) . byLogin ( organisation ) ; return ghOrganisation.listRepositories ( config.repositoryListPageSize ) ; } }
public void onEvent ( com.google.gerrit.server.events.Event event ) { if ( ! ( event instanceof com.google.gerrit.server.events.ChangeMergedEvent ) ) { return ; } com.google.gerrit.server.events.ChangeMergedEvent e = ( ( com.google.gerrit.server.events.ChangeMergedEvent ) ( event ) ) ; com.google.gerrit.server.data.ChangeAttribute c = e.change.get ( ) ; com.google.gerrit.server.data.PatchSetAttribute ps = e.patchSet.get ( ) ; com.google.gerrit.acceptance.rest.change.AbstractSubmit.log.debug ( "Merged {},{} as {}" , ps.number , c.number , e.newRev ) ; mergeResults.put ( e.change.get ( ) . number , e.newRev ) ; }
public void run ( ) { if ( ( prefs.context ( ) ) == ( com.google.gerrit.reviewdb.client.AccountDiffPreference.WHOLE_FILE_CONTEXT ) ) { contextEntireFile.setValue ( true ) ; } if ( view.canRenderEntireFile ( prefs ) ) { renderEntireFile.setEnabled ( true ) ; renderEntireFile.setValue ( prefs.renderEntireFile ( ) ) ; } else { renderEntireFile.setValue ( false ) ; renderEntireFile.setEnabled ( false ) ; } view.setContext ( prefs.context ( ) ) ; }
public void stop ( ) { if ( ( task ) != null ) { task.cancel ( true ) ; } try { eventsDb.close ( ) ; } catch ( java.sql.SQLException e ) { com.ericsson.gerrit.plugins.eventslog.SQLStore.log.warn ( "Cannot close datasource " , e ) ; } try { localEventsDb.close ( ) ; } catch ( java.sql.SQLException e ) { com.ericsson.gerrit.plugins.eventslog.SQLStore.log.warn ( "Cannot close datasource " , e ) ; } }
public synchronized void addWriteIndex ( com.google.gerrit.server.index.ChangeIndex index ) { int version = index.getSchema ( ) . getVersion ( ) ; for ( com.google.gerrit.server.index.ChangeIndex i : writeIndexes ) { if ( ( i.getSchema ( ) . getVersion ( ) ) == version ) { throw new java.lang.IllegalArgumentException ( ( ( "Write index version " + version ) + " already in list" ) ) ; } } writeIndexes.add ( index ) ; }
private com.google.gerrit.server.query.change.ChangeData newChangeData ( com.google.gerrit.reviewdb.server.ReviewDb db , com.google.gerrit.reviewdb.client.Project.NameKey project , com.google.gerrit.reviewdb.client.Change.Id changeId ) throws com.google.gwtorm.server.OrmException { if ( ! ( notesMigration.readChanges ( ) ) ) { com.google.gerrit.server.notedb.ChangeNotes notes = changeNotesFactory.createWithAutoRebuildingDisabled ( db , project , changeId ) ; return changeDataFactory.create ( db , notes ) ; } return changeDataFactory.create ( db , project , changeId ) ; }
private void addPriority ( java.util.Map < java.lang.String , java.lang.Object > have , com.google.gerrit.server.account.AccountLimits limits ) { com.google.gerrit.server.git.QueueProvider.QueueType queue = limits.getQueueType ( ) ; if ( ( queue != ( QueueProvider.QueueType.INTERACTIVE ) ) || ( ( ( query ) != null ) && ( query.contains ( com.google.gerrit.common.data.GlobalCapability.PRIORITY ) ) ) ) { have.put ( com.google.gerrit.common.data.GlobalCapability.PRIORITY , queue ) ; } }
public void run ( ) { new com.google.gwtexpui.globalkey.client.ShowHelpCommand ( ) . onKeyPress ( null ) ; }
private com.amd.gerrit.plugins.manifestsubscription.VersionedManifests parseManifests ( com.google.gerrit.reviewdb.client.Project.NameKey p , java.lang.String refName ) throws java.io.IOException , javax.xml.bind.JAXBException , org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.Repository repo = gitRepoManager.openRepository ( p ) ; org.eclipse.jgit.lib.ObjectId commitId = repo.resolve ( refName ) ; com.google.gerrit.server.git.MetaDataUpdate update = metaDataUpdateFactory.create ( p ) ; com.amd.gerrit.plugins.manifestsubscription.VersionedManifests vManifests = new com.amd.gerrit.plugins.manifestsubscription.VersionedManifests ( refName ) ; vManifests.load ( update , commitId ) ; return vManifests ; }
com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpResponseHandler.HttpResult send ( ) throws java.io.IOException { java.lang.String serializedEvent = new com.google.gson.GsonBuilder ( ) . registerTypeAdapter ( com.google.common.base.Supplier.class , new com.google.gerrit.server.events.SupplierSerializer ( ) ) . create ( ) . toJson ( event ) ; return httpSession.post ( com.google.common.base.Joiner.on ( "/" ) . join ( pluginRelativePath , "event" ) , serializedEvent ) ; }
boolean hasDynamicItem ( com.google.inject.TypeLiteral < ? > type ) { return ( ( sysItems.containsKey ( type ) ) || ( ( ( sshItems ) != null ) && ( sshItems.containsKey ( type ) ) ) ) || ( ( ( httpItems ) != null ) && ( httpItems.containsKey ( type ) ) ) ; }
public com.google.gerrit.extensions.common.ChangeInfo apply ( com.google.gerrit.server.change.ChangeResource req , com.google.gerrit.extensions.api.changes.AbandonInput input ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.git.UpdateException , com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl control = req.getControl ( ) ; if ( ! ( control.canAbandon ( dbProvider.get ( ) ) ) ) { throw new com.google.gerrit.extensions.restapi.AuthException ( "abandon not permitted" ) ; } com.google.gerrit.reviewdb.client.Change change = abandon ( control , input.message , input.notify , notifyUtil.resolveAccounts ( input.notifyDetails ) ) ; return json.create ( ChangeJson.NO_OPTIONS ) . format ( change ) ; }
public void onSuccess ( final com.google.gwtjsonrpc.client.VoidResult result ) { for ( int row = 1 ; row < ( table.getRowCount ( ) ) ; ) { final com.google.gerrit.client.reviewdb.AccountGroupMember k = getRowItem ( row ) ; if ( ( k != null ) && ( ids.contains ( k.getKey ( ) ) ) ) { table.removeRow ( row ) ; } else { row ++ ; } } }
public com.google.gerrit.server.events.PatchSetCommentAttribute asPatchSetLineAttribute ( com.google.gerrit.reviewdb.client.PatchLineComment c ) { com.google.gerrit.server.events.PatchSetCommentAttribute a = new com.google.gerrit.server.events.PatchSetCommentAttribute ( ) ; a.reviewer = asAccountAttribute ( c.getAuthor ( ) ) ; a.file = c.getKey ( ) . getParentKey ( ) . get ( ) ; a.line = c.getLine ( ) ; a.message = c.getMessage ( ) ; return a ; }
void onWhitespaceErrors ( com.google.gwt.event.logical.shared.ValueChangeEvent < java.lang.Boolean > e ) { prefs.showWhitespaceErrors ( e.getValue ( ) ) ; if ( ( view ) != null ) { view.operation ( new java.lang.Runnable ( ) { @ java.lang.Override public void run ( ) { boolean s = prefs.showWhitespaceErrors ( ) ; for ( net.codemirror.lib.CodeMirror cm : view.getCms ( ) ) { cm.setOption ( "showTrailingSpace" , s ) ; } } } ) ; } }
public void addPatchSets ( com.google.gerrit.reviewdb.server.ReviewDb db , org.eclipse.jgit.revwalk.RevWalk revWalk , com.google.gerrit.server.data.ChangeAttribute ca , java.util.Collection < com.google.gerrit.reviewdb.client.PatchSet > ps , java.util.Map < com.google.gerrit.reviewdb.client.PatchSet.Id , java.util.Collection < com.google.gerrit.reviewdb.client.PatchSetApproval > > approvals , com.google.gerrit.common.data.LabelTypes labelTypes ) { addPatchSets ( db , revWalk , ca , ps , approvals , false , null , labelTypes ) ; }
public com.google.gerrit.extensions.restapi.Response < ? > apply ( com.google.gerrit.server.change.RevisionResource rsrc , com.google.gerrit.server.change.PublishDraftPatchSet.Input input ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.git.UpdateException { return apply ( rsrc.getUser ( ) , rsrc.getChange ( ) , rsrc.getPatchSet ( ) . getId ( ) , rsrc.getPatchSet ( ) ) ; }
public void deleteReviewerFromWipChangeNotifyAll ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageWipChangeWithExtraReviewer ( ) ; removeReviewer ( sc , extraReviewer , NotifyHandling.ALL ) ; assertThat ( sender ) . sent ( "deleteReviewer" , sc ) . to ( extraReviewer ) . cc ( extraCcer , sc.reviewer , sc.ccer ) . cc ( sc.reviewerByEmail , sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS ) . noOneElse ( ) ; }
public com.google.gerrit.extensions.restapi.Response < com.google.gerrit.extensions.common.CommentInfo > apply ( com.google.gerrit.server.change.DraftResource rsrc , com.google.gerrit.server.change.DeleteDraft.Input input ) throws com.google.gwtorm.server.OrmException , java.io.IOException { com.google.gerrit.server.notedb.ChangeUpdate update = updateFactory.create ( rsrc.getControl ( ) ) ; com.google.gerrit.reviewdb.client.PatchLineComment c = rsrc.getComment ( ) ; com.google.gerrit.server.PatchLineCommentsUtil.setCommentRevId ( c , patchListCache , rsrc.getChange ( ) , rsrc.getPatchSet ( ) ) ; plcUtil.deleteComments ( db.get ( ) , update , java.util.Collections.singleton ( c ) ) ; update.commit ( ) ; return com.google.gerrit.extensions.restapi.Response.none ( ) ; }
void onCancel ( com.google.gwt.event.dom.client.ClickEvent e ) { e.stopPropagation ( ) ; if ( ( isNew ( ) ) && ( ! ( isDirty ( ) ) ) ) { removeUI ( ) ; } else { setEdit ( false ) ; cm.focus ( ) ; } }
protected void doPost ( javax.servlet.http.HttpServletRequest req , javax.servlet.http.HttpServletResponse rsp ) { if ( ! ( permissionBackend.user ( currentUserProvider.get ( ) ) . testOrFalse ( com.google.gerrit.server.permissions.GlobalPermission.ADMINISTRATE_SERVER ) ) ) { sendError ( rsp , javax.servlet.http.HttpServletResponse.SC_FORBIDDEN ) ; return ; } this . healthy = true ; rsp.setStatus ( javax.servlet.http.HttpServletResponse.SC_NO_CONTENT ) ; }
private void saveChange ( com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx ) throws com.google.gwtorm.server.OrmException { change = ctx.getChange ( ) ; wasDraftChange = ( change.getStatus ( ) ) == ( Change.Status.DRAFT ) ; if ( wasDraftChange ) { change.setStatus ( Change.Status.NEW ) ; com.google.gerrit.server.ChangeUtil.updated ( change ) ; ctx.getDb ( ) . changes ( ) . update ( java.util.Collections.singleton ( change ) ) ; } }
public void onShowView ( ) { super . onShowView ( ) ; com.google.gwt.user.client.Window.enableScrolling ( false ) ; final int height = getCodeMirrorHeight ( ) ; operation ( new java.lang.Runnable ( ) { @ java.lang.Override public void run ( ) { cmA.setHeight ( height ) ; cmB.setHeight ( height ) ; cmA.refresh ( ) ; cmB.refresh ( ) ; cmB.setCursor ( net.codemirror.lib.LineCharacter.create ( 0 ) ) ; cmB.focus ( ) ; } } ) ; diffTable.sidePanel.adjustGutters ( cmB ) ; prefetchNextFile ( ) ; }
public void testItsAssociationPolicyMandatory ( ) { com.googlesource.gerrit.plugins.hooks.its.ItsConfig itsConfig = createItsConfig ( ) ; org.easymock.EasyMock.expect ( serverConfig.getEnum ( "commentlink" , "ItsTestName" , "association" , ItsAssociationPolicy.OPTIONAL ) ) . andReturn ( ItsAssociationPolicy.MANDATORY ) . atLeastOnce ( ) ; replayMocks ( ) ; assertEquals ( "Expected and generated associated policy do not match" , ItsAssociationPolicy.MANDATORY , itsConfig.getItsAssociationPolicy ( ) ) ; }
public com.googlecode.prolog_cafe.lang.Operation switch_on_term ( com.googlecode.prolog_cafe.lang.Operation var , com.googlecode.prolog_cafe.lang.Operation Int , com.googlecode.prolog_cafe.lang.Operation flo , com.googlecode.prolog_cafe.lang.Operation con , com.googlecode.prolog_cafe.lang.Operation str , com.googlecode.prolog_cafe.lang.Operation lis ) { switch ( r1.dereference ( ) . type ( ) ) { case Term.TYPE_VARIABLE : return var ; case Term.TYPE_INTEGER : return Int ; case Term.TYPE_DOUBLE : return flo ; case Term.TYPE_SYMBOL : return con ; case Term.TYPE_STRUCTURE : return str ; case Term.TYPE_LIST : return lis ; default : return var ; } }
private static void mergeTestConfig ( org.eclipse.jgit.lib.Config cfg ) { java.lang.String forceEphemeralPort = java.lang.String.format ( "%s:0" , com.google.gerrit.acceptance.GerritServer.getLocalHost ( ) . getHostName ( ) ) ; java.lang.String url = ( "http://" + forceEphemeralPort ) + "/" ; cfg.setString ( "gerrit" , null , "canonicalWebUrl" , url ) ; cfg.setString ( "httpd" , null , "listenUrl" , url ) ; cfg.setString ( "sshd" , null , "listenAddress" , forceEphemeralPort ) ; cfg.setBoolean ( "sshd" , null , "testUseInsecureRandom" , true ) ; cfg.setString ( "cache" , null , "directory" , null ) ; cfg.setString ( "gerrit" , null , "basePath" , "git" ) ; cfg.setBoolean ( "sendemail" , null , "enable" , false ) ; cfg.setInt ( "cache" , "projects" , "checkFrequency" , 0 ) ; cfg.setInt ( "plugins" , null , "checkFrequency" , 0 ) ; }
public void add ( com.google.gerrit.extensions.registration.RegistrationHandle handle ) { if ( handle instanceof com.google.gerrit.extensions.registration.ReloadableRegistrationHandle ) { if ( ( reloadableHandles ) == null ) { reloadableHandles = com.google.common.collect.Lists.newArrayList ( ) ; } reloadableHandles.add ( ( ( com.google.gerrit.extensions.registration.ReloadableRegistrationHandle < ? > ) ( handle ) ) ) ; } manager.add ( handle ) ; }
public void clearReviewed ( com.google.gerrit.reviewdb.client.PatchSet.Id psId ) throws com.google.gwtorm.server.OrmException { try ( java.sql.Connection con = ds.getConnection ( ) ; java.sql.PreparedStatement stmt = con.prepareStatement ( ( "DELETE FROM ACCOUNT_PATCH_REVIEWS " + "WHERE CHANGE_ID = ? AND PATCH_SET_ID = ?" ) ) ) { stmt.setInt ( 1 , psId.getParentKey ( ) . get ( ) ) ; stmt.setInt ( 2 , psId.get ( ) ) ; stmt.executeUpdate ( ) ; } catch ( java.sql.SQLException e ) { throw com.google.gerrit.server.schema.H2AccountPatchReviewStore.convertError ( "delete" , e ) ; } }
protected void configure ( ) { final com.google.inject.TypeLiteral < com.google.gerrit.server.cache.Cache < java.lang.String , java.util.Set < com.google.gerrit.reviewdb.Account.Id > > > type = new com.google.inject.TypeLiteral < com.google.gerrit.server.cache.Cache < java.lang.String , java.util.Set < com.google.gerrit.reviewdb.Account.Id > > > ( ) { } ; core ( type , com.google.gerrit.server.account.AccountByEmailCacheImpl.CACHE_NAME ) . populateWith ( com.google.gerrit.server.account.AccountByEmailCacheImpl.Loader.class ) ; bind ( com.google.gerrit.server.account.AccountByEmailCacheImpl.class ) ; bind ( com.google.gerrit.server.account.AccountByEmailCache.class ) . to ( com.google.gerrit.server.account.AccountByEmailCacheImpl.class ) ; }
public com.google.gerrit.server.project.ProjectState get ( final com.google.gerrit.reviewdb.Project.NameKey projectName ) { com.google.gerrit.server.project.ProjectState state = byName.get ( projectName ) ; if ( ( state != null ) && ( state.needsRefresh ( generation ) ) ) { byName.remove ( projectName ) ; state = byName.get ( projectName ) ; } return state ; }
public java.lang.String toString ( ) { final java.lang.StringBuffer r = new java.lang.StringBuffer ( ) ; if ( ( getParentKey ( ) ) != null ) { r.append ( getParentKey ( ) . toString ( ) ) ; r.append ( ',' ) ; } r.append ( com.google.gwtorm.client.KeyUtil.encode ( get ( ) ) ) ; return r.toString ( ) ; }
private java.util.Set < java.lang.String > allRefPatterns ( com.google.gerrit.reviewdb.ApprovalCategory.Id actionId ) { final java.util.Set < java.lang.String > all = new java.util.HashSet < java.lang.String > ( ) ; for ( final com.google.gerrit.reviewdb.RefRight pr : state.getLocalRights ( actionId ) ) { all.add ( pr.getRefPattern ( ) ) ; } if ( actionId.canInheritFromWildProject ( ) ) { for ( final com.google.gerrit.reviewdb.RefRight pr : state.getInheritedRights ( actionId ) ) { all.add ( pr.getRefPattern ( ) ) ; } } return all ; }
public void testUnblockInLocalVisibilityByRegisteredUsers_Fails ( ) { com.google.gerrit.server.project.Util.block ( parent , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/heads/*" ) ; com.google.gerrit.server.project.Util.allow ( local , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS , "refs/heads/*" ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS ) ; org.junit.Assert.assertFalse ( "u can't read" , u.controlForRef ( "refs/heads/master" ) . isVisibleByRegisteredUsers ( ) ) ; }
private void mapMessages ( com.google.gerrit.server.change.ChangeJson.ChangeInfo i , com.google.gerrit.extensions.common.ChangeInfo o ) { java.util.List < com.google.gerrit.extensions.common.ChangeMessageInfo > r = com.google.common.collect.Lists.newArrayListWithCapacity ( i.messages.size ( ) ) ; for ( com.google.gerrit.server.change.ChangeJson.ChangeMessageInfo m : i.messages ) { com.google.gerrit.extensions.common.ChangeMessageInfo cmi = new com.google.gerrit.extensions.common.ChangeMessageInfo ( ) ; cmi.id = m.id ; cmi.author = com.google.gerrit.server.api.accounts.AccountInfoMapper.fromAcountInfo ( m.author ) ; cmi.date = m.date ; cmi.message = m.message ; cmi._revisionNumber = m._revisionNumber ; r.add ( cmi ) ; } o.messages = r ; }
public void parseTopic ( ) throws java.lang.Exception { assertParseSucceeds ( ( "Update change\n" + ( ( ( ( ( "\n" + "Branch: refs/heads/master\n" ) + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" ) + "Patch-Set: 1\n" ) + "Topic: Some Topic\n" ) + "Subject: This is a test change\n" ) ) ) ; assertParseSucceeds ( ( "Update change\n" + ( ( ( ( ( "\n" + "Branch: refs/heads/master\n" ) + "Change-id: I577fb248e474018276351785930358ec0450e9f7\n" ) + "Patch-Set: 1\n" ) + "Topic:\n" ) + "Subject: This is a test change\n" ) ) ) ; assertParseFails ( ( "Update change\n" + ( ( ( "\n" + "Patch-Set: 1\n" ) + "Topic: Some Topic\n" ) + "Topic: Other Topic" ) ) ) ; }
public void testDeleteResponseOK ( ) throws java.lang.Exception { wireMockRule.givenThat ( com.github.tomakehurst.wiremock.client.WireMock.delete ( com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo ( com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.ENDPOINT ) ) . willReturn ( com.github.tomakehurst.wiremock.client.WireMock.aResponse ( ) . withStatus ( com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.NO_CONTENT ) ) ) ; com.google.common.truth.Truth.assertThat ( httpSession.delete ( com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpSessionTest.ENDPOINT ) . isSuccessful ( ) ) . isTrue ( ) ; }
public static java.lang.String messageUUID ( com.google.gerrit.reviewdb.server.ReviewDb db ) throws com.google.gwtorm.server.OrmException { int p ; int s ; synchronized ( com.google.gerrit.server.ChangeUtil.uuidLock ) { if ( ( com.google.gerrit.server.ChangeUtil.uuidSeq ) == 0 ) { com.google.gerrit.server.ChangeUtil.uuidPrefix = db.nextChangeMessageId ( ) ; com.google.gerrit.server.ChangeUtil.uuidSeq = java.lang.Integer.MAX_VALUE ; } p = com.google.gerrit.server.ChangeUtil.uuidPrefix ; s = ( com.google.gerrit.server.ChangeUtil.uuidSeq ) -- ; } java.lang.String u = com.google.gerrit.server.util.IdGenerator.format ( com.google.gerrit.server.util.IdGenerator.mix ( com.google.gerrit.server.ChangeUtil.SEED , p ) ) ; java.lang.String l = com.google.gerrit.server.util.IdGenerator.format ( com.google.gerrit.server.util.IdGenerator.mix ( p , s ) ) ; return ( u + '_' ) + l ; }
public void setUpMocks ( ) { changeId = new com.google.gerrit.reviewdb.client.Change.Id ( com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandlerTest.CHANGE_ID ) ; accountId = new com.google.gerrit.reviewdb.client.Account.Id ( com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandlerTest.ACCOUNT_ID ) ; accountGroupUUID = new com.google.gerrit.reviewdb.client.AccountGroup.UUID ( com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandlerTest.UUID ) ; indexEventHandler = new com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandler ( com.google.common.util.concurrent.MoreExecutors.directExecutor ( ) , com.ericsson.gerrit.plugins.highavailability.index.IndexEventHandlerTest.PLUGIN_NAME , forwarder ) ; }
protected void configure ( ) { bind ( java.lang.String.class ) . annotatedWith ( com.google.gerrit.extensions.annotations.PluginName.class ) . toInstance ( "ItsTestName" ) ; serverConfig = createMock ( org.eclipse.jgit.lib.Config.class ) ; bind ( org.eclipse.jgit.lib.Config.class ) . annotatedWith ( com.google.gerrit.server.config.GerritServerConfig.class ) . toInstance ( serverConfig ) ; issueExtractor = createMock ( com.googlesource.gerrit.plugins.hooks.util.IssueExtractor.class ) ; bind ( com.googlesource.gerrit.plugins.hooks.util.IssueExtractor.class ) . toInstance ( issueExtractor ) ; itsFacade = createMock ( com.googlesource.gerrit.plugins.hooks.its.ItsFacade.class ) ; bind ( com.googlesource.gerrit.plugins.hooks.its.ItsFacade.class ) . toInstance ( itsFacade ) ; }
public void onKeyDown ( com.google.gwt.event.dom.client.KeyDownEvent event ) { if ( ( event.getNativeKeyCode ( ) ) == ( com.google.gwt.event.dom.client.KeyCodes.KEY_ENTER ) ) { if ( userPopup.isShowing ( ) ) { userPopup.hide ( ) ; } else { userPopup.showRelativeTo ( l ) ; } event.preventDefault ( ) ; } }
private static java.lang.String nameOf ( java.io.File jar ) { java.lang.String name = jar.getName ( ) ; if ( name.endsWith ( ".disabled" ) ) { name = name.substring ( 0 , name.lastIndexOf ( '.' ) ) ; } int ext = name.lastIndexOf ( '.' ) ; return 0 < ext ? name.substring ( 0 , ext ) : name ; }
public void configureServlets ( ) { serveRegex ( "^/gerrit_ui/(?!rpc/)(.*)$" ) . with ( com.google.inject.Key.get ( javax.servlet.http.HttpServlet.class , com.google.inject.name.Names.named ( com.google.gerrit.httpd.raw.StaticModule.GWT_UI_SERVLET ) ) ) ; com.google.gerrit.httpd.raw.StaticModule.Paths p = getPaths ( ) ; if ( p.isDev ( ) ) { filter ( "/" ) . through ( new com.google.gerrit.httpd.raw.RecompileGwtUiFilter ( p.builder , p.unpackedWar ) ) ; } }
private void listen ( com.google.gerrit.server.plugins.JarScanner.ExtensionMetaData def ) throws com.google.gerrit.server.plugins.InvalidPluginException { java.lang.Class < ? > clazz ; try { clazz = java.lang.Class.forName ( def.getClassName ( ) , false , classLoader ) ; } catch ( java.lang.ClassNotFoundException err ) { throw new com.google.gerrit.server.plugins.InvalidPluginException ( java.lang.String.format ( "Cannot load %s with @Listen" , def.getClassName ( ) ) , err ) ; } com.google.gerrit.extensions.annotations.Listen listen = clazz.getAnnotation ( com.google.gerrit.extensions.annotations.Listen.class ) ; if ( listen != null ) { listen ( clazz , clazz ) ; } else { PluginLoader.log.warn ( java.lang.String.format ( "In plugin %s asm incorrectly parsed %s with @Listen" , pluginName , clazz.getName ( ) ) ) ; } }
public void postUpdate ( com.google.gerrit.server.git.BatchUpdate.Context ctx ) throws com.google.gwtorm.server.OrmException { if ( ( updated ( ) ) && ( runHooks ) ) { hashtagsEdited.fire ( change , ctx.getUser ( ) . getAccountId ( ) , updatedHashtags , toAdd , toRemove ) ; hooks.doHashtagsChangedHook ( change , ctx.getUser ( ) . asIdentifiedUser ( ) . getAccount ( ) , toAdd , toRemove , updatedHashtags , ctx.getDb ( ) ) ; } }
java.nio.file.Path getSharedDirectory ( com.google.gerrit.server.config.PluginConfigFactory cfg , @ com.google.gerrit.extensions.annotations.PluginName java.lang.String pluginName ) throws java.io.IOException { java.lang.String sharedDirectory = com.google.common.base.Strings.emptyToNull ( cfg.getFromGerritConfig ( pluginName , true ) . getString ( com.ericsson.gerrit.plugins.highavailability.Configuration.SHARED_DIRECTORY ) ) ; if ( sharedDirectory == null ) { throw new com.google.inject.ProvisionException ( ( ( com.ericsson.gerrit.plugins.highavailability.Configuration.SHARED_DIRECTORY ) + " must be configured" ) ) ; } java.nio.file.Path sharedDirectoryPath = java.nio.file.Paths.get ( sharedDirectory ) ; java.nio.file.Files.createDirectories ( sharedDirectoryPath ) ; return sharedDirectoryPath ; }
public void isEnabledForMultipleRefs ( ) throws java.lang.Exception { com.googlesource.gerrit.plugins.uploadvalidator.ValidatorConfig config = getConfig ( ( "[plugin \"uploadvalidator\"]\n" + ( ( " ref = refs/heads/branch1\n" + " ref = refs/heads/branch2\n" ) + " blockedFileExtension = jar" ) ) ) ; com.google.common.truth.Truth.assertThat ( config.isEnabledForRef ( anyUser , projectName , "refs/heads/branch1" , "blockedFileExtension" ) ) . isTrue ( ) ; com.google.common.truth.Truth.assertThat ( config.isEnabledForRef ( anyUser , projectName , "refs/heads/branch2" , "blockedFileExtension" ) ) . isTrue ( ) ; com.google.common.truth.Truth.assertThat ( config.isEnabledForRef ( anyUser , projectName , "refs/heads/branch3" , "blockedFileExtension" ) ) . isFalse ( ) ; }
protected void bccWatchesNotifyAllComments ( ) { if ( ( db ) != null ) { try { final com.google.gerrit.server.project.ProjectState ps = getProjectState ( ) ; if ( ps != null ) { for ( final com.google.gerrit.client.reviewdb.AccountProjectWatch w : db.accountProjectWatches ( ) . notifyAllComments ( ps.getProject ( ) . getNameKey ( ) ) ) { add ( RecipientType.BCC , w.getAccountId ( ) ) ; } } } catch ( com.google.gwtorm.client.OrmException err ) { } } }
private void migrateData ( java.util.List < com.google.gerrit.server.schema.SchemaVersion > pending , com.google.gerrit.server.schema.UpdateUI ui , com.google.gerrit.reviewdb.client.CurrentSchemaVersion curr , com.google.gerrit.reviewdb.server.ReviewDb db ) throws com.google.gwtorm.server.OrmException , java.sql.SQLException { for ( com.google.gerrit.server.schema.SchemaVersion v : pending ) { com.google.common.base.Stopwatch sw = com.google.common.base.Stopwatch.createStarted ( ) ; ui.message ( java.lang.String.format ( "Migrating data to schema %d ..." , v.getVersionNbr ( ) ) ) ; v.migrateData ( db , ui ) ; v.finish ( curr , db ) ; ui.message ( java.lang.String.format ( "\t> Done (%.3f s)" , ( ( sw.elapsed ( java.util.concurrent.TimeUnit.MILLISECONDS ) ) / 1000.0 ) ) ) ; } }
private static void checkTimerDescription ( com.google.gerrit.metrics.Description desc ) { com.google.common.base.Preconditions.checkArgument ( ( ! ( desc.isConstant ( ) ) ) , "timer must not be constant" ) ; com.google.common.base.Preconditions.checkArgument ( ( ! ( desc.isGauge ( ) ) ) , "timer must not be a gauge" ) ; com.google.common.base.Preconditions.checkArgument ( ( ! ( desc.isRate ( ) ) ) , "timer must not be a rate" ) ; com.google.common.base.Preconditions.checkArgument ( desc.isCumulative ( ) , "timer must be cumulative" ) ; com.google.common.base.Preconditions.checkArgument ( ( ( desc.getTimeUnit ( ) ) != null ) , "timer must have a unit" ) ; }
private static java.lang.String authorName ( com.google.gerrit.client.changes.CommentInfo info ) { if ( ( info.author ( ) ) != null ) { if ( ( info.author ( ) . name ( ) ) != null ) { return info.author ( ) . name ( ) ; } return com.google.gerrit.client.Gerrit.info ( ) . user ( ) . anonymousCowardName ( ) ; } return Util.C.messageNoAuthor ( ) ; }
public void withDuplicateSystemGroupCaseSensitiveName_Conflict ( ) throws java.lang.Exception { java.lang.String newGroupName = "Registered Users" ; adminSshSession.exec ( ( ( "gerrit create-group '" + newGroupName ) + "'" ) ) ; com.google.common.truth.Truth.assert_ ( ) . withFailureMessage ( adminSshSession.getError ( ) ) . that ( adminSshSession.hasError ( ) ) . isTrue ( ) ; com.google.common.truth.Truth.assertThat ( adminSshSession.getError ( ) ) . isEqualTo ( ( ( "fatal: group '" + newGroupName ) + "\' already exists\n" ) ) ; }
com.googlesource.gerrit.plugins.findowners.OwnersDb get ( com.google.gerrit.server.account.AccountCache accountCache , com.google.gerrit.server.account.Emails emails , org.eclipse.jgit.lib.Repository repository , com.google.gerrit.server.query.change.ChangeData changeData , int patchset ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Project.NameKey project = changeData.change ( ) . getProject ( ) ; java.lang.String branch = changeData.change ( ) . getDest ( ) . get ( ) ; java.lang.String dbKey = com.googlesource.gerrit.plugins.findowners.Cache.makeKey ( changeData.getId ( ) . get ( ) , patchset , branch ) ; return get ( accountCache , emails , dbKey , repository , project , branch , changeData.currentFilePaths ( ) ) ; }
public void modifyCommitMessage ( java.lang.String newCommitMessage ) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.change.ChangeEdits.EditMessage.Input input = new com.google.gerrit.server.change.ChangeEdits.EditMessage.Input ( ) ; input.message = newCommitMessage ; try { modifyChangeEditCommitMessage.apply ( changeResource , input ) ; } catch ( java.lang.Exception e ) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException ( "Cannot modify commit message of change edit" , e ) ; } }
public void commitWhoseParentIsUninterestingGetsNewGroup ( ) throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit branchTip = tr.commit ( ) . create ( ) ; org.eclipse.jgit.revwalk.RevCommit a = tr.commit ( ) . parent ( branchTip ) . create ( ) ; com.google.common.collect.SortedSetMultimap < org.eclipse.jgit.lib.ObjectId , java.lang.String > groups = com.google.gerrit.server.git.GroupCollectorTest.collectGroups ( newWalk ( a , branchTip ) , com.google.gerrit.server.git.GroupCollectorTest.patchSets ( ) , com.google.gerrit.server.git.GroupCollectorTest.groups ( ) ) ; com.google.common.truth.Truth.assertThat ( groups ) . containsEntry ( a , a.name ( ) ) ; }
private java.util.List < com.google.gerrit.reviewdb.client.AccountGroupById > loadIncludes ( ) throws com.google.gwtorm.server.OrmException { if ( ! ( control.canSeeGroup ( ) ) ) { return com.google.common.collect.ImmutableList.of ( ) ; } java.util.List < com.google.gerrit.reviewdb.client.AccountGroupById > groups = new java.util.ArrayList < > ( ) ; for ( com.google.gerrit.reviewdb.client.AccountGroupById m : db.accountGroupById ( ) . byGroup ( groupId ) ) { groups.add ( m ) ; } return groups ; }
public static java.lang.String projectQuery ( com.google.gerrit.reviewdb.Project.NameKey proj , com.google.gerrit.reviewdb.Change.Status status ) { switch ( status ) { case ABANDONED : return "status:abandoned " + ( com.google.gerrit.common.PageLinks.op ( "project" , proj.get ( ) ) ) ; case MERGED : return "status:merged " + ( com.google.gerrit.common.PageLinks.op ( "project" , proj.get ( ) ) ) ; case NEW : case SUBMITTED : default : return "status:open " + ( com.google.gerrit.common.PageLinks.op ( "project" , proj.get ( ) ) ) ; } }
private org.eclipse.jgit.lib.Repository openRepository ( final com.google.gerrit.reviewdb.Change change ) { com.google.gerrit.reviewdb.Project.NameKey name = change.getProject ( ) ; try { return repoManager.openRepository ( name.get ( ) ) ; } catch ( org.eclipse.jgit.errors.RepositoryNotFoundException err ) { com.google.gerrit.common.ChangeHookRunner.log.warn ( ( "Cannot open repository " + ( name.get ( ) ) ) , err ) ; return null ; } }
private void executeUpdateRepo ( ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.git.UpdateException { try { com.google.gerrit.server.git.BatchUpdate.RepoContext ctx = new com.google.gerrit.server.git.BatchUpdate.RepoContext ( ) ; for ( com.google.gerrit.server.git.BatchUpdate.Op op : ops.values ( ) ) { op.updateRepo ( ctx ) ; } if ( ( inserter ) != null ) { inserter.flush ( ) ; } } catch ( java.lang.Exception e ) { com.google.common.base.Throwables.propagateIfPossible ( e , com.google.gerrit.extensions.restapi.RestApiException.class ) ; throw new com.google.gerrit.server.git.UpdateException ( e ) ; } }
public static synchronized com.google.gerrit.server.GerritServer getInstance ( ) throws com.google.gwtjsonrpc.server.XsrfException , com.google.gwtorm.client.OrmException { if ( ( com.google.gerrit.server.GerritServer.impl ) == null ) { try { com.google.gerrit.server.GerritServer.impl = new com.google.gerrit.server.GerritServer ( ) ; } catch ( com.google.gwtorm.client.OrmException e ) { com.google.gerrit.server.GerritServer.log.error ( "GerritServer ORM is unavailable" , e ) ; throw e ; } catch ( com.google.gwtjsonrpc.server.XsrfException e ) { com.google.gerrit.server.GerritServer.log.error ( "GerritServer XSRF support failed to initailize" , e ) ; throw e ; } } return com.google.gerrit.server.GerritServer.impl ; }
void set ( com.google.gerrit.client.info.ChangeInfo info ) { this . changeId = info.legacyId ( ) ; this . project = info.projectNameKey ( ) ; this . canEdit = ( info.hasActions ( ) ) && ( info.actions ( ) . containsKey ( "assignee" ) ) ; assigneeSuggestOracle.setChange ( info ) ; setAssignee ( info.assignee ( ) ) ; editAssigneeIcon.setVisible ( canEdit ) ; if ( ! ( canEdit ) ) { show.setTitle ( null ) ; } }
private java.lang.String configurationToString ( ) { java.lang.StringBuilder b = new java.lang.StringBuilder ( ) ; b.append ( "Supermanifest config (" ) . append ( config.size ( ) ) . append ( ") {\n" ) ; for ( com.googlesource.gerrit.plugins.supermanifest.ConfigEntry c : config ) { b.append ( " " ) . append ( c ) . append ( "\n" ) ; } b.append ( "}\n" ) ; return b.toString ( ) ; }
public org.kohsuke.github.GitHub login ( com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.AccessToken authToken ) throws java.io.IOException { com.googlesource.gerrit.plugins.github.oauth.GitHubLogin.log.debug ( "Logging in using access token {}" , authToken.access_token ) ; this . token = authToken ; this . hub = org.kohsuke.github.GitHub.connectUsingOAuth ( authToken.access_token ) ; this . myself = hub.getMyself ( ) ; return this . hub ; }
org.eclipse.jgit.lib.ObjectId getTestAgainst ( ) throws com.google.gwtorm.server.OrmException { if ( ( testAgainst ) == null ) { testAgainst = org.eclipse.jgit.lib.ObjectId.fromString ( changeDataFactory.create ( db.get ( ) , change ) . currentPatchSet ( ) . getRevision ( ) . get ( ) ) ; } return testAgainst ; }
public static com.google.gerrit.server.notedb.ChangeBundle fromNotes ( com.google.gerrit.server.PatchLineCommentsUtil plcUtil , com.google.gerrit.server.notedb.ChangeNotes notes ) throws com.google.gwtorm.server.OrmException { return new com.google.gerrit.server.notedb.ChangeBundle ( notes.getChange ( ) , notes.getChangeMessages ( ) , notes.getPatchSets ( ) . values ( ) , notes.getApprovals ( ) . values ( ) , com.google.common.collect.Iterables.concat ( plcUtil.draftByChange ( null , notes ) , plcUtil.publishedByChange ( null , notes ) ) , com.google.gerrit.server.notedb.ChangeBundle.Source.NOTE_DB ) ; }
protected byte [ ] indexRowData ( T obj ) { final long now = java.lang.System.currentTimeMillis ( ) ; final com.google.gwtorm.nosql.IndexKeyBuilder b = new com.google.gwtorm.nosql.IndexKeyBuilder ( ) ; encodePrimaryKey ( b , com.google.gwtorm.nosql.generic.GenericAccess.primaryKey ( obj ) ) ; final byte [ ] key = b.toByteArray ( ) ; return IndexRow.CODEC.encodeToByteArray ( com.google.gwtorm.nosql.IndexRow.forKey ( now , key ) ) ; }
com.google.gerrit.server.account.externalids.ExternalId get ( com.google.gerrit.server.account.externalids.ExternalId.Key key , org.eclipse.jgit.lib.ObjectId rev ) throws java.io.IOException , org.eclipse.jgit.errors.ConfigInvalidException { checkReadEnabled ( ) ; if ( rev.equals ( org.eclipse.jgit.lib.ObjectId.zeroId ( ) ) ) { return null ; } try ( org.eclipse.jgit.lib.Repository repo = repoManager.openRepository ( allUsersName ) ; org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk ( repo ) ) { return com.google.gerrit.server.account.externalids.ExternalIdReader.parse ( key , rw , rev ) ; } }
void resizePaddingWidget ( ) { selfWidget.changed ( ) ; com.google.gwt.core.client.Scheduler.get ( ) . scheduleDeferred ( new com.google.gwt.core.client.Scheduler.ScheduledCommand ( ) { @ java.lang.Override public void execute ( ) { if ( ( diffChunkInfo ) != null ) { parent.resizePaddingOnOtherSide ( getCommentInfo ( ) . side ( ) , diffChunkInfo.getEnd ( ) ) ; } else { assert ( selfWidget ) != null ; assert ( widgetManager ) != null ; widgetManager.resizePaddingWidget ( ) ; } } } ) ; }
public void onFailure ( final java.lang.Throwable caught ) { if ( com.google.gerrit.client.rpc.RestApi.isNotFound ( caught ) ) { com.google.gerrit.client.Gerrit.getUserAccount ( ) . setUserName ( null ) ; display ( ) ; } else { super . onFailure ( caught ) ; } }
public static boolean isSqlPrimitive ( final java.lang.Class < ? > type ) { if ( ( type == null ) || ( type == ( java.lang.Void.TYPE ) ) ) { return false ; } if ( type.isPrimitive ( ) ) { return true ; } if ( type == ( java.lang.String.class ) ) { return true ; } if ( type == ( java.sql.Timestamp.class ) ) { return true ; } return false ; }
void onDelete ( int idx ) { java.lang.String path = list.get ( idx ) . path ( ) ; com.google.gerrit.client.changes.ChangeFileApi.deleteContent ( curr , path , new com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.client.VoidResult > ( ) { @ java.lang.Override public void onSuccess ( com.google.gerrit.client.VoidResult result ) { com.google.gerrit.client.Gerrit.display ( com.google.gerrit.common.PageLinks.toChangeInEditMode ( curr.getParentKey ( ) ) ) ; } @ java.lang.Override public void onFailure ( java.lang.Throwable caught ) { } } ) ; }
private com.google.gerrit.server.account.AccountState missing ( com.google.gerrit.reviewdb.client.Account.Id accountId ) { com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account ( accountId , com.google.gerrit.common.TimeUtil.nowTs ( ) ) ; account.setActive ( false ) ; return com.google.gerrit.server.account.AccountState.forAccount ( allUsersName , account ) ; }
public void onSuccess ( final java.util.List < com.google.gerrit.common.data.SshHostKey > result ) { serverKeys.clear ( ) ; for ( final com.google.gerrit.common.data.SshHostKey keyInfo : result ) { serverKeys.add ( new com.google.gerrit.client.account.SshHostKeyPanel ( keyInfo ) ) ; } if ( ( ++ ( loadCount ) ) == 2 ) { display ( ) ; } }
private void initChangeAction ( com.google.gerrit.client.changes.ChangeInfo info ) { if ( ( info.status ( ) ) == ( com.google.gerrit.reviewdb.client.Change.Status.DRAFT ) ) { com.google.gerrit.client.rpc.NativeMap < com.google.gerrit.client.actions.ActionInfo > actions = ( info.has_actions ( ) ) ? info.actions ( ) : com.google.gerrit.client.rpc.NativeMap.< com.google.gerrit.client.actions.ActionInfo > create ( ) ; actions.copyKeysIntoChildren ( "id" ) ; if ( actions.containsKey ( "/" ) ) { deleteChange.setVisible ( true ) ; deleteChange.setTitle ( actions.get ( "/" ) . title ( ) ) ; } } }
private com.google.gerrit.acceptance.server.mail.StagedChange stageChangeWithExtraReviewer ( com.google.gerrit.acceptance.server.mail.DeleteReviewerSenderIT.Stager stager ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stager.stage ( ) ; com.google.gerrit.extensions.api.changes.ReviewInput in = com.google.gerrit.extensions.api.changes.ReviewInput.noScore ( ) . reviewer ( extraReviewer.email ) . reviewer ( extraCcer.email , ReviewerState.CC , false ) ; gApi.changes ( ) . id ( sc.changeId ) . revision ( "current" ) . review ( in ) ; return sc ; }
java.lang.Iterable < com.google.gerrit.reviewdb.client.PatchSetApproval > getForPatchSet ( com.google.gerrit.reviewdb.server.ReviewDb db , com.google.gerrit.server.project.ChangeControl ctl , com.google.gerrit.reviewdb.client.PatchSet.Id psId , @ com.google.gerrit.common.Nullable org.eclipse.jgit.revwalk.RevWalk rw , @ com.google.gerrit.common.Nullable org.eclipse.jgit.lib.Config repoConfig ) throws com.google.gwtorm.server.OrmException { return getForPatchSet ( db , ctl , psId , rw , repoConfig , java.util.Collections.< com.google.gerrit.reviewdb.client.PatchSetApproval > emptyList ( ) ) ; }
protected java.util.List < com.google.gerrit.extensions.common.ChangeInfo > assertQuery ( com.google.gerrit.extensions.api.changes.Changes.QueryRequest query , com.google.gerrit.reviewdb.client.Change ... changes ) throws java.lang.Exception { java.util.List < com.google.gerrit.extensions.common.ChangeInfo > result = query.get ( ) ; java.lang.Iterable < java.lang.Integer > ids = com.google.gerrit.server.query.change.AbstractQueryChangesTest.ids ( result ) ; com.google.common.truth.Truth.assertThat ( ids ) . named ( ids.toString ( ) ) . containsExactlyElementsIn ( com.google.gerrit.server.query.change.AbstractQueryChangesTest.ids ( changes ) ) . inOrder ( ) ; return result ; }
public com.google.common.util.concurrent.ListenableFuture < java.lang.Void > delete ( com.google.gerrit.server.query.change.ChangeData cd ) throws java.io.IOException { org.apache.lucene.index.Term id = com.google.gerrit.lucene.QueryBuilder.idTerm ( cd ) ; return com.google.gerrit.lucene.LuceneChangeIndex.allOf ( openIndex.delete ( id ) , closedIndex.delete ( id ) ) ; }
public int getIssuePatternGroupIndex ( ) { java.util.regex.Pattern pattern = getIssuePattern ( ) ; int groupCount = pattern.matcher ( "" ) . groupCount ( ) ; int index = getPluginConfigInt ( "commentlinkGroupIndex" , 1 ) ; if ( ( index < 0 ) || ( index > groupCount ) ) { index = ( groupCount == 0 ) ? 0 : 1 ; } return index ; }
private java.util.Set < com.google.gerrit.server.change.PostReview.CommentSetEntry > readExistingComments ( com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx ) throws com.google.gwtorm.server.OrmException { java.util.Set < com.google.gerrit.server.change.PostReview.CommentSetEntry > r = new java.util.HashSet < > ( ) ; for ( com.google.gerrit.reviewdb.client.PatchLineComment c : plcUtil.publishedByChange ( ctx.getDb ( ) , ctx.getNotes ( ) ) ) { r.add ( com.google.gerrit.server.change.PostReview.CommentSetEntry.create ( c ) ) ; } return r ; }
protected void deny ( com.google.gerrit.reviewdb.client.Project.NameKey p , java.lang.String permission , com.google.gerrit.reviewdb.client.AccountGroup.UUID id , java.lang.String ref ) throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet ( p ) . getConfig ( ) ; com.google.gerrit.server.project.Util.deny ( cfg , permission , id , ref ) ; saveProjectConfig ( p , cfg ) ; }
protected void configure ( ) { com.google.gerrit.extensions.registration.DynamicSet.bind ( binder ( ) , com.google.gerrit.server.git.validators.CommitValidationListener.class ) . to ( com.googlesource.gerrit.plugins.uploadvalidator.SymlinkValidator.class ) ; bind ( com.google.gerrit.server.config.ProjectConfigEntry.class ) . annotatedWith ( com.google.gerrit.extensions.annotations.Exports.named ( com.googlesource.gerrit.plugins.uploadvalidator.SymlinkValidator.KEY_CHECK_SYMLINK ) ) . toInstance ( new com.google.gerrit.server.config.ProjectConfigEntry ( "Reject Symbolic Links" , "false" , com.google.gerrit.extensions.api.projects.ProjectConfigEntryType.BOOLEAN , null , false , ( "Symbolic Links. Pushes of commits that include symbolic " + "links will be rejected." ) ) ) ; }
public void changeMessageWithTrailingDoubleNewline ( ) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange ( ) ; com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate ( c , changeOwner ) ; update.setChangeMessage ( "Testing trailing double newline\n\n" ) ; update.commit ( ) ; assertBodyEquals ( ( "Update patch set 1\n" + ( ( ( ( ( "\n" + "Testing trailing double newline\n" ) + "\n" ) + "\n" ) + "\n" ) + "Patch-set: 1\n" ) ) , update.getResult ( ) ) ; }
public com.google.gerrit.extensions.registration.DynamicSet < T > . ReloadableHandle replace ( com.google.inject.Key < T > newKey , com.google.inject.Provider < T > newItem ) { if ( ref.compareAndSet ( item , newItem ) ) { return new ReloadableHandle ( ref , newKey , newItem ) ; } return null ; }
private java.util.Set < com.google.gerrit.reviewdb.client.AccountGroup.UUID > groupsOf ( com.google.gerrit.reviewdb.client.Account.Id account ) { return new java.util.HashSet ( com.google.common.collect.Sets.filter ( userFactory.create ( account ) . getEffectiveGroups ( ) . getKnownGroups ( ) , new com.google.common.base.Predicate < com.google.gerrit.reviewdb.client.AccountGroup.UUID > ( ) { @ java.lang.Override public boolean apply ( com.google.gerrit.reviewdb.client.AccountGroup.UUID in ) { return ! ( com.google.gerrit.server.group.SystemGroupBackend.isSystemGroup ( in ) ) ; } } ) ) ; }
public void listTasksWithoutViewQueueCapability ( ) throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = userSession.get ( "/config/server/tasks/" ) ; r.assertOK ( ) ; java.util.List < com.google.gerrit.server.config.ListTasks.TaskInfo > result = newGson ( ) . fromJson ( r.getReader ( ) , new com.google.gson.reflect.TypeToken < java.util.List < com.google.gerrit.server.config.ListTasks.TaskInfo > > ( ) { } . getType ( ) ) ; com.google.common.truth.Truth.assertThat ( result ) . isEmpty ( ) ; }
public void update ( final java.lang.Iterable < T > instances ) throws com.google.gwtorm.server.OrmException { try { if ( schema.getDialect ( ) . canDetermineTotalBatchUpdateCount ( ) ) { updateAsBatch ( instances ) ; } else { updateIndividually ( instances ) ; } } catch ( java.sql.SQLException e ) { throw convertError ( "update" , e ) ; } }
protected void preDisplay ( com.google.gerrit.client.projects.ConfigInfoCache.Entry result ) { commentManager = new com.google.gerrit.client.diff.UnifiedCommentManager ( this , base , revision , path , result.getCommentLinkProcessor ( ) , getChangeStatus ( ) . isOpen ( ) ) ; setTheme ( result.getTheme ( ) ) ; display ( comments ) ; header.setupPrevNextFiles ( comments ) ; }
public void onEvent ( com.google.gerrit.server.events.Event event ) { if ( event instanceof com.google.gerrit.server.events.ChangeMergedEvent ) { com.google.gerrit.server.events.ChangeMergedEvent changeMergedEvent = ( ( com.google.gerrit.server.events.ChangeMergedEvent ) ( event ) ) ; mergeResults.put ( changeMergedEvent.change.number , changeMergedEvent.newRev ) ; } else if ( event instanceof com.google.gerrit.server.events.RefUpdatedEvent ) { com.google.gerrit.server.events.RefUpdatedEvent e = ( ( com.google.gerrit.server.events.RefUpdatedEvent ) ( event ) ) ; com.google.gerrit.server.data.RefUpdateAttribute r = e.refUpdate ; refUpdatedEvents.put ( ( ( ( r.project ) + "-" ) + ( r.refName ) ) , r.newRev ) ; } }
public void pathOfFixReplacementIsMandatory ( ) throws java.lang.Exception { com.google.common.truth.TruthJUnit.assume ( ) . that ( notesMigration.enabled ( ) ) . isTrue ( ) ; fixReplacementInfo.path = null ; exception.expect ( com.google.gerrit.extensions.restapi.BadRequestException.class ) ; exception.expectMessage ( java.lang.String.format ( "A file path must be given for the replacement of the robot comment on %s" , withFixRobotCommentInput.path ) ) ; addRobotComment ( changeId , withFixRobotCommentInput ) ; }
com.google.common.hash.Funnel < K > funnel ( ) { return new com.google.common.hash.Funnel < K > ( ) { private static final long serialVersionUID = 1L ; @ java.lang.Override public void funnel ( K from , com.google.common.hash.PrimitiveSink into ) { try { java.io.ObjectOutputStream ser = new java.io.ObjectOutputStream ( new com.google.gerrit.server.cache.h2.H2CacheImpl.SinkOutputStream ( into ) ) ; ser.writeObject ( from ) ; ser.flush ( ) ; } catch ( java.io.IOException err ) { throw new java.lang.RuntimeException ( "Cannot hash as Serializable" , err ) ; } } } ; }
public void onSuccess ( java.lang.Void result ) { if ( prefs.syntaxHighlighting ( ) ) { cmA.setOption ( "mode" , getContentType ( diff.meta_a ( ) ) ) ; cmB.setOption ( "mode" , getContentType ( diff.meta_b ( ) ) ) ; } }
public synchronized void deleteRepository ( com.google.gerrit.reviewdb.client.Project.NameKey name ) { repos.remove ( com.google.gerrit.testutil.InMemoryRepositoryManager.normalize ( name ) ) ; }
public org.parboiled.Rule typeOfNote ( ) { return firstOf ( sequence ( string ( "note" ) , push ( match ( ) ) ) , sequence ( string ( "promo" ) , push ( match ( ) ) ) , sequence ( string ( "aside" ) , push ( match ( ) ) ) ) ; }
public void listOneIncludeMember ( ) throws java.lang.Exception { java.lang.String gx = group ( "gx" ) ; java.lang.String gy = group ( "gy" ) ; gApi.groups ( ) . id ( gx ) . addGroups ( gy ) ; assertIncludes ( gApi.groups ( ) . id ( gx ) . includedGroups ( ) , gy ) ; }
public java.lang.String get ( ) { java.lang.String canonicalUrl = super . get ( ) ; if ( canonicalUrl != null ) { return canonicalUrl ; } return guessUrlFromHttpRequest ( ) . orElseGet ( ( ) -> ( "http://" + ( org.eclipse.jgit.util.SystemReader.getInstance ( ) . getHostname ( ) ) ) + '/' ) ; }
public java.lang.Object apply ( com.google.gerrit.server.group.GroupResource resource , com.google.gerrit.server.group.AddMembers.PutMember.Input input ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.extensions.restapi.BadRequestException , com.google.gerrit.extensions.restapi.MethodNotAllowedException , com.google.gwtorm.server.OrmException { com.google.gerrit.server.group.AddMembers.Input in = new com.google.gerrit.server.group.AddMembers.Input ( ) ; in._oneMember = id ; java.util.List < com.google.gerrit.server.group.MembersCollection.MemberInfo > list = put.get ( ) . apply ( resource , in ) ; if ( list.isEmpty ( ) ) { return com.google.gerrit.extensions.restapi.Response.none ( ) ; } else if ( ( list.size ( ) ) == 1 ) { return list.get ( 0 ) ; } else { throw new java.lang.IllegalStateException ( ) ; } }
public com.google.gitiles.doc.html.HtmlBuilder close ( java.lang.String tag ) { com.google.common.base.Preconditions.checkArgument ( ( ( com.google.gitiles.doc.html.HtmlBuilder.ALLOWED_TAGS.contains ( tag ) ) && ( ! ( com.google.gitiles.doc.html.HtmlBuilder.SELF_CLOSING_TAGS.contains ( tag ) ) ) ) , "invalid HTML tag %s" , tag ) ; finishActiveTag ( ) ; try { htmlBuf.append ( "</" ) . append ( tag ) . append ( '>' ) ; } catch ( java.io.IOException e ) { throw new com.google.gitiles.doc.RuntimeIOException ( e ) ; } return this ; }
private static com.google.gerrit.client.reviewdb.AccountExternalId lookupGoogleAccount ( final com.google.gerrit.client.reviewdb.AccountExternalIdAccess extAccess , final java.lang.String email ) throws com.google.gwtorm.client.OrmException { final java.util.List < com.google.gerrit.client.reviewdb.AccountExternalId > m = new java.util.ArrayList < com.google.gerrit.client.reviewdb.AccountExternalId > ( ) ; for ( final com.google.gerrit.client.reviewdb.AccountExternalId e : extAccess.byEmailAddress ( email ) ) { if ( e.getExternalId ( ) . equals ( ( "Google Account " + email ) ) ) { m.add ( e ) ; } } return ( m.size ( ) ) == 1 ? m.get ( 0 ) : null ; }
protected void configure ( ) { install ( new com.google.gerrit.server.config.FactoryModule ( ) { @ java.lang.Override protected void configure ( ) { factory ( ForwardingRemovalListener.Factory.class ) ; } } ) ; bind ( com.google.gerrit.server.cache.h2.DefaultCacheFactory.class ) ; bind ( com.google.gerrit.server.cache.MemoryCacheFactory.class ) . to ( com.google.gerrit.server.cache.h2.DefaultCacheFactory.class ) ; bind ( com.google.gerrit.server.cache.PersistentCacheFactory.class ) . to ( com.google.gerrit.server.cache.h2.H2CacheFactory.class ) ; listener ( ) . to ( com.google.gerrit.server.cache.h2.H2CacheFactory.class ) ; }
public boolean isReviewer ( com.google.gerrit.reviewdb.server.ReviewDb db , @ com.google.gerrit.common.Nullable com.google.gerrit.server.query.change.ChangeData cd ) throws com.google.gwtorm.server.OrmException { if ( getCurrentUser ( ) . isIdentifiedUser ( ) ) { java.util.Collection < com.google.gerrit.reviewdb.client.Account.Id > results = changeData ( db , cd ) . reviewers ( ) . values ( ) ; com.google.gerrit.server.IdentifiedUser user = ( ( com.google.gerrit.server.IdentifiedUser ) ( getCurrentUser ( ) ) ) ; return results.contains ( user.getAccountId ( ) ) ; } return false ; }
private static java.util.List < java.lang.reflect.Method > getConfigs ( java.lang.Class < ? > clazz ) { java.util.List < java.lang.reflect.Method > result = com.google.common.collect.Lists.newArrayListWithExpectedSize ( 3 ) ; for ( java.lang.reflect.Method m : clazz.getMethods ( ) ) { com.google.gerrit.testutil.ConfigSuite.Config ann = m.getAnnotation ( com.google.gerrit.testutil.ConfigSuite.Config.class ) ; if ( ann != null ) { com.google.common.base.Preconditions.checkArgument ( ( ! ( m.getName ( ) . equals ( com.google.gerrit.testutil.ConfigSuite.DEFAULT ) ) ) , "%s cannot be named %s" , ann , com.google.gerrit.testutil.ConfigSuite.DEFAULT ) ; result.add ( m ) ; } } return result ; }
protected java.lang.String getNameFor ( final com.google.gerrit.reviewdb.client.Account.Id accountId ) { if ( accountId == null ) { return args.gerritPersonIdent.getName ( ) ; } final com.google.gerrit.reviewdb.client.Account userAccount = args.accountCache.get ( accountId ) . getAccount ( ) ; java.lang.String name = userAccount.getFullName ( ) ; if ( name == null ) { name = userAccount.getPreferredEmail ( ) ; } if ( name == null ) { name = ( ( args.anonymousCowardName ) + " #" ) + accountId ; } return name ; }
public void markReady ( ) throws java.io.IOException { try { org.eclipse.jgit.storage.file.FileBasedConfig cfg = com.google.gerrit.lucene.LuceneVersionManager.loadGerritIndexConfig ( sitePaths ) ; cfg.setBoolean ( "index" , java.lang.Integer.toString ( schema.getVersion ( ) ) , "ready" , true ) ; cfg.save ( ) ; } catch ( org.eclipse.jgit.errors.ConfigInvalidException e ) { throw new java.io.IOException ( e ) ; } }
private org.kohsuke.args4j.spi.OptionHandler findHandler ( java.lang.String name ) { if ( ( options ) == null ) { options = com.google.gerrit.util.cli.CmdLineParser.index ( parser.options ) ; } return options.get ( name ) ; }
protected java.util.List < java.lang.String > getRowItem ( int row ) { java.util.List < java.lang.String > v = new java.util.ArrayList < > ( ) ; for ( int i = 0 ; i < ( inputs.size ( ) ) ; i ++ ) { v.add ( table.getText ( row , ( i + 1 ) ) ) ; } return v ; }
public final java.util.List < com.google.gerrit.reviewdb.client.Account.FieldName > editableAccountFields ( ) { java.util.List < com.google.gerrit.reviewdb.client.Account.FieldName > fields = new java.util.ArrayList < > ( ) ; for ( java.lang.String f : com.google.gerrit.client.rpc.Natives.asList ( _editableAccountFields ( ) ) ) { fields.add ( Account.FieldName.valueOf ( f ) ) ; } return fields ; }
private void insertNoneRow ( final int row ) { insertRow ( row ) ; table.setText ( row , 0 , Util.C.changeTableNone ( ) ) ; final com.google.gwt.user.client.ui.FlexTable.FlexCellFormatter fmt = table.getFlexCellFormatter ( ) ; fmt.setColSpan ( row , 0 , columns ) ; fmt.setStyleName ( row , 0 , com.google.gerrit.client.changes.ChangeTable.S_EMPTY_SECTION ) ; }
public com.google.gerrit.extensions.registration.RegistrationHandle put ( java.lang.String pluginName , java.lang.String exportName , final com.google.inject.Provider < T > item ) { final com.google.gerrit.extensions.registration.NamePair key = new com.google.gerrit.extensions.registration.NamePair ( pluginName , exportName ) ; items.put ( key , item ) ; return new com.google.gerrit.extensions.registration.RegistrationHandle ( ) { @ java.lang.Override public void remove ( ) { items.remove ( key , item ) ; } } ; }
public java.util.List < com.google.gerrit.server.update.BatchUpdate > batchUpdates ( java.util.Collection < com.google.gerrit.reviewdb.client.Project.NameKey > projects ) throws com.google.gerrit.server.project.NoSuchProjectException , java.io.IOException { java.util.List < com.google.gerrit.server.update.BatchUpdate > updates = new java.util.ArrayList ( projects.size ( ) ) ; for ( com.google.gerrit.reviewdb.client.Project.NameKey project : projects ) { updates.add ( getRepo ( project ) . getUpdate ( ) . setRefLogMessage ( "merged" ) ) ; } return updates ; }
public void commentOnReviewableChangeByReviewer ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange ( ) ; review ( sc.reviewer , sc.changeId , com.google.gerrit.extensions.client.GeneralPreferencesInfo.EmailStrategy.ENABLED ) ; assertThat ( sender ) . sent ( "comment" , sc ) . to ( sc.owner ) . cc ( sc.ccer ) . cc ( sc.reviewerByEmail , sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS ) . noOneElse ( ) ; }
public void testUpsertOneNotExisting ( ) throws com.google.gwtorm.server.OrmException , java.sql.SQLException { java.sql.PreparedStatement update = stubStatementWithUpdateCounts ( com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE ) ; java.sql.PreparedStatement insert = stubStatementWithUpdateCounts ( com.google.gwtorm.jdbc.TestJdbcAccess.INSERT , 1 ) ; createClassUnderTest ( ) . upsert ( oneRow ) ; com.google.gwtorm.jdbc.TestJdbcAccess.assertUsedBatchingOnly ( update ) ; com.google.gwtorm.jdbc.TestJdbcAccess.assertUsedBatchingOnly ( insert ) ; com.google.gwtorm.jdbc.TestJdbcAccess.assertExpectedIdsUsed ( insert , 1 ) ; }
private com.google.gerrit.common.data.LabelTypes getLabelTypes ( ) throws java.lang.Exception { db.create ( ) ; com.google.gerrit.server.git.ProjectConfig c = new com.google.gerrit.server.git.ProjectConfig ( allProjects ) ; org.eclipse.jgit.lib.Repository repo = repoManager.openRepository ( allProjects ) ; try { c.load ( repo ) ; return new com.google.gerrit.common.data.LabelTypes ( com.google.common.collect.ImmutableList.copyOf ( c.getLabelSections ( ) . values ( ) ) ) ; } finally { repo.close ( ) ; } }
public com.google.gerrit.extensions.restapi.Response < java.lang.String > apply ( com.google.gerrit.server.config.CacheResource rsrc , com.google.gerrit.server.config.FlushCache.Input input ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.server.permissions.PermissionBackendException { if ( com.google.gerrit.server.config.FlushCache.WEB_SESSIONS.equals ( rsrc.getName ( ) ) ) { permissionBackend.user ( self ) . check ( GlobalPermission.MAINTAIN_SERVER ) ; } rsrc.getCache ( ) . invalidateAll ( ) ; return com.google.gerrit.extensions.restapi.Response.ok ( "" ) ; }
private org.eclipse.jgit.revwalk.RevCommit makeCommit ( ) throws java.io.IOException , org.eclipse.jgit.api.errors.GitAPIException , org.eclipse.jgit.api.errors.NoFilepatternException { java.util.Map < java.io.File , byte [ ] > files = new java.util.HashMap < > ( ) ; java.lang.String content = "http://foo.bar.tld/?pw=myp4ssw0rdTefoobarstline2\n" ; files.put ( new java.io.File ( repo.getDirectory ( ) . getParent ( ) , "foo.txt" ) , content.getBytes ( java.nio.charset.StandardCharsets.UTF_8 ) ) ; content = "$Id$\n" + ( ( ( "$Header$\n" + "$Author$\n" ) + "processXFile($File::Find::name, $Config{$type});\n" ) + "$Id: foo bar$\n" ) ; files.put ( new java.io.File ( repo.getDirectory ( ) . getParent ( ) , "bar.txt" ) , content.getBytes ( java.nio.charset.StandardCharsets.UTF_8 ) ) ; content = "Testline1\n" + ( ( "Testline2\n" + "Testline3\n" ) + "Testline4" ) ; files.put ( new java.io.File ( repo.getDirectory ( ) . getParent ( ) , "foobar.txt" ) , content.getBytes ( java.nio.charset.StandardCharsets.UTF_8 ) ) ; return com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.makeCommit ( repo , "Commit with test files." , files ) ; }
static void approve ( com.google.gerrit.acceptance.RestSession adminSession , java.lang.String changeId ) throws java.io.IOException { com.google.gerrit.acceptance.RestResponse r = adminSession.post ( ( ( "/changes/" + changeId ) + "/revisions/current/review" ) , new com.google.gerrit.extensions.api.changes.ReviewInput ( ) . label ( "Code-Review" , 2 ) ) ; com.google.common.truth.Truth.assertThat ( r.getStatusCode ( ) ) . isEqualTo ( HttpStatus.SC_OK ) ; r.consume ( ) ; }
private void addSshKeys ( com.googlesource.gerrit.plugins.importer.GerritApi api , com.google.gerrit.extensions.common.AccountInfo acc ) throws com.google.gerrit.common.errors.InvalidSshKeyException , com.google.gerrit.extensions.restapi.BadRequestException , com.google.gwtorm.server.OrmException , java.io.IOException , org.eclipse.jgit.errors.ConfigInvalidException { java.util.List < com.google.gerrit.extensions.common.SshKeyInfo > sshKeys = api.getSshKeys ( acc.username ) ; com.google.gerrit.server.account.AccountState a = accountCache.getByUsername ( acc.username ) ; for ( com.google.gerrit.extensions.common.SshKeyInfo sshKeyInfo : sshKeys ) { authorizedKeys.addKey ( a.getAccount ( ) . getId ( ) , sshKeyInfo.sshPublicKey ) ; } }
public com.google.gerrit.extensions.common.ChangeInfo apply ( com.google.gerrit.server.change.ChangeResource req , com.google.gerrit.extensions.api.changes.AbandonInput input ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.git.UpdateException , com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl control = req.getControl ( ) ; if ( ! ( control.canAbandon ( dbProvider.get ( ) ) ) ) { throw new com.google.gerrit.extensions.restapi.AuthException ( "abandon not permitted" ) ; } com.google.gerrit.reviewdb.client.Change change = abandon ( control , input.message , input.notify , notifyUtil.resolveAccounts ( input.notifyDetails ) ) ; return json.create ( ChangeJson.NO_OPTIONS ) . format ( change ) ; }
public void mergeByReviewer ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageChange ( ) ; merge ( sc.changeId , sc.reviewer ) ; assertThat ( sender ) . sent ( "merged" , sc ) . to ( sc.owner ) . cc ( sc.ccer ) . cc ( sc.reviewerByEmail , sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS , com.google.gerrit.server.account.WatchConfig.NotifyType.SUBMITTED_CHANGES ) . noOneElse ( ) ; }
private java.lang.String getPullUrl ( ) { final java.lang.String host = getSshHost ( ) ; if ( host == null ) { return "" ; } final java.lang.StringBuilder r = new java.lang.StringBuilder ( ) ; r.append ( "git pull ssh://" ) ; r.append ( host ) ; r.append ( "/" ) ; r.append ( projectName ) ; r.append ( " " ) ; r.append ( patchSet.getRefName ( ) ) ; return r.toString ( ) ; }
private void emptycell ( final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder m , final int colspan ) { m.openTd ( ) ; m.addStyleName ( Gerrit.RESOURCES.css ( ) . dataCell ( ) ) ; m.addStyleName ( Gerrit.RESOURCES.css ( ) . diffLinkCell ( ) ) ; m.setAttribute ( "colspan" , colspan ) ; m.nbsp ( ) ; m.closeTd ( ) ; }
private java.lang.String deserializerFor ( com.google.gwt.core.ext.typeinfo.JArrayType targetType ) { final com.google.gwt.core.ext.typeinfo.JType componentType = targetType.getComponentType ( ) ; if ( com.google.gwtjsonrpc.rebind.SerializerCreator.isBoxedPrimitive ( componentType ) ) return ( ( ( com.google.gwtjsonrpc.client.impl.ser.PrimitiveArrayResultDeserializers.class . getCanonicalName ( ) ) + "." ) + ( componentType.getSimpleSourceName ( ) . toUpperCase ( ) ) ) + "_INSTANCE" ; final java.lang.String name = generatedDeserializers.get ( targetType.getQualifiedSourceName ( ) ) ; return name == null ? null : name + ".INSTANCE" ; }
private < K , V > java.util.Map < K , V > limitToValidPatchSets ( java.util.Map < K , V > in , final com.google.common.base.Function < K , com.google.gerrit.reviewdb.client.PatchSet.Id > func ) { final com.google.common.base.Predicate < com.google.gerrit.reviewdb.client.PatchSet.Id > upToCurrent = upToCurrentPredicate ( ) ; return com.google.common.collect.Maps.filterKeys ( in , new com.google.common.base.Predicate < K > ( ) { @ java.lang.Override public boolean apply ( K in ) { com.google.gerrit.reviewdb.client.PatchSet.Id psId = func.apply ( in ) ; return ( upToCurrent.apply ( psId ) ) && ( patchSets.containsKey ( psId ) ) ; } } ) ; }
public void groupNameNoteIsMissing ( ) throws java.lang.Exception { updateGroupNamesRef ( "g-2" , "[group]\n\tuuid = uuid-2\n\tname = g-2\n" ) ; java.util.List < com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo > problems = com.google.gerrit.server.group.db.GroupsNoteDbConsistencyChecker.checkWithGroupNameNotes ( allUsersRepo , new com.google.gerrit.reviewdb.client.AccountGroup.NameKey ( "g-1" ) , new com.google.gerrit.reviewdb.client.AccountGroup.UUID ( "uuid-1" ) ) ; com.google.common.truth.Truth.assertThat ( problems ) . containsExactly ( com.google.gerrit.extensions.api.config.ConsistencyCheckInfo.ConsistencyProblemInfo.warning ( "Group with name 'g-1' doesn't exist in the list of all names" ) ) ; }
private boolean canEditTopicName ( ) { if ( getChange ( ) . getStatus ( ) . isOpen ( ) ) { return ( ( ( ( isOwner ( ) ) || ( refControl.isOwner ( ) ) ) || ( getProjectControl ( ) . isOwner ( ) ) ) || ( refControl.canEditTopicName ( ) ) ) || ( getProjectControl ( ) . isAdmin ( ) ) ; } return refControl.canForceEditTopicName ( ) ; }
public void newPatchSetOnReviewableWipChange ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableWipChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.NEW_PATCHSETS ) ; pushTo ( sc , "refs/for/master%wip" , sc.owner ) ; assertThat ( sender ) . notSent ( ) ; }
public void testChangeOwner_BlockedOnParentProject ( ) throws java.lang.Exception { setApiUser ( admin ) ; blockApproveForChangeOwner ( project ) ; com.google.gerrit.reviewdb.client.Project.NameKey child = createProject ( "child" , project ) ; setApiUser ( user ) ; grantApproveToAll ( child ) ; org.eclipse.jgit.junit.TestRepository < org.eclipse.jgit.internal.storage.dfs.InMemoryRepository > childRepo = cloneProject ( child , user ) ; java.lang.String changeId = createMyChange ( childRepo ) ; assertApproveFails ( user , changeId ) ; approve ( user2 , changeId ) ; }
public void testExecuteItem ( ) throws java.io.IOException { com.googlesource.gerrit.plugins.hooks.workflow.ActionRequest actionRequest = createMock ( com.googlesource.gerrit.plugins.hooks.workflow.ActionRequest.class ) ; org.easymock.EasyMock.expect ( actionRequest.getName ( ) ) . andReturn ( "unparsed" ) ; org.easymock.EasyMock.expect ( actionRequest.getUnparsed ( ) ) . andReturn ( "unparsed action 1" ) ; java.util.Set < com.googlesource.gerrit.plugins.hooks.workflow.Property > properties = java.util.Collections.emptySet ( ) ; its.performAction ( "4711" , "unparsed action 1" ) ; replayMocks ( ) ; com.googlesource.gerrit.plugins.hooks.workflow.ActionExecutor actionExecutor = createActionExecutor ( ) ; actionExecutor.execute ( "4711" , actionRequest , properties ) ; }
public com.google.gerrit.acceptance.RestResponse postWithHeader ( java.lang.String endPoint , java.lang.Object content , org.apache.http.Header header ) throws java.io.IOException { org.apache.http.client.fluent.Request post = org.apache.http.client.fluent.Request.Post ( getUrl ( endPoint ) ) ; if ( header != null ) { post.addHeader ( header ) ; } if ( content != null ) { post.addHeader ( new org.apache.http.message.BasicHeader ( "Content-Type" , "application/json" ) ) ; post.body ( new org.apache.http.entity.StringEntity ( OutputFormat.JSON_COMPACT.newGson ( ) . toJson ( content ) , java.nio.charset.StandardCharsets.UTF_8 ) ) ; } return execute ( post ) ; }
public void evaluate ( ) throws java.lang.Throwable { beforeTest ( description ) ; try { base.evaluate ( ) ; } finally { afterTest ( ) ; } }
public void shouldFailWithFilesWithoutPatchSetsOrCurrentPatchSetsOption ( ) throws java.lang.Exception { java.lang.String changeId = createChange ( ) . getChangeId ( ) ; adminSshSession.exec ( ( "gerrit query --files " + changeId ) ) ; com.google.common.truth.Truth.assertThat ( adminSshSession.hasError ( ) ) . isTrue ( ) ; com.google.common.truth.Truth.assertThat ( adminSshSession.getError ( ) ) . contains ( "needs --patch-sets or --current-patch-set" ) ; }
public void testUnblockRangeForNotChangeOwner ( ) { com.google.gerrit.server.project.Util.grant ( local , ( ( com.google.gerrit.common.data.Permission.LABEL ) + "Code-Review" ) , ( - 2 ) , ( + 2 ) , com.google.gerrit.server.group.SystemGroupBackend.CHANGE_OWNER , "refs/heads/*" ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.project.Util.DEVS ) ; com.google.gerrit.common.data.PermissionRange range = u.controlForRef ( "refs/heads/master" ) . getRange ( ( ( com.google.gerrit.common.data.Permission.LABEL ) + "Code-Review" ) ) ; org.junit.Assert.assertFalse ( "u can vote -2" , range.contains ( ( - 2 ) ) ) ; org.junit.Assert.assertFalse ( "u can vote +2" , range.contains ( 2 ) ) ; }
void onKeyDownInput ( com.google.gwt.event.dom.client.KeyDownEvent e ) { if ( ( e.getNativeKeyCode ( ) ) == ( com.google.gwt.event.dom.client.KeyCodes.KEY_ESCAPE ) ) { onCancel ( null ) ; } else if ( ( e.getNativeKeyCode ( ) ) == ( com.google.gwt.event.dom.client.KeyCodes.KEY_ENTER ) ) { e.stopPropagation ( ) ; onSave ( null ) ; } }
public static org.eclipse.jgit.lib.Ref updateAnnotatedTag ( org.eclipse.jgit.junit.TestRepository < ? > testRepo , java.lang.String name , org.eclipse.jgit.lib.PersonIdent tagger ) throws org.eclipse.jgit.api.errors.GitAPIException { org.eclipse.jgit.api.TagCommand tc = testRepo.git ( ) . tag ( ) . setName ( name ) ; return tc.setAnnotated ( true ) . setMessage ( name ) . setTagger ( tagger ) . setForceUpdate ( true ) . call ( ) ; }
public static java.lang.String shortestExample ( java.lang.String pattern ) { if ( com.google.gerrit.server.project.RefControl.isRE ( pattern ) ) { return com.google.gerrit.server.project.RefControl.toRegExp ( pattern ) . toAutomaton ( ) . getShortestExample ( true ) ; } else if ( pattern.endsWith ( "/*" ) ) { return ( pattern.substring ( 0 , ( ( pattern.length ( ) ) - 1 ) ) ) + '1' ; } else { return pattern ; } }
void onDiscard ( com.google.gwt.event.dom.client.ClickEvent e ) { e.stopPropagation ( ) ; if ( isNew ( ) ) { removeUI ( ) ; restoreSelection ( ) ; } else { setEdit ( false ) ; com.google.gerrit.client.changes.CommentApi.deleteDraft ( psId , comment.id ( ) , new com.google.gerrit.client.rpc.GerritCallback < com.google.gwt.core.client.JavaScriptObject > ( ) { @ java.lang.Override public void onSuccess ( com.google.gwt.core.client.JavaScriptObject result ) { removeUI ( ) ; } } ) ; } }
public void tearDown ( ) { if ( ( repo ) != null ) { repo.getRepository ( ) . close ( ) ; } if ( ( lifecycle ) != null ) { lifecycle.stop ( ) ; } requestContext.setContext ( null ) ; if ( ( db ) != null ) { db.close ( ) ; } com.google.gerrit.testutil.InMemoryDatabase.drop ( inMemoryDatabase ) ; }
public com.google.gerrit.extensions.common.PluginInfo apply ( com.google.gerrit.server.plugins.PluginResource resource , com.google.gerrit.server.plugins.DisablePlugin.Input input ) throws com.google.gerrit.extensions.restapi.MethodNotAllowedException { if ( ! ( loader.isRemoteAdminEnabled ( ) ) ) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException ( "remote plugin administration is disabled" ) ; } java.lang.String name = resource.getName ( ) ; loader.disablePlugins ( com.google.common.collect.ImmutableSet.of ( name ) ) ; return com.google.gerrit.server.plugins.ListPlugins.toPluginInfo ( loader.get ( name ) ) ; }
public void parseMultipleValue ( ) throws java.lang.Exception { java.lang.String in = "a.b=c,d,e" ; java.util.Map < java.lang.String , java.util.Map < java.lang.String , com.google.gerrit.extensions.api.projects.ProjectInput.ConfigValue > > r = cmd.parsePluginConfigValues ( java.util.Collections.singletonList ( in ) ) ; com.google.gerrit.extensions.api.projects.ProjectInput.ConfigValue configValue = r.get ( "a" ) . get ( "b" ) ; com.google.common.truth.Truth.assertThat ( configValue.values ) . containsExactly ( "c" , "d" , "e" ) . inOrder ( ) ; com.google.common.truth.Truth.assertThat ( configValue.value ) . isNull ( ) ; }
public void topic ( java.lang.String topic ) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.change.PutTopic.Input in = new com.google.gerrit.server.change.PutTopic.Input ( ) ; in.topic = topic ; try { putTopic.apply ( change , in ) ; } catch ( com.google.gerrit.server.update.UpdateException e ) { throw new com.google.gerrit.extensions.restapi.RestApiException ( "Cannot set topic" , e ) ; } }
private org.eclipse.jgit.transport.PushResult pushVia ( final org.eclipse.jgit.transport.Transport tn ) throws java.io.IOException , org.eclipse.jgit.errors.NotSupportedException , org.eclipse.jgit.errors.TransportException { tn.applyConfig ( config ) ; tn.setCredentialsProvider ( credentialsProvider ) ; final java.util.List < org.eclipse.jgit.transport.RemoteRefUpdate > todo = generateUpdates ( tn ) ; if ( todo.isEmpty ( ) ) { return new org.eclipse.jgit.transport.PushResult ( ) ; } return tn.push ( NullProgressMonitor.INSTANCE , todo ) ; }
boolean inCharacter ( com.googlecode.prolog_cafe.lang.Term t ) { if ( ! ( t instanceof com.googlecode.prolog_cafe.lang.SymbolTerm ) ) return false ; if ( t.equals ( com.googlecode.prolog_cafe.builtin.PRED_get_char_2.SYM_EOF ) ) return true ; return ( ( ( com.googlecode.prolog_cafe.lang.SymbolTerm ) ( t ) ) . name ( ) . length ( ) ) == 1 ; }
private < T > java.lang.String printCircularPath ( java.util.LinkedHashSet < T > p , T target ) { java.lang.StringBuilder sb = new java.lang.StringBuilder ( ) ; sb.append ( target ) ; java.util.ArrayList < T > reverseP = new java.util.ArrayList < > ( p ) ; java.util.Collections.reverse ( reverseP ) ; for ( T t : reverseP ) { sb.append ( "->" ) ; sb.append ( t ) ; if ( t.equals ( target ) ) { break ; } } return sb.toString ( ) ; }
public void testUnblockForceWithAllowNoForce_NotPossible ( ) { com.google.gerrit.common.data.PermissionRule r = com.google.gerrit.server.project.Util.block ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/heads/*" ) ; r.setForce ( true ) ; com.google.gerrit.server.project.Util.allow ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.Util.DEVS , "refs/heads/*" ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.project.Util.DEVS ) ; org.junit.Assert.assertFalse ( "u can't force push" , u.controlForRef ( "refs/heads/master" ) . canForceUpdate ( ) ) ; }
boolean isOwner ( final com.google.gerrit.server.account.GroupMembership groups ) { return com.google.common.collect.Iterables.any ( tree ( ) , new com.google.common.base.Predicate < com.google.gerrit.server.project.ProjectState > ( ) { @ java.lang.Override public boolean apply ( com.google.gerrit.server.project.ProjectState in ) { return groups.containsAnyOf ( in.localOwners ) ; } } ) ; }
private void assertContent ( com.google.gerrit.acceptance.PushOneCommit.Result pushResult , java.lang.String path , java.lang.String expectedContent ) throws java.lang.Exception { com.google.gerrit.extensions.restapi.BinaryResult bin = gApi.changes ( ) . id ( pushResult.getChangeId ( ) ) . revision ( pushResult.getCommit ( ) . name ( ) ) . file ( path ) . content ( ) ; java.io.ByteArrayOutputStream os = new java.io.ByteArrayOutputStream ( ) ; bin.writeTo ( os ) ; java.lang.String res = new java.lang.String ( os.toByteArray ( ) , java.nio.charset.StandardCharsets.UTF_8 ) ; com.google.common.truth.Truth.assertThat ( res ) . isEqualTo ( expectedContent ) ; }
public void generatesExpectedMessage ( ) throws java.lang.Exception { mockEvent.change = com.google.common.base.Suppliers.ofInstance ( mockChange ) ; mockEvent.author = com.google.common.base.Suppliers.ofInstance ( mockAccount ) ; mockEvent.comment = "This is the first line\nAnd the second line." ; mockChange.project = "testproject" ; mockChange.branch = "master" ; mockChange.url = "https://change/" ; mockAccount.name = "Unit Tester" ; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator ; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance ( mockEvent , config ) ; java.lang.String expectedResult ; expectedResult = "{\"text\": \"Unit Tester commented\\n>>>" + ( ( "testproject (master): This is the first line\n" + "And the second line. (https://change/)\"," ) + "\"channel\": \"#testchannel\",\"username\": \"testuser\"}\n" ) ; java.lang.String actualResult ; actualResult = messageGenerator.generate ( ) ; org.junit.Assert.assertThat ( actualResult , org.hamcrest.core.Is.is ( org.hamcrest.CoreMatchers.equalTo ( expectedResult ) ) ) ; }
private boolean isLive ( final java.io.File entry ) { final java.lang.String name = entry.getName ( ) ; return ( ( ( ( ErrorLogFile.LOG_NAME.equals ( name ) ) || ( "sshd_log" . equals ( name ) ) ) || ( "httpd_log" . equals ( name ) ) ) || ( "gerrit.run" . equals ( name ) ) ) || ( name.endsWith ( ".pid" ) ) ; }
public void testIsEnabledEventMultiBranchMixedMatchRegExp ( ) { java.lang.String [ ] branches = new java.lang.String [ ] { "refs/heads/foo" , "^refs/heads/test.*" } ; setupIsEnabled ( "true" , null , branches ) ; com.google.gerrit.server.events.PatchSetCreatedEvent event = new com.google.gerrit.server.events.PatchSetCreatedEvent ( ) ; com.google.gerrit.server.data.ChangeAttribute changeAttribute = new com.google.gerrit.server.data.ChangeAttribute ( ) ; changeAttribute.project = "testProject" ; changeAttribute.branch = "testBranch" ; event.change = com.google.common.base.Suppliers.ofInstance ( changeAttribute ) ; com.googlesource.gerrit.plugins.its.base.its.ItsConfig itsConfig = createItsConfig ( ) ; replayMocks ( ) ; assertTrue ( itsConfig.isEnabled ( event ) ) ; }
private Account.Id parseIdent ( org.eclipse.jgit.lib.PersonIdent ident ) throws org.eclipse.jgit.errors.ConfigInvalidException { java.lang.String email = ident.getEmailAddress ( ) ; int at = email.indexOf ( '@' ) ; if ( at >= 0 ) { java.lang.String host = email.substring ( ( at + 1 ) , email.length ( ) ) ; java.lang.Integer id = com.google.common.primitives.Ints.tryParse ( email.substring ( 0 , at ) ) ; if ( ( id != null ) && ( host.equals ( com.google.gerrit.server.notedb.ChangeNoteUtil.GERRIT_PLACEHOLDER_HOST ) ) ) { return new com.google.gerrit.reviewdb.client.Account.Id ( id ) ; } } throw parseException ( "invalid identity, expected <id>@%s: %s" , com.google.gerrit.server.notedb.ChangeNoteUtil.GERRIT_PLACEHOLDER_HOST , email ) ; }
private com.google.gerrit.reviewdb.client.PatchLineComment publishComment ( com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx , com.google.gerrit.reviewdb.client.PatchLineComment c , com.google.gerrit.reviewdb.client.PatchSet ps ) throws com.google.gwtorm.server.OrmException { c.setStatus ( PatchLineComment.Status.PUBLISHED ) ; c.setWrittenOn ( ctx.getWhen ( ) ) ; c.setTag ( in.tag ) ; com.google.gerrit.server.PatchLineCommentsUtil.setCommentRevId ( c , patchListCache , ctx.getChange ( ) , com.google.common.base.Preconditions.checkNotNull ( ps ) ) ; return c ; }
public com.google.gerrit.extensions.restapi.RestApiException apply ( java.lang.Exception input ) { if ( input instanceof com.google.gerrit.extensions.restapi.RestApiException ) { return ( ( com.google.gerrit.extensions.restapi.RestApiException ) ( input ) ) ; } return new com.google.gerrit.extensions.restapi.RestApiException ( "Error inserting change/patchset" , input ) ; }
public com.google.gerrit.extensions.client.ChangeKind getChangeKind ( com.google.gerrit.reviewdb.client.Project.NameKey project , @ com.google.gerrit.common.Nullable org.eclipse.jgit.revwalk.RevWalk rw , @ com.google.gerrit.common.Nullable org.eclipse.jgit.lib.Config repoConfig , org.eclipse.jgit.lib.ObjectId prior , org.eclipse.jgit.lib.ObjectId next ) { try { com.google.gerrit.server.change.ChangeKindCacheImpl.Key key = new com.google.gerrit.server.change.ChangeKindCacheImpl.Key ( prior , next , useRecursiveMerge ) ; return cache.get ( key , new com.google.gerrit.server.change.ChangeKindCacheImpl.Loader ( key , repoManager , project , rw , repoConfig ) ) ; } catch ( java.util.concurrent.ExecutionException e ) { com.google.gerrit.server.change.ChangeKindCacheImpl.log.warn ( ( ( ( "Cannot check trivial rebase of new patch set " + ( next.name ( ) ) ) + " in " ) + project ) , e ) ; return com.google.gerrit.extensions.client.ChangeKind.REWORK ; } }
public void createProject ( ) throws java.lang.Exception { java.lang.String name = name ( "foo" ) ; com.google.common.truth.Truth.assertThat ( gApi.projects ( ) . create ( name ) . get ( ) . name ) . isEqualTo ( name ) ; org.eclipse.jgit.revwalk.RevCommit head = getRemoteHead ( name , RefNames.REFS_CONFIG ) ; eventRecorder.assertRefUpdatedEvents ( name , RefNames.REFS_CONFIG , null , head ) ; eventRecorder.assertRefUpdatedEvents ( name , "refs/heads/master" , new java.lang.String [ ] { } ) ; projectIndexedCounter.assertReindexOf ( name ) ; }
public void abandonWipChange ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageWipChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.ABANDONED_CHANGES ) ; abandon ( sc.changeId , sc.owner ) ; assertThat ( sender ) . sent ( "abandon" , sc ) . notTo ( sc.owner ) . cc ( sc.reviewer , sc.ccer ) . to ( sc.reviewerByEmail ) . cc ( sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.ABANDONED_CHANGES ) ; }
void audit ( com.google.gerrit.sshd.SshScope.Context ctx , java.lang.Object result , java.lang.String cmd ) { final java.lang.String sid = extractSessionId ( ctx ) ; final long created = extractCreated ( ctx ) ; auditService.dispatch ( new com.google.gerrit.audit.SshAuditEvent ( sid , extractCurrentUser ( ctx ) , cmd , created , null , result ) ) ; }
protected void configure ( ) { install ( new com.google.gerrit.server.index.IndexModule ( threads ) ) ; bind ( com.google.gerrit.server.index.ChangeIndex.class ) . to ( com.google.gerrit.lucene.LuceneChangeIndex.class ) ; listener ( ) . to ( com.google.gerrit.lucene.LuceneChangeIndex.class ) ; if ( checkVersion ) { listener ( ) . to ( com.google.gerrit.lucene.IndexVersionCheck.class ) ; } }
public com.google.gerrit.extensions.restapi.Response < java.lang.String > apply ( com.google.gerrit.server.change.ChangeResource rsrc , com.google.gerrit.server.change.Mute.Input input ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.StarredChangesUtil.IllegalLabelException , com.google.gwtorm.server.OrmException { if ( rsrc.isUserOwner ( ) ) { throw new com.google.gerrit.extensions.restapi.BadRequestException ( "cannot mute own change" ) ; } if ( ! ( isMuted ( rsrc ) ) ) { stars.mute ( rsrc ) ; } return com.google.gerrit.extensions.restapi.Response.ok ( "" ) ; }
public void testParseFooComment ( ) throws java.lang.Exception { com.google.gerrit.server.account.QueryList ql = com.google.gerrit.server.account.QueryList.parse ( ( ( "#" + ( com.google.gerrit.server.account.QueryListTest.L_FOO ) ) + ( com.google.gerrit.server.account.QueryListTest.L_BAR ) ) , null ) ; com.google.common.truth.Truth.assertThat ( ql.getQuery ( com.google.gerrit.server.account.QueryListTest.N_FOO ) ) . isNull ( ) ; com.google.common.truth.Truth.assertThat ( ql.getQuery ( com.google.gerrit.server.account.QueryListTest.N_BAR ) ) . isEqualTo ( com.google.gerrit.server.account.QueryListTest.Q_B ) ; }
public void onlyResetMatchingRefs ( ) throws java.lang.Exception { org.eclipse.jgit.lib.Ref matchingRef = createRef ( "refs/match/test" ) ; org.eclipse.jgit.lib.Ref anotherMatchingRef = createRef ( "refs/another-match/test" ) ; org.eclipse.jgit.lib.Ref nonMatchingRef = createRef ( "refs/no-match/test" ) ; org.eclipse.jgit.lib.Ref updatedNonMatchingRef ; try ( com.google.gerrit.acceptance.ProjectResetter resetProject = builder ( ) . build ( new com.google.gerrit.acceptance.ProjectResetter.Config ( ) . reset ( project , "refs/match/*" , "refs/another-match/*" ) ) ) { updateRef ( matchingRef ) ; updateRef ( anotherMatchingRef ) ; updatedNonMatchingRef = updateRef ( nonMatchingRef ) ; } assertRef ( matchingRef ) ; assertRef ( anotherMatchingRef ) ; assertRef ( updatedNonMatchingRef ) ; }
public java.lang.Iterable < com.google.gerrit.extensions.common.WebLinkInfo > getPatchSetLinks ( java.lang.String project , java.lang.String commit ) { java.util.List < com.google.gerrit.extensions.common.WebLinkInfo > links = com.google.common.collect.Lists.newArrayList ( ) ; for ( com.google.gerrit.extensions.webui.PatchSetWebLink webLink : patchSetLinks ) { links.add ( new com.google.gerrit.extensions.common.WebLinkInfo ( webLink.getLinkName ( ) , webLink.getPatchSetUrl ( project , commit ) ) ) ; } return links ; }
java.lang.String image ( java.lang.String dest ) { if ( ( com.google.gitiles.doc.html.HtmlBuilder.isValidHttpUri ( dest ) ) || ( com.google.gitiles.doc.html.HtmlBuilder.isImageDataUri ( dest ) ) ) { return dest ; } else if ( ( imageLoader ) != null ) { return imageLoader.inline ( filePath , dest ) ; } return FilterImageDataUri.INSTANCE.getInnocuousOutput ( ) ; }
public UiAction.Description getDescription ( com.google.gerrit.server.change.RevisionResource resource ) { com.google.gerrit.reviewdb.client.PatchSet.Id current = resource.getChange ( ) . currentPatchSetId ( ) ; return new com.google.gerrit.extensions.webui.UiAction.Description ( ) . setLabel ( java.lang.String.format ( "Submit Revision %d" , resource.getPatchSet ( ) . getPatchSetId ( ) ) ) . setVisible ( ( ( ( resource.getChange ( ) . getStatus ( ) . isOpen ( ) ) && ( resource.getPatchSet ( ) . getId ( ) . equals ( current ) ) ) && ( resource.getControl ( ) . canSubmit ( ) ) ) ) ; }
private void display ( com.google.gwt.core.client.JsArray < com.google.gerrit.client.info.TopMenuItem > items ) { java.util.List < java.util.List < java.lang.String > > values = new java.util.ArrayList < > ( ) ; for ( com.google.gerrit.client.info.TopMenuItem item : com.google.gerrit.client.rpc.Natives.asList ( items ) ) { values.add ( java.util.Arrays.asList ( item.getName ( ) , item.getUrl ( ) ) ) ; } myMenus.display ( values ) ; }
public void changeIsIndexed ( ) throws java.lang.Exception { setupPostMocks ( com.ericsson.gerrit.plugins.syncindex.SyncIndexRestApiServletTest.CHANGE_EXISTS ) ; syncIndexRestApiServlet.doPost ( req , rsp ) ; org.mockito.Mockito.verify ( indexer , org.mockito.Mockito.times ( 1 ) ) . index ( db , change ) ; org.mockito.Mockito.verify ( rsp ) . setStatus ( javax.servlet.http.HttpServletResponse.SC_NO_CONTENT ) ; }
private void assertDeleteSucceeds ( ) throws java.lang.Exception { com.google.common.truth.Truth.assertThat ( branch ( ) . get ( ) . canDelete ) . isTrue ( ) ; java.lang.String branchRev = branch ( ) . get ( ) . revision ; branch ( ) . delete ( ) ; eventRecorder.assertRefUpdatedEvents ( project.get ( ) , branch.get ( ) , null , branchRev , branchRev , null ) ; exception.expect ( com.google.gerrit.extensions.restapi.ResourceNotFoundException.class ) ; branch ( ) . get ( ) ; }
public com.google.gerrit.server.change.VoteResource parse ( com.google.gerrit.server.change.ReviewerResource reviewer , com.google.gerrit.extensions.restapi.IdString id ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.extensions.restapi.MethodNotAllowedException , com.google.gerrit.extensions.restapi.ResourceNotFoundException , com.google.gwtorm.server.OrmException { if ( ! ( reviewer.getRevisionResource ( ) . isCurrent ( ) ) ) { throw new com.google.gerrit.extensions.restapi.MethodNotAllowedException ( "Cannot access on non-current patch set" ) ; } return new com.google.gerrit.server.change.VoteResource ( reviewer , id.get ( ) ) ; }
private org.eclipse.jgit.dircache.DirCacheEntry file ( final java.lang.String name ) throws java.io.IOException { final org.eclipse.jgit.lib.ObjectInserter oi = repository.newObjectInserter ( ) ; try { final org.eclipse.jgit.dircache.DirCacheEntry e = new org.eclipse.jgit.dircache.DirCacheEntry ( name ) ; e.setFileMode ( FileMode.REGULAR_FILE ) ; e.setObjectId ( oi.insert ( Constants.OBJ_BLOB , org.eclipse.jgit.lib.Constants.encode ( name ) ) ) ; oi.flush ( ) ; return e ; } finally { oi.release ( ) ; } }
public static java.lang.String toLongString ( final com.google.gerrit.extensions.client.SubmitType type ) { if ( type == null ) { return "" ; } switch ( type ) { case FAST_FORWARD_ONLY : return com.google.gerrit.client.admin.Util.C.projectSubmitType_FAST_FORWARD_ONLY ( ) ; case MERGE_IF_NECESSARY : return com.google.gerrit.client.admin.Util.C.projectSubmitType_MERGE_IF_NECESSARY ( ) ; case REBASE_IF_NECESSARY : return com.google.gerrit.client.admin.Util.C.projectSubmitType_REBASE_IF_NECESSARY ( ) ; case REBASE_ALWAYS : return com.google.gerrit.client.admin.Util.C.projectSubmitType_REBASE_ALWAYS ( ) ; case MERGE_ALWAYS : return com.google.gerrit.client.admin.Util.C.projectSubmitType_MERGE_ALWAYS ( ) ; case CHERRY_PICK : return com.google.gerrit.client.admin.Util.C.projectSubmitType_CHERRY_PICK ( ) ; default : return type.name ( ) ; } }
public void onKeyPress ( final com.google.gwt.event.dom.client.KeyPressEvent event ) { event.stopPropagation ( ) ; }
public org.eclipse.jgit.lib.RefUpdate.Result call ( ) throws java.lang.Exception { org.eclipse.jgit.lib.Ref ref = repo.exactRef ( refName ) ; afterReadRef.run ( ) ; org.eclipse.jgit.lib.ObjectId oldId ; if ( ref == null ) { oldId = org.eclipse.jgit.lib.ObjectId.zeroId ( ) ; next = seed.get ( ) ; } else { oldId = ref.getObjectId ( ) ; next = parse ( rw , oldId ) ; } return store ( repo , rw , oldId , ( ( next ) + ( count ) ) ) ; }
public void onResize ( com.google.gwt.event.logical.shared.ResizeEvent event ) { int h = ( com.google.gerrit.client.Gerrit.getHeaderFooterHeight ( ) ) + ( reviewed.getOffsetHeight ( ) ) ; if ( ( cmA ) != null ) { cmA.setHeight ( ( ( event.getHeight ( ) ) - h ) ) ; cmA.refresh ( ) ; } if ( ( cmB ) != null ) { cmB.setHeight ( ( ( event.getHeight ( ) ) - h ) ) ; cmB.refresh ( ) ; } resizeBoxPaddings ( ) ; }
public void createdOnIsPopulatedForGroupsCreatedAfterAudit ( ) throws java.lang.Exception { java.sql.Timestamp testStartTime = com.google.gerrit.common.TimeUtil.nowTs ( ) ; com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = createGroup ( "Group for schema migration" ) ; setCreatedOnToVeryOldTimestamp ( groupId ) ; schema151.migrateData ( db , new com.google.gerrit.testutil.TestUpdateUI ( ) ) ; com.google.gerrit.reviewdb.client.AccountGroup group = db.accountGroups ( ) . get ( groupId ) ; com.google.common.truth.Truth.assertThat ( group.getCreatedOn ( ) ) . isAtLeast ( testStartTime ) ; }
private static org.bouncycastle.openpgp.PGPPublicKeyRingCollection readPubRing ( final java.io.File pub ) { try ( java.io.InputStream fin = new java.io.FileInputStream ( pub ) ; java.io.InputStream in = org.bouncycastle.openpgp.PGPUtil.getDecoderStream ( fin ) ) { return new org.bouncycastle.openpgp.PGPPublicKeyRingCollection ( in ) ; } catch ( java.io.IOException e ) { throw new com.google.inject.ProvisionException ( ( "Cannot read " + pub ) , e ) ; } catch ( org.bouncycastle.openpgp.PGPException e ) { throw new com.google.inject.ProvisionException ( ( "Cannot read " + pub ) , e ) ; } }
public void init ( javax.servlet.FilterConfig config ) throws javax.servlet.ServletException { if ( ( isPropertyInPluginConfig ( com.googlesource.gerrit.plugins.javamelody.GerritMonitoringFilter.JavamelodyFilter.HTTP_TRANSFORM_PATTERN ) ) || ( isPropertyUndefined ( config , com.googlesource.gerrit.plugins.javamelody.GerritMonitoringFilter.JavamelodyFilter.HTTP_TRANSFORM_PATTERN , com.googlesource.gerrit.plugins.javamelody.GerritMonitoringFilter.JavamelodyFilter.GLOBAL_HTTP_TRANSFORM_PATTERN ) ) ) { java.lang.System.setProperty ( com.googlesource.gerrit.plugins.javamelody.GerritMonitoringFilter.JavamelodyFilter.GLOBAL_HTTP_TRANSFORM_PATTERN , getTransformPattern ( ) ) ; } if ( ( isPropertyInPluginConfig ( com.googlesource.gerrit.plugins.javamelody.GerritMonitoringFilter.JavamelodyFilter.STORAGE_DIR ) ) || ( isPropertyUndefined ( config , com.googlesource.gerrit.plugins.javamelody.GerritMonitoringFilter.JavamelodyFilter.STORAGE_DIR , com.googlesource.gerrit.plugins.javamelody.GerritMonitoringFilter.JavamelodyFilter.GLOBAL_STORAGE_DIR ) ) ) { java.lang.System.setProperty ( com.googlesource.gerrit.plugins.javamelody.GerritMonitoringFilter.JavamelodyFilter.GLOBAL_STORAGE_DIR , getStorageDir ( ) ) ; } super . init ( config ) ; }
private static org.eclipse.jgit.dircache.DirCache readTree ( final org.eclipse.jgit.lib.Ref branch , org.eclipse.jgit.revwalk.RevWalk rw ) throws java.io.IOException , org.eclipse.jgit.errors.IncorrectObjectTypeException , org.eclipse.jgit.errors.MissingObjectException { final org.eclipse.jgit.dircache.DirCache dc = org.eclipse.jgit.dircache.DirCache.newInCore ( ) ; final org.eclipse.jgit.dircache.DirCacheBuilder b = dc.builder ( ) ; b.addTree ( new byte [ 0 ] , DirCacheEntry.STAGE_0 , rw.getObjectReader ( ) , rw.parseTree ( branch.getObjectId ( ) ) ) ; b.finish ( ) ; return dc ; }
public void onSuccess ( java.lang.Void result ) { java.lang.String b = ( ( base ) != null ) ? base.getId ( ) : null ; java.lang.String rev = revision.getId ( ) ; com.google.gerrit.client.Gerrit.display ( com.google.gerrit.common.PageLinks.toChange ( changeId , b , rev ) , new com.google.gerrit.client.change.ChangeScreen2 ( changeId , b , rev , openReplyBox ) ) ; }
private org.eclipse.jgit.treewalk.TreeWalk find ( final org.eclipse.jgit.lib.ObjectId within ) throws java.io.IOException , org.eclipse.jgit.errors.CorruptObjectException , org.eclipse.jgit.errors.IncorrectObjectTypeException , org.eclipse.jgit.errors.MissingObjectException { if ( ( ( path ) == null ) || ( within == null ) ) { return null ; } final org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk ( reader ) ; final org.eclipse.jgit.revwalk.RevTree tree = rw.parseTree ( within ) ; return org.eclipse.jgit.treewalk.TreeWalk.forPath ( reader , path , tree ) ; }
public boolean updateChange ( com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.PatchSet ps = psUtil.get ( ctx.getDb ( ) , ctx.getNotes ( ) , psId ) ; psUtil.setGroups ( ctx.getDb ( ) , ctx.getUpdate ( psId ) , ps , com.google.common.collect.ImmutableList.< java.lang.String > of ( ) ) ; ctx.bumpLastUpdatedOn ( false ) ; return true ; }
protected void display ( com.googlesource.gerrit.plugins.xdocs.client.ChangeInfo change ) { java.lang.String frameId = "xdoc_unified_diff_iframe" ; com.google.gwt.user.client.ui.Frame frame = new com.google.gwt.user.client.ui.Frame ( com.googlesource.gerrit.plugins.xdocs.client.XDocScreen.getUrl ( change.project ( ) , getRevision ( ) , getPath ( ) ) ) ; frame.getElement ( ) . setId ( frameId ) ; com.googlesource.gerrit.plugins.xdocs.client.XDocScreen.resize ( frame , frameId ) ; add ( frame ) ; }
void initMeter ( ) { if ( ( ( stage ) == 0 ) && ( ( meter ) == null ) ) { final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder b = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder ( ) ; b.openTr ( ) ; b.openTd ( ) ; b.closeTd ( ) ; b.closeTr ( ) ; resetHtml ( b ) ; meter = new com.google.gwtexpui.progress.client.ProgressBar ( Util.M.loadingPatchSet ( psid.get ( ) ) ) ; table.setWidget ( 0 , 0 , meter ) ; } updateMeter ( ) ; }
public void parseOptionMap ( java.util.Map < java.lang.String , java.lang.String [ ] > parameters ) throws org.kohsuke.args4j.CmdLineException { com.google.common.collect.ListMultimap < java.lang.String , java.lang.String > map = com.google.common.collect.MultimapBuilder.hashKeys ( ) . arrayListValues ( ) . build ( ) ; for ( java.util.Map.Entry < java.lang.String , java.lang.String [ ] > ent : parameters.entrySet ( ) ) { for ( java.lang.String val : ent.getValue ( ) ) { map.put ( ent.getKey ( ) , val ) ; } } parseOptionMap ( map ) ; }
private com.google.inject.Injector createSshInjector ( ) { final java.util.List < com.google.inject.Module > modules = new java.util.ArrayList < com.google.inject.Module > ( ) ; if ( sshd ) { modules.add ( sysInjector.getInstance ( com.google.gerrit.sshd.SshModule.class ) ) ; if ( slave ) { modules.add ( new com.google.gerrit.sshd.commands.SlaveCommandModule ( ) ) ; } else { modules.add ( new com.google.gerrit.sshd.commands.MasterCommandModule ( ) ) ; } } else { modules.add ( new com.google.gerrit.server.ssh.NoSshModule ( ) ) ; } return sysInjector.createChildInjector ( modules ) ; }
public void run ( ) { com.google.gerrit.server.ssh.SshScopes.invoke ( session , cmd , new java.lang.Runnable ( ) { public void run ( ) { try { synchronized ( list ) { list.add ( cmd ) ; } runImp ( ) ; } finally { synchronized ( list ) { list.remove ( cmd ) ; } } } } ) ; }
private java.io.File copyToTempFile ( org.eclipse.jgit.lib.ObjectId blobId , java.io.File tempDir ) throws java.io.FileNotFoundException , java.io.IOException , org.eclipse.jgit.errors.MissingObjectException { java.io.File tmp = java.io.File.createTempFile ( "rules" , ".pl" , tempDir ) ; try ( java.io.OutputStream out = java.nio.file.Files.newOutputStream ( tmp.toPath ( ) ) ) { git.open ( blobId ) . copyTo ( out ) ; } return tmp ; }
public void index ( com.google.gerrit.reviewdb.client.Account.Id id ) throws java.io.IOException { for ( com.google.gerrit.index.Index < com.google.gerrit.reviewdb.client.Account.Id , com.google.gerrit.server.account.AccountState > i : getWriteIndexes ( ) ) { java.util.Optional < com.google.gerrit.server.account.AccountState > accountState = byIdCache.maybeGet ( id ) ; if ( accountState.isPresent ( ) ) { i.replace ( accountState.get ( ) ) ; } else { i.delete ( id ) ; } } fireAccountIndexedEvent ( id.get ( ) ) ; com.google.gerrit.server.index.account.AccountIndexerImpl.autoReindexIfStale ( id ) ; }
void setText ( final java.lang.String query ) { if ( ( query == null ) || ( query.equals ( "" ) ) ) { searchBox.setText ( Gerrit.C.searchHint ( ) ) ; searchBox.addStyleName ( Gerrit.RESOURCES.css ( ) . inputFieldTypeHint ( ) ) ; } else { searchBox.setText ( query ) ; searchBox.removeStyleName ( Gerrit.RESOURCES.css ( ) . inputFieldTypeHint ( ) ) ; } }
private static void unified ( final java.lang.String token , final com.google.gerrit.reviewdb.client.PatchSet.Id baseId , final com.google.gerrit.reviewdb.client.Patch.Key id , final com.google.gerrit.client.diff.DisplaySide side , final int line ) { com.google.gwt.core.client.GWT.runAsync ( new com.google.gerrit.client.Dispatcher.AsyncSplit ( token ) { @ java.lang.Override public void onSuccess ( ) { com.google.gerrit.client.Gerrit.display ( token , new com.google.gerrit.client.diff.Unified ( baseId , id.getParentKey ( ) , id.get ( ) , side , line ) ) ; } } ) ; }
private void streamFile ( javax.servlet.http.HttpServletRequest req , javax.servlet.http.HttpServletResponse res ) throws java.io.IOException { java.io.File f = resolveFile ( req ) ; res.setStatus ( HttpServletResponse.SC_OK ) ; res.setContentType ( "application/octet-stream" ) ; res.setContentLength ( ( ( int ) ( f.length ( ) ) ) ) ; java.io.OutputStream out = res.getOutputStream ( ) ; try ( java.io.InputStream in = new java.io.FileInputStream ( f ) ) { com.google.common.io.ByteStreams.copy ( in , out ) ; } }
public void testGetIssuePatternWCommentLink ( ) { com.googlesource.gerrit.plugins.its.base.its.ItsConfig itsConfig = createItsConfig ( ) ; org.easymock.EasyMock.expect ( serverConfig.getString ( "plugin" , "ItsTestName" , "commentlink" ) ) . andReturn ( "foo" ) . atLeastOnce ( ) ; org.easymock.EasyMock.expect ( serverConfig.getString ( "commentlink" , "foo" , "match" ) ) . andReturn ( "TestPattern" ) . atLeastOnce ( ) ; replayMocks ( ) ; assertEquals ( "Expected and generated pattern are not equal" , "TestPattern" , itsConfig.getIssuePattern ( ) . pattern ( ) ) ; }
private java.lang.String errorMessageForBranches ( java.util.List < java.lang.String > branches ) { java.lang.StringBuilder message = new java.lang.StringBuilder ( ) ; for ( java.lang.String branch : branches ) { message.append ( "Cannot delete " ) . append ( prefixRef ( branch ) ) . append ( ": it doesn't exist or you do not have permission " ) . append ( "to delete it\n" ) ; } return message.toString ( ) ; }
private void mergeImpl ( final com.google.gerrit.client.reviewdb.Branch.NameKey branch ) { try { new com.google.gerrit.git.MergeOp ( server , schema , replication , emailSender , mergedSenderFactory , branch ) . merge ( ) ; } catch ( java.lang.Throwable e ) { com.google.gerrit.git.ChangeMergeQueue.log.error ( ( ( "Merge attempt for " + branch ) + " failed" ) , e ) ; } }
private java.lang.String buildJsonRaw ( java.lang.String path , java.lang.String additionalQueryString ) throws java.lang.Exception { com.google.gitiles.FakeHttpServletResponse res = buildResponse ( path , ( "format=json" + additionalQueryString ) , javax.servlet.http.HttpServletResponse.SC_OK ) ; com.google.common.truth.Truth.assertThat ( res.getHeader ( com.google.common.net.HttpHeaders.CONTENT_TYPE ) ) . isEqualTo ( "application/json" ) ; java.lang.String body = res.getActualBodyString ( ) ; java.lang.String magic = ")]}\'\n" ; com.google.common.truth.Truth.assertThat ( body ) . startsWith ( magic ) ; return body.substring ( magic.length ( ) ) ; }
public java.util.SortedMap < java.lang.String , com.google.gerrit.extensions.common.GroupInfo > apply ( com.google.gerrit.extensions.restapi.TopLevelResource resource ) throws com.google.gerrit.extensions.restapi.BadRequestException , com.google.gwtorm.server.OrmException { java.util.SortedMap < java.lang.String , com.google.gerrit.extensions.common.GroupInfo > output = new java.util.TreeMap < > ( ) ; for ( com.google.gerrit.extensions.common.GroupInfo info : get ( ) ) { output.put ( com.google.common.base.MoreObjects.firstNonNull ( info.name , ( "Group " + ( com.google.gerrit.extensions.restapi.Url.decode ( info.id ) ) ) ) , info ) ; info.name = null ; } return output ; }
public java.util.SortedMap < java.lang.String , com.google.gerrit.extensions.common.PluginInfo > getAsMap ( ) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.plugins.ListPlugins list = listProvider.get ( ) ; list.setAll ( this . getAll ( ) ) ; list.setStart ( this . getStart ( ) ) ; list.setLimit ( this . getLimit ( ) ) ; list.setMatchPrefix ( this . getPrefix ( ) ) ; list.setMatchSubstring ( this . getSubstring ( ) ) ; list.setMatchRegex ( this . getRegex ( ) ) ; return list.apply ( ) ; }
private void testPushForMasterWithTopic ( com.google.gerrit.acceptance.git.PushForReviewIT.Protocol p ) throws com.google.gwtorm.server.OrmException , java.io.IOException , org.eclipse.jgit.api.errors.GitAPIException { selectProtocol ( p ) ; java.lang.String topic = "my/topic" ; com.google.gerrit.acceptance.git.PushOneCommit.Result r = pushTo ( ( "refs/for/master/" + topic ) ) ; r.assertOkStatus ( ) ; r.assertChange ( Change.Status.NEW , topic ) ; r = pushTo ( ( "refs/for/master%topic=" + topic ) ) ; r.assertOkStatus ( ) ; r.assertChange ( Change.Status.NEW , topic ) ; }
public void newPatchSetByOwnerOnReviewableChangeToWip ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.NEW_PATCHSETS ) ; pushTo ( sc , "refs/for/master%wip" , sc.owner ) ; assertThat ( sender ) . notSent ( ) ; }
private java.util.Collection < com.google.gerrit.reviewdb.client.ChangeMessage > filterChangeMessages ( ) { final com.google.common.base.Predicate < com.google.gerrit.reviewdb.client.PatchSet.Id > upToCurrent = upToCurrentPredicate ( ) ; return com.google.common.collect.Collections2.filter ( changeMessages , new com.google.common.base.Predicate < com.google.gerrit.reviewdb.client.ChangeMessage > ( ) { @ java.lang.Override public boolean apply ( com.google.gerrit.reviewdb.client.ChangeMessage in ) { com.google.gerrit.reviewdb.client.PatchSet.Id psId = in.getPatchSetId ( ) ; if ( psId == null ) { return true ; } return ( upToCurrent.apply ( psId ) ) && ( patchSets.containsKey ( psId ) ) ; } } ) ; }
protected < T > void doInvoke ( final boolean allowXsrf , final java.lang.String reqData , final com.google.gwtjsonrpc.client.JsonSerializer < T > ser , final com.google.gwt.user.client.rpc.AsyncCallback < T > cb ) throws com.google.gwt.user.client.rpc.InvocationException { if ( ( url ) == null ) { throw new com.google.gwtjsonrpc.client.NoServiceEntryPointSpecifiedException ( ) ; } new com.google.gwtjsonrpc.client.JsonCall < T > ( this , allowXsrf , reqData , ser , cb ) . send ( ) ; }
public void topic ( java.lang.String topic ) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.change.PutTopic.Input in = new com.google.gerrit.server.change.PutTopic.Input ( ) ; in.topic = topic ; try { putTopic.apply ( change , in ) ; } catch ( com.google.gerrit.server.git.UpdateException e ) { throw new com.google.gerrit.extensions.restapi.RestApiException ( "Cannot set topic" , e ) ; } }
private static void populateBottomMenu ( ) { final com.google.gwt.user.client.ui.RootPanel btmmenu = com.google.gwt.user.client.ui.RootPanel.get ( "gerrit_btmmenu" ) ; final java.lang.String vs = com.google.gerrit.client.Gerrit.getVersion ( ) ; final com.google.gwt.user.client.ui.HTML version = new com.google.gwt.user.client.ui.HTML ( com.google.gerrit.client.Gerrit.M.poweredBy ( vs ) ) ; version.setStyleName ( "gerrit-version" ) ; btmmenu.add ( version ) ; }
private static org.bouncycastle.openpgp.PGPPublicKeyRingCollection readPubRing ( final java.io.File pub ) { try ( java.io.InputStream fin = new java.io.FileInputStream ( pub ) ; java.io.InputStream in = org.bouncycastle.openpgp.PGPUtil.getDecoderStream ( fin ) ) { return new org.bouncycastle.openpgp.bc.BcPGPPublicKeyRingCollection ( in ) ; } catch ( java.io.IOException e ) { throw new com.google.inject.ProvisionException ( ( "Cannot read " + pub ) , e ) ; } catch ( org.bouncycastle.openpgp.PGPException e ) { throw new com.google.inject.ProvisionException ( ( "Cannot read " + pub ) , e ) ; } }
private static java.lang.String formatAsPercent ( java.lang.Integer i ) { return i != null ? ( java.lang.String.valueOf ( i ) ) + "%" : "" ; }
protected com.google.gerrit.reviewdb.client.PatchLineComment newPublishedComment ( com.google.gerrit.reviewdb.client.PatchSet.Id psId , java.lang.String filename , java.lang.String UUID , com.google.gerrit.reviewdb.client.CommentRange range , int line , com.google.gerrit.server.IdentifiedUser commenter , java.lang.String parentUUID , java.sql.Timestamp t , java.lang.String message , short side , java.lang.String commitSHA1 ) { return newComment ( psId , filename , UUID , range , line , commenter , parentUUID , t , message , side , commitSHA1 , PatchLineComment.Status.PUBLISHED ) ; }
private void skipIfWin32Platform ( ) { if ( com.google.gerrit.server.util.HostPlatform.isWin32 ( ) ) { java.lang.System.err.println ( ( ( " - Skipping " + ( test.getMethodName ( ) ) ) + " on this system" ) ) ; org.junit.Assume.assumeTrue ( false ) ; } }
private static org.eclipse.jgit.lib.AnyObjectId aFor ( final com.google.gerrit.server.patch.PatchListKey key , final org.eclipse.jgit.lib.Repository repo , final org.eclipse.jgit.revwalk.RevCommit b ) throws java.io.IOException { if ( ( key.getOldId ( ) ) != null ) { return key.getOldId ( ) ; } switch ( b.getParentCount ( ) ) { case 0 : return com.google.gerrit.server.patch.PatchListCacheImpl.Loader.emptyTree ( repo ) ; case 1 : return b.getParent ( 0 ) ; default : return null ; } }
public com.google.gerrit.extensions.restapi.Response < com.googlesource.gerrit.plugins.findowners.RestResult > apply ( com.google.gerrit.reviewdb.server.ReviewDb reviewDb , com.google.gerrit.server.change.ChangeResource rsrc , com.googlesource.gerrit.plugins.findowners.Action.Parameters params ) throws com.google.gerrit.extensions.restapi.BadRequestException , com.google.gwtorm.server.OrmException , java.io.IOException { com.google.gerrit.reviewdb.client.Change c = rsrc.getChange ( ) ; try ( org.eclipse.jgit.lib.Repository repo = repoManager.openRepository ( c.getProject ( ) ) ) { com.google.gerrit.server.query.change.ChangeData changeData = changeDataFactory.create ( reviewDb , c ) ; return getChangeData ( repo , params , changeData ) ; } }
public void onSuccess ( java.lang.Void result ) { if ( prefs.syntaxHighlighting ( ) ) { cmA.setOption ( "mode" , getContentType ( diff.meta_a ( ) ) ) ; cmB.setOption ( "mode" , getContentType ( diff.meta_b ( ) ) ) ; } }
public static void doSignIn ( ) { switch ( com.google.gerrit.client.Gerrit.myConfig.getAuthType ( ) ) { case HTTP : case HTTP_LDAP : com.google.gwt.user.client.Window.Location.assign ( ( "login/" + ( com.google.gwt.user.client.History.getToken ( ) ) ) ) ; break ; case DEVELOPMENT_BECOME_ANY_ACCOUNT : com.google.gwt.user.client.Window.Location.assign ( "become" ) ; break ; case OPENID : default : new com.google.gerrit.client.SignInDialog ( ) . center ( ) ; break ; } }
public com.googlecode.prolog_cafe.lang.Operation exec ( com.googlecode.prolog_cafe.lang.Prolog engine ) throws com.googlecode.prolog_cafe.lang.PrologException { engine.setB0 ( ) ; com.googlecode.prolog_cafe.lang.Term a1 = arg1.dereference ( ) ; com.google.gerrit.reviewdb.client.Project.NameKey name = com.google.gerrit.rules.StoredValues.getChange ( engine ) . getProject ( ) ; if ( ! ( a1.unify ( com.googlecode.prolog_cafe.lang.SymbolTerm.create ( name.get ( ) ) , engine.trail ) ) ) { return engine.fail ( ) ; } return cont ; }
private void renderSubmitType ( com.google.gerrit.reviewdb.client.Change.Status status , boolean canSubmit , com.google.gerrit.extensions.client.SubmitType submitType ) { if ( canSubmit && ( status == ( com.google.gerrit.reviewdb.client.Change.Status.NEW ) ) ) { statusText.setInnerText ( ( changeInfo.mergeable ( ) ? Util.C.readyToSubmit ( ) : Util.C.mergeConflict ( ) ) ) ; } setVisible ( notMergeable , ( ! ( changeInfo.mergeable ( ) ) ) ) ; submitActionText.setInnerText ( com.google.gerrit.client.admin.Util.toLongString ( submitType ) ) ; }
public void writeNoChanges ( ) throws java.lang.Exception { com.google.common.truth.Truth.assertThat ( modifier.createEdit ( change , ps ) ) . isEqualTo ( RefUpdate.Result.NEW ) ; try { modifier.modifyFile ( editUtil.byChange ( change ) . get ( ) , com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME , com.google.gerrit.acceptance.RestSession.newRawInput ( com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_OLD ) ) ; org.junit.Assert.fail ( ) ; } catch ( com.google.gerrit.server.project.InvalidChangeOperationException e ) { com.google.common.truth.Truth.assertThat ( e.getMessage ( ) ) . isEqualTo ( "no changes were made" ) ; } }
public void onKeyPress ( com.google.gwt.event.dom.client.KeyPressEvent event ) { upToChange ( true ) . run ( ) ; }
public java.util.Map < java.lang.String , com.google.gitiles.RepositoryDescription > listRepositories ( java.util.Set < java.lang.String > branches ) throws java.io.IOException { java.util.Map < java.lang.String , com.google.gitiles.RepositoryDescription > repos = com.google.common.collect.Maps.newTreeMap ( com.google.gitiles.DefaultAccess.US_COLLATOR ) ; for ( org.eclipse.jgit.lib.Repository repo : scanRepositories ( basePath , req ) ) { repos.put ( getRepositoryName ( repo ) , buildDescription ( repo , branches ) ) ; repo.close ( ) ; } return repos ; }
private java.lang.String addressList ( ) { final java.lang.StringBuilder r = new java.lang.StringBuilder ( ) ; for ( java.util.Iterator < java.net.SocketAddress > i = listen.iterator ( ) ; i.hasNext ( ) ; ) { r.append ( com.google.gerrit.server.util.SocketUtil.format ( i.next ( ) , com.google.gerrit.sshd.SshDaemon.IANA_SSH_PORT ) ) ; if ( i.hasNext ( ) ) { r.append ( ", " ) ; } } return r.toString ( ) ; }
private org.eclipse.jetty.util.resource.Resource getBaseResource ( ) throws java.io.IOException { if ( ( baseResource ) == null ) { try { baseResource = unpackWar ( ) ; } catch ( java.io.FileNotFoundException err ) { if ( ( err.getMessage ( ) ) == ( com.google.gerrit.main.GerritLauncher.NOT_ARCHIVED ) ) { baseResource = useDeveloperBuild ( ) ; } else { throw err ; } } } return baseResource ; }
public java.util.List < com.google.gerrit.git.WorkQueue.Task < ? > > getTasks ( ) { final java.util.List < com.google.gerrit.git.WorkQueue.Task < ? > > r = new java.util.ArrayList < com.google.gerrit.git.WorkQueue.Task < ? > > ( ) ; for ( final com.google.gerrit.git.WorkQueue.Executor e : queues ) { e.addAllTo ( r ) ; } return r ; }
com.google.gson.JsonObject toJsonWebToken ( java.lang.String accessToken ) throws com.googlesource.gerrit.plugins.cfoauth.UAAClientException { java.lang.String [ ] segments = getSegments ( accessToken ) ; if ( verifySignatures ) { verifySignature ( segments ) ; } return getAsJsonObject ( decodeBase64 ( segments [ 1 ] ) ) ; }
protected void run ( ) throws com.google.gerrit.sshd.commands.UnloggedFailure { if ( ( ( names ) == null ) || ( names.isEmpty ( ) ) ) { loader.rescan ( ) ; } else { try { loader.reload ( names ) ; } catch ( com.google.gerrit.server.plugins.InvalidPluginException e ) { throw die ( e.getMessage ( ) ) ; } catch ( com.google.gerrit.server.plugins.PluginInstallException e ) { throw die ( e.getMessage ( ) ) ; } } }
public void onKeyPress ( com.google.gwt.event.dom.client.KeyPressEvent event ) { toggleReviewed ( ) . run ( ) ; }
public java.lang.String getSshHost ( ) { final java.util.List < com.jcraft.jsch.HostKey > hostKeys = sshInfo.getHostKeys ( ) ; if ( hostKeys.isEmpty ( ) ) { return null ; } final java.lang.String host = hostKeys.get ( 0 ) . getHost ( ) ; if ( host.startsWith ( "*:" ) ) { return ( getGerritHost ( ) ) + ( host.substring ( 1 ) ) ; } return host ; }
void set ( com.google.gerrit.client.info.ChangeInfo info ) { canEdit = ( info.hasActions ( ) ) && ( info.actions ( ) . containsKey ( "hashtags" ) ) ; this . changeId = info.legacyId ( ) ; display ( info ) ; openForm.setVisible ( canEdit ) ; }
public void run ( ) { if ( com.google.gerrit.client.account.SshPanel.isAppletRunning ( com.google.gerrit.client.account.SshPanel.applet ) ) { appletLoadTimer = null ; cancel ( ) ; doBrowse ( ) ; } else if ( ( 30000 / 200 ) < ( ( attempts ) ++ ) ) { appletLoadTimer = null ; cancel ( ) ; noBrowse ( ) ; } }
private static java.lang.String url ( com.google.gerrit.reviewdb.client.PatchSet.Id ps , com.google.gerrit.client.changes.CommentInfo info ) { return com.google.gerrit.client.Dispatcher.toPatch ( null , ps , info.path ( ) , ( ( info.side ( ) ) == ( com.google.gerrit.extensions.client.Side.PARENT ) ? com.google.gerrit.client.diff.DisplaySide.A : com.google.gerrit.client.diff.DisplaySide.B ) , info.line ( ) ) ; }
public void run ( ) { if ( ( active ) == null ) { active = this ; fixup.scheduleRepeating ( 20 ) ; } if ( ( active ) == ( this ) ) { net.codemirror.lib.ScrollInfo si = src.getScrollInfo ( ) ; updateScreenHeader ( si ) ; overview.update ( si ) ; dst.scrollTo ( si.getLeft ( ) , align ( si.getTop ( ) ) ) ; state = 0 ; } }
public void deleteComment ( com.google.gerrit.reviewdb.client.Comment c ) { verifyComment ( c ) ; createDraftUpdateIfNull ( ) . deleteComment ( c ) ; }
public com.google.gerrit.reviewdb.AccountGroup createEntry ( final com.google.gerrit.reviewdb.AccountGroup.Id key ) throws java.lang.Exception { final com.google.gerrit.reviewdb.ReviewDb db = schema.open ( ) ; try { final com.google.gerrit.reviewdb.AccountGroup group = db.accountGroups ( ) . get ( key ) ; if ( group != null ) { return group ; } else { return missing ( key ) ; } } finally { db.close ( ) ; } }
private boolean containsMissingCommits ( final com.google.common.collect.ListMultimap < com.google.gerrit.reviewdb.client.Project.SubmitType , com.google.gerrit.server.git.CodeReviewCommit > map , final com.google.gerrit.server.git.CodeReviewCommit commit ) { if ( ! ( isSubmitForMissingCommitsStillPossible ( commit ) ) ) { return false ; } for ( final com.google.gerrit.server.git.CodeReviewCommit missingCommit : commit.missing ) { if ( ! ( map.containsValue ( missingCommit ) ) ) { return false ; } } return true ; }
private static com.google.gerrit.server.git.CodeReviewCommit failed ( com.google.gerrit.server.git.CodeReviewCommit.CodeReviewRevWalk rw , com.google.gerrit.server.git.CodeReviewCommit mergeTip , com.google.gerrit.server.git.CodeReviewCommit n , com.google.gerrit.server.git.strategy.CommitMergeStatus failure ) throws java.io.IOException , org.eclipse.jgit.errors.IncorrectObjectTypeException , org.eclipse.jgit.errors.MissingObjectException { rw.reset ( ) ; rw.markStart ( n ) ; rw.markUninteresting ( mergeTip ) ; com.google.gerrit.server.git.CodeReviewCommit failed ; while ( ( failed = rw.next ( ) ) != null ) { failed.setStatusCode ( failure ) ; } return failed ; }
public void restoreExternalIds ( ) throws java.lang.Exception { db.accountExternalIds ( ) . delete ( getExternalIds ( admin ) ) ; db.accountExternalIds ( ) . delete ( getExternalIds ( user ) ) ; db.accountExternalIds ( ) . insert ( savedExternalIds ) ; accountCache.evict ( admin.getId ( ) ) ; accountCache.evict ( user.getId ( ) ) ; }
private void doDeleteRefRights ( final java.util.HashSet < com.google.gerrit.reviewdb.RefRight.Key > refRightIds ) { if ( ! ( refRightIds.isEmpty ( ) ) ) { Util.PROJECT_SVC.deleteRight ( projectName , refRightIds , new com.google.gerrit.client.rpc.GerritCallback < com.google.gerrit.common.data.ProjectDetail > ( ) { @ java.lang.Override public void onSuccess ( final com.google.gerrit.common.data.ProjectDetail result ) { display ( result ) ; } } ) ; } }
public void skipOnlyOnSpecificRef ( ) throws java.lang.Exception { java.lang.String config = "[plugin \"uploadvalidator\"]\n" + ( ( "skipValidation=testOp\n" + "skipRef=refs/heads/myref\n" ) + "skipGroup=testGroup" ) ; com.googlesource.gerrit.plugins.uploadvalidator.ValidatorConfig validatorConfig = new com.googlesource.gerrit.plugins.uploadvalidator.ValidatorConfig ( new com.googlesource.gerrit.plugins.uploadvalidator.FakeConfigFactory ( projectName , config ) , new com.googlesource.gerrit.plugins.uploadvalidator.FakeGroupCacheUUIDByName ( ) ) ; com.google.common.truth.Truth.assertThat ( validatorConfig.isEnabledForRef ( new com.googlesource.gerrit.plugins.uploadvalidator.FakeUserProvider ( "testGroup" ) . get ( ) , projectName , "refs/heads/myref" , "testOp" ) ) . isFalse ( ) ; }
private static void set ( org.eclipse.jgit.lib.Config cfg , java.lang.String section , java.lang.String key , java.lang.String val ) { if ( com.google.common.base.Strings.isNullOrEmpty ( val ) ) { cfg.unset ( UserConfigSections.MY , section , key ) ; } else { cfg.setString ( UserConfigSections.MY , section , key , val ) ; } }
public static com.google.gerrit.server.index.IndexConfig fromConfig ( org.eclipse.jgit.lib.Config cfg ) { com.google.gerrit.server.index.IndexConfig.Builder b = com.google.gerrit.server.index.IndexConfig.builder ( ) ; com.google.gerrit.server.index.IndexConfig.setIfPresent ( cfg , "maxLimit" , b :: maxLimit ) ; com.google.gerrit.server.index.IndexConfig.setIfPresent ( cfg , "maxPages" , b :: maxPages ) ; com.google.gerrit.server.index.IndexConfig.setIfPresent ( cfg , "maxTerms" , b :: maxTerms ) ; return b.build ( ) ; }
public void onSuccess ( java.lang.Void result ) { if ( ( ( prefs.syntaxHighlighting ( ) ) && ( java.util.Objects.equals ( mode , getSelectedMode ( ) ) ) ) && ( view.isAttached ( ) ) ) { view.operation ( new java.lang.Runnable ( ) { @ java.lang.Override public void run ( ) { view.getCmFromSide ( DisplaySide.A ) . setOption ( "mode" , mode ) ; view.getCmFromSide ( DisplaySide.B ) . setOption ( "mode" , mode ) ; } } ) ; } }
public void deleteVoteFromWipChange ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageWipChange ( ) ; deleteVote ( sc , voter ) ; assertThat ( sender ) . sent ( "deleteVote" , sc ) . to ( sc.owner ) . cc ( sc.reviewer , sc.ccer ) . cc ( sc.reviewerByEmail , sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS ) . noOneElse ( ) ; }
public boolean dryRun ( final com.google.gerrit.server.git.CodeReviewCommit mergeTip , final com.google.gerrit.server.git.CodeReviewCommit toMerge ) throws com.google.gerrit.server.git.MergeException { return ( ! ( args.mergeUtil.hasMissingDependencies ( args.mergeSorter , toMerge ) ) ) && ( args.mergeUtil.canCherryPick ( args.mergeSorter , args.repo , mergeTip , args.rw , toMerge ) ) ; }
public static com.google.gerrit.reviewdb.client.AccountDiffPreference createDefault ( com.google.gerrit.reviewdb.client.Account.Id accountId ) { com.google.gerrit.reviewdb.client.AccountDiffPreference p = new com.google.gerrit.reviewdb.client.AccountDiffPreference ( accountId ) ; p.setIgnoreWhitespace ( com.google.gerrit.reviewdb.client.AccountDiffPreference.Whitespace.IGNORE_NONE ) ; p.setTabSize ( 8 ) ; p.setLineLength ( 100 ) ; p.setSyntaxHighlighting ( true ) ; p.setShowWhitespaceErrors ( true ) ; p.setShowLineEndings ( true ) ; p.setIntralineDifference ( true ) ; p.setShowTabs ( true ) ; p.setContext ( com.google.gerrit.reviewdb.client.AccountDiffPreference.DEFAULT_CONTEXT ) ; p.setManualReview ( false ) ; return p ; }
public void setCurrentPatchSet ( com.google.gerrit.reviewdb.client.PatchSet.Id psId , java.lang.String subject , java.lang.String originalSubject ) { if ( ! ( psId.getParentKey ( ) . equals ( changeId ) ) ) { throw new java.lang.IllegalArgumentException ( ( ( ( "patch set ID " + psId ) + " is not for change " ) + ( changeId ) ) ) ; } currentPatchSetId = psId.get ( ) ; this . subject = subject ; this . originalSubject = originalSubject ; }
public static com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > forStatus ( com.google.gerrit.reviewdb.client.Change.Status status ) { return com.google.gerrit.server.query.change.ChangeStatusPredicate.parse ( status.name ( ) ) ; }
public static void addMember ( com.google.gerrit.reviewdb.client.AccountGroup.UUID group , java.lang.String member , com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.client.groups.MemberInfo > cb ) { com.google.gerrit.client.groups.GroupApi.members ( group ) . id ( member ) . put ( cb ) ; }
private Account.Id parseIdent ( org.eclipse.jgit.revwalk.RevCommit commit ) throws org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.PersonIdent a = commit.getAuthorIdent ( ) ; org.eclipse.jgit.lib.PersonIdent c = commit.getCommitterIdent ( ) ; if ( ( a.getName ( ) . equals ( c.getName ( ) ) ) && ( a.getEmailAddress ( ) . equals ( c.getEmailAddress ( ) ) ) ) { return null ; } return parseIdent ( commit.getAuthorIdent ( ) ) ; }
private void expandSideBefore ( int cnt ) { net.codemirror.lib.TextMarker.FromTo range = textMarker.find ( ) ; int oldStart = range.from ( ) . line ( ) ; int newStart = oldStart + cnt ; int end = range.to ( ) . line ( ) ; clearMarkerAndWidget ( ) ; collapse ( newStart , end , true ) ; updateSelection ( ) ; }
public com.google.gerrit.client.ui.InlineHyperlink getNextPatchLink ( int index , com.google.gerrit.client.patches.PatchScreen.Type patchType ) { int nextPatchIndex = getNextPatch ( index , false , PREFERENCE_VALIDATOR ) ; if ( nextPatchIndex < 0 ) { return null ; } com.google.gerrit.client.ui.InlineHyperlink link = createLink ( nextPatchIndex , patchType , null , com.google.gwtexpui.safehtml.client.SafeHtml.asis ( Util.C.nextPatchLinkIcon ( ) ) ) ; return link ; }
public com.google.gwtjsonrpc.client.VoidResult run ( final com.google.gerrit.client.reviewdb.ReviewDb db ) throws com.google.gerrit.client.account.Failure , com.google.gwtorm.client.OrmException { final com.google.gerrit.client.reviewdb.Account a = db.accounts ( ) . get ( com.google.gerrit.client.rpc.Common.getAccountId ( ) ) ; if ( a == null ) { throw new com.google.gerrit.client.account.Failure ( new com.google.gerrit.client.rpc.NoSuchEntityException ( ) ) ; } a.setGeneralPreferences ( pref ) ; db.accounts ( ) . update ( java.util.Collections.singleton ( a ) ) ; com.google.gerrit.client.rpc.Common.getAccountCache ( ) . invalidate ( a.getId ( ) ) ; return com.google.gwtjsonrpc.client.VoidResult.INSTANCE ; }
public static java.lang.String projectQuery ( com.google.gerrit.reviewdb.client.Project.NameKey proj , com.google.gerrit.reviewdb.client.Change.Status status ) { return ( ( com.google.gerrit.common.PageLinks.status ( status ) ) + " " ) + ( com.google.gerrit.common.PageLinks.op ( "project" , proj.get ( ) ) ) ; }
private void review ( com.google.gerrit.acceptance.TestAccount account , java.lang.String changeId , com.google.gerrit.extensions.client.GeneralPreferencesInfo.EmailStrategy strategy , @ com.google.gerrit.common.Nullable com.google.gerrit.extensions.api.changes.NotifyHandling notify ) throws java.lang.Exception { setEmailStrategy ( account , strategy ) ; com.google.gerrit.extensions.api.changes.ReviewInput in = com.google.gerrit.extensions.api.changes.ReviewInput.recommend ( ) ; in.notify = notify ; gApi.changes ( ) . id ( changeId ) . revision ( "current" ) . review ( in ) ; }
private void afterTest ( ) throws java.lang.Exception { org.eclipse.jgit.transport.Transport.unregister ( inProcessProtocol ) ; for ( org.eclipse.jgit.lib.Repository repo : toClose ) { repo.close ( ) ; } db.close ( ) ; sshSession.close ( ) ; if ( ( server ) != ( com.google.gerrit.acceptance.AbstractDaemonTest.commonServer ) ) { server.stop ( ) ; } }
public com.google.gerrit.extensions.client.DiffPreferencesInfo apply ( com.google.gerrit.server.account.AccountResource rsrc ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.permissions.PermissionBackendException , java.io.IOException , org.eclipse.jgit.errors.ConfigInvalidException { if ( ( self.get ( ) ) != ( rsrc.getUser ( ) ) ) { permissionBackend.currentUser ( ) . check ( GlobalPermission.ADMINISTRATE_SERVER ) ; } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser ( ) . getAccountId ( ) ; return accountCache.get ( id ) . map ( AccountState :: getDiffPreferences ) . orElseThrow ( ( ) -> new com.google.gerrit.extensions.restapi.ResourceNotFoundException ( com.google.gerrit.extensions.restapi.IdString.fromDecoded ( id.toString ( ) ) ) ) ; }
public boolean isIdentityTrustable ( final java.util.Collection < com.google.gerrit.client.reviewdb.AccountExternalId > ids ) { switch ( getLoginType ( ) ) { case DEVELOPMENT_BECOME_ANY_ACCOUNT : case HTTP : case HTTP_LDAP : return true ; case OPENID : for ( final com.google.gerrit.client.reviewdb.AccountExternalId e : ids ) { if ( ! ( isTrusted ( e ) ) ) { return false ; } } return true ; default : return false ; } }
public java.util.List < com.google.gerrit.reviewdb.client.PatchSetApproval > addReviewers ( com.google.gerrit.reviewdb.server.ReviewDb db , com.google.gerrit.common.data.LabelTypes labelTypes , com.google.gerrit.reviewdb.client.Change change , com.google.gerrit.reviewdb.client.PatchSet ps , com.google.gerrit.reviewdb.client.PatchSetInfo info , java.lang.Iterable < com.google.gerrit.reviewdb.client.Account.Id > wantReviewers , java.util.Collection < com.google.gerrit.reviewdb.client.Account.Id > existingReviewers ) throws com.google.gwtorm.server.OrmException { return addReviewers ( db , labelTypes , change , ps.getId ( ) , ps.isDraft ( ) , info.getAuthor ( ) . getAccount ( ) , info.getCommitter ( ) . getAccount ( ) , wantReviewers , existingReviewers ) ; }
public com.google.common.util.concurrent.ListenableFuture < V > get ( K key ) { return com.google.common.util.concurrent.Futures.compose ( cache.get ( wrapKey ( key ) ) , unpack ) ; }
public java.lang.Object apply ( com.google.gerrit.server.change.FileResource resource , com.google.gerrit.server.change.Reviewed.Input input ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.server.ReviewDb db = dbProvider.get ( ) ; com.google.gerrit.reviewdb.client.AccountPatchReview apr = com.google.gerrit.server.change.Reviewed.getExisting ( db , resource ) ; if ( apr != null ) { db.accountPatchReviews ( ) . delete ( java.util.Collections.singleton ( apr ) ) ; } return com.google.gerrit.extensions.restapi.Response.none ( ) ; }
public void getGrandChildProjectWithRecursiveFlag ( ) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey child = createProject ( "p1" ) ; com.google.gerrit.reviewdb.client.Project.NameKey grandChild = createProject ( "p1.1" , child ) ; com.google.gerrit.extensions.common.ProjectInfo grandChildInfo = gApi.projects ( ) . name ( allProjects.get ( ) ) . child ( grandChild.get ( ) ) . get ( true ) ; com.google.gerrit.acceptance.rest.project.ProjectAssert.assertProjectInfo ( projectCache.get ( grandChild ) . getProject ( ) , grandChildInfo ) ; }
public void setUp ( ) throws java.lang.Exception { group1 = group ( "users1" ) ; group2 = group ( "users2" ) ; group3 = group ( "users3" ) ; user1 = user ( "user1" , group1 ) ; user2 = user ( "user2" , group2 ) ; user3 = user ( "user3" , group1 , group2 ) ; }
private int num ( com.google.gerrit.client.changes.ChangeInfo.RevisionInfo r ) { return ! ( r.is_edit ( ) ) ? ( 2 * ( ( r._number ( ) ) - 1 ) ) + 1 : 2 * editParent ; }
private boolean canPerformOnAllRefs ( com.google.gerrit.reviewdb.ApprovalCategory.Id actionId , short requireValue ) { return canPerform ( actionId , requireValue , "refs/*" ) ; }
public com.google.common.collect.ImmutableListMultimap < com.google.gerrit.reviewdb.client.PatchSet.Id , com.google.gerrit.reviewdb.client.PatchSetApproval > getApprovals ( ) { if ( ( approvals ) == null ) { com.google.common.collect.ImmutableListMultimap.Builder < com.google.gerrit.reviewdb.client.PatchSet.Id , com.google.gerrit.reviewdb.client.PatchSetApproval > b = com.google.common.collect.ImmutableListMultimap.builder ( ) ; for ( java.util.Map.Entry < com.google.gerrit.reviewdb.client.PatchSet.Id , com.google.gerrit.reviewdb.client.PatchSetApproval > e : state.approvals ( ) ) { b.put ( e.getKey ( ) , new com.google.gerrit.reviewdb.client.PatchSetApproval ( e.getValue ( ) ) ) ; } approvals = b.build ( ) ; } return approvals ; }
private com.google.gerrit.client.diff.DraftBox addDraftBox ( com.google.gerrit.client.changes.CommentInfo info , boolean doSave ) { com.google.gerrit.client.diff.DraftBox box = new com.google.gerrit.client.diff.DraftBox ( this , revision , info , commentLinkProcessor , true , doSave ) ; addCommentBox ( info , box ) ; if ( ! doSave ) { box.setEdit ( true ) ; } net.codemirror.lib.CodeMirror.LineHandle handle = getCmFromSide ( info.side ( ) ) . getLineHandle ( ( ( info.line ( ) ) - 1 ) ) ; lineActiveBoxMap.put ( handle , box ) ; return box ; }
private com.google.gerrit.server.account.AccountState toAccountState ( com.google.gson.JsonElement json ) { com.google.gson.JsonElement source = json.getAsJsonObject ( ) . get ( "_source" ) ; if ( source == null ) { source = json.getAsJsonObject ( ) . get ( "fields" ) ; } com.google.gerrit.reviewdb.client.Account.Id id = new com.google.gerrit.reviewdb.client.Account.Id ( source.getAsJsonObject ( ) . get ( com.google.gerrit.server.index.account.AccountField.ID.getName ( ) ) . getAsInt ( ) ) ; return accountCache.get ( id ) ; }
public void onKeyUp ( final com.google.gwt.event.dom.client.KeyUpEvent event ) { com.google.gwt.core.client.Scheduler.get ( ) . scheduleDeferred ( new com.google.gwt.user.client.Command ( ) { public void execute ( ) { hideTextBox ( ) ; } } ) ; }
private static org.eclipse.jetty.server.ServerConnector newServerConnector ( org.eclipse.jetty.server.Server server , int acceptors , org.eclipse.jetty.server.HttpConfiguration config ) { return new org.eclipse.jetty.server.ServerConnector ( server , null , null , null , 0 , acceptors , new org.eclipse.jetty.server.HttpConnectionFactory ( config ) ) ; }
public void onFailure ( final java.lang.Throwable caught ) { userNameTxt.setEnabled ( true ) ; changeUserName.setEnabled ( true ) ; if ( InvalidSshUserNameException.MESSAGE.equals ( caught.getMessage ( ) ) ) { invalidUserName ( ) ; } else { super . onFailure ( caught ) ; } }
private boolean isRepo ( java.nio.file.Path p ) { java.lang.String name = p.getFileName ( ) . toString ( ) ; return ( ! ( name.equals ( Constants.DOT_GIT ) ) ) && ( ( name.endsWith ( Constants.DOT_GIT_EXT ) ) || ( org.eclipse.jgit.lib.RepositoryCache.FileKey.isGitRepository ( p.toFile ( ) , FS.DETECTED ) ) ) ; }
public com.google.common.collect.ImmutableList < com.google.gerrit.reviewdb.client.AccountGroup.UUID > load ( java.lang.String key ) throws java.lang.Exception { try ( com.google.gerrit.reviewdb.server.ReviewDb db = schema.open ( ) ) { return groups.getExternalGroups ( db ) . collect ( com.google.common.collect.ImmutableList.toImmutableList ( ) ) ; } }
private void throwUnsupported ( final org.objectweb.asm.MethodVisitor mv , final java.lang.String message ) { final org.objectweb.asm.Type eType = org.objectweb.asm.Type.getType ( java.lang.UnsupportedOperationException.class ) ; mv.visitTypeInsn ( com.google.gwtorm.jdbc.NEW , eType.getInternalName ( ) ) ; mv.visitInsn ( com.google.gwtorm.jdbc.DUP ) ; mv.visitLdcInsn ( message ) ; mv.visitMethodInsn ( com.google.gwtorm.jdbc.INVOKESPECIAL , eType.getInternalName ( ) , "<init>" , org.objectweb.asm.Type.getMethodDescriptor ( Type.VOID_TYPE , new org.objectweb.asm.Type [ ] { org.objectweb.asm.Type.getType ( java.lang.String.class ) } ) ) ; mv.visitInsn ( com.google.gwtorm.jdbc.ATHROW ) ; }
private void assertReviewers ( com.google.gerrit.reviewdb.client.Change c , com.google.gerrit.acceptance.TestAccount ... expectedReviewers ) throws com.google.gerrit.server.project.NoSuchChangeException , com.google.gwtorm.server.OrmException { java.lang.Iterable < com.google.gerrit.reviewdb.client.Account.Id > actualIds = approvalsUtil.getReviewers ( db , notesFactory.createChecked ( db , c ) ) . values ( ) ; com.google.common.truth.Truth.assertThat ( actualIds ) . containsExactlyElementsIn ( com.google.common.collect.Sets.newHashSet ( com.google.gerrit.acceptance.TestAccount.ids ( expectedReviewers ) ) ) ; }
public static void toggleStar ( final com.google.gerrit.reviewdb.client.Change.Id changeId , final boolean newValue ) { com.google.gerrit.client.changes.StarredChanges.pending.put ( changeId , newValue ) ; com.google.gerrit.client.changes.StarredChanges.fireChangeStarEvent ( changeId , newValue ) ; if ( ! ( com.google.gerrit.client.changes.StarredChanges.busy ) ) { com.google.gerrit.client.changes.StarredChanges.startRequest ( ) ; } }
private static boolean getBoolean ( org.eclipse.jgit.lib.Config cfg , java.lang.String section , java.lang.String name , boolean defaultValue ) { try { return cfg.getBoolean ( section , name , defaultValue ) ; } catch ( java.lang.IllegalArgumentException e ) { com.ericsson.gerrit.plugins.highavailability.Configuration.log.error ( "invalid value for {}; using default value {}" , name , defaultValue ) ; com.ericsson.gerrit.plugins.highavailability.Configuration.log.debug ( "Failed to retrieve boolean value: {}" , e.getMessage ( ) , e ) ; return defaultValue ; } }
public void onSuccess ( com.google.gerrit.client.rpc.NativeString msg ) { setEnabled ( true ) ; if ( ( msg != null ) && ( ! ( msg.asString ( ) . isEmpty ( ) ) ) ) { com.google.gwt.user.client.Window.alert ( msg.asString ( ) ) ; } com.google.gerrit.client.Gerrit.display ( com.google.gerrit.common.PageLinks.toChange2 ( changeId ) ) ; }
private boolean couldDeleteWhenIn ( com.google.gerrit.reviewdb.client.Change.Status status ) { switch ( status ) { case NEW : case ABANDONED : return true ; case MERGED : return false ; case DRAFT : if ( allowDrafts ) { return true ; } return permissionBackend.user ( user ) . testOrFalse ( GlobalPermission.ADMINISTRATE_SERVER ) ; } return false ; }
public static java.util.Set < java.lang.String > accountFields ( com.google.gerrit.server.index.QueryOptions opts ) { java.util.Set < java.lang.String > fs = opts.fields ( ) ; return fs.contains ( AccountField.ID.getName ( ) ) ? fs : com.google.common.collect.Sets.union ( fs , com.google.common.collect.ImmutableSet.of ( AccountField.ID.getName ( ) ) ) ; }
void index ( com.google.gerrit.reviewdb.client.Account.Id id , com.ericsson.gerrit.plugins.highavailability.forwarder.rest.Operation operation ) throws java.io.IOException { indexer.index ( id ) ; com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexAccountRestApiServlet.logger.debug ( "Account {} successfully indexed" , id ) ; }
private byte [ ] formatMarkdownAsHtml ( com.googlesource.gerrit.plugins.xdocs.XDocGlobalConfig cfg , java.lang.String md ) throws java.io.IOException { com.google.gerrit.server.documentation.MarkdownFormatter f = new com.google.gerrit.server.documentation.MarkdownFormatter ( ) ; if ( ! ( cfg.isHtmlAllowed ( Formatter.MARKDOWN ) ) ) { f.suppressHtml ( ) ; } return f.markdownToDocHtml ( md , java.nio.charset.StandardCharsets.UTF_8.name ( ) ) ; }
protected void configure ( ) { bind ( java.util.concurrent.ScheduledThreadPoolExecutor.class ) . annotatedWith ( com.googlesource.gerrit.plugins.webhooks.WebHooksExecutor.class ) . toProvider ( com.googlesource.gerrit.plugins.webhooks.ExecutorProvider.class ) ; bind ( com.googlesource.gerrit.plugins.webhooks.Configuration.class ) . in ( Scopes.SINGLETON ) ; bind ( org.apache.http.impl.client.CloseableHttpClient.class ) . toProvider ( com.googlesource.gerrit.plugins.webhooks.HttpClientProvider.class ) . in ( Scopes.SINGLETON ) ; factory ( PostTask.Factory.class ) ; com.google.gerrit.extensions.registration.DynamicSet.bind ( binder ( ) , com.google.gerrit.common.EventListener.class ) . to ( com.googlesource.gerrit.plugins.webhooks.EventHandler.class ) ; }
public final boolean hasSkip ( ) { com.google.gwt.core.client.JsArray < com.google.gerrit.client.diff.DiffInfo.Region > c = content ( ) ; for ( int i = 0 ; i < ( c.length ( ) ) ; i ++ ) { if ( ( c.get ( i ) . skip ( ) ) != 0 ) { return true ; } } return false ; }
public com.google.gerrit.extensions.restapi.Response < com.google.gerrit.extensions.common.ChangeInfo > apply ( com.google.gerrit.server.change.ChangeResource rsrc , com.google.gerrit.extensions.api.changes.FixInput input ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.permissions.PermissionBackendException , com.google.gerrit.server.project.NoSuchProjectException , com.google.gwtorm.server.OrmException , java.io.IOException { if ( ( ! ( rsrc.isUserOwner ( ) ) ) && ( ! ( projectControlFactory.controlFor ( rsrc.getProject ( ) , rsrc.getUser ( ) ) . isOwner ( ) ) ) ) { permissionBackend.user ( user ) . check ( GlobalPermission.MAINTAIN_SERVER ) ; } return com.google.gerrit.extensions.restapi.Response.withMustRevalidate ( newChangeJson ( ) . fix ( input ) . format ( rsrc ) ) ; }
private org.eclipse.jgit.revwalk.RevObject resolve ( java.lang.String name , org.eclipse.jgit.revwalk.RevWalk walk ) throws java.io.IOException { try { org.eclipse.jgit.lib.ObjectId id = repo.resolve ( name ) ; return id != null ? walk.parseAny ( id ) : null ; } catch ( org.eclipse.jgit.errors.AmbiguousObjectException e ) { return null ; } catch ( org.eclipse.jgit.errors.RevisionSyntaxException e ) { return null ; } catch ( org.eclipse.jgit.errors.MissingObjectException e ) { return null ; } }
protected void checkParsed ( ) { com.google.common.base.Preconditions.checkState ( ( ( raw ) != null ) , "revision note not parsed yet" ) ; }
public void missingRepo ( ) throws java.lang.Exception { assumeNoteDbDisabled ( ) ; com.google.gerrit.server.notedb.ChangeNotes notes = insertChange ( ) ; com.google.gerrit.reviewdb.client.Project.NameKey name = notes.getProjectName ( ) ; com.google.gerrit.server.project.ChangeControl ctl = controlForNotes ( notes ) ; ( ( com.google.gerrit.testutil.InMemoryRepositoryManager ) ( repoManager ) ) . deleteRepository ( name ) ; com.google.common.truth.Truth.assertThat ( checker.check ( ctl , null ) . problems ( ) ) . containsExactly ( com.google.gerrit.acceptance.server.change.ConsistencyCheckerIT.problem ( ( "Destination repository not found: " + name ) ) ) ; }
public void parseRef ( ) throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit master = repo.branch ( "refs/heads/master" ) . commit ( ) . create ( ) ; com.google.common.truth.Truth.assertThat ( parser.parse ( "master" ) ) . isEqualTo ( new com.google.gitiles.RevisionParser.Result ( com.google.gitiles.Revision.peeled ( "master" , master ) ) ) ; com.google.common.truth.Truth.assertThat ( parser.parse ( "refs/heads/master" ) ) . isEqualTo ( new com.google.gitiles.RevisionParser.Result ( com.google.gitiles.Revision.peeled ( "refs/heads/master" , master ) ) ) ; com.google.common.truth.Truth.assertThat ( parser.parse ( "refs//heads//master" ) ) . isNull ( ) ; com.google.common.truth.Truth.assertThat ( parser.parse ( "refs heads master" ) ) . isNull ( ) ; }
public com.google.gerrit.server.change.ChangeJson.ChangeInfo format ( com.google.gerrit.server.change.RevisionResource rsrc ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.ChangeData cd = changeDataFactory.create ( db.get ( ) , rsrc.getControl ( ) ) ; cd.limitToPatchSets ( com.google.common.collect.ImmutableList.of ( rsrc.getPatchSet ( ) . getId ( ) ) ) ; return format ( cd ) ; }
public void newPatchSetByOtherOnReviewableChangeOwnerSelfCcInNoteDb ( ) throws java.lang.Exception { com.google.common.truth.TruthJUnit.assume ( ) . that ( notesMigration.readChanges ( ) ) . isTrue ( ) ; com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange ( ) ; pushTo ( sc , "refs/for/master" , other , EmailStrategy.CC_ON_OWN_COMMENTS ) ; assertThat ( sender ) . sent ( "newpatchset" , sc ) . to ( sc.owner , sc.reviewer , other ) . cc ( sc.ccer ) . cc ( sc.reviewerByEmail , sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.NEW_PATCHSETS ) . noOneElse ( ) ; }
public static org.eclipse.jgit.lib.Config allEnabledConfig ( ) { org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config ( ) ; for ( com.google.gerrit.server.notedb.NoteDbTable t : com.google.gerrit.server.notedb.NoteDbTable.values ( ) ) { cfg.setBoolean ( com.google.gerrit.server.notedb.ConfigNotesMigration.NOTE_DB , t.key ( ) , com.google.gerrit.server.notedb.ConfigNotesMigration.WRITE , true ) ; cfg.setBoolean ( com.google.gerrit.server.notedb.ConfigNotesMigration.NOTE_DB , t.key ( ) , com.google.gerrit.server.notedb.ConfigNotesMigration.READ , true ) ; } return cfg ; }
private void testPushWithMultipleChangeIds ( ) throws java.lang.Exception { com.google.gerrit.acceptance.git.AbstractPushForReview.createCommit ( testRepo , ( "Message with multiple Change-Id\n" + ( ( "\n" + "Change-Id: I10f98c2ef76e52e23aa23be5afeb71e40b350e86\n" ) + "Change-Id: Ie9a132e107def33bdd513b7854b50de911edba0a\n" ) ) ) ; com.google.gerrit.acceptance.git.AbstractPushForReview.pushForReviewRejected ( testRepo , "multiple Change-Id lines in commit message footer" ) ; setRequireChangeId ( InheritableBoolean.FALSE ) ; com.google.gerrit.acceptance.git.AbstractPushForReview.pushForReviewRejected ( testRepo , "multiple Change-Id lines in commit message footer" ) ; }
public void run ( ) { skipManager.removeAll ( ) ; getChunkManager ( ) . reset ( ) ; getDiffTable ( ) . scrollbar.removeDiffAnnotations ( ) ; setShowIntraline ( prefs.intralineDifference ( ) ) ; render ( diff ) ; skipManager.render ( prefs.context ( ) , diff ) ; }
private static boolean isDateField ( java.lang.String name ) { return ( ( ( "lastUpdated" . equals ( name ) ) || ( "grantedOn" . equals ( name ) ) ) || ( "timestamp" . equals ( name ) ) ) || ( "createdOn" . equals ( name ) ) ; }
private com.google.gerrit.extensions.client.SubmitType getSubmitType ( com.google.gerrit.server.CurrentUser user , com.google.gerrit.server.query.change.ChangeData cd , com.google.gerrit.reviewdb.client.PatchSet patchSet ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.SubmitTypeRecord rec = submitRuleEvaluatorFactory.create ( user , cd ) . setPatchSet ( patchSet ) . getSubmitType ( ) ; if ( ( rec.status ) != ( SubmitTypeRecord.Status.OK ) ) { throw new com.google.gwtorm.server.OrmException ( ( "Submit type rule failed: " + rec ) ) ; } return rec.type ; }
static void addHistoryHook ( final com.google.gwt.core.client.JavaScriptObject hook ) { if ( ( com.google.gerrit.client.Gerrit.historyHooks ) == null ) { com.google.gerrit.client.Gerrit.historyHooks = new java.util.ArrayList < com.google.gwt.core.client.JavaScriptObject > ( ) ; com.google.gwt.user.client.History.addValueChangeHandler ( new com.google.gwt.event.logical.shared.ValueChangeHandler < java.lang.String > ( ) { @ java.lang.Override public void onValueChange ( com.google.gwt.event.logical.shared.ValueChangeEvent < java.lang.String > event ) { com.google.gerrit.client.Gerrit.dispatchHistoryHooks ( event.getValue ( ) ) ; } } ) ; } com.google.gerrit.client.Gerrit.historyHooks.add ( hook ) ; }
private java.lang.String anchorHref ( java.lang.String val ) { if ( ( com.google.gitiles.doc.html.HtmlBuilder.URI.getValueFilter ( ) . matcher ( val ) . find ( ) ) || ( com.google.gitiles.doc.html.HtmlBuilder.isValidGitUri ( val ) ) ) { return com.google.gitiles.doc.html.HtmlBuilder.URI.escape ( val ) ; } return com.google.gitiles.doc.html.HtmlBuilder.URI.getInnocuousOutput ( ) ; }
private void readObject ( final java.io.ObjectInputStream in ) throws java.io.IOException { projectKey = new com.google.gerrit.client.reviewdb.Project.NameKey ( in.readUTF ( ) ) ; oldId = org.spearce.jgit.lib.ObjectIdSerialization.read ( in ) ; newId = org.spearce.jgit.lib.ObjectIdSerialization.read ( in ) ; fileName = com.google.gerrit.server.patch.DiffCacheKey.readString ( in ) ; sourceFileName = com.google.gerrit.server.patch.DiffCacheKey.readString ( in ) ; whitespace = com.google.gerrit.client.patches.PatchScriptSettings.Whitespace.valueOf ( com.google.gerrit.server.patch.DiffCacheKey.readString ( in ) ) ; }
private boolean canPushWithForce ( ) { if ( ( ! ( canWrite ( ) ) ) || ( ( GitRepositoryManager.REF_CONFIG.equals ( refName ) ) && ( ! ( projectControl.isOwner ( ) ) ) ) ) { return false ; } boolean result = false ; for ( com.google.gerrit.common.data.PermissionRule rule : access ( Permission.PUSH ) ) { if ( rule.isBlock ( ) ) { return false ; } if ( rule.getForce ( ) ) { result = true ; } } return result ; }
public void testCarriageReturn ( ) throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit c = makeCommit ( ) ; com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator validator = new com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator ( null , new com.googlesource.gerrit.plugins.uploadvalidator.ContentTypeUtil ( com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.PATTERN_CACHE ) , null , null , null ) ; java.util.List < com.google.gerrit.server.git.validators.CommitValidationMessage > m = validator.performValidation ( repo , c , com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.EMPTY_PLUGIN_CONFIG ) ; com.google.common.truth.Truth.assertThat ( com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.transformMessages ( m ) ) . containsExactly ( "ERROR: found carriage return (CR) character in file: foo.txt" ) ; }
public com.google.gerrit.extensions.client.GeneralPreferencesInfo apply ( com.google.gerrit.server.config.ConfigResource rsrc , com.google.gerrit.extensions.client.GeneralPreferencesInfo input ) throws com.google.gerrit.extensions.restapi.BadRequestException , java.io.IOException , org.eclipse.jgit.errors.ConfigInvalidException { if ( ! ( com.google.gerrit.server.restapi.config.SetPreferences.hasSetFields ( input ) ) ) { throw new com.google.gerrit.extensions.restapi.BadRequestException ( "unsupported option" ) ; } com.google.gerrit.server.account.Preferences.validateMy ( input.my ) ; try ( com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.get ( ) . create ( allUsersName ) ) { com.google.gerrit.extensions.client.GeneralPreferencesInfo updatedPrefs = com.google.gerrit.server.account.Preferences.updateDefaultGeneralPreferences ( md , input ) ; accountCache.evictAll ( ) ; return updatedPrefs ; } }
public void onSuccess ( final com.google.gerrit.client.reviewdb.AccountSshKey result ) { addNew.setEnabled ( true ) ; addTxt.setText ( "" ) ; keys.addOneKey ( result ) ; if ( ! ( keys.isVisible ( ) ) ) { showAddKeyBlock ( false ) ; setKeyTableVisible ( true ) ; } }
private com.google.gerrit.extensions.common.GroupInfo createGroupInfo ( com.google.gerrit.common.data.GroupDescription.Basic group , java.util.function.Supplier < com.google.gerrit.server.account.GroupControl > groupControlSupplier ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.extensions.common.GroupInfo info = com.google.gerrit.server.group.GroupJson.createBasicGroupInfo ( group ) ; if ( group instanceof com.google.gerrit.common.data.GroupDescription.Internal ) { addInternalDetails ( info , ( ( com.google.gerrit.common.data.GroupDescription.Internal ) ( group ) ) , groupControlSupplier ) ; } return info ; }
public static java.lang.String toLongString ( final com.google.gerrit.extensions.client.ProjectState type ) { if ( type == null ) { return "" ; } switch ( type ) { case ACTIVE : return com.google.gerrit.client.admin.Util.C.projectState_ACTIVE ( ) ; case READ_ONLY : return com.google.gerrit.client.admin.Util.C.projectState_READ_ONLY ( ) ; case HIDDEN : return com.google.gerrit.client.admin.Util.C.projectState_HIDDEN ( ) ; default : return type.name ( ) ; } }
private static com.google.gwt.user.client.ui.Anchor anchor ( final java.lang.String text , final java.lang.String to ) { final com.google.gwt.user.client.ui.Anchor a = new com.google.gwt.user.client.ui.Anchor ( text , to ) ; a.setStyleName ( "gerrit-MenuItem" ) ; com.google.gwt.user.client.ui.Accessibility.setRole ( a.getElement ( ) , Accessibility.ROLE_MENUITEM ) ; return a ; }
private int getCodeMirrorHeight ( ) { int rest = ( ( ( com.google.gerrit.client.Gerrit.getHeaderFooterHeight ( ) ) + ( header.getOffsetHeight ( ) ) ) + ( diffTable.getHeaderHeight ( ) ) ) + 5 ; return ( com.google.gwt.user.client.Window.getClientHeight ( ) ) - rest ; }
public void listBranchesOfNonVisibleProject_NotFound ( ) throws java.lang.Exception { blockRead ( project , "refs/*" ) ; setApiUser ( user ) ; try { gApi.projects ( ) . name ( project.get ( ) ) . branches ( ) . get ( ) ; org.junit.Assert.fail ( "Expected ResourceNotFoundException" ) ; } catch ( com.google.gerrit.extensions.restapi.ResourceNotFoundException expected ) { } }
public static boolean branchExists ( final com.google.gerrit.server.git.GitRepositoryManager repoManager , final com.google.gerrit.reviewdb.client.Branch.NameKey branch ) throws java.io.IOException , org.eclipse.jgit.errors.RepositoryNotFoundException { final org.eclipse.jgit.lib.Repository repo = repoManager.openRepository ( branch.getParentKey ( ) ) ; try { boolean exists = ( repo.getRefDatabase ( ) . exactRef ( branch.get ( ) ) ) != null ; if ( ! exists ) { exists = repo.getFullBranch ( ) . equals ( branch.get ( ) ) ; } return exists ; } finally { repo.close ( ) ; } }
private void parseReviewer ( com.google.gerrit.server.notedb.ReviewerStateInternal state , java.lang.String line ) throws org.eclipse.jgit.errors.ConfigInvalidException { org.eclipse.jgit.lib.PersonIdent ident = org.eclipse.jgit.util.RawParseUtils.parsePersonIdent ( line ) ; if ( ident == null ) { throw invalidFooter ( state.getFooterKey ( ) , line ) ; } com.google.gerrit.reviewdb.client.Account.Id accountId = parseIdent ( ident ) ; if ( ! ( reviewers.containsKey ( accountId ) ) ) { reviewers.put ( accountId , state ) ; } }
static java.lang.String escapeName ( java.lang.String name ) { try { return java.net.URLEncoder.encode ( name , java.nio.charset.StandardCharsets.UTF_8.name ( ) ) . replace ( "%2F" , "/" ) . replace ( "%2f" , "/" ) . replace ( "+" , "%20" ) . replace ( "%2B" , "+" ) . replace ( "%2b" , "+" ) ; } catch ( java.io.UnsupportedEncodingException e ) { throw new java.lang.IllegalStateException ( e ) ; } }
public void newPatchSetOnWipChangeSettingReadyInReviewDb ( ) throws java.lang.Exception { com.google.common.truth.TruthJUnit.assume ( ) . that ( notesMigration.readChanges ( ) ) . isFalse ( ) ; com.google.gerrit.acceptance.server.mail.StagedChange sc = stageWipChange ( ) ; pushTo ( sc , "refs/for/master%ready" , sc.owner ) ; assertThat ( sender ) . sent ( "newpatchset" , sc ) . to ( sc.reviewer , sc.ccer ) . cc ( sc.reviewerByEmail , sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.NEW_PATCHSETS ) . noOneElse ( ) ; assertThat ( sender ) . notSent ( ) ; }
private void expandAfter ( ) { net.codemirror.lib.TextMarker.FromTo range = textMarker.find ( ) ; int start = range.from ( ) . line ( ) ; int oldEnd = range.to ( ) . line ( ) ; int newEnd = oldEnd - ( com.google.gerrit.client.diff.SkipBar.NUM_ROWS_TO_EXPAND ) ; boolean attach = start == 0 ; if ( attach ) { clearMarkerAndWidget ( ) ; } else { textMarker.clear ( ) ; } collapse ( start , newEnd , attach ) ; updateSelection ( ) ; }
public static com.google.gerrit.server.patch.DiffSummaryKey fromPatchListKey ( com.google.gerrit.server.patch.PatchListKey plk ) { com.google.common.base.Preconditions.checkArgument ( ( ( plk.getAlgorithm ( ) ) == ( PatchListKey.Algorithm.OPTIMIZED_DIFF ) ) ) ; return new com.google.gerrit.server.patch.DiffSummaryKey ( plk.getOldId ( ) , plk.getParentNum ( ) , plk.getNewId ( ) , plk.getWhitespace ( ) ) ; }
public void execute ( ) { deferred = null ; cmA.operation ( new java.lang.Runnable ( ) { @ java.lang.Override public void run ( ) { cmB.operation ( new java.lang.Runnable ( ) { @ java.lang.Override public void run ( ) { for ( java.lang.Runnable thunk : list ) { thunk.run ( ) ; } } } ) ; } } ) ; }
private static java.lang.String name ( java.nio.file.Path dir ) { return dir.getFileName ( ) . toString ( ) ; }
public static java.lang.StringBuilder appendTo ( java.lang.StringBuilder sb , java.lang.String label , short value ) { if ( value == ( ( short ) ( 0 ) ) ) { return sb.append ( '-' ) . append ( label ) ; } else if ( value < 0 ) { return sb.append ( label ) . append ( value ) ; } return sb.append ( label ) . append ( '+' ) . append ( value ) ; }
protected boolean canDelete ( com.google.gerrit.server.project.ProjectResource rsrc ) { com.google.gerrit.server.permissions.PermissionBackend.WithUser userPermission = permissionBackend.currentUser ( ) ; com.google.gerrit.server.permissions.PermissionBackend.ForProject projectPermission = userPermission.project ( rsrc.getNameKey ( ) ) ; return ( ( userPermission.testOrFalse ( GlobalPermission.ADMINISTRATE_SERVER ) ) || ( userPermission.testOrFalse ( new com.google.gerrit.extensions.api.access.PluginPermission ( pluginName , com.googlesource.gerrit.plugins.deleteproject.DeleteProjectCapability.DELETE_PROJECT ) ) ) ) || ( ( userPermission.testOrFalse ( new com.google.gerrit.extensions.api.access.PluginPermission ( pluginName , com.googlesource.gerrit.plugins.deleteproject.DeleteOwnProjectCapability.DELETE_OWN_PROJECT ) ) ) && ( projectPermission.testOrFalse ( ProjectPermission.WRITE_CONFIG ) ) ) ; }
private boolean canRead ( org.eclipse.jgit.lib.ObjectId revId ) throws com.google.gerrit.server.permissions.PermissionBackendException , java.io.IOException { try { permissionBackend.user ( user ) . project ( project.getNameKey ( ) ) . check ( ProjectPermission.READ ) ; return true ; } catch ( com.google.gerrit.extensions.restapi.AuthException e ) { try ( org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk ( repo ) ) { org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit ( revId ) ; return projectControl.canReadCommit ( db , repo , commit ) ; } } }
void onSyntaxHighlighting ( com.google.gwt.event.logical.shared.ValueChangeEvent < java.lang.Boolean > e ) { prefs.syntaxHighlighting ( e.getValue ( ) ) ; if ( ( view ) != null ) { mode.setEnabled ( prefs.syntaxHighlighting ( ) ) ; if ( prefs.syntaxHighlighting ( ) ) { setMode ( view.getContentType ( ) ) ; } view.setSyntaxHighlighting ( prefs.syntaxHighlighting ( ) ) ; } }
void openAll ( ) { if ( ( table ) != null ) { java.lang.String self = com.google.gerrit.client.Gerrit.selfRedirect ( null ) ; for ( com.google.gerrit.client.info.FileInfo info : com.google.gerrit.client.rpc.Natives.asList ( table.list ) ) { com.google.gwt.user.client.Window.open ( ( ( self + "#" ) + ( url ( info ) ) ) , "_blank" , null ) ; } } }
public boolean match ( com.google.gerrit.server.query.change.ChangeData cd ) throws com.google.gwtorm.client.OrmException { com.google.gerrit.reviewdb.Change c = cd.change ( dbProvider ) ; return ( c != null ) && ( ( c.getSortKeyDesc ( ) . compareTo ( getValue ( ) ) ) > 0 ) ; }
public void testUnblockForce ( ) { com.google.gerrit.common.data.PermissionRule r = com.google.gerrit.server.project.Util.block ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/heads/*" ) ; r.setForce ( true ) ; com.google.gerrit.server.project.Util.allow ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.Util.DEVS , "refs/heads/*" ) . setForce ( true ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.project.Util.DEVS ) ; assertCanForceUpdate ( "refs/heads/master" , u ) ; }
public void createEmptyChange_InvalidSubject ( ) throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInput ci = newChangeInput ( ChangeStatus.NEW ) ; ci.subject = "Change-Id: I1234000000000000000000000000000000000000" ; assertCreateFails ( ci , com.google.gerrit.extensions.restapi.ResourceConflictException.class , "missing subject; Change-Id must be in commit message footer" ) ; }
private void expectToHaveCommitMessage ( org.eclipse.jgit.junit.TestRepository < ? > repo , java.lang.String branch , java.lang.String expectedMessage ) throws java.lang.Exception { org.eclipse.jgit.lib.ObjectId commitId = repo.git ( ) . fetch ( ) . setRemote ( "origin" ) . call ( ) . getAdvertisedRef ( ( "refs/heads/" + branch ) ) . getObjectId ( ) ; org.eclipse.jgit.revwalk.RevWalk rw = repo.getRevWalk ( ) ; org.eclipse.jgit.revwalk.RevCommit c = rw.parseCommit ( commitId ) ; com.google.common.truth.Truth.assertThat ( c.getFullMessage ( ) ) . isEqualTo ( expectedMessage ) ; }
public void onKeyPress ( com.google.gwt.event.dom.client.KeyPressEvent event ) { if ( com.google.gerrit.client.Gerrit.isSignedIn ( ) ) { reviewers.onOpenForm ( ) ; } else { com.google.gerrit.client.Gerrit.doSignIn ( getToken ( ) ) ; } }
private void initRepository ( ) throws java.io.IOException { if ( ( repo ) == null ) { this . repo = repoManager.openRepository ( project ) ; closeRepo = true ; inserter = repo.newObjectInserter ( ) ; revWalk = new org.eclipse.jgit.revwalk.RevWalk ( inserter.newReader ( ) ) ; commands = new com.google.gerrit.server.git.ChainedReceiveCommands ( repo ) ; } }
private com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection newReviewerFilterSection ( java.lang.String filter ) { com.google.common.collect.ImmutableSet.Builder < java.lang.String > b = com.google.common.collect.ImmutableSet.builder ( ) ; for ( java.lang.String reviewer : cfg.getStringList ( com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.FILTER , filter , com.googlesource.gerrit.plugins.reviewers.ReviewersConfig.REVIEWER ) ) { b.add ( reviewer ) ; } return new com.googlesource.gerrit.plugins.reviewers.ReviewerFilterSection ( filter , b.build ( ) ) ; }
public boolean isOwner ( ) { if ( canPerform ( com.google.gerrit.reviewdb.ApprovalCategory.OWN , ( ( short ) ( 1 ) ) ) ) { return true ; } if ( ( getRefName ( ) . equals ( RefRight.ALL.substring ( 0 , ( ( RefRight.ALL.length ( ) ) - 1 ) ) ) ) && ( getProjectControl ( ) . isOwner ( ) ) ) { return true ; } return false ; }
public java.lang.String getUrl ( java.lang.String project ) { if ( ( ! ( isEnabled ( ) ) ) || ( ! ( userProvider.get ( ) . isIdentifiedUser ( ) ) ) ) { return null ; } java.lang.StringBuilder r = new java.lang.StringBuilder ( ) ; r.append ( "ssh://" ) ; r.append ( userProvider.get ( ) . getUserName ( ) ) ; r.append ( "@" ) ; r.append ( com.googlesource.gerrit.plugins.download.scheme.SshScheme.ensureSlash ( sshdAddress ) ) ; r.append ( project ) ; return r.toString ( ) ; }
public void testUpsertOneException ( ) throws com.google.gwtorm.server.OrmException , java.sql.SQLException { java.sql.SQLException exception = new java.sql.BatchUpdateException ( ) ; java.sql.PreparedStatement update = stubStatementThrowExceptionOnExecute ( com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE , exception ) ; com.google.gwtorm.jdbc.JdbcAccess < com.google.gwtorm.jdbc.TestJdbcAccess.Data , com.google.gwtorm.jdbc.TestJdbcAccess.Data.DataKey > classUnderTest = createClassUnderTest ( ) ; try { classUnderTest.upsert ( oneRow ) ; org.junit.Assert.fail ( "missingException" ) ; } catch ( com.google.gwtorm.server.OrmException e ) { org.junit.Assert.assertSame ( e.getCause ( ) , exception ) ; } com.google.gwtorm.jdbc.TestJdbcAccess.assertUsedBatchingOnly ( update ) ; }
private RevisionParser.Result parseRevision ( javax.servlet.http.HttpServletRequest req , java.lang.String path ) throws java.io.IOException { com.google.gitiles.RevisionParser revParser = new com.google.gitiles.RevisionParser ( org.eclipse.jgit.http.server.ServletUtils.getRepository ( req ) , accessFactory.forRequest ( req ) , visibilityCache ) ; return revParser.parse ( com.google.gitiles.ViewFilter.checkLeadingSlash ( path ) ) ; }
public com.google.gerrit.server.account.AccountSshKey create ( com.google.gerrit.reviewdb.client.Account.Id accountId , int seq , java.lang.String encoded ) throws com.google.gerrit.common.errors.InvalidSshKeyException { try { com.google.gerrit.server.account.AccountSshKey key = com.google.gerrit.server.account.AccountSshKey.create ( accountId , seq , com.google.gerrit.sshd.SshUtil.toOpenSshPublicKey ( encoded ) ) ; com.google.gerrit.sshd.SshUtil.parse ( key ) ; return key ; } catch ( java.security.NoSuchAlgorithmException | java.security.spec.InvalidKeySpecException e ) { throw new com.google.gerrit.common.errors.InvalidSshKeyException ( ) ; } catch ( java.security.NoSuchProviderException e ) { com.google.gerrit.sshd.SshKeyCreatorImpl.log.error ( "Cannot parse SSH key" , e ) ; throw new com.google.gerrit.common.errors.InvalidSshKeyException ( ) ; } }
public int compare ( final com.google.gerrit.client.data.ChangeInfo o1 , final com.google.gerrit.client.data.ChangeInfo o2 ) { return ( o1.getId ( ) . get ( ) ) - ( o2.getId ( ) . get ( ) ) ; }
public void deleteReviewerFromReviewableChangeByAdmin ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChangeWithExtraReviewer ( ) ; setApiUser ( admin ) ; removeReviewer ( sc , extraReviewer ) ; assertThat ( sender ) . sent ( "deleteReviewer" , sc ) . to ( sc.owner , extraReviewer ) . cc ( extraCcer , sc.reviewer , sc.ccer ) . cc ( sc.reviewerByEmail , sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS ) . noOneElse ( ) ; }
private void addSshKeys ( java.util.List < java.lang.String > sshKeys ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gwtorm.server.OrmException , java.io.IOException { for ( final java.lang.String sshKey : sshKeys ) { com.google.gerrit.server.account.AddSshKey.Input in = new com.google.gerrit.server.account.AddSshKey.Input ( ) ; in.raw = com.google.gerrit.common.RawInputUtil.create ( sshKey.getBytes ( ) , "plain/text" ) ; addSshKey.apply ( rsrc , in ) ; } }
public com.google.gerrit.common.data.Capable canUpload ( ) { com.google.gerrit.common.data.Capable result = projectControl.canPushToAtLeastOneRef ( ) ; if ( result != ( com.google.gerrit.common.data.Capable.OK ) ) { return result ; } return com.google.gerrit.server.util.MagicBranch.checkMagicBranchRefs ( repo , project ) ; }
private int limit ( com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > s ) { int n = com.google.common.base.MoreObjects.firstNonNull ( com.google.gerrit.server.query.change.ChangeQueryBuilder.getLimit ( s ) , maxLimit ) ; return ( limit ) > 0 ? ( java.lang.Math.min ( n , limit ) ) + 1 : n + 1 ; }
public void parseBranch ( ) throws java.lang.Exception { assertParseSucceeds ( ( "Update change\n" + ( ( ( "\n" + "Branch: refs/heads/master\n" ) + "Patch-Set: 1\n" ) + "Subject: This is a test change\n" ) ) ) ; assertParseSucceeds ( ( "Update change\n" + ( ( ( "\n" + "Branch: master\n" ) + "Patch-Set: 1\n" ) + "Subject: This is a test change\n" ) ) ) ; assertParseFails ( ( "Update change\n" + ( ( ( "\n" + "Patch-Set: 1\n" ) + "Branch: refs/heads/master\n" ) + "Branch: refs/heads/stable" ) ) ) ; }
public void upsertOneNotExisting ( ) throws com.google.gwtorm.server.OrmException , java.sql.SQLException { java.sql.PreparedStatement update = stubStatementWithUpdateCounts ( com.google.gwtorm.jdbc.AbstractTestJdbcAccess.UPDATE ) ; java.sql.PreparedStatement insert = stubStatementWithUpdateCounts ( com.google.gwtorm.jdbc.AbstractTestJdbcAccess.INSERT , 1 ) ; classUnderTest.upsert ( oneRow ) ; assertCorrectUpdating ( update , 1 ) ; assertCorrectUpdating ( insert , 1 ) ; }
public void patchSetObjectAndRefMissingWithFix ( ) throws java.lang.Exception { java.lang.String rev = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" ; com.google.gerrit.server.project.ChangeControl ctl = insertChange ( ) ; com.google.gerrit.reviewdb.client.PatchSet ps = insertMissingPatchSet ( ctl , rev ) ; ctl = reload ( ctl ) ; java.lang.String refName = ps.getId ( ) . toRefName ( ) ; assertProblems ( ctl , new com.google.gerrit.extensions.api.changes.FixInput ( ) , com.google.gerrit.acceptance.server.change.ConsistencyCheckerIT.problem ( ( "Ref missing: " + refName ) ) , com.google.gerrit.acceptance.server.change.ConsistencyCheckerIT.problem ( ( "Object missing: patch set 2: " + rev ) ) ) ; }
private static boolean isBoolean ( com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > p ) { return ( ( p instanceof com.google.gerrit.server.query.AndPredicate ) || ( p instanceof com.google.gerrit.server.query.OrPredicate ) ) || ( p instanceof com.google.gerrit.server.query.NotPredicate ) ; }
private java.io.File getPath ( ) { java.nio.file.Path basePath = site.resolve ( flags.cfg.getString ( "gerrit" , null , "basePath" ) ) ; if ( basePath == null ) { throw new java.lang.IllegalStateException ( "gerrit.basePath must be configured" ) ; } return org.eclipse.jgit.lib.RepositoryCache.FileKey.resolve ( basePath.resolve ( allUsers ) . toFile ( ) , FS.DETECTED ) ; }
private boolean isRefDeleted ( com.google.gerrit.server.events.RefUpdatedEvent event ) { if ( event.refUpdate.newRev.equals ( org.eclipse.jgit.lib.ObjectId.zeroId ( ) . getName ( ) ) ) { com.googlesource.gerrit.plugins.refprotection.RefUpdateListener.log.info ( java.lang.String.format ( "Ref Deleted: project [%s] refname [%s] old object id [%s]" , event.getProjectNameKey ( ) . toString ( ) , event.getRefName ( ) , event.refUpdate.oldRev ) ) ; return true ; } return false ; }
public static void generateHttpPassword ( java.lang.String account , com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.client.rpc.NativeString > cb ) { com.google.gerrit.client.account.AccountApi.HttpPasswordInput in = com.google.gerrit.client.account.AccountApi.HttpPasswordInput.create ( ) ; in.generate ( true ) ; new com.google.gerrit.client.rpc.RestApi ( "/accounts/" ) . id ( account ) . view ( "password.http" ) . put ( in , cb ) ; }
public void noRescheduleOnSuccess ( ) throws java.io.IOException { org.mockito.Mockito.when ( session.post ( org.mockito.ArgumentMatchers.eq ( remote ) , org.mockito.ArgumentMatchers.eq ( content ) ) ) . thenReturn ( com.googlesource.gerrit.plugins.webhooks.PostTaskTest.OK_RESULT ) ; task.run ( ) ; org.mockito.Mockito.verifyZeroInteractions ( executor ) ; }
private void assertExternalId ( com.google.gerrit.server.account.externalids.ExternalId.Key extIdKey , @ com.google.gerrit.common.Nullable java.lang.String expectedEmail ) throws java.lang.Exception { java.util.Optional < com.google.gerrit.server.account.externalids.ExternalId > extId = externalIds.get ( extIdKey ) ; com.google.common.truth.Truth.assertThat ( extId ) . named ( extIdKey.get ( ) ) . isPresent ( ) ; com.google.common.truth.Truth.assertThat ( extId.get ( ) . email ( ) ) . named ( ( "email of " + ( extIdKey.get ( ) ) ) ) . isEqualTo ( expectedEmail ) ; }
private void setDefaultBlameCache ( ) { if ( ( blameCache ) == null ) { if ( config.getSubsections ( "cache" ) . contains ( "blame" ) ) { blameCache = new com.google.gitiles.BlameCacheImpl ( com.google.gitiles.ConfigUtil.getCacheBuilder ( config , "blame" ) ) ; } else { blameCache = new com.google.gitiles.BlameCacheImpl ( ) ; } } }
public void testUnblockForceEditTopicName ( ) { com.google.gerrit.server.project.Util.block ( local , com.google.gerrit.common.data.Permission.EDIT_TOPIC_NAME , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/heads/*" ) ; com.google.gerrit.server.project.Util.allow ( local , com.google.gerrit.common.data.Permission.EDIT_TOPIC_NAME , com.google.gerrit.server.project.Util.DEVS , "refs/heads/*" ) . setForce ( true ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.project.Util.DEVS ) ; com.google.common.truth.Truth.assertThat ( u.controlForRef ( "refs/heads/master" ) . canForceEditTopicName ( ) ) . named ( "u can edit topic name" ) . isTrue ( ) ; }
private synchronized void runHook ( com.google.gerrit.reviewdb.client.Project.NameKey project , java.io.File hook , java.util.List < java.lang.String > args ) { if ( ( project != null ) && ( hook.exists ( ) ) ) { hookQueue.execute ( new com.google.gerrit.common.ChangeHookRunner.AsyncHookTask ( project , hook , args ) ) ; } }
public org.apache.http.impl.client.HttpClientBuilder extend ( org.apache.http.impl.client.HttpClientBuilder httpClientBuilder , com.urswolfer.gerrit.client.rest.GerritAuthData authData ) { httpClientBuilder.addInterceptorLast ( new org.apache.http.HttpRequestInterceptor ( ) { public void process ( org.apache.http.HttpRequest request , org.apache.http.protocol.HttpContext context ) throws java.io.IOException , org.apache.http.HttpException { org.apache.http.Header existingUserAgent = request.getFirstHeader ( HttpHeaders.USER_AGENT ) ; java.lang.String userAgent = java.lang.String.format ( "%s/%s" , getApplicationName ( ) , getVersion ( ) ) ; userAgent += " using " + ( existingUserAgent.getValue ( ) ) ; request.setHeader ( HttpHeaders.USER_AGENT , userAgent ) ; } } ) ; return super . extend ( httpClientBuilder , authData ) ; }
public < F1 , V > com.google.gerrit.metrics.CallbackMetric1 < F1 , V > newCallbackMetric ( java.lang.String name , java.lang.Class < V > valueClass , com.google.gerrit.metrics.Description desc , com.google.gerrit.metrics.Field < F1 > field1 ) { com.google.gerrit.metrics.dropwizard.DropWizardMetricMaker.checkMetricName ( name ) ; com.google.gerrit.metrics.dropwizard.CallbackMetricImpl1 < F1 , V > m = new com.google.gerrit.metrics.dropwizard.CallbackMetricImpl1 ( this , registry , name , valueClass , desc , field1 ) ; define ( name , desc ) ; bucketed.put ( name , m ) ; return m.create ( ) ; }
public void setUp ( ) throws java.lang.Exception { super . setUp ( ) ; final java.util.Properties p = new java.util.Properties ( ) ; p.setProperty ( "driver" , org.h2.Driver.class . getName ( ) ) ; p.setProperty ( "url" , ( "jdbc:h2:mem:PhoneBookDb" + ( ( com.google.gwtorm.server.PhoneBookDbTestCase.runCount ) ++ ) ) ) ; db = new com.google.gwtorm.jdbc.Database < com.google.gwtorm.data.PhoneBookDb > ( new com.google.gwtorm.jdbc.SimpleDataSource ( p ) , com.google.gwtorm.data.PhoneBookDb.class ) ; openSchemas = new java.util.ArrayList < com.google.gwtorm.data.PhoneBookDb > ( ) ; }
public void indexChange ( ) throws java.lang.Exception { java.lang.String changeId = createChange ( ) . getChangeId ( ) ; com.google.gerrit.acceptance.RestResponse r = adminSession.post ( ( ( "/changes/" + changeId ) + "/index/" ) ) ; com.google.common.truth.Truth.assertThat ( r.getStatusCode ( ) ) . isEqualTo ( HttpStatus.SC_NO_CONTENT ) ; }
private void addLabelDelta ( java.lang.String name , short value ) { labelDelta.add ( new com.google.gerrit.server.util.LabelVote ( name , value ) . format ( ) ) ; }
public static com.google.gerrit.client.diff.CommentRange create ( net.codemirror.lib.TextMarker.FromTo fromTo ) { if ( fromTo == null ) { return null ; } net.codemirror.lib.LineCharacter from = fromTo.getFrom ( ) ; net.codemirror.lib.LineCharacter to = fromTo.getTo ( ) ; return com.google.gerrit.client.diff.CommentRange.create ( ( ( from.getLine ( ) ) + 1 ) , from.getCh ( ) , ( ( to.getLine ( ) ) + 1 ) , to.getCh ( ) ) ; }
private static boolean isUnreasonableName ( java.lang.String name ) { if ( ( name.length ( ) ) < 1 ) return true ; if ( name.contains ( "\\" ) ) return true ; if ( name.startsWith ( "../" ) ) return true ; if ( name.contains ( "/../" ) ) return true ; if ( name.contains ( "/./" ) ) return true ; if ( name.contains ( "//" ) ) return true ; return false ; }
public void onLoad ( ) { super . onLoad ( ) ; table.setSavePointerId ( com.google.gwt.user.client.History.getToken ( ) ) ; Util.LIST_SVC.myStarredChanges ( new com.google.gerrit.client.rpc.GerritCallback < java.util.List < com.google.gerrit.client.data.ChangeInfo > > ( ) { public void onSuccess ( final java.util.List < com.google.gerrit.client.data.ChangeInfo > result ) { starred.display ( result ) ; table.finishDisplay ( ) ; } } ) ; }
private static java.util.List < com.google.gwtexpui.safehtml.client.RegexFindReplace > repls ( com.google.gwtexpui.safehtml.client.RegexFindReplace ... repls ) { return java.util.Arrays.asList ( repls ) ; }
public boolean indexChange ( int changeId ) { try { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpResponseHandler.HttpResult result = httpSession.post ( buildIndexEndpoint ( changeId ) ) ; if ( result.isSuccessful ( ) ) { return true ; } com.ericsson.gerrit.plugins.highavailability.forwarder.rest.RestForwarder.log.error ( "Unable to index change {}. Cause: {}" , changeId , result.getMessage ( ) ) ; } catch ( java.io.IOException e ) { com.ericsson.gerrit.plugins.highavailability.forwarder.rest.RestForwarder.log.error ( ( "Error trying to index change " + changeId ) , e ) ; } return false ; }
public java.util.Set < java.lang.String > getMyOrganisationsLogins ( ) throws java.io.IOException { if ( isLoggedIn ( ) ) { return getHub ( ) . getMyOrganizations ( ) . keySet ( ) ; } return java.util.Collections.emptySet ( ) ; }
protected boolean isVisibleTo ( com.google.gerrit.reviewdb.client.Branch.NameKey branchName , com.google.gerrit.server.CurrentUser user ) throws com.google.gerrit.server.permissions.PermissionBackendException { com.google.gerrit.server.project.ProjectState pe = projectCache.get ( branchName.getParentKey ( ) ) ; if ( pe == null ) { return false ; } return permissionBackend.user ( user ) . ref ( branchName ) . test ( RefPermission.READ ) ; }
public void testUpdateOneException ( ) throws java.sql.SQLException { sqlException = new java.sql.BatchUpdateException ( ) ; java.sql.PreparedStatement update = stubStatementThrowExceptionOnExecute ( com.google.gwtorm.jdbc.AbstractTestJdbcAccess.UPDATE , sqlException ) ; try { classUnderTest.update ( oneRow ) ; org.junit.Assert.fail ( "missingException" ) ; } catch ( com.google.gwtorm.server.OrmException e ) { org.junit.Assert.assertSame ( e.getCause ( ) , sqlException ) ; } assertCorrectUpdating ( update , 1 ) ; }
public boolean visit ( java.lang.String name , com.google.gerrit.extensions.common.ActionInfo actionInfo , com.google.gerrit.extensions.common.ChangeInfo changeInfo ) { return true ; }
public void testUnblockForceWithAllowNoForce_NotPossible ( ) { com.google.gerrit.common.data.PermissionRule r = com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.Util.ANONYMOUS , "refs/heads/*" ) ; r.setBlock ( ) ; r.setForce ( true ) ; com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.Util.DEVS , "refs/heads/*" ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.project.Util.DEVS ) ; org.junit.Assert.assertFalse ( "u can't force push" , u.controlForRef ( "refs/heads/master" ) . canForceUpdate ( ) ) ; }
public com.google.gerrit.reviewdb.client.AccountSshKey addKey ( java.lang.String pub ) { com.google.common.base.Preconditions.checkState ( ( ( keys ) != null ) , "SSH keys not loaded yet" ) ; int seq = ( keys.isEmpty ( ) ) ? 1 : ( keys.size ( ) ) + 1 ; com.google.gerrit.reviewdb.client.AccountSshKey.Id keyId = new com.google.gerrit.reviewdb.client.AccountSshKey.Id ( accountId , seq ) ; com.google.gerrit.reviewdb.client.AccountSshKey key = new com.google.gerrit.server.account.VersionedAuthorizedKeys.SimpleSshKeyCreator ( ) . create ( keyId , pub ) ; keys.add ( java.util.Optional.of ( key ) ) ; return key ; }
public void suggestReviewersChange ( ) throws java.lang.Exception { java.lang.String changeId = createChange ( ) . getChangeId ( ) ; java.util.List < com.google.gerrit.extensions.common.SuggestedReviewerInfo > reviewers = suggestReviewers ( changeId , "u" , 6 ) ; com.google.common.truth.Truth.assertThat ( reviewers ) . hasSize ( 6 ) ; reviewers = suggestReviewers ( changeId , "u" , 5 ) ; com.google.common.truth.Truth.assertThat ( reviewers ) . hasSize ( 5 ) ; reviewers = suggestReviewers ( changeId , "users3" , 10 ) ; com.google.common.truth.Truth.assertThat ( reviewers ) . hasSize ( 1 ) ; }
com.google.gerrit.server.account.externalids.ExternalId get ( com.google.gerrit.server.account.externalids.ExternalId.Key key , org.eclipse.jgit.lib.ObjectId rev ) throws java.io.IOException , org.eclipse.jgit.errors.ConfigInvalidException { checkReadEnabled ( ) ; try ( org.eclipse.jgit.lib.Repository repo = repoManager.openRepository ( allUsersName ) ) { return com.google.gerrit.server.account.externalids.ExternalIdNotes.loadReadOnly ( repo , rev ) . get ( key ) . orElse ( null ) ; } }
private synchronized void define ( java.lang.String name , com.google.gerrit.metrics.Description desc ) { if ( descriptions.containsKey ( name ) ) { com.google.common.collect.ImmutableMap < java.lang.String , java.lang.String > annotations = descriptions.get ( name ) ; if ( ! ( desc.getAnnotations ( ) . get ( Description.DESCRIPTION ) . equals ( annotations.get ( Description.DESCRIPTION ) ) ) ) { throw new java.lang.IllegalStateException ( java.lang.String.format ( "metric %s already defined" , name ) ) ; } } else { descriptions.put ( name , desc.getAnnotations ( ) ) ; } }
public com.google.gerrit.client.ui.InlineHyperlink getNextPatchLink ( int index , com.google.gerrit.client.patches.PatchScreen.Type patchType ) { for ( index ++ ; index < ( patchList.size ( ) ) ; index ++ ) { com.google.gerrit.client.ui.InlineHyperlink link = createLink ( index , patchType , null , com.google.gwtexpui.safehtml.client.SafeHtml.asis ( Util.C.nextPatchLinkIcon ( ) ) ) ; if ( link != null ) { return link ; } } return null ; }
public void testNonIndexPredicate ( ) throws java.lang.Exception { com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > in = parse ( "foo:a" ) ; com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > out = rewrite ( in ) ; com.google.common.truth.Truth.assertThat ( com.google.gerrit.server.query.change.AndSource.class ) . isSameAs ( out.getClass ( ) ) ; com.google.common.truth.Truth.assertThat ( out.getChildren ( ) ) . containsExactly ( query ( com.google.gerrit.server.query.change.ChangeStatusPredicate.open ( ) ) , in ) . inOrder ( ) ; }
private void display ( final com.google.gerrit.client.reviewdb.AccountGeneralPreferences p ) { showSiteHeader.setValue ( p.isShowSiteHeader ( ) ) ; useFlashClipboard.setValue ( p.isUseFlashClipboard ( ) ) ; setListBox ( maximumPageSize , com.google.gerrit.client.reviewdb.AccountGeneralPreferences.DEFAULT_PAGESIZE , p.getMaximumPageSize ( ) ) ; setListBox ( defaultContext , com.google.gerrit.client.reviewdb.AccountGeneralPreferences.DEFAULT_CONTEXT , p.getDefaultContext ( ) ) ; }
private static com.googlecode.prolog_cafe.lang.BufferingPrologControl newEmptyMachine ( java.lang.ClassLoader cl ) { com.googlecode.prolog_cafe.lang.BufferingPrologControl ctl = new com.googlecode.prolog_cafe.lang.BufferingPrologControl ( ) ; ctl.setMaxArity ( PrologEnvironment.MAX_ARITY ) ; ctl.setMaxDatabaseSize ( com.google.gerrit.rules.RulesCache.DB_MAX ) ; ctl.setPrologClassLoader ( new com.googlecode.prolog_cafe.lang.PrologClassLoader ( cl ) ) ; ctl.setEnabled ( java.util.EnumSet.allOf ( Prolog.Feature.class ) , false ) ; ctl.initialize ( com.google.gerrit.rules.RulesCache.PACKAGE_LIST ) ; return ctl ; }
public void usernamePatternNonRegex ( ) { com.google.gerrit.server.project.testing.Util.allow ( local , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.project.testing.Util.DEVS , "refs/sb/${username}/heads/*" ) ; com.google.gerrit.server.project.ProjectControl u = user ( local , "u" , com.google.gerrit.server.project.testing.Util.DEVS ) ; com.google.gerrit.server.project.ProjectControl d = user ( local , "d" , com.google.gerrit.server.project.testing.Util.DEVS ) ; assertCannotRead ( "refs/sb/d/heads/foobar" , u ) ; assertCanRead ( "refs/sb/d/heads/foobar" , d ) ; }
public com.google.gerrit.server.patch.PatchList get ( final com.google.gerrit.server.patch.PatchListKey key ) { if ( com.google.gerrit.server.patch.PatchListCacheImpl.dynamic ) { try { return compute ( key ) ; } catch ( java.lang.Exception e ) { throw new java.lang.RuntimeException ( ( "Cannot lookup " + key ) , e ) ; } } return self.get ( key ) ; }
protected void migrateData ( final com.google.gerrit.reviewdb.server.ReviewDb db , final com.google.gerrit.server.schema.UpdateUI ui ) throws java.sql.SQLException { try ( java.sql.Statement stmt = newStatement ( db ) ) { stmt.executeUpdate ( "UPDATE account_diff_preferences SET show_line_endings='Y'" ) ; } }
private com.google.common.collect.SetMultimap < org.eclipse.jgit.lib.ObjectId , org.eclipse.jgit.lib.Ref > changeRefsById ( ) throws java.io.IOException { if ( ( refsById ) == null ) { refsById = com.google.common.collect.HashMultimap.create ( ) ; for ( org.eclipse.jgit.lib.Ref r : repo.getRefDatabase ( ) . getRefs ( com.google.gerrit.reviewdb.client.RefNames.REFS_CHANGES ) . values ( ) ) { if ( com.google.gerrit.reviewdb.client.PatchSet.isRef ( r.getName ( ) ) ) { refsById.put ( r.getObjectId ( ) , r ) ; } } } return refsById ; }
public T apply ( com.google.gerrit.server.events.RefEvent e ) { return ( ( T ) ( e ) ) ; }
public void doAction ( ) throws java.lang.Exception { gApi.groups ( ) . id ( someGroupId ) . addGroups ( someOtherGroupId ) ; }
public void missingRepo ( ) throws java.lang.Exception { assumeNoteDbDisabled ( ) ; com.google.gerrit.server.project.ChangeControl ctl = insertChange ( ) ; com.google.gerrit.reviewdb.client.Project.NameKey name = ctl.getProject ( ) . getNameKey ( ) ; ( ( com.google.gerrit.testutil.InMemoryRepositoryManager ) ( repoManager ) ) . deleteRepository ( name ) ; assertProblems ( ctl , null , com.google.gerrit.acceptance.server.change.ConsistencyCheckerIT.problem ( ( "Destination repository not found: " + name ) ) ) ; }
public void testUnblockInLocalVisibilityByRegisteredUsers_Fails ( ) { com.google.gerrit.server.project.Util.block ( parent , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/heads/*" ) ; com.google.gerrit.server.project.Util.allow ( local , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS , "refs/heads/*" ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS ) ; com.google.common.truth.Truth.assertThat ( u.controlForRef ( "refs/heads/master" ) . isVisibleByRegisteredUsers ( ) ) . named ( "u can't read" ) . isFalse ( ) ; }
public void onSuccess ( com.google.gerrit.common.data.PatchSetDetail result ) { patchSetDetail = result ; if ( ( fileList ) == null ) { fileList = new com.google.gerrit.client.changes.PatchTable ( prefs ) ; fileList.setAccountInfoCache ( lastScript.getCommentDetail ( ) . getAccounts ( ) ) ; fileList.display ( idSideA , result ) ; patchIndex = fileList.indexOf ( patchKey ) ; } refresh ( true ) ; }
private com.google.gerrit.client.reviewdb.AccountGroup lookup ( final com.google.gerrit.client.reviewdb.AccountGroup.NameKey groupName ) throws com.google.gwtorm.client.OrmException { final com.google.gerrit.client.reviewdb.ReviewDb db = schema.open ( ) ; try { return db.accountGroups ( ) . get ( groupName ) ; } finally { db.close ( ) ; } }
private static java.lang.String KD ( java.lang.String secret , java.lang.String data ) { java.security.MessageDigest md = com.google.gerrit.httpd.ProjectDigestFilter.newMD5 ( ) ; md.update ( secret.getBytes ( java.nio.charset.StandardCharsets.UTF_8 ) ) ; md.update ( ( ( byte ) ( ':' ) ) ) ; md.update ( data.getBytes ( java.nio.charset.StandardCharsets.UTF_8 ) ) ; return com.google.gerrit.httpd.ProjectDigestFilter.LHEX ( md.digest ( ) ) ; }
protected void setUp ( ) throws java.lang.Exception { repo = new org.eclipse.jgit.junit.TestRepository < org.eclipse.jgit.internal.storage.dfs.DfsRepository > ( new org.eclipse.jgit.internal.storage.dfs.InMemoryRepository ( new org.eclipse.jgit.internal.storage.dfs.DfsRepositoryDescription ( "test" ) ) ) ; servlet = new com.google.gitiles.RepositoryIndexServlet ( new com.google.gitiles.DefaultRenderer ( ) , new com.google.gitiles.TestGitilesAccess ( repo.getRepository ( ) ) , new com.google.gitiles.TimeCache ( ) ) ; }
void addReplyBox ( boolean quote ) { com.google.gerrit.client.changes.CommentInfo commentReply = com.google.gerrit.client.changes.CommentInfo.createReply ( comment ) ; if ( quote ) { commentReply.message ( com.google.gerrit.client.change.ReplyBox.quote ( comment.message ( ) ) ) ; } getCommentManager ( ) . addDraftBox ( getCm ( ) . side ( ) , commentReply ) . setEdit ( true ) ; }
public com.google.gerrit.extensions.restapi.Response < ? > apply ( com.google.gerrit.server.change.ChangeResource rsrc , java.lang.String filePath ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.extensions.restapi.ResourceConflictException , com.google.gerrit.server.permissions.PermissionBackendException , com.google.gwtorm.server.OrmException , java.io.IOException { try ( org.eclipse.jgit.lib.Repository repository = repositoryManager.openRepository ( rsrc.getProject ( ) ) ) { editModifier.deleteFile ( repository , rsrc.getNotes ( ) , filePath ) ; } catch ( com.google.gerrit.server.project.InvalidChangeOperationException e ) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException ( e.getMessage ( ) ) ; } return com.google.gerrit.extensions.restapi.Response.none ( ) ; }
protected com.google.gwtorm.data.PhoneBookDb openAndCreate ( ) throws com.google.gwtorm.client.OrmException { final com.google.gwtorm.data.PhoneBookDb schema = open ( ) ; final com.google.gwtorm.jdbc.JdbcExecutor e = new com.google.gwtorm.jdbc.JdbcExecutor ( ( ( com.google.gwtorm.jdbc.JdbcSchema ) ( schema ) ) ) ; try { schema.updateSchema ( e ) ; } finally { e.close ( ) ; } return schema ; }
public boolean isVisible ( ) { return ( ( ( ( user.isInternalUser ( ) ) || ( groupBackend.isVisibleToAll ( group.getGroupUUID ( ) ) ) ) || ( user.getEffectiveGroups ( ) . contains ( group.getGroupUUID ( ) ) ) ) || ( user.getCapabilities ( ) . canAdministrateServer ( ) ) ) || ( isOwner ( ) ) ; }
private void insertNoneRow ( final int row ) { insertRow ( row ) ; table.setText ( row , 0 , Util.C.changeTableNone ( ) ) ; final com.google.gwt.user.client.ui.FlexTable.FlexCellFormatter fmt = table.getFlexCellFormatter ( ) ; fmt.setColSpan ( row , 0 , com.google.gerrit.client.changes.ChangeTable.COLUMNS ) ; fmt.setStyleName ( row , 0 , com.google.gerrit.client.changes.ChangeTable.S_EMPTY_SECTION ) ; }
private static void addFooter ( java.lang.StringBuilder sb , org.eclipse.jgit.revwalk.FooterKey footer , java.lang.Object ... values ) { com.google.gerrit.server.notedb.ChangeUpdate.addFooter ( sb , footer ) ; for ( java.lang.Object value : values ) { sb.append ( com.google.gerrit.server.notedb.ChangeNoteUtil.sanitizeFooter ( java.util.Objects.toString ( value ) ) ) ; } sb.append ( '\n' ) ; }
java.lang.String getTokenSuffixForActiveLine ( net.codemirror.lib.CodeMirror cm ) { int cmLinePlusOne = ( cm.getLineNumber ( cm.extras ( ) . activeLine ( ) ) ) + 1 ; com.google.gerrit.client.diff.UnifiedChunkManager.LineRegionInfo info = ( ( com.google.gerrit.client.diff.Unified ) ( host ) ) . getLineRegionInfoFromCmLine ( ( cmLinePlusOne - 1 ) ) ; return ( ( info.getSide ( ) ) == ( DisplaySide.A ) ? "a" : "" ) + cmLinePlusOne ; }
private void fireEvent ( com.google.gerrit.reviewdb.client.Change change , com.google.gerrit.common.Event event , com.google.gerrit.reviewdb.server.ReviewDb db ) throws com.google.gwtorm.server.OrmException { for ( com.google.gerrit.common.ChangeHookRunner.EventListenerHolder holder : listeners.values ( ) ) { if ( isVisibleTo ( change , holder.user , db ) ) { holder.listener.onEvent ( event ) ; } } fireEventForUnrestrictedListeners ( event ) ; }
protected org.eclipse.jgit.revwalk.RevCommit getRemoteHead ( ) throws java.lang.Exception { return getRemoteHead ( project , "master" ) ; }
public void testUpsertTwoSecondExisting ( ) throws com.google.gwtorm.server.OrmException , java.sql.SQLException { java.sql.PreparedStatement update = stubStatementWithUpdateCounts ( com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE , 0 , 1 ) ; java.sql.PreparedStatement insert = stubStatementWithUpdateCounts ( com.google.gwtorm.jdbc.TestJdbcAccess.INSERT , 1 ) ; createClassUnderTest ( ) . upsert ( twoRows ) ; com.google.gwtorm.jdbc.TestJdbcAccess.assertUsedBatchingOnly ( update ) ; com.google.gwtorm.jdbc.TestJdbcAccess.assertUsedBatchingOnly ( insert ) ; com.google.gwtorm.jdbc.TestJdbcAccess.assertExpectedIdsUsed ( insert , 1 ) ; }
public void basicGroupProperties ( ) throws java.lang.Exception { com.google.gerrit.extensions.common.GroupInfo createdGroup = gApi.groups ( ) . create ( name ( "group" ) ) . get ( ) ; com.google.gerrit.server.group.InternalGroup reviewDbGroup = groups.getGroup ( db , new com.google.gerrit.reviewdb.client.AccountGroup.UUID ( createdGroup.id ) ) . get ( ) ; deleteGroupRefs ( reviewDbGroup ) ; com.google.common.truth.Truth.assertThat ( com.google.gerrit.acceptance.api.group.GroupRebuilderIT.removeRefState ( rebuild ( reviewDbGroup ) ) ) . isEqualTo ( roundToSecond ( reviewDbGroup ) ) ; }
private boolean matchGroup ( com.google.gerrit.reviewdb.AccountGroup.UUID uuid ) { java.util.Set < com.google.gerrit.reviewdb.AccountGroup.UUID > userGroups = getCurrentUser ( ) . getEffectiveGroups ( ) ; if ( AccountGroup.PROJECT_OWNERS.equals ( uuid ) ) { com.google.gerrit.server.project.ProjectState state = projectControl.getProjectState ( ) ; return com.google.gerrit.common.CollectionsUtil.isAnyIncludedIn ( state.getAllOwners ( ) , userGroups ) ; } else { return userGroups.contains ( uuid ) ; } }
public static com.google.gerrit.gpg.testing.TestKey keyRevokedByExpiredKeyAfterExpiration ( ) throws java.lang.Exception { return new com.google.gerrit.gpg.testing.TestKey ( ( "-----BEGIN PGP PUBLIC KEY BLOCK-----\n" + ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( "Version: GnuPG v1\n" + "\n" ) + "mQENBELuRwABCAC56yhFKybBtuKT4nyb7RdLE98pZR54aGjcDcKH3VKVyBF8Z4Kx\n" ) + "ptd7Sre0mLPCQiNWVOmCT+JG7GKVE6YeFmyXDUnhX9w4+HAeDEh23S4u9JvwWaF+\n" ) + "wlJ6jLq/oe5gdT1F6Y2yqNpQ6CztOw52Ko9KSYz7/1zBMPcCkl/4k15ee4iebVdq\n" ) + "c7qT5Qt49Poiozh0DI5prPQ624uckHkz2mXshjWQVuHWwrkIkCJZ2I/KQN2kBjKw\n" ) + "/ALxumaWmiB9lQ0nIwLuGzHCh0Xg5RxuCrK8fJp47Aza3ikVuYlNzSxhJVav3OtK\n" ) + "gftBihQXUlY3Uy/4QTCeH/BdVs5OALtXL3VhABEBAAGJAS0EIAECABcFAlYmr4kQ\n" ) + "HQN0ZXN0OCBub3QgdXNlZAAKCRA87HgbF94azQJ5B/0TeQk7TSChNp+NqCKPTuw0\n" ) + "wpflDyc+5ru/Gcs4r358cWzgiLUb3M0Q1+M8CF13BFQdrxT05vjheI9o5PCn3b//\n" ) + "AHV8m+QFSnRi2J3QslbvuOqOnipz7vc7lyZ7q1sWNC33YN+ZcGZiMuu5HJi9iadf\n" ) + "ZL7AdInpUb4Zb+XKphbMokDcN3yw7rqSMMcx+rKytUAqUnt9qvaSLrIH/zeazxlp\n" ) + "YG4jaN53WPfLCcGG+Rw56mW+eCQD2rmzaNHCw8Qr+19sokXLB7OML+rd1wNwZT4q\n" ) + "stWnL+nOj8ZkbFV0w3zClDYaARr7H+vTckwVStyDVRbnpRitSAtJwbRDzZBaS4Vx\n" ) + "iQE3BB8BAgAhBQJC7lUQFwyAAR2e63ndOLBJk52crzzseBsX3hrNAgcAAAoJEAAa\n" ) + "34t4v31+AS4H/0x3Y9E3q9DR5FCuYTXG4BHyrALo2WKoP0CfUWL98Fw9Txl0hF+9\n" ) + "5wriNlnmd2zvM0quHs78x4/xehQO88cw0lqPx3RARq/ju5/VbOjoNlcHvfGYZiEd\n" ) + "yWOwHu7O8sZrenFDjeDglD6NArrjncOcC51XIPSSTLvVQpSauQ1FS4tan5Q4aWMb\n" ) + "s4DzE+Vqu2xMkO/X9toYAZKzyWP29OckpouMbt3GUnS6/o0A8Z7jVX+XOIk3XolP\n" ) + "Li9tzTQB12Xl23mgFvearDoguR2Bu2SbmTJtdiXz8L3S54kGvxVqak5uOP2dagzU\n" ) + "vBiqR4SVoAdGoXt6TI6mpA+qdYmPMG8v21S0IlRlc3R1c2VyIEVpZ2h0IDx0ZXN0\n" ) + "OEBleGFtcGxlLmNvbT6JATgEEwECACIFAkLuRwACGwMGCwkIBwMCBhUIAgkKCwQW\n" ) + "AgMBAh4BAheAAAoJEAAa34t4v31+8/sIAIuqd+dU8k9c5VQ12k7IfZGGYQHF2Mk/\n" ) + "8FNuP7hFP/VOXBK3QIxIfGEOHbDX6uIxudYMaDmn2UJbdIqJd8NuQByh1gqXdX/x\n" ) + "nteUa+4e7U6uTjkp/Ij5UzRed8suINA3NzVOy6qwCu3DTOXIZcjiOZtOA5GTqG6Z\n" ) + "naDP0hwDssJp+LXIYTJgsvneJQFGSdQhhJSv19oV0JPSbb6Zc7gEIHtPcaJHjuZQ\n" ) + "Ev+TRcRrI9HPTF0MvgOYgIDo2sbcSFV+8moKsHMC+j1Hmuuqgm/1yKGIZrt0V75s\n" ) + "D9HYu0tiS3+Wlsry3y1hg/2XBQbwgh6sT/jWkpWar7+uzNxO5GdFYrC5AQ0EQu5H\n" ) + "AAEIALPFTedbfyK+9B35Uo9cPsmFa3mT3qp/bAQtnOjiTTTiIO3tu0ALnaBjf6On\n" ) + "fAV1HmGz6hRMRK4LGyHkNTaGDNNPoXO7+t9DWycSHmsCL5d5zp7VevQE8MPR8zHK\n" ) + "Il2YQlCzdy5TWSUhunKd4guDNZ9GiOS6NQ9feYZ9DQ1kzC8nnu7jLkR2zNT02sYU\n" ) + "kuOCZUktQhVNszUlavdIFjvToZo3RPcdb/E3kTTy2R9xi89AXjWZf3lSAZe3igkL\n" ) + "jhwsd+u3RRx0ptOJym7zYl5ZdUZk4QrS7FPI6zEBpjawbS4/r6uEW89P3QAkanDI\n" ) + "ridIAZP8awLZU3uSPtMwPIJpao0AEQEAAYkBHwQYAQIACQUCQu5HAAIbDAAKCRAA\n" ) + "Gt+LeL99fqpHB/wOXhdMNtgeVW38bLk8YhcEB23FW6fDjFjBJb9m/yqRTh5CIeG2\n" ) + "bm29ofT4PTamPb8Gt+YuDLnQQ3K2jURakxNDcYwiurvR/oHVdxsBRU7Px7UPeZk3\n" ) + "BG5VnIJRT198dF7MWFJ+x5wHbNXwM8DDvUwTjXLH/TlGl1XIheSTHCYd9Pra4ejE\n" ) + "ockkrDaZlPCQdTwY+P7K2ieb5tsqNpJkQeBrglF2bemY/CtQHnM9qwa6ZJqkyYNR\n" ) + "F1nkSYn36BPuNpytYw1CaQV9GbePugPHtshECLwA160QzqISQUcJlKXttUqUGnoO\n" ) + "0d0PyzZT3676mQwmFoebMR9vACAeHjvDxD4F\n" ) + "=ihWb\n" ) + "-----END PGP PUBLIC KEY BLOCK-----\n" ) ) , ( "-----BEGIN PGP PRIVATE KEY BLOCK-----\n" + ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( ( "Version: GnuPG v1\n" + "\n" ) + "lQOYBELuRwABCAC56yhFKybBtuKT4nyb7RdLE98pZR54aGjcDcKH3VKVyBF8Z4Kx\n" ) + "ptd7Sre0mLPCQiNWVOmCT+JG7GKVE6YeFmyXDUnhX9w4+HAeDEh23S4u9JvwWaF+\n" ) + "wlJ6jLq/oe5gdT1F6Y2yqNpQ6CztOw52Ko9KSYz7/1zBMPcCkl/4k15ee4iebVdq\n" ) + "c7qT5Qt49Poiozh0DI5prPQ624uckHkz2mXshjWQVuHWwrkIkCJZ2I/KQN2kBjKw\n" ) + "/ALxumaWmiB9lQ0nIwLuGzHCh0Xg5RxuCrK8fJp47Aza3ikVuYlNzSxhJVav3OtK\n" ) + "gftBihQXUlY3Uy/4QTCeH/BdVs5OALtXL3VhABEBAAEAB/wLr88oGuxsoqIHRQZL\n" ) + "eGm9jc4aQGmcDMcjpwdGilhrwyfrO6f84hWbQdD+rJcnI8hsH7oOd5ZMGkWfpJyt\n" ) + "eUAh9iNB5ChYGfDVSLUg6KojqDtprj6vNMihvLkr/OI6xL/hZksikwfnLFMPpgXU\n" ) + "knwPocQ3nn+egsUSL7CR8/SLiIm4MC0brer6jhDxB5LKweExNlfTe4c0MDeYTsWt\n" ) + "0WGzNPlvRZQXRotJzqemt3wdNZXUnCKR0n7pSQ8EhZr2O6NXr+mUgp6PIOE/3un2\n" ) + "YGiBEf5uy3qEFe7FjEGIHz+Z3ySRdUDfHOk82TKAzynoJIxRUvLIYVNw4eFB3l5U\n" ) + "s1w5BADUzfciG7RVLa8UFKJfqQ/5M06QmdS1v1/hMQXg38+3vKe8RgfSSnMJ08Sc\n" ) + "eAEsmugwpNXAxgRKHcmWzN3NMBHhE3KiyiogWaMGqmSo6swFpu0+dwMvZSxMlfD+\n" ) + "ka/BWt8YsUdrqW06ow39aTgCV+icbNRV81C7NKe7u0X1JDx2CQQA36gbdo62h/Wd\n" ) + "gJI8kdz/se3xrt8x6RoWvOnWPNmsZR5XkDqAMTL1dWiEEA/dQTphMcgAe9z3WaP+\n" ) + "F1TPAfounbiurGCcS3kxJ5tY7ojyU7nYz4DA/V2OU0C/LUoLXhttG5HM+m/i3qn4\n" ) + "K9bBoWIQY1ijliS7cTSwNqd6IHaQGpkEAMnp5GwSGhY+kUuLw06hmH4xnsuf6agz\n" ) + "AfhbPylB2nf/ZaX6dt6/mFEAkvQNahcoWEskfS3LGCD8jHm8PvF8K0mciXPDweq2\n" ) + "gW3/irE0RXNwn3Oa222VSvcgUlocBm9InkfvpFXh20OYFe3dFH7uYkwUqIHJeXjw\n" ) + "TjpXUX/vC5QJQOyJATcEHwECACEFAkLuVRAXDIABHZ7red04sEmTnZyvPOx4Gxfe\n" ) + "Gs0CBwAACgkQABrfi3i/fX4BLgf/THdj0Ter0NHkUK5hNcbgEfKsAujZYqg/QJ9R\n" ) + "Yv3wXD1PGXSEX73nCuI2WeZ3bO8zSq4ezvzHj/F6FA7zxzDSWo/HdEBGr+O7n9Vs\n" ) + "6Og2Vwe98ZhmIR3JY7Ae7s7yxmt6cUON4OCUPo0CuuOdw5wLnVcg9JJMu9VClJq5\n" ) + "DUVLi1qflDhpYxuzgPMT5Wq7bEyQ79f22hgBkrPJY/b05ySmi4xu3cZSdLr+jQDx\n" ) + "nuNVf5c4iTdeiU8uL23NNAHXZeXbeaAW95qsOiC5HYG7ZJuZMm12JfPwvdLniQa/\n" ) + "FWpqTm44/Z1qDNS8GKpHhJWgB0ahe3pMjqakD6p1iY8wby/bVLQiVGVzdHVzZXIg\n" ) + "RWlnaHQgPHRlc3Q4QGV4YW1wbGUuY29tPokBOAQTAQIAIgUCQu5HAAIbAwYLCQgH\n" ) + "AwIGFQgCCQoLBBYCAwECHgECF4AACgkQABrfi3i/fX7z+wgAi6p351TyT1zlVDXa\n" ) + "Tsh9kYZhAcXYyT/wU24/uEU/9U5cErdAjEh8YQ4dsNfq4jG51gxoOafZQlt0iol3\n" ) + "w25AHKHWCpd1f/Ge15Rr7h7tTq5OOSn8iPlTNF53yy4g0Dc3NU7LqrAK7cNM5chl\n" ) + "yOI5m04DkZOobpmdoM/SHAOywmn4tchhMmCy+d4lAUZJ1CGElK/X2hXQk9Jtvplz\n" ) + "uAQge09xokeO5lAS/5NFxGsj0c9MXQy+A5iAgOjaxtxIVX7yagqwcwL6PUea66qC\n" ) + "b/XIoYhmu3RXvmwP0di7S2JLf5aWyvLfLWGD/ZcFBvCCHqxP+NaSlZqvv67M3E7k\n" ) + "Z0VisJ0DmARC7kcAAQgAs8VN51t/Ir70HflSj1w+yYVreZPeqn9sBC2c6OJNNOIg\n" ) + "7e27QAudoGN/o6d8BXUeYbPqFExErgsbIeQ1NoYM00+hc7v630NbJxIeawIvl3nO\n" ) + "ntV69ATww9HzMcoiXZhCULN3LlNZJSG6cp3iC4M1n0aI5Lo1D195hn0NDWTMLyee\n" ) + "7uMuRHbM1PTaxhSS44JlSS1CFU2zNSVq90gWO9OhmjdE9x1v8TeRNPLZH3GLz0Be\n" ) + "NZl/eVIBl7eKCQuOHCx367dFHHSm04nKbvNiXll1RmThCtLsU8jrMQGmNrBtLj+v\n" ) + "q4Rbz0/dACRqcMiuJ0gBk/xrAtlTe5I+0zA8gmlqjQARAQABAAf+JNVkZOcGYaQm\n" ) + "eI3BMMaBxuCjaMG3ec+p3iFKaR0VHKTIgneXSkQXA+nfGTUT4DpjAznN2GLYH6D+\n" ) + "6i7MCGPm9NT4C7KUcHJoltTLjrlf7vVyNHEhRCZO/pBh9+2mpO6xh799x+wj88u5\n" ) + "XAqlah50OjJFkjfk70VsrPWqWvgwLejkaQpGbE+pdL+vjy+ol5FHzidzmJvsXDR1\n" ) + "I1as0vBu5g2XPpexyVanmHJglZdZX07OPYQBhxQKuPXT/2/IRnXsXEpitk4IyJT0\n" ) + "U5D/iedEUldhBByep1lBcJnAap0CP7iuu2CYhRp6V2wVvdweNPng5Eo7f7LNyjnX\n" ) + "UMAeaeCjAQQA1A0iKtg3Grxc9+lpFl1znc2/kO3p6ixM13uUvci+yGFNJJninnxo\n" ) + "99KXEzqqVD0zerjiyyegQmzpITE/+hFIOJZInxEH08WQwZstV/KYeRSJkXf0Um48\n" ) + "E+Zrh8fpJVW1w3ZCw9Ee2yE6fEhAA4w66+50pM+vBXanWOrG1HDrkxEEANkHc2Rz\n" ) + "YJsO4v63xo/7/njLSQ31miOglb99ACKBA0Yl/jvj2KqLcomKILqvK3DKP+BHNq86\n" ) + "LUBUglyKjKuj0wkSWT0tCnfgLzysUpowcoyFhJ36KzAz8hjqIn3TQpMF21HvkZdG\n" ) + "Mtkcyhu5UDvbfOuWOBaKIeNQWCWv1rNzMme9A/9zU1+esEhKwGWEqa3/B/Te/xQh\n" ) + "alk180n74sTZid6lXD8o8cEei0CUq7zBSV0P8v6kk8PP9/XyLRl3Rqa95fESUWrL\n" ) + "xD6TBY1JlHBZS+N6rN/7Ilf5EXSELmnbDFsVxkNGp4elKxajvZxC6uEWYBu62AYy\n" ) + "wS0dj8mZR3faCEps90YXiQEfBBgBAgAJBQJC7kcAAhsMAAoJEAAa34t4v31+qkcH\n" ) + "/A5eF0w22B5VbfxsuTxiFwQHbcVbp8OMWMElv2b/KpFOHkIh4bZubb2h9Pg9NqY9\n" ) + "vwa35i4MudBDcraNRFqTE0NxjCK6u9H+gdV3GwFFTs/HtQ95mTcEblWcglFPX3x0\n" ) + "XsxYUn7HnAds1fAzwMO9TBONcsf9OUaXVciF5JMcJh30+trh6MShySSsNpmU8JB1\n" ) + "PBj4/sraJ5vm2yo2kmRB4GuCUXZt6Zj8K1Aecz2rBrpkmqTJg1EXWeRJiffoE+42\n" ) + "nK1jDUJpBX0Zt4+6A8e2yEQIvADXrRDOohJBRwmUpe21SpQaeg7R3Q/LNlPfrvqZ\n" ) + "DCYWh5sxH28AIB4eO8PEPgU=\n" ) + "=cSfw\n" ) + "-----END PGP PRIVATE KEY BLOCK-----\n" ) ) ) ; }
public void handle ( final net.codemirror.lib.CodeMirror instance , final net.codemirror.lib.CodeMirror.LineHandle handle , com.google.gwt.dom.client.Element element ) { if ( lineActiveBoxMap.containsKey ( handle ) ) { lineActiveBoxMap.get ( handle ) . resizePaddingWidget ( ) ; } if ( linePaddingOnOtherSideMap.containsKey ( handle ) ) { defer ( new java.lang.Runnable ( ) { @ java.lang.Override public void run ( ) { resizePaddingOnOtherSide ( side , instance.getLineNumber ( handle ) ) ; } } ) ; } }
public void close ( ) { com.google.common.util.concurrent.MoreExecutors.shutdownAndAwaitTermination ( executor , java.lang.Long.MAX_VALUE , java.util.concurrent.TimeUnit.SECONDS ) ; try { openIndex.close ( ) ; } finally { closedIndex.close ( ) ; } }
public void run ( ) { try { for ( com.google.gerrit.reviewdb.client.Project.NameKey nameKey : projectCache.all ( ) ) { replication.scheduleFullSync ( nameKey , urlMatch , state ) ; } } catch ( java.lang.Exception e ) { com.googlesource.gerrit.plugins.replication.PushAll.wrappedLog.error ( "Cannot enumerate known projects" , e , state ) ; } state.markAllPushTasksScheduled ( ) ; }
public void ignore ( com.google.gerrit.server.change.ChangeResource rsrc ) throws com.google.gwtorm.server.OrmException { star ( rsrc.getUser ( ) . asIdentifiedUser ( ) . getAccountId ( ) , rsrc.getProject ( ) , rsrc.getChange ( ) . getId ( ) , com.google.common.collect.ImmutableSet.of ( com.google.gerrit.server.StarredChangesUtil.IGNORE_LABEL ) , com.google.common.collect.ImmutableSet.of ( ) ) ; }
public void testErrorDuringTransitionToUnhealty ( ) throws java.io.IOException { tempFolder.delete ( ) ; javax.servlet.http.HttpServletResponse responseMock = org.mockito.Mockito.mock ( javax.servlet.http.HttpServletResponse.class ) ; servlet.doDelete ( null , responseMock ) ; org.mockito.Mockito.verify ( responseMock ) . sendError ( javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR ) ; }
public void testBlockPushDraftsUnblockAdmin ( ) { com.google.gerrit.server.project.Util.block ( util.getParentConfig ( ) , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/drafts/*" ) ; com.google.gerrit.server.project.Util.allow ( util.getParentConfig ( ) , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.Util.ADMIN , "refs/drafts/*" ) ; org.junit.Assert.assertTrue ( "push is blocked for anonymous to refs/drafts/master" , util.user ( local ) . controlForRef ( "refs/drafts/refs/heads/master" ) . isBlocked ( com.google.gerrit.common.data.Permission.PUSH ) ) ; org.junit.Assert.assertFalse ( "push is blocked for admin refs/drafts/master" , util.user ( local , "a" , com.google.gerrit.server.project.Util.ADMIN ) . controlForRef ( "refs/drafts/refs/heads/master" ) . isBlocked ( com.google.gerrit.common.data.Permission.PUSH ) ) ; }
protected java.util.List createEntry ( final java.lang.String url ) throws java.lang.Exception { try { final java.util.List < ? > list = manager.discover ( url ) ; return ( list != null ) && ( ! ( list.isEmpty ( ) ) ) ? list : null ; } catch ( org.openid4java.discovery.DiscoveryException e ) { com.google.gerrit.httpd.auth.openid.OpenIdServiceImpl.log.error ( ( "Cannot discover OpenID " + url ) , e ) ; return null ; } }
public void ignore ( boolean ignore ) throws com.google.gerrit.extensions.restapi.RestApiException { try { if ( ignore ) { this . ignore.apply ( change , new com.google.gerrit.extensions.common.Input ( ) ) ; } else { unignore.apply ( change , new com.google.gerrit.extensions.common.Input ( ) ) ; } } catch ( com.google.gwtorm.server.OrmException | com.google.gerrit.server.StarredChangesUtil.IllegalLabelException e ) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException ( "Cannot ignore change" , e ) ; } }
public static int limitThreads ( com.google.inject.Injector dbInjector , int threads ) { return com.google.gerrit.pgm.util.ThreadLimiter.limitThreads ( dbInjector.getInstance ( com.google.inject.Key.get ( org.eclipse.jgit.lib.Config.class , com.google.gerrit.server.config.GerritServerConfig.class ) ) , dbInjector.getInstance ( com.google.gerrit.server.schema.DataSourceType.class ) , dbInjector.getInstance ( com.google.gerrit.server.config.ThreadSettingsConfig.class ) , threads ) ; }
public void close ( ) { com.google.common.util.concurrent.MoreExecutors.shutdownAndAwaitTermination ( executor , java.lang.Long.MAX_VALUE , java.util.concurrent.TimeUnit.SECONDS ) ; try { openIndex.close ( ) ; } finally { closedIndex.close ( ) ; } }
private void initSite ( ) throws java.lang.Exception { com.google.gerrit.acceptance.pgm.ReindexIT.runGerrit ( "init" , "-d" , sitePath.getPath ( ) , "--batch" , "--no-auto-start" , "--skip-plugins" , "--show-stack-trace" ) ; }
public java.util.List < com.google.gerrit.reviewdb.client.Change > submit ( com.google.gerrit.server.change.RevisionResource rsrc , com.google.gerrit.server.IdentifiedUser caller , boolean force ) throws com.google.gerrit.extensions.restapi.ResourceConflictException , com.google.gwtorm.server.OrmException , java.io.IOException { java.lang.String topic = rsrc.getChange ( ) . getTopic ( ) ; if ( ( submitWholeTopic ) && ( ! ( com.google.common.base.Strings.isNullOrEmpty ( topic ) ) ) ) { return submitWholeTopic ( rsrc , caller , force , topic ) ; } else { return java.util.Arrays.asList ( submitThisChange ( rsrc , caller , force ) ) ; } }
private void configureCmdLineParser ( ) { factory ( CmdLineParser.Factory.class ) ; registerOptionHandler ( Account.Id.class , com.google.gerrit.sshd.args4j.AccountIdHandler.class ) ; registerOptionHandler ( AccountGroup.Id.class , com.google.gerrit.sshd.args4j.AccountGroupIdHandler.class ) ; registerOptionHandler ( AccountGroup.UUID.class , com.google.gerrit.sshd.args4j.AccountGroupUUIDHandler.class ) ; registerOptionHandler ( PatchSet.Id.class , com.google.gerrit.sshd.args4j.PatchSetIdHandler.class ) ; registerOptionHandler ( com.google.gerrit.server.project.ProjectControl.class , com.google.gerrit.sshd.args4j.ProjectControlHandler.class ) ; registerOptionHandler ( java.net.SocketAddress.class , com.google.gerrit.sshd.args4j.SocketAddressHandler.class ) ; }
protected PushOneCommit.Result createChange ( org.eclipse.jgit.junit.TestRepository < ? > repo , java.lang.String branch , java.lang.String subject , java.lang.String fileName , java.lang.String content , java.lang.String topic ) throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create ( db , admin.getIdent ( ) , repo , subject , fileName , content ) ; return push.to ( ( ( ( "refs/for/" + branch ) + "/" ) + ( name ( topic ) ) ) ) ; }
public com.google.gerrit.prettify.common.SparseHtmlFile getSparseHtmlFileA ( ) { com.google.gerrit.prettify.common.PrettySettings s = new com.google.gerrit.prettify.common.PrettySettings ( settings.getPrettySettings ( ) ) ; s.setFileName ( a.getPath ( ) ) ; s.setShowWhiteSpaceErrors ( false ) ; com.google.gerrit.prettify.common.PrettyFormatter f = ClientSideFormatter.FACTORY.get ( ) ; f.setPrettySettings ( s ) ; f.setEditFilter ( PrettyFormatter.A ) ; f.setEditList ( getEditList ( ) ) ; f.format ( a ) ; return f ; }
public void create_Empty ( ) throws java.io.IOException { final java.nio.file.Path root = com.google.gerrit.server.config.SitePathsTest.random ( ) ; try { java.nio.file.Files.createDirectory ( root ) ; final com.google.gerrit.server.config.SitePaths site = new com.google.gerrit.server.config.SitePaths ( root ) ; com.google.common.truth.Truth.assertThat ( site.isNew ) . isTrue ( ) ; com.google.gerrit.extensions.common.testing.PathSubject.assertThat ( site.site_path ) . isEqualTo ( root ) ; } finally { java.nio.file.Files.delete ( root ) ; } }
protected void configure ( ) { bind ( com.google.gerrit.server.config.SitePaths.class ) ; bind ( com.google.gerrit.server.config.TrackingFooters.class ) . toProvider ( com.google.gerrit.server.config.TrackingFootersProvider.class ) . in ( com.google.inject.Scopes.SINGLETON ) ; bind ( org.eclipse.jgit.lib.Config.class ) . annotatedWith ( com.google.gerrit.server.config.GerritServerConfig.class ) . toProvider ( com.google.gerrit.server.config.GerritServerConfigProvider.class ) . in ( com.google.inject.Scopes.SINGLETON ) ; }
public void onError ( final com.google.gwt.http.client.Request request , final java.lang.Throwable exception ) { fireEvent ( RpcCompleteEvent.e ) ; if ( ( ( exception.getClass ( ) ) == ( java.lang.RuntimeException.class ) ) && ( exception.getMessage ( ) . contains ( "XmlHttpRequest.status" ) ) ) { callback.onFailure ( new com.google.gwtjsonrpc.client.ServerUnavailableException ( ) ) ; } else { callback.onFailure ( exception ) ; } }
public void deletingNonExistingEditRest ( ) throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = adminSession.delete ( urlEdit ( ) ) ; com.google.common.truth.Truth.assertThat ( r.getStatusCode ( ) ) . isEqualTo ( org.apache.http.HttpStatus.SC_NOT_FOUND ) ; }
public void repositoryIndex ( ) throws java.lang.Exception { com.google.gitiles.GitilesView view = getView ( "/repo" ) ; com.google.common.truth.Truth.assertThat ( view.getType ( ) ) . isEqualTo ( Type.REPOSITORY_INDEX ) ; com.google.common.truth.Truth.assertThat ( view.getRepositoryName ( ) ) . isEqualTo ( "repo" ) ; com.google.common.truth.Truth.assertThat ( view.getRevision ( ) ) . isEqualTo ( Revision.NULL ) ; com.google.common.truth.Truth.assertThat ( view.getOldRevision ( ) ) . isEqualTo ( Revision.NULL ) ; com.google.common.truth.Truth.assertThat ( view.getPathPart ( ) ) . isNull ( ) ; }
private void assertDeleteByRestSucceeds ( java.lang.String ref ) throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = userRestSession.delete ( ( ( ( "/projects/" + ( project.get ( ) ) ) + "/branches/" ) + ref ) ) ; r.assertNoContent ( ) ; exception.expect ( com.google.gerrit.extensions.restapi.ResourceNotFoundException.class ) ; branch ( ) . get ( ) ; }
public void fooBarSubdirJson ( ) throws java.lang.Exception { java.util.Map < java.lang.String , com.google.gitiles.RepositoryDescription > res = buildJson ( "/foo/bar/" , new com.google.gson.reflect.TypeToken < java.util.Map < java.lang.String , com.google.gitiles.RepositoryDescription > > ( ) { } . getType ( ) ) ; com.google.common.truth.Truth.assertThat ( res ) . hasSize ( 1 ) ; com.google.common.truth.Truth.assertThat ( res ) . containsKey ( "repo" ) ; com.google.gitiles.RepositoryDescription d = res.get ( "repo" ) ; com.google.common.truth.Truth.assertThat ( d.name ) . isEqualTo ( repo.getRepository ( ) . getDescription ( ) . getRepositoryName ( ) ) ; }
java.util.List < java.util.List < java.lang.String > > getValues ( ) { java.util.List < java.util.List < java.lang.String > > values = new java.util.ArrayList < > ( ) ; for ( int row = 2 ; row < ( table.getRowCount ( ) ) ; row ++ ) { values.add ( getRowItem ( row ) ) ; } return values ; }
public void emptyPermissionRangeKeepsResult ( ) throws java.lang.Exception { com.google.gerrit.reviewdb.client.PatchSetApproval cr = psa ( userId , "Code-Review" , 1 ) ; com.google.gerrit.reviewdb.client.PatchSetApproval v = psa ( userId , "Verified" , 1 ) ; org.junit.Assert.assertEquals ( com.google.gerrit.server.change.LabelNormalizer.Result.create ( com.google.gerrit.server.change.LabelNormalizerTest.list ( cr , v ) , com.google.gerrit.server.change.LabelNormalizerTest.list ( ) , com.google.gerrit.server.change.LabelNormalizerTest.list ( ) ) , norm.normalize ( notes , com.google.gerrit.server.change.LabelNormalizerTest.list ( cr , v ) ) ) ; }
public com.google.gerrit.extensions.restapi.Response < com.google.gerrit.server.project.DashboardsCollection.DashboardInfo > apply ( com.google.gerrit.server.project.ProjectResource resource , com.google.gerrit.server.project.SetDashboard.Input input ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.extensions.restapi.BadRequestException , com.google.gerrit.extensions.restapi.ResourceConflictException , com.google.gerrit.extensions.restapi.ResourceNotFoundException , java.io.IOException { com.google.gerrit.server.project.SetDefaultDashboard set = setDefault.get ( ) ; set.inherited = inherited ; return set.apply ( com.google.gerrit.server.project.DashboardResource.projectDefault ( resource.getControl ( ) ) , input ) ; }
private static org.apache.lucene.search.Query not ( com.google.gerrit.server.index.Schema < com.google.gerrit.server.query.change.ChangeData > schema , com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > p ) throws com.google.gerrit.server.query.QueryParseException { com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > n = p.getChild ( 0 ) ; if ( n instanceof com.google.gerrit.server.index.TimestampRangePredicate ) { return com.google.gerrit.lucene.QueryBuilder.notTimestamp ( ( ( com.google.gerrit.server.index.TimestampRangePredicate < com.google.gerrit.server.query.change.ChangeData > ) ( n ) ) ) ; } org.apache.lucene.search.BooleanQuery q = new org.apache.lucene.search.BooleanQuery ( ) ; q.add ( new org.apache.lucene.search.MatchAllDocsQuery ( ) , org.apache.lucene.search.BooleanClause.Occur.MUST ) ; q.add ( com.google.gerrit.lucene.QueryBuilder.toQuery ( schema , n ) , org.apache.lucene.search.BooleanClause.Occur.MUST_NOT ) ; return q ; }
boolean requestRunway ( com.googlesource.gerrit.plugins.replication.PushOne op ) { synchronized ( stateLock ) { if ( op.wasCanceled ( ) ) { return false ; } pending.remove ( op.getURI ( ) ) ; if ( inFlight.containsKey ( op.getURI ( ) ) ) { return false ; } inFlight.put ( op.getURI ( ) , op ) ; } return true ; }
private void testGetGroup ( java.lang.String url , com.google.gerrit.reviewdb.client.AccountGroup expectedGroup ) throws java.io.IOException { com.google.gerrit.acceptance.RestResponse r = session.get ( url ) ; com.google.gerrit.server.group.GroupJson.GroupInfo group = newGson ( ) . fromJson ( r.getReader ( ) , com.google.gerrit.server.group.GroupJson.GroupInfo.class ) ; com.google.gerrit.acceptance.rest.group.GroupAssert.assertGroupInfo ( expectedGroup , group ) ; }
private boolean add ( com.google.gerrit.server.mail.send.ProjectWatch.Watchers matching , com.google.gerrit.reviewdb.client.Account.Id accountId , com.google.gerrit.server.account.WatchConfig.ProjectWatchKey key , java.util.Set < com.google.gerrit.server.account.WatchConfig.NotifyType > watchedTypes , com.google.gerrit.server.account.WatchConfig.NotifyType type ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.IdentifiedUser user = args.identifiedUserFactory.create ( accountId ) ; try { if ( filterMatch ( user , key.filter ( ) ) ) { if ( watchedTypes.contains ( type ) ) { matching.bcc.accounts.add ( accountId ) ; } return true ; } } catch ( com.google.gerrit.server.query.QueryParseException e ) { } return false ; }
public java.util.List < com.google.gerrit.extensions.common.WebLinkInfo > getPatchSetLinks ( java.lang.String project , java.lang.String commit ) { java.util.List < com.google.gerrit.extensions.common.WebLinkInfo > links = new java.util.ArrayList < > ( 4 ) ; for ( com.google.gerrit.extensions.webui.PatchSetWebLink webLink : patchSetLinks ) { links.add ( webLink.getPathSetWebLink ( project , commit ) ) ; } return links ; }
public void singlePeeledTagText ( ) throws java.lang.Exception { setUpSimpleRefs ( ) ; com.google.gitiles.FakeHttpServletRequest req = com.google.gitiles.FakeHttpServletRequest.newRequest ( ) ; req.setPathInfo ( "/test/+refs/tags/atag" ) ; req.setQueryString ( "format=TEXT" ) ; com.google.gitiles.FakeHttpServletResponse res = new com.google.gitiles.FakeHttpServletResponse ( ) ; servlet.service ( req , res ) ; org.junit.Assert.assertEquals ( 200 , res.getStatus ( ) ) ; org.junit.Assert.assertEquals ( ( ( ( ( id ( "refs/tags/atag" ) ) + " refs/tags/atag\n" ) + ( peeled ( "refs/tags/atag" ) ) ) + " refs/tags/atag^{}\n" ) , res.getActualBodyString ( ) ) ; }
public void serverConfigWithPlugin ( ) throws java.lang.Exception { java.nio.file.Path plugins = tempSiteDir.newFolder ( "plugins" ) . toPath ( ) ; java.nio.file.Path jsplugin = plugins.resolve ( "js-plugin-1.js" ) ; java.nio.file.Files.write ( jsplugin , "Gerrit.install(function(self){});\n" . getBytes ( java.nio.charset.StandardCharsets.UTF_8 ) ) ; adminSshSession.exec ( "gerrit plugin reload" ) ; com.google.gerrit.extensions.common.ServerInfo i = gApi.config ( ) . server ( ) . getInfo ( ) ; com.google.common.truth.Truth.assertThat ( i.plugin.jsResourcePaths ) . hasSize ( 1 ) ; }
protected com.google.gson.GsonBuilder newGsonBuilder ( javax.servlet.http.HttpServletRequest req ) throws java.io.IOException { return new com.google.gson.GsonBuilder ( ) . setFieldNamingPolicy ( com.google.gson.FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES ) . setPrettyPrinting ( ) . generateNonExecutableJson ( ) ; }
private java.nio.file.Path webappSourcePath ( java.lang.String name ) { com.google.gerrit.httpd.raw.StaticModule.Paths p = getPaths ( ) ; if ( ( p.unpackedWar ) != null ) { return p.unpackedWar.resolve ( name ) ; } return p.buckOut.resolveSibling ( "gerrit-war" ) . resolve ( "src" ) . resolve ( "main" ) . resolve ( "webapp" ) . resolve ( name ) ; }
private static com.google.gerrit.extensions.restapi.BinaryResult asBinaryResult ( final org.eclipse.jgit.util.TemporaryBuffer.Heap buf ) { return new com.google.gerrit.extensions.restapi.BinaryResult ( ) { @ java.lang.Override public void writeTo ( java.io.OutputStream os ) throws java.io.IOException { buf.writeTo ( os , null ) ; } } . setContentLength ( buf.length ( ) ) ; }
public void queryChangesOwnerWithDifferentUsers ( ) throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange ( ) ; com.google.common.truth.Truth.assertThat ( com.google.common.collect.Iterables.getOnlyElement ( query ( ( ( "project:{" + ( project.get ( ) ) ) + "} owner:self" ) ) ) . changeId ) . isEqualTo ( r.getChangeId ( ) ) ; setApiUser ( user ) ; com.google.common.truth.Truth.assertThat ( query ( "owner:self" ) ) . isEmpty ( ) ; }
public com.google.gerrit.server.change.GetRelated.RelatedInfo getRelated ( com.google.gerrit.server.change.RevisionResource rsrc ) throws com.google.gwtorm.server.OrmException , java.io.IOException , org.eclipse.jgit.errors.RepositoryNotFoundException { try ( org.eclipse.jgit.lib.Repository git = gitMgr.openRepository ( rsrc.getChange ( ) . getProject ( ) ) ; org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk ( git ) ) { org.eclipse.jgit.lib.Ref ref = git.getRefDatabase ( ) . exactRef ( rsrc.getChange ( ) . getDest ( ) . get ( ) ) ; com.google.gerrit.server.change.GetRelated.RelatedInfo info = new com.google.gerrit.server.change.GetRelated.RelatedInfo ( ) ; info.changes = walk ( rsrc , rw , ref ) ; return info ; } }
private void restoreSelection ( ) { if ( ( ( getFromTo ( ) ) != null ) && ( ( comment.in_reply_to ( ) ) == null ) ) { getCm ( ) . setSelection ( getFromTo ( ) . from ( ) , getFromTo ( ) . to ( ) ) ; } }
private com.google.gerrit.server.patch.PatchScriptBuilder newBuilder ( ) throws com.google.gerrit.client.rpc.BaseServiceImplementation.Failure { final com.google.gerrit.server.patch.PatchScriptBuilder b = new com.google.gerrit.server.patch.PatchScriptBuilder ( ) ; b.setRepository ( git ) ; b.setPatch ( patch ) ; if ( ( context ) == ( com.google.gerrit.client.reviewdb.AccountGeneralPreferences.WHOLE_FILE_CONTEXT ) ) b.setContext ( PatchScriptBuilder.MAX_CONTEXT ) ; else if ( ( 0 <= ( context ) ) && ( ( context ) <= ( PatchScriptBuilder.MAX_CONTEXT ) ) ) b.setContext ( context ) ; else throw new com.google.gerrit.client.rpc.BaseServiceImplementation.Failure ( new com.google.gerrit.client.rpc.NoSuchEntityException ( ) ) ; return b ; }
protected void allowGlobalCapabilities ( com.google.gerrit.reviewdb.client.AccountGroup.UUID id , java.lang.Iterable < java.lang.String > capabilityNames ) throws java.lang.Exception { com.google.gerrit.server.git.ProjectConfig cfg = projectCache.checkedGet ( allProjects ) . getConfig ( ) ; for ( java.lang.String capabilityName : capabilityNames ) { com.google.gerrit.server.project.Util.allow ( cfg , capabilityName , id ) ; } saveProjectConfig ( allProjects , cfg ) ; }
public void deleteReviewerByEmailFromWipChangeInNoteDb ( ) throws java.lang.Exception { com.google.common.truth.TruthJUnit.assume ( ) . that ( notesMigration.readChanges ( ) ) . isTrue ( ) ; com.google.gerrit.acceptance.server.mail.StagedChange sc = stageWipChangeWithExtraReviewer ( ) ; gApi.changes ( ) . id ( sc.changeId ) . reviewer ( sc.reviewerByEmail ) . remove ( ) ; assertThat ( sender ) . notSent ( ) ; }
protected void configure ( ) { bind ( com.googlesource.gerrit.plugins.uploadvalidator.ContentTypeUtil.class ) ; bind ( com.google.gerrit.server.config.ProjectConfigEntry.class ) . annotatedWith ( com.google.gerrit.extensions.annotations.Exports.named ( com.googlesource.gerrit.plugins.uploadvalidator.ContentTypeUtil.KEY_BINARY_TYPES ) ) . toInstance ( new com.google.gerrit.server.config.ProjectConfigEntry ( "Binary Types" , null , com.google.gerrit.extensions.api.projects.ProjectConfigEntryType.ARRAY , null , false , ( "At the moment, there is no ideal solution to detect binary " + ( ( ( "files. But some checks shouldn't run on binary files " + "(e. g. InvalidLineEndingCheck). Because of that you can " ) + "enter content types to avoid that these checks run on " ) + "files with one of the entered content types." ) ) ) ) ; }
public java.util.Collection < com.google.gerrit.reviewdb.client.PatchLineComment > comments ( ) throws com.google.gwtorm.server.OrmException { if ( ( comments ) == null ) { comments = db.patchComments ( ) . byChange ( legacyId ) . toList ( ) ; } return comments ; }
public com.google.gerrit.extensions.client.GeneralPreferencesInfo apply ( com.google.gerrit.server.account.AccountResource rsrc ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.permissions.PermissionBackendException { if ( ( self.get ( ) ) != ( rsrc.getUser ( ) ) ) { permissionBackend.user ( self ) . check ( GlobalPermission.MODIFY_ACCOUNT ) ; } com.google.gerrit.reviewdb.client.Account.Id id = rsrc.getUser ( ) . getAccountId ( ) ; return accountCache.maybeGet ( id ) . map ( AccountState :: getGeneralPreferences ) . orElseThrow ( ( ) -> new com.google.gerrit.extensions.restapi.ResourceNotFoundException ( com.google.gerrit.extensions.restapi.IdString.fromDecoded ( id.toString ( ) ) ) ) ; }
private java.lang.String getOwerGroupName ( com.google.gerrit.server.project.ProjectState project ) { java.util.Set < com.google.gerrit.reviewdb.client.AccountGroup.UUID > owners = project.getAllOwners ( ) ; if ( ! ( owners.isEmpty ( ) ) ) { java.util.Optional < com.google.gerrit.server.group.InternalGroup > owner = groupCache.get ( owners.iterator ( ) . next ( ) ) ; if ( owner.isPresent ( ) ) { return owner.get ( ) . getName ( ) ; } } return java.lang.String.format ( "no owners for project %s" , project.getProject ( ) . getName ( ) ) ; }
protected void renderJson ( javax.servlet.http.HttpServletRequest req , javax.servlet.http.HttpServletResponse res , java.lang.Object src , java.lang.reflect.Type typeOfSrc ) throws java.io.IOException { setApiHeaders ( res , com.google.gitiles.FormatType.JSON ) ; res.setStatus ( javax.servlet.http.HttpServletResponse.SC_OK ) ; java.io.Writer writer = getWriter ( res ) ; newGsonBuilder ( req ) . create ( ) . toJson ( src , typeOfSrc , writer ) ; writer.write ( '\n' ) ; writer.close ( ) ; }
public void testNotNot ( ) { final com.google.gerrit.server.query.TestPredicate p = f ( "author" , "bob" ) ; final com.google.gerrit.server.query.Predicate < java.lang.String > n = com.google.gerrit.server.query.Predicate.not ( p ) ; org.junit.Assert.assertTrue ( ( n instanceof com.google.gerrit.server.query.NotPredicate ) ) ; org.junit.Assert.assertNotSame ( p , n ) ; org.junit.Assert.assertSame ( p , com.google.gerrit.server.query.Predicate.not ( n ) ) ; }
public java.lang.String createCherryPickCommitMessage ( final com.google.gerrit.server.git.CodeReviewCommit n ) { return createCherryPickCommitMessage ( n , n.getControl ( ) , n.getPatchsetId ( ) ) ; }
public void testKeyObjectId ( ) throws java.lang.Exception { org.bouncycastle.openpgp.PGPPublicKey key = com.google.gerrit.gpg.testutil.TestKey.key1 ( ) . getPublicKey ( ) ; java.lang.String objId = com.google.gerrit.gpg.PublicKeyStore.keyObjectId ( key.getKeyID ( ) ) . name ( ) ; org.junit.Assert.assertEquals ( "ed0625dc46328a8c000000000000000000000000" , objId ) ; org.junit.Assert.assertEquals ( com.google.gerrit.gpg.PublicKeyStore.keyIdToString ( key.getKeyID ( ) ) . toLowerCase ( ) , objId.substring ( 8 , 16 ) ) ; }
public void duplicateCompoundIndexOnlyPredicates ( ) throws java.lang.Exception { com.google.gerrit.index.query.Predicate < com.google.gerrit.server.query.change.ChangeData > in = parse ( "(status:new OR file:a) bar:p file:b" ) ; com.google.gerrit.index.query.Predicate < com.google.gerrit.server.query.change.ChangeData > out = rewrite ( in ) ; com.google.common.truth.Truth.assertThat ( out.getClass ( ) ) . isEqualTo ( com.google.gerrit.server.query.change.AndChangeSource.class ) ; com.google.common.truth.Truth.assertThat ( out.getChildren ( ) ) . containsExactly ( query ( com.google.gerrit.index.query.Predicate.and ( in.getChild ( 0 ) , in.getChild ( 2 ) ) ) , in.getChild ( 1 ) ) . inOrder ( ) ; }
public com.google.gerrit.extensions.restapi.Response < ? > apply ( com.google.gerrit.server.change.ChangeResource rsrc , com.google.gerrit.server.change.Index.Input input ) throws com.google.gerrit.extensions.restapi.AuthException , java.io.IOException { com.google.gerrit.server.project.ChangeControl ctl = rsrc.getControl ( ) ; if ( ( ! ( ctl.isOwner ( ) ) ) && ( ! ( ctl.getUser ( ) . getCapabilities ( ) . canMaintainServer ( ) ) ) ) { throw new com.google.gerrit.extensions.restapi.AuthException ( "Only change owner or server maintainer can reindex" ) ; } indexer.index ( db.get ( ) , rsrc.getChange ( ) ) ; return com.google.gerrit.extensions.restapi.Response.none ( ) ; }
public void testSubscriptionWithoutSpecificSubscription ( ) throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository < ? > superRepo = createProjectWithPush ( "super-project" ) ; org.eclipse.jgit.junit.TestRepository < ? > subRepo = createProjectWithPush ( "subscribed-to-project" ) ; createSubmoduleSubscription ( superRepo , "master" , "subscribed-to-project" , "master" ) ; pushChangeTo ( subRepo , "master" ) ; com.google.common.truth.Truth.assertThat ( hasSubmodule ( superRepo , "master" , "subscribed-to-project" ) ) . isFalse ( ) ; }
public com.google.gerrit.server.change.ChangeEditResource parse ( com.google.gerrit.server.change.ChangeResource rsrc , com.google.gerrit.extensions.restapi.IdString id ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.extensions.restapi.ResourceNotFoundException , com.google.gerrit.server.project.InvalidChangeOperationException , java.io.IOException { com.google.common.base.Optional < com.google.gerrit.server.edit.ChangeEdit > edit = editUtil.byChange ( rsrc.getChange ( ) ) ; if ( ! ( edit.isPresent ( ) ) ) { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException ( id ) ; } return new com.google.gerrit.server.change.ChangeEditResource ( rsrc , edit.get ( ) , id.get ( ) ) ; }
public com.google.gerrit.extensions.api.changes.ReviewerInfo format ( com.google.gerrit.extensions.api.changes.ReviewerInfo out , com.google.gerrit.server.project.ChangeControl ctl ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.PatchSet.Id psId = ctl.getChange ( ) . currentPatchSetId ( ) ; return format ( out , ctl , approvalsUtil.byPatchSetUser ( db.get ( ) , ctl , psId , new com.google.gerrit.reviewdb.client.Account.Id ( out._accountId ) ) ) ; }
public com.google.gerrit.acceptance.RestResponse putRaw ( java.lang.String endPoint , com.google.gerrit.extensions.restapi.RawInput stream ) throws java.io.IOException { com.google.common.base.Preconditions.checkNotNull ( stream ) ; org.apache.http.client.fluent.Request put = org.apache.http.client.fluent.Request.Put ( getUrl ( endPoint ) ) ; put.addHeader ( new org.apache.http.message.BasicHeader ( "Content-Type" , stream.getContentType ( ) ) ) ; put.body ( new org.apache.http.entity.BufferedHttpEntity ( new org.apache.http.entity.InputStreamEntity ( stream.getInputStream ( ) , stream.getContentLength ( ) ) ) ) ; return execute ( put ) ; }
public com.google.gwtorm.server.ResultSet < com.google.gerrit.server.query.change.ChangeData > read ( ) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.reviewdb.client.RevId id = new com.google.gerrit.reviewdb.client.RevId ( abbrevId.name ( ) ) ; if ( id.isComplete ( ) ) { return com.google.gerrit.server.query.change.ChangeDataResultSet.patchSet ( dbProvider.get ( ) . patchSets ( ) . byRevision ( id ) ) ; } else { return com.google.gerrit.server.query.change.ChangeDataResultSet.patchSet ( dbProvider.get ( ) . patchSets ( ) . byRevisionRange ( id , id.max ( ) ) ) ; } }
public com.google.gitiles.GitilesView.Builder setPathPart ( java.lang.String path ) { switch ( type ) { case PATH : case DIFF : com.google.common.base.Preconditions.checkState ( ( path != null ) , "cannot set null path on %s view" , type ) ; break ; case BLAME : case ARCHIVE : case DESCRIBE : case REFS : case LOG : break ; default : com.google.common.base.Preconditions.checkState ( ( path == null ) , "cannot set path on %s view" , type ) ; break ; } this . path = ( path != null ) ? com.google.gitiles.GitilesView.maybeTrimLeadingAndTrailingSlash ( path ) : null ; return this ; }
protected org.eclipse.jgit.junit.TestRepository < ? > createProjectWithPush ( java.lang.String name , @ com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey parent , boolean createEmptyCommit , com.google.gerrit.extensions.client.SubmitType submitType ) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey project = createProject ( name , parent , createEmptyCommit , submitType ) ; grant ( Permission.PUSH , project , "refs/heads/*" ) ; grant ( Permission.SUBMIT , project , "refs/for/refs/heads/*" ) ; return cloneProject ( project ) ; }
public void run ( ) throws java.io.IOException { ui.header ( "Index" ) ; com.google.gerrit.server.index.IndexModule.IndexType type = index.select ( "Type" , "type" , IndexType.LUCENE ) ; if ( ( site.isNew ) && ( type == ( com.google.gerrit.server.index.IndexModule.IndexType.LUCENE ) ) ) { com.google.gerrit.lucene.LuceneChangeIndex.setReady ( site , com.google.gerrit.server.index.ChangeSchemas.getLatest ( ) . getVersion ( ) , true ) ; } else { ui.message ( ( "The index must be built before starting Gerrit:\n" + " java -jar gerrit.war reindex -d site_path\n" ) ) ; initFlags.autoStart = false ; } }
public void putComment ( com.google.gerrit.reviewdb.client.PatchLineComment c ) { verifyComment ( c ) ; createDraftUpdateIfNull ( ) ; if ( ( c.getStatus ( ) ) == ( PatchLineComment.Status.DRAFT ) ) { draftUpdate.putComment ( c ) ; } else { comments.add ( c ) ; draftUpdate.deleteComment ( c ) ; } }
void display ( java.lang.String token ) { assert token != null ; try { try { if ( token.startsWith ( com.google.gerrit.client.Dispatcher.RELOAD_UI ) ) { com.google.gerrit.client.Dispatcher.wasStartedByReloadUI = true ; token = com.google.gerrit.client.Dispatcher.skip ( com.google.gerrit.client.Dispatcher.RELOAD_UI , token ) ; } com.google.gerrit.client.Dispatcher.select ( token ) ; } finally { com.google.gerrit.client.Dispatcher.wasStartedByReloadUI = false ; } } catch ( java.lang.RuntimeException err ) { com.google.gwt.core.client.GWT.log ( ( "Error parsing history token: " + token ) , err ) ; com.google.gerrit.client.Gerrit.display ( token , new com.google.gerrit.client.NotFoundScreen ( ) ) ; } }
protected void configureServlets ( ) { serve ( "/gitweb" ) . with ( com.google.gerrit.httpd.gitweb.GitWebServlet.class ) ; serve ( "/gitweb-logo.png" ) . with ( com.google.gerrit.httpd.gitweb.GitLogoServlet.class ) ; serve ( "/gitweb.js" ) . with ( com.google.gerrit.httpd.gitweb.GitWebJavaScriptServlet.class ) ; serve ( "/gitweb-default.css" ) . with ( GitWebCssServlet.Default.class ) ; serve ( "/gitweb-site.css" ) . with ( GitWebCssServlet.Site.class ) ; }
public com.google.gerrit.extensions.api.projects.CommitApi commit ( java.lang.String commit ) throws com.google.gerrit.extensions.restapi.RestApiException { try { return commitApi.create ( commitsCollection.parse ( checkExists ( ) , com.google.gerrit.extensions.restapi.IdString.fromDecoded ( commit ) ) ) ; } catch ( java.lang.Exception e ) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException ( "Cannot parse commit" , e ) ; } }
public java.lang.String getRequestURI ( ) { java.lang.String uri = ( ( contextPath ) + ( servletPath ) ) + ( path ) ; if ( ! ( parameters.isEmpty ( ) ) ) { uri += "?" + ( com.google.gitiles.GitilesView.paramsToString ( parameters ) ) ; } return uri ; }
private com.google.gerrit.server.account.AuthResult byUserName ( final javax.servlet.http.HttpServletResponse rsp , final java.lang.String userName ) { try { final com.google.gerrit.reviewdb.ReviewDb db = schema.open ( ) ; try { com.google.gerrit.reviewdb.AccountExternalId.Key key = new com.google.gerrit.reviewdb.AccountExternalId.Key ( com.google.gerrit.reviewdb.AccountExternalId.SCHEME_USERNAME , userName ) ; return auth ( accountExternalIdCache.get ( key ) ) ; } finally { db.close ( ) ; } } catch ( com.google.gwtorm.client.OrmException e ) { getServletContext ( ) . log ( "cannot query database" , e ) ; return null ; } }
public org.apache.sshd.server.CommandFactory get ( ) { return new org.apache.sshd.server.CommandFactory ( ) { @ java.lang.Override public org.apache.sshd.server.Command createCommand ( java.lang.String requestCommand ) { java.lang.String c = requestCommand ; com.google.gerrit.sshd.SshCreateCommandInterceptor interceptor = createCommandInterceptor.get ( ) ; if ( interceptor != null ) { c = interceptor.intercept ( c ) ; } return new com.google.gerrit.sshd.CommandFactoryProvider.Trampoline ( c ) ; } } ; }
private org.apache.lucene.search.Query fullTextQuery ( com.google.gerrit.server.index.IndexPredicate < com.google.gerrit.server.query.change.ChangeData > p ) throws com.google.gerrit.server.query.QueryParseException { java.lang.String value = p.getValue ( ) ; if ( value == null ) { throw new com.google.gerrit.server.query.QueryParseException ( "Full-text search over empty string not supported" ) ; } org.apache.lucene.search.Query query = queryBuilder.createPhraseQuery ( p.getField ( ) . getName ( ) , value ) ; if ( query == null ) { throw new com.google.gerrit.server.query.QueryParseException ( ( "Cannot create full-text query with value: " + value ) ) ; } return query ; }
public void getMultiple ( ) throws java.lang.Exception { com.google.gerrit.gpg.testing.TestKey key1 = com.google.gerrit.gpg.testing.TestKeys.validKeyWithoutExpiration ( ) ; com.google.gerrit.gpg.testing.TestKey key2 = com.google.gerrit.gpg.testing.TestKeys.validKeyWithExpiration ( ) ; tr.branch ( com.google.gerrit.gpg.PublicKeyStore.REFS_GPG_KEYS ) . commit ( ) . add ( com.google.gerrit.gpg.PublicKeyStore.keyObjectId ( key1.getKeyId ( ) ) . name ( ) , ( ( key1.getPublicKeyArmored ( ) ) + ( key2.getPublicKeyArmored ( ) ) ) ) . create ( ) ; assertKeys ( key1.getKeyId ( ) , key1 , key2 ) ; }
public void testUpsertOneExisting ( ) throws com.google.gwtorm.server.OrmException , java.sql.SQLException { java.sql.PreparedStatement update = stubStatementWithUpdateCounts ( com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE , 1 ) ; java.sql.PreparedStatement insert = stubStatementWithUpdateCounts ( com.google.gwtorm.jdbc.TestJdbcAccess.INSERT ) ; createClassUnderTest ( ) . upsert ( oneRow ) ; com.google.gwtorm.jdbc.TestJdbcAccess.assertUsedBatchingOnly ( update ) ; com.google.gwtorm.jdbc.TestJdbcAccess.assertNotUsed ( insert ) ; }
public void onFailure ( java.lang.Throwable caught ) { if ( failed ) { return ; } failed = true ; failedThrowable = caught ; for ( com.google.gerrit.client.rpc.CallbackGroup.CallbackImpl < ? > cb : callbacks ) { cb.delegate.onFailure ( failedThrowable ) ; cb.delegate = null ; cb.result = null ; } callbacks.clear ( ) ; remaining.clear ( ) ; }
public void testPersonByNameRange_OrderByName ( ) throws java.lang.Exception { com.google.gwtorm.nosql.IndexFunction < com.google.gwtorm.data.Person > idx = index ( "nameSuggest" , "WHERE name >= ? AND name <= ? ORDER BY name" ) ; org.junit.Assert.assertEquals ( "nameSuggest" , idx.getName ( ) ) ; com.google.gwtorm.nosql.IndexKeyBuilder b ; com.google.gwtorm.data.Person p ; b = new com.google.gwtorm.nosql.IndexKeyBuilder ( ) ; p = new com.google.gwtorm.data.Person ( new com.google.gwtorm.data.Person.Key ( "q" ) , 42 ) ; org.junit.Assert.assertTrue ( idx.includes ( p ) ) ; idx.encode ( b , p ) ; com.google.gwtorm.nosql.IndexFunctionTest.assertEqualToBuilderResult ( new byte [ ] { 'q' } , b ) ; }
public void testInheritRead_SingleBranchDoesNotOverrideInherited ( ) { grant ( parent , com.google.gerrit.common.data.Permission.READ , registered , "refs/*" ) ; grant ( parent , com.google.gerrit.common.data.Permission.PUSH , registered , "refs/for/refs/*" ) ; grant ( local , com.google.gerrit.common.data.Permission.READ , registered , "refs/heads/foobar" ) ; com.google.gerrit.server.project.ProjectControl u = user ( ) ; assertTrue ( "can upload" , ( ( u.canPushToAtLeastOneRef ( ) ) == ( com.google.gerrit.common.data.Capable.OK ) ) ) ; assertTrue ( "can upload refs/heads/master" , u.controlForRef ( "refs/heads/master" ) . canUpload ( ) ) ; assertTrue ( "can upload refs/heads/foobar" , u.controlForRef ( "refs/heads/foobar" ) . canUpload ( ) ) ; }
byte [ ] build ( com.google.gerrit.server.notedb.CommentsInNotesUtil commentsUtil ) { java.io.ByteArrayOutputStream out = new java.io.ByteArrayOutputStream ( ) ; if ( ( pushCert ) != null ) { byte [ ] certBytes = pushCert.getBytes ( java.nio.charset.StandardCharsets.UTF_8 ) ; out.write ( certBytes , 0 , com.google.gerrit.server.notedb.RevisionNoteBuilder.trimTrailingNewlines ( certBytes ) ) ; out.write ( '\n' ) ; } commentsUtil.buildNote ( com.google.gerrit.server.PatchLineCommentsUtil.PLC_ORDER.sortedCopy ( comments.values ( ) ) , out ) ; return out.toByteArray ( ) ; }
public void testCUSTOM_NoFullNameUser ( ) { setFrom ( "A ${user} B <my.server@email.address>" ) ; final java.lang.String email = "a.u.thor@test.example.com" ; final com.google.gerrit.reviewdb.client.Account.Id user = user ( null , email ) ; org.easymock.EasyMock.replay ( accountCache ) ; final com.google.gerrit.server.mail.Address r = create ( ) . from ( user ) ; org.junit.Assert.assertNotNull ( r ) ; org.junit.Assert.assertEquals ( "A Anonymous Coward B" , r.name ) ; org.junit.Assert.assertEquals ( "my.server@email.address" , r.email ) ; org.easymock.EasyMock.verify ( accountCache ) ; }
public void insert ( byte [ ] key , final byte [ ] newData ) throws com.google.gwtorm.client.OrmDuplicateKeyException , com.google.gwtorm.client.OrmException { try { atomicUpdate ( key , new com.google.gwtorm.client.AtomicUpdate < byte [ ] > ( ) { @ java.lang.Override public byte [ ] update ( byte [ ] oldData ) { if ( oldData != null ) { throw new com.google.gwtorm.nosql.generic.GenericSchema.KeyExists ( ) ; } return newData ; } } ) ; } catch ( com.google.gwtorm.nosql.generic.GenericSchema.KeyExists err ) { throw new com.google.gwtorm.client.OrmDuplicateKeyException ( "Duplicate key" ) ; } }
protected static void assertUsedBatchingOnly ( java.sql.PreparedStatement ps , int ... ids ) throws java.sql.SQLException { org.mockito.Mockito.verify ( ps , org.mockito.Mockito.times ( ids.length ) ) . addBatch ( ) ; org.mockito.Mockito.verify ( ps ) . executeBatch ( ) ; org.mockito.Mockito.verify ( ps , org.mockito.Mockito.never ( ) ) . executeUpdate ( ) ; com.google.gwtorm.jdbc.AbstractTestJdbcAccess.assertExpectedIdsUsed ( ps , ids ) ; }
public com.google.common.util.concurrent.ListenableFuture < java.lang.Void > insert ( com.google.gerrit.server.query.change.ChangeData cd ) throws java.io.IOException { org.apache.lucene.index.Term id = com.google.gerrit.lucene.QueryBuilder.idTerm ( cd ) ; org.apache.lucene.document.Document doc = toDocument ( cd ) ; if ( cd.getChange ( ) . getStatus ( ) . isOpen ( ) ) { return com.google.gerrit.lucene.LuceneChangeIndex.allOf ( closedIndex.delete ( id ) , openIndex.insert ( doc ) ) ; } else { return com.google.gerrit.lucene.LuceneChangeIndex.allOf ( openIndex.delete ( id ) , closedIndex.insert ( doc ) ) ; } }
private com.googlesource.gerrit.plugins.hooks.validation.ItsAssociationPolicy getItsAssociationPolicy ( ) { return gerritConfig.getEnum ( "commentLink" , itsName , "association" , ItsAssociationPolicy.OPTIONAL ) ; }
public void setSshInjector ( com.google.inject.Injector injector ) { sshModule = com.google.gerrit.server.plugins.PluginGuiceEnvironment.copy ( injector ) ; sshGen = injector.getProvider ( com.google.gerrit.server.plugins.ModuleGenerator.class ) ; sshSets = com.google.gerrit.extensions.registration.PrivateInternals_DynamicTypes.dynamicSetsOf ( injector ) ; sshMaps = com.google.gerrit.extensions.registration.PrivateInternals_DynamicTypes.dynamicMapsOf ( injector ) ; onStart.addAll ( com.google.gerrit.server.plugins.PluginGuiceEnvironment.listeners ( injector , com.google.gerrit.server.plugins.StartPluginListener.class ) ) ; onReload.addAll ( com.google.gerrit.server.plugins.PluginGuiceEnvironment.listeners ( injector , com.google.gerrit.server.plugins.ReloadPluginListener.class ) ) ; }
protected void provideStateTo ( final org.apache.sshd.server.CommandFactory.Command cmd ) { if ( cmd instanceof org.apache.sshd.server.CommandFactory.SessionAware ) { ( ( org.apache.sshd.server.CommandFactory.SessionAware ) ( cmd ) ) . setSession ( session ) ; } cmd.setInputStream ( in ) ; cmd.setOutputStream ( out ) ; cmd.setErrorStream ( err ) ; cmd.setExitCallback ( exit ) ; }
public void generatesExpectedMessage ( ) throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig ( ) ; mockEvent.change = com.google.common.base.Suppliers.ofInstance ( mockChange ) ; mockEvent.reviewer = com.google.common.base.Suppliers.ofInstance ( mockAccount ) ; mockChange.number = 1234 ; mockChange.project = "testproject" ; mockChange.branch = "master" ; mockChange.commitMessage = "This is the first line\nAnd the second line." ; mockChange.url = "https://change/" ; mockAccount.name = "Unit Tester" ; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator ; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance ( mockEvent , config ) ; java.lang.String expectedResult ; expectedResult = "{\n" + ( ( ( ( ( ( ( ( ( ( ( " \"channel\": \"#testchannel\",\n" + " \"attachments\": [\n" ) + " {\n" ) + " \"fallback\": \"Unit Tester was added to review - testproject (master) - change 1234 - https://change/\",\n" ) + " \"pretext\": \"Unit Tester was added to review\",\n" ) + " \"title\": \"testproject (master) - change 1234\",\n" ) + " \"title_link\": \"https://change/\",\n" ) + " \"text\": \"This is the first line\",\n" ) + " \"color\": \"good\"\n" ) + " }\n" ) + " ]\n" ) + "}\n" ) ; java.lang.String actualResult ; actualResult = messageGenerator.generate ( ) ; org.junit.Assert.assertThat ( actualResult , org.hamcrest.core.Is.is ( org.hamcrest.CoreMatchers.equalTo ( expectedResult ) ) ) ; }
public void loadPatchTable ( final com.google.gerrit.common.data.PatchSetDetail detail ) { if ( ! ( patchSet.getId ( ) . equals ( diffBaseId ) ) ) { patchTable = new com.google.gerrit.client.changes.PatchTable ( ) ; patchTable.setSavePointerId ( ( "PatchTable " + ( patchSet.getId ( ) ) ) ) ; patchTable.display ( diffBaseId , detail ) ; for ( com.google.gwt.event.dom.client.ClickHandler clickHandler : registeredClickHandler ) { patchTable.addClickHandler ( clickHandler ) ; } patchTable.setRegisterKeys ( true ) ; setActive ( true ) ; body.add ( patchTable ) ; } }
private static com.google.gerrit.server.git.CodeReviewCommit failed ( com.google.gerrit.server.git.CodeReviewCommit.CodeReviewRevWalk rw , org.eclipse.jgit.revwalk.RevFlag canMergeFlag , com.google.gerrit.server.git.CodeReviewCommit mergeTip , com.google.gerrit.server.git.CodeReviewCommit n , com.google.gerrit.server.git.CommitMergeStatus failure ) throws java.io.IOException , org.eclipse.jgit.errors.IncorrectObjectTypeException , org.eclipse.jgit.errors.MissingObjectException { rw.resetRetain ( canMergeFlag ) ; rw.markStart ( n ) ; rw.markUninteresting ( mergeTip ) ; com.google.gerrit.server.git.CodeReviewCommit failed ; while ( ( failed = rw.next ( ) ) != null ) { failed.setStatusCode ( failure ) ; } return failed ; }
public int compare ( com.google.gerrit.server.notedb.ChangeRebuilderImpl.Event a , com.google.gerrit.server.notedb.ChangeRebuilderImpl.Event b ) { return com.google.common.collect.ComparisonChain.start ( ) . compare ( a.when , b.when ) . compareTrueFirst ( isPatchSet ( a ) , isPatchSet ( b ) ) . compareTrueFirst ( a.predatesChange , b.predatesChange ) . compare ( a.who , b.who , com.google.gerrit.reviewdb.server.ReviewDbUtil.intKeyOrdering ( ) ) . compare ( a.psId , b.psId , com.google.gerrit.reviewdb.server.ReviewDbUtil.intKeyOrdering ( ) . nullsLast ( ) ) . result ( ) ; }
protected void configure ( ) { bind ( java.lang.String.class ) . annotatedWith ( com.googlesource.gerrit.plugins.hooks.its.ItsName.class ) . toInstance ( "ItsTestName" ) ; serverConfig = createMock ( org.eclipse.jgit.lib.Config.class ) ; bind ( org.eclipse.jgit.lib.Config.class ) . annotatedWith ( com.google.gerrit.server.config.GerritServerConfig.class ) . toInstance ( serverConfig ) ; commitMessageFetcher = createMock ( com.googlesource.gerrit.plugins.hooks.util.CommitMessageFetcher.class ) ; bind ( com.googlesource.gerrit.plugins.hooks.util.CommitMessageFetcher.class ) . toInstance ( commitMessageFetcher ) ; db = createMock ( com.google.gerrit.reviewdb.server.ReviewDb.class ) ; bind ( com.google.gerrit.reviewdb.server.ReviewDb.class ) . toInstance ( db ) ; }
private static void assertIncludes ( java.lang.Iterable < com.google.gerrit.extensions.common.GroupInfo > includes , java.lang.String ... expectedNames ) { java.lang.Iterable < java.lang.String > includeNames = com.google.common.collect.Iterables.transform ( includes , new com.google.common.base.Function < com.google.gerrit.extensions.common.GroupInfo , java.lang.String > ( ) { @ java.lang.Override public java.lang.String apply ( @ com.google.gerrit.common.Nullable com.google.gerrit.extensions.common.GroupInfo info ) { return info.name ; } } ) ; com.google.common.truth.Truth.assertThat ( includeNames ) . containsExactlyElementsIn ( java.util.Arrays.asList ( expectedNames ) ) . inOrder ( ) ; }
public java.lang.String toString ( ) { com.google.common.base.MoreObjects.ToStringHelper h = com.google.common.base.MoreObjects.toStringHelper ( this ) ; if ( ( change ) != null ) { h.addValue ( change ) ; } else { h.addValue ( legacyId ) ; } return h.toString ( ) ; }
private static java.util.List < java.lang.String > splitProjection ( com.google.gerrit.extensions.restapi.IdString projection ) { java.util.List < java.lang.String > p = com.google.common.collect.Lists.newArrayListWithCapacity ( 2 ) ; com.google.common.collect.Iterables.addAll ( p , com.google.common.base.Splitter.on ( '~' ) . limit ( 2 ) . split ( projection.get ( ) ) ) ; return p ; }
protected java.util.SortedSet < java.lang.String > cacheNames ( ) { java.util.SortedSet < java.lang.String > names = com.google.common.collect.Sets.newTreeSet ( ) ; for ( com.google.gerrit.extensions.registration.DynamicMap.Entry < com.google.common.cache.Cache < ? , ? > > e : cacheMap ) { names.add ( cacheNameOf ( e.getPluginName ( ) , e.getExportName ( ) ) ) ; } return names ; }
public void subsetOfBranchesVisibleIncludingHead ( ) throws java.lang.Exception { allow ( Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS , "refs/heads/master" ) ; deny ( Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS , "refs/heads/branch" ) ; setApiUser ( user ) ; assertRefs ( "HEAD" , ( ( r1 ) + "1" ) , ( ( r1 ) + "meta" ) , "refs/heads/master" , "refs/tags/master-tag" ) ; }
void resizeCodeMirror ( ) { int hdr = ( header.getOffsetHeight ( ) ) + ( diffTable.getHeaderHeight ( ) ) ; cmA.adjustHeight ( hdr ) ; cmB.adjustHeight ( hdr ) ; }
public java.util.Map < java.lang.String , com.j2bugzilla.rpc.GetLegalValues.Fields > getFields ( ) { java.util.Map < java.lang.String , com.j2bugzilla.rpc.GetLegalValues.Fields > fields = new java.util.HashMap < java.lang.String , com.j2bugzilla.rpc.GetLegalValues.Fields > ( ) ; fields.put ( "status" , Fields.STATUS ) ; fields.put ( "resolution" , Fields.RESOLUTION ) ; return fields ; }
public void setDefault ( ) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.common.SetDashboardInput input = new com.google.gerrit.extensions.common.SetDashboardInput ( ) ; input.id = id ; try { set.apply ( com.google.gerrit.server.project.DashboardResource.projectDefault ( project.getProjectState ( ) , project.getUser ( ) ) , input ) ; } catch ( java.lang.Exception e ) { java.lang.String msg = java.lang.String.format ( "Cannot %s default dashboard" , ( ( id ) != null ? "set" : "remove" ) ) ; throw com.google.gerrit.server.api.ApiUtil.asRestApiException ( msg , e ) ; } }
private org.eclipse.jgit.revwalk.RevCommit parse ( final org.eclipse.jgit.lib.Repository git , com.google.gerrit.reviewdb.PatchSet ps ) throws java.io.IOException , org.eclipse.jgit.errors.IncorrectObjectTypeException , org.eclipse.jgit.errors.MissingObjectException { org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk ( git ) ; try { return rw.parseCommit ( org.eclipse.jgit.lib.ObjectId.fromString ( ps.getRevision ( ) . get ( ) ) ) ; } finally { rw.release ( ) ; } }
private void enable ( final boolean on ) { showSiteHeader.setEnabled ( on ) ; useFlashClipboard.setEnabled ( on ) ; copySelfOnEmails.setEnabled ( on ) ; maximumPageSize.setEnabled ( on ) ; dateFormat.setEnabled ( on ) ; timeFormat.setEnabled ( on ) ; }
protected PushOneCommit.Result amendChange ( java.lang.String changeId ) throws java.io.IOException , org.eclipse.jgit.api.errors.GitAPIException { java.util.Collections.shuffle ( com.google.gerrit.acceptance.AbstractDaemonTest.RANDOM ) ; com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create ( db , admin.getIdent ( ) , PushOneCommit.SUBJECT , PushOneCommit.FILE_NAME , new java.lang.String ( com.google.common.primitives.Chars.toArray ( com.google.gerrit.acceptance.AbstractDaemonTest.RANDOM ) ) , changeId ) ; return push.to ( git , "refs/for/master" ) ; }
public com.googlecode.prolog_cafe.builtin.Operation exec ( com.googlecode.prolog_cafe.builtin.Prolog engine ) { engine.setB0 ( ) ; com.googlecode.prolog_cafe.builtin.Term a1 ; a1 = arg1 ; a1 = a1.dereference ( ) ; if ( a1 instanceof com.googlecode.prolog_cafe.builtin.VariableTerm ) throw new com.googlecode.prolog_cafe.exceptions.PInstantiationException ( this , 1 ) ; if ( ! ( a1 instanceof com.googlecode.prolog_cafe.builtin.IntegerTerm ) ) throw new com.googlecode.prolog_cafe.exceptions.IllegalTypeException ( this , 1 , "integer" , a1 ) ; engine.halt = 1 + ( ( ( com.googlecode.prolog_cafe.builtin.IntegerTerm ) ( a1 ) ) . intValue ( ) ) ; return cont ; }
private void assertChildNotFound ( com.google.gerrit.reviewdb.client.Project.NameKey parent , java.lang.String child ) throws java.lang.Exception { try { gApi.projects ( ) . name ( parent.get ( ) ) . child ( child ) ; } catch ( com.google.gerrit.extensions.restapi.ResourceNotFoundException e ) { e.printStackTrace ( ) ; com.google.common.truth.Truth.assertThat ( e.getMessage ( ) ) . contains ( child ) ; } }
public void onResize ( com.google.gwt.event.logical.shared.ResizeEvent event ) { cm.adjustHeight ( header.getOffsetHeight ( ) ) ; }
protected void onLoad ( ) { super . onLoad ( ) ; java.lang.String who = ( mine ) ? "self" : ownerId.toString ( ) ; com.google.gerrit.client.changes.ChangeList.query ( new com.google.gerrit.client.rpc.ScreenLoadCallback < com.google.gerrit.client.rpc.NativeList < com.google.gerrit.client.changes.ChangeList > > ( this ) { @ java.lang.Override protected void preDisplay ( com.google.gerrit.client.rpc.NativeList < com.google.gerrit.client.changes.ChangeList > result ) { display ( result ) ; } } , ( "is:open owner:" + who ) , ( ( ( "is:open reviewer:" + who ) + " -owner:" ) + who ) , ( ( "is:closed owner:" + who ) + " -age:1w limit:10" ) ) ; }
public void testHasValidScheme ( ) { com.google.common.truth.Truth.assertThat ( com.google.gwtexpui.safehtml.client.LinkFindReplace.hasValidScheme ( "/absolute/path" ) ) . isTrue ( ) ; com.google.common.truth.Truth.assertThat ( com.google.gwtexpui.safehtml.client.LinkFindReplace.hasValidScheme ( "relative/path" ) ) . isTrue ( ) ; com.google.common.truth.Truth.assertThat ( com.google.gwtexpui.safehtml.client.LinkFindReplace.hasValidScheme ( "http://url/" ) ) . isTrue ( ) ; com.google.common.truth.Truth.assertThat ( com.google.gwtexpui.safehtml.client.LinkFindReplace.hasValidScheme ( "HTTP://url/" ) ) . isTrue ( ) ; com.google.common.truth.Truth.assertThat ( com.google.gwtexpui.safehtml.client.LinkFindReplace.hasValidScheme ( "https://url/" ) ) . isTrue ( ) ; com.google.common.truth.Truth.assertThat ( com.google.gwtexpui.safehtml.client.LinkFindReplace.hasValidScheme ( "mailto://url/" ) ) . isTrue ( ) ; com.google.common.truth.Truth.assertThat ( com.google.gwtexpui.safehtml.client.LinkFindReplace.hasValidScheme ( "ftp://url/" ) ) . isFalse ( ) ; com.google.common.truth.Truth.assertThat ( com.google.gwtexpui.safehtml.client.LinkFindReplace.hasValidScheme ( "data:evil" ) ) . isFalse ( ) ; com.google.common.truth.Truth.assertThat ( com.google.gwtexpui.safehtml.client.LinkFindReplace.hasValidScheme ( "javascript:alert(1)" ) ) . isFalse ( ) ; }
public void testStringFF ( ) { com.google.gwtorm.nosql.IndexKeyBuilder ib = new com.google.gwtorm.nosql.IndexKeyBuilder ( ) ; ib.add ( new byte [ ] { ( ( byte ) ( 255 ) ) } ) ; com.google.gwtorm.nosql.IndexKeyBuilderTest.assertEqualToBuilderResult ( new byte [ ] { ( ( byte ) ( 255 ) ) , 0 } , ib ) ; }
public boolean retryRequest ( org.apache.http.HttpResponse response , int executionCount , org.apache.http.protocol.HttpContext context ) { if ( executionCount > ( cfg.getMaxTries ( ) ) ) { return false ; } if ( ( response.getStatusLine ( ) . getStatusCode ( ) ) >= ( com.googlesource.gerrit.plugins.webhooks.HttpClientProvider.ERROR_CODES ) ) { logRetry ( response.getStatusLine ( ) . getReasonPhrase ( ) , context ) ; return true ; } return false ; }
public void testSubscriptionFailOnWrongProjectACL ( ) throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository < ? > superRepo = createProjectWithPush ( "super-project" ) ; org.eclipse.jgit.junit.TestRepository < ? > subRepo = createProjectWithPush ( "subscribed-to-project" ) ; allowMatchingSubmoduleSubscription ( "subscribed-to-project" , "refs/heads/master" , "wrong-super-project" , "refs/heads/master" ) ; pushChangeTo ( subRepo , "master" ) ; createSubmoduleSubscription ( superRepo , "master" , "subscribed-to-project" , "master" ) ; pushChangeTo ( subRepo , "master" ) ; com.google.common.truth.Truth.assertThat ( hasSubmodule ( superRepo , "master" , "subscribed-to-project" ) ) . isFalse ( ) ; }
public void testIsEnabledChangeRestoredEvent ( ) { java.lang.String [ ] branches = new java.lang.String [ ] { } ; setupIsEnabled ( "true" , null , branches ) ; com.google.gerrit.server.events.ChangeRestoredEvent event = new com.google.gerrit.server.events.ChangeRestoredEvent ( testChange ( "testProject" , "testBranch" ) ) ; com.googlesource.gerrit.plugins.its.base.its.ItsConfig itsConfig = createItsConfig ( ) ; replayMocks ( ) ; assertTrue ( itsConfig.isEnabled ( event ) ) ; }
public void onFailure ( java.lang.Throwable e ) { enableEdit ( true ) ; pendingGroup = null ; if ( com.google.gerrit.client.rpc.RestApi.isNotSignedIn ( e ) ) { com.google.gerrit.client.changes.CommentInfo saved = com.google.gerrit.client.changes.CommentInfo.copy ( comment ) ; saved.message ( editArea.getValue ( ) . trim ( ) ) ; lc.setInlineComment ( saved ) ; } super . onFailure ( e ) ; }
public void duplicatePatchSetRevisions ( ) throws java.lang.Exception { com.google.gerrit.server.project.ChangeControl ctl = insertChange ( ) ; com.google.gerrit.reviewdb.client.PatchSet ps1 = psUtil.current ( db , ctl.getNotes ( ) ) ; java.lang.String rev = ps1.getRevision ( ) . get ( ) ; ctl = incrementPatchSet ( ctl , testRepo.getRevWalk ( ) . parseCommit ( org.eclipse.jgit.lib.ObjectId.fromString ( rev ) ) ) ; assertProblems ( ctl , null , com.google.gerrit.acceptance.server.change.ConsistencyCheckerIT.problem ( ( ( "Multiple patch sets pointing to " + rev ) + ": [1, 2]" ) ) ) ; }
private com.google.gerrit.server.permissions.ProjectControl user ( com.google.gerrit.server.project.ProjectConfig local , java.lang.String name , com.google.gerrit.reviewdb.client.AccountGroup ... memberOf ) { return new com.google.gerrit.server.permissions.ProjectControl ( java.util.Collections.< com.google.gerrit.reviewdb.client.AccountGroup.UUID > emptySet ( ) , java.util.Collections.< com.google.gerrit.reviewdb.client.AccountGroup.UUID > emptySet ( ) , sectionSorter , changeControlFactory , permissionBackend , refFilterFactory , new com.google.gerrit.server.permissions.RefControlTest.MockUser ( name , memberOf ) , newProjectState ( local ) ) ; }
private java.util.List < com.google.gerrit.common.data.SubmitRecord > ruleError ( java.lang.String err , java.lang.Exception e ) { if ( logErrors ) { if ( e == null ) { com.google.gerrit.server.project.SubmitRuleEvaluator.log.error ( err ) ; } else { com.google.gerrit.server.project.SubmitRuleEvaluator.log.error ( err , e ) ; } return com.google.gerrit.server.project.SubmitRuleEvaluator.defaultRuleError ( ) ; } else { return com.google.gerrit.server.project.SubmitRuleEvaluator.createRuleError ( err ) ; } }
public void fire ( com.google.gerrit.extensions.common.ChangeInfo change , com.google.gerrit.extensions.common.AccountInfo editor , java.lang.String oldTopic , java.sql.Timestamp when ) { if ( ! ( listeners.iterator ( ) . hasNext ( ) ) ) { return ; } com.google.gerrit.server.extensions.events.TopicEdited.Event event = new com.google.gerrit.server.extensions.events.TopicEdited.Event ( change , editor , oldTopic , when ) ; for ( com.google.gerrit.extensions.events.TopicEditedListener l : listeners ) { try { l.onTopicEdited ( event ) ; } catch ( java.lang.Exception e ) { util.logEventListenerError ( com.google.gerrit.server.extensions.events.TopicEdited.log , e ) ; } } }
public java.util.Set < com.google.gerrit.reviewdb.client.AccountGroup.UUID > load ( java.lang.String key ) throws java.lang.Exception { try ( com.google.gerrit.reviewdb.server.ReviewDb db = schema.open ( ) ) { java.util.Set < com.google.gerrit.reviewdb.client.AccountGroup.UUID > ids = new java.util.HashSet < > ( ) ; for ( com.google.gerrit.reviewdb.client.AccountGroupById agi : db.accountGroupById ( ) . all ( ) ) { if ( ! ( com.google.gerrit.reviewdb.client.AccountGroup.isInternalGroup ( agi.getIncludeUUID ( ) ) ) ) { ids.add ( agi.getIncludeUUID ( ) ) ; } } return com.google.common.collect.ImmutableSet.copyOf ( ids ) ; } }
public void httpLink ( ) { com.google.gitiles.doc.MarkdownToHtml md = com.google.gitiles.doc.MarkdownToHtml.builder ( ) . setGitilesView ( view ) . setConfig ( new com.google.gitiles.doc.MarkdownConfig ( config ) ) . setFilePath ( "index.md" ) . build ( ) ; java.lang.String url ; url = "http://example.com/foo.html" ; com.google.common.truth.Truth.assertThat ( md.href ( url ) ) . isEqualTo ( url ) ; url = "https://example.com/foo.html" ; com.google.common.truth.Truth.assertThat ( md.href ( url ) ) . isEqualTo ( url ) ; url = "//example.com/foo.html" ; com.google.common.truth.Truth.assertThat ( md.href ( url ) ) . isEqualTo ( url ) ; }
private int finish ( final java.util.Iterator < com.google.gerrit.reviewdb.client.PatchLineComment > i , int row , final int col , boolean expandComment ) { while ( i.hasNext ( ) ) { final com.google.gerrit.reviewdb.client.PatchLineComment c = i.next ( ) ; if ( ( c.getLine ( ) ) == ( R_HEAD ) ) { insertFileCommentRow ( row ) ; } else { insertRow ( row ) ; } bindComment ( row , col , c , ( ! ( i.hasNext ( ) ) ) , expandComment ) ; row ++ ; } return row ; }
private HostPageData.Theme getTheme ( java.lang.String name ) { com.google.gerrit.common.data.HostPageData.Theme theme = new com.google.gerrit.common.data.HostPageData.Theme ( ) ; theme.backgroundColor = color ( name , "backgroundColor" , "#FCFEEF" ) ; theme.textColor = color ( name , "textColor" , "#000000" ) ; theme.trimColor = color ( name , "trimColor" , "#D4E9A9" ) ; theme.selectionColor = color ( name , "selectionColor" , "#FFFFCC" ) ; theme.topMenuColor = color ( name , "topMenuColor" , theme.trimColor ) ; return theme ; }
public com.google.gerrit.server.notedb.ChangeNotes call ( ) throws java.lang.Exception { com.google.common.base.Preconditions.checkArgument ( change.getProject ( ) . equals ( project ) , ( "passed project %s when creating ChangeNotes for %s," + " but actual project is %s" ) , project , changeId , change.getProject ( ) ) ; return new com.google.gerrit.server.notedb.ChangeNotes ( repoManager , migration , allUsers , changeNoteUtil , commentsUtil , project , change ) . load ( ) ; }
private java.lang.String getScopesKey ( javax.servlet.http.HttpServletRequest request , javax.servlet.http.HttpServletResponse response ) { java.lang.String scopeRequested = request.getParameter ( "scope" ) ; if ( scopeRequested == null ) { scopeRequested = getScopesKeyFromCookie ( request ) ; } if ( scopeRequested != null ) { javax.servlet.http.Cookie scopeCookie = new javax.servlet.http.Cookie ( "scope" , scopeRequested ) ; scopeCookie.setPath ( "/" ) ; scopeCookie.setMaxAge ( ( ( int ) ( com.googlesource.gerrit.plugins.github.oauth.GitHubLogin.SCOPE_COOKIE_NEVER_EXPIRES ) ) ) ; response.addCookie ( scopeCookie ) ; } return com.google.common.base.MoreObjects.firstNonNull ( scopeRequested , "scopes" ) ; }
public boolean updateChange ( com.google.gerrit.server.update.ChangeContext ctx ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gwtorm.server.OrmException { change = ctx.getChange ( ) ; com.google.gerrit.server.notedb.ChangeUpdate update = ctx.getUpdate ( change.currentPatchSetId ( ) ) ; com.google.gerrit.reviewdb.client.Account.Id currentAssigneeId = change.getAssignee ( ) ; if ( currentAssigneeId == null ) { return false ; } com.google.gerrit.server.IdentifiedUser deletedAssigneeUser = userFactory.create ( currentAssigneeId ) ; deletedAssignee = deletedAssigneeUser.state ( ) ; update.removeAssignee ( ) ; change.setAssignee ( null ) ; addMessage ( ctx , update , deletedAssigneeUser ) ; return true ; }
com.google.gerrit.metrics.dropwizard.DropWizardMetricMaker.HistogramImpl forceCreate ( java.lang.Object key ) { com.google.gerrit.metrics.dropwizard.DropWizardMetricMaker.HistogramImpl c = cells.get ( key ) ; if ( c != null ) { return c ; } synchronized ( lock ) { c = cells.get ( key ) ; if ( c == null ) { c = metrics.newHistogramImpl ( submetric ( key ) ) ; cells.put ( key , c ) ; } return c ; } }
public com.google.common.collect.ImmutableList < com.google.gerrit.reviewdb.client.AccountGroup > all ( ) { try ( com.google.gerrit.reviewdb.server.ReviewDb db = schema.open ( ) ) { return groups.getAll ( db ) . collect ( com.google.common.collect.ImmutableList.toImmutableList ( ) ) ; } catch ( com.google.gwtorm.server.OrmException e ) { com.google.gerrit.server.account.GroupCacheImpl.log.warn ( "Cannot list internal groups" , e ) ; return com.google.common.collect.ImmutableList.of ( ) ; } }
public void testGetItsAssociationPolicyMandatory ( ) { com.googlesource.gerrit.plugins.hooks.its.ItsConfig itsConfig = createItsConfig ( ) ; org.easymock.EasyMock.expect ( serverConfig.getString ( "ItsTestName" , null , "commentlink" ) ) . andReturn ( null ) . atLeastOnce ( ) ; org.easymock.EasyMock.expect ( serverConfig.getEnum ( "commentlink" , "ItsTestName" , "association" , ItsAssociationPolicy.OPTIONAL ) ) . andReturn ( ItsAssociationPolicy.MANDATORY ) . atLeastOnce ( ) ; replayMocks ( ) ; assertEquals ( "Expected and generated associated policy do not match" , ItsAssociationPolicy.MANDATORY , itsConfig.getItsAssociationPolicy ( ) ) ; }
public void writeToConfig ( org.eclipse.jgit.lib.Config c ) { java.lang.String externalIdKey = key ( ) . get ( ) ; c.setString ( com.google.gerrit.server.account.externalids.ExternalId.EXTERNAL_ID_SECTION , externalIdKey , com.google.gerrit.server.account.externalids.ExternalId.ACCOUNT_ID_KEY , java.lang.Integer.toString ( accountId ( ) . get ( ) ) ) ; if ( ( email ( ) ) != null ) { c.setString ( com.google.gerrit.server.account.externalids.ExternalId.EXTERNAL_ID_SECTION , externalIdKey , com.google.gerrit.server.account.externalids.ExternalId.EMAIL_KEY , email ( ) ) ; } if ( ( password ( ) ) != null ) { c.setString ( com.google.gerrit.server.account.externalids.ExternalId.EXTERNAL_ID_SECTION , externalIdKey , com.google.gerrit.server.account.externalids.ExternalId.PASSWORD_KEY , password ( ) ) ; } }
public void run ( ) { cm.execCommand ( "selectAll" ) ; }
public com.google.gitiles.GitilesView.Builder setPathPart ( java.lang.String path ) { switch ( type ) { case PATH : case DIFF : com.google.common.base.Preconditions.checkState ( ( path != null ) , "cannot set null path on %s view" , type ) ; break ; case DESCRIBE : case REFS : case LOG : break ; default : com.google.common.base.Preconditions.checkState ( ( path == null ) , "cannot set path on %s view" , type ) ; break ; } this . path = ( path != null ) ? com.google.gitiles.GitilesView.maybeTrimLeadingAndTrailingSlash ( path ) : null ; return this ; }
protected void insert ( final int row , final com.google.gerrit.client.dashboards.DashboardInfo k ) { table.insertRow ( row ) ; applyDataRowStyle ( row ) ; final com.google.gwt.user.client.ui.FlexTable.FlexCellFormatter fmt = table.getFlexCellFormatter ( ) ; fmt.addStyleName ( row , 1 , Gerrit.RESOURCES.css ( ) . dataCell ( ) ) ; fmt.addStyleName ( row , 2 , Gerrit.RESOURCES.css ( ) . dataCell ( ) ) ; fmt.addStyleName ( row , 3 , Gerrit.RESOURCES.css ( ) . dataCell ( ) ) ; populate ( row , k ) ; }
public void revokedKeyDueToCompromise ( ) throws java.lang.Exception { com.google.gerrit.gpg.testutil.TestKey k = add ( com.google.gerrit.gpg.testutil.TestKeys.revokedCompromisedKey ( ) ) ; add ( com.google.gerrit.gpg.testutil.TestKeys.validKeyWithoutExpiration ( ) ) ; save ( ) ; assertProblems ( k , "Key is revoked (key material has been compromised): test6 compromised" ) ; org.bouncycastle.openpgp.PGPPublicKeyRing kr = removeRevokers ( k.getPublicKeyRing ( ) ) ; store.add ( kr ) ; save ( ) ; assertNoProblems ( kr.getPublicKey ( ) ) ; }
private static com.google.gerrit.extensions.restapi.BinaryResult compress ( com.google.gerrit.extensions.restapi.BinaryResult bin ) throws java.io.IOException { org.eclipse.jgit.util.TemporaryBuffer.Heap buf = com.google.gerrit.httpd.restapi.RestApiServlet.heap ( ( 20 << 20 ) ) ; java.util.zip.GZIPOutputStream gz = new java.util.zip.GZIPOutputStream ( buf ) ; bin.writeTo ( gz ) ; gz.close ( ) ; return com.google.gerrit.httpd.restapi.RestApiServlet.asBinaryResult ( buf ) . setContentType ( bin.getContentType ( ) ) ; }
public boolean isPrivateVisible ( com.google.gerrit.reviewdb.server.ReviewDb db , com.google.gerrit.server.query.change.ChangeData cd ) throws com.google.gwtorm.server.OrmException { return ( ( ( isOwner ( ) ) || ( isReviewer ( db , cd ) ) ) || ( getRefControl ( ) . canViewPrivateChanges ( ) ) ) || ( getUser ( ) . isInternalUser ( ) ) ; }
private static void updateHeadLocally ( org.eclipse.jgit.transport.URIish uri , java.lang.String newHead ) { try { org.eclipse.jgit.lib.Repository repo = new org.eclipse.jgit.internal.storage.file.FileRepository ( uri.getPath ( ) ) ; try { if ( newHead != null ) { org.eclipse.jgit.lib.RefUpdate u = repo.updateRef ( Constants.HEAD ) ; u.link ( newHead ) ; } } finally { repo.close ( ) ; } } catch ( java.io.IOException e ) { com.googlesource.gerrit.plugins.replication.ReplicationQueue.repLog.error ( java.lang.String.format ( "Failed to update HEAD of repository %s to %s" , uri.getPath ( ) , newHead ) , e ) ; } }
public void onFailure ( final java.lang.Throwable caught ) { text.setReadOnly ( false ) ; text.setFocus ( true ) ; save.setEnabled ( true ) ; cancel.setEnabled ( true ) ; discard.setEnabled ( true ) ; super . onFailure ( caught ) ; }
public void tearDown ( ) { if ( ( repo ) != null ) { repo.getRepository ( ) . close ( ) ; } if ( ( lifecycle ) != null ) { lifecycle.stop ( ) ; } requestContext.setContext ( null ) ; if ( ( db ) != null ) { db.close ( ) ; } com.google.gerrit.testutil.InMemoryDatabase.drop ( schemaFactory ) ; }
boolean filterMatch ( java.lang.String filter , com.google.gerrit.server.query.change.ChangeData changeData ) throws com.google.gerrit.index.query.QueryParseException , com.google.gwtorm.server.OrmException { com.google.common.base.Preconditions.checkNotNull ( filter ) ; com.google.gerrit.server.query.change.ChangeQueryBuilder qb = queryBuilder.asUser ( user.get ( ) ) ; com.google.gerrit.index.query.Predicate < com.google.gerrit.server.query.change.ChangeData > filterPredicate = qb.parse ( filter ) ; return filterPredicate.asMatchable ( ) . match ( changeData ) ; }
private PushOneCommit.Result createChange ( boolean conflicting ) throws java.lang.Exception { testRepo.reset ( "origin/master" ) ; java.lang.String file = ( conflicting ) ? "test.txt" : ( "test-" + ( count ) ) + ".txt" ; com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create ( db , admin.getIdent ( ) , testRepo , ( "Change " + ( count ) ) , file , ( "content " + ( count ) ) ) ; ( count ) ++ ; return push.to ( "refs/for/master" ) ; }
private void subWindowResolution ( ) { com.google.gerrit.testutil.TestTimeUtil.setClockStep ( 1 , java.util.concurrent.TimeUnit.SECONDS ) ; com.google.gerrit.common.TimeUtil.nowTs ( ) ; }
public void onSuccess ( final java.util.List < com.google.gerrit.reviewdb.AccountExternalId > result ) { java.lang.String userName = null ; for ( com.google.gerrit.reviewdb.AccountExternalId i : result ) { if ( i.isScheme ( com.google.gerrit.reviewdb.AccountExternalId.SCHEME_USERNAME ) ) { userName = i.getSchemeRest ( ) ; break ; } } com.google.gerrit.client.Gerrit.getUserAccount ( ) . setUserName ( userName ) ; userNameTxt.setText ( userName ) ; userNameTxt.setEnabled ( true ) ; }
private java.util.List < com.google.gerrit.reviewdb.client.Project > getChildren ( final com.google.gerrit.reviewdb.client.Project.NameKey parentName ) { final java.util.List < com.google.gerrit.reviewdb.client.Project > childProjects = new java.util.ArrayList < com.google.gerrit.reviewdb.client.Project > ( ) ; for ( final com.google.gerrit.reviewdb.client.Project.NameKey projectName : projectCache.all ( ) ) { final com.google.gerrit.server.project.ProjectState e = projectCache.get ( projectName ) ; if ( e == null ) { continue ; } if ( parentName.equals ( e.getProject ( ) . getParent ( allProjectsName ) ) ) { childProjects.add ( e.getProject ( ) ) ; } } return childProjects ; }
public void linkifyMessageUrl ( ) throws java.lang.Exception { com.google.gitiles.Linkifier l = new com.google.gitiles.Linkifier ( TestGitilesUrls.URLS ) ; org.junit.Assert.assertEquals ( com.google.common.collect.ImmutableList.of ( com.google.common.collect.ImmutableMap.of ( "text" , "http://my/url" , "url" , "http://my/url" ) ) , l.linkify ( com.google.gitiles.LinkifierTest.REQ , "http://my/url" ) ) ; org.junit.Assert.assertEquals ( com.google.common.collect.ImmutableList.of ( com.google.common.collect.ImmutableMap.of ( "text" , "https://my/url" , "url" , "https://my/url" ) ) , l.linkify ( com.google.gitiles.LinkifierTest.REQ , "https://my/url" ) ) ; org.junit.Assert.assertEquals ( com.google.common.collect.ImmutableList.of ( com.google.common.collect.ImmutableMap.of ( "text" , "foo " ) , com.google.common.collect.ImmutableMap.of ( "text" , "http://my/url" , "url" , "http://my/url" ) , com.google.common.collect.ImmutableMap.of ( "text" , " bar" ) ) , l.linkify ( com.google.gitiles.LinkifierTest.REQ , "foo http://my/url bar" ) ) ; org.junit.Assert.assertEquals ( com.google.common.collect.ImmutableList.of ( com.google.common.collect.ImmutableMap.of ( "text" , "foo " ) , com.google.common.collect.ImmutableMap.of ( "text" , "http://my/url" , "url" , "http://my/url" ) , com.google.common.collect.ImmutableMap.of ( "text" , " bar " ) , com.google.common.collect.ImmutableMap.of ( "text" , "http://my/other/url" , "url" , "http://my/other/url" ) , com.google.common.collect.ImmutableMap.of ( "text" , " baz" ) ) , l.linkify ( com.google.gitiles.LinkifierTest.REQ , "foo http://my/url bar http://my/other/url baz" ) ) ; }
public void description ( java.lang.String description ) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.server.change.PutDescription.Input in = new com.google.gerrit.server.change.PutDescription.Input ( ) ; in.description = description ; try { putDescription.apply ( revision , in ) ; } catch ( com.google.gerrit.server.update.UpdateException | com.google.gerrit.server.permissions.PermissionBackendException e ) { throw new com.google.gerrit.extensions.restapi.RestApiException ( "Cannot set description" , e ) ; } }
public void onResize ( com.google.gwt.event.logical.shared.ResizeEvent event ) { if ( ( cmA ) != null ) { cmA.setHeight ( ( ( event.getHeight ( ) ) - ( com.google.gerrit.client.diff.SideBySide2.HEADER_FOOTER ) ) ) ; cmA.refresh ( ) ; } if ( ( cmB ) != null ) { cmB.setHeight ( ( ( event.getHeight ( ) ) - ( com.google.gerrit.client.diff.SideBySide2.HEADER_FOOTER ) ) ) ; cmB.refresh ( ) ; } resizeBoxPaddings ( ) ; }
protected void configure ( ) { com.google.gerrit.extensions.registration.DynamicSet.bind ( binder ( ) , com.google.gerrit.extensions.events.GitReferenceUpdatedListener.class ) . to ( com.googlesource.gerrit.plugins.repositoryuse.EventHandler.class ) ; requestStaticInjection ( com.googlesource.gerrit.plugins.repositoryuse.Config.class ) ; requestStaticInjection ( Ref.Table.class ) ; requestStaticInjection ( Usage.Table.class ) ; install ( new com.google.inject.assistedinject.FactoryModuleBuilder ( ) . implement ( com.googlesource.gerrit.plugins.repositoryuse.RefUpdateHandler.class , com.googlesource.gerrit.plugins.repositoryuse.RefUpdateHandlerImpl.class ) . build ( com.googlesource.gerrit.plugins.repositoryuse.RefUpdateHandlerFactory.class ) ) ; bind ( com.google.gerrit.extensions.events.LifecycleListener.class ) . annotatedWith ( com.google.inject.internal.UniqueAnnotations.create ( ) ) . to ( com.googlesource.gerrit.plugins.repositoryuse.SQLDriver.class ) ; }
public com.google.gerrit.extensions.restapi.Response < com.google.gerrit.extensions.common.SshKeyInfo > apply ( com.google.gerrit.server.account.AccountResource rsrc , com.google.gerrit.extensions.common.SshKeyInput input ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.extensions.restapi.BadRequestException , com.google.gerrit.server.permissions.PermissionBackendException , com.google.gwtorm.server.OrmException , java.io.IOException , org.eclipse.jgit.errors.ConfigInvalidException { if ( ( self.get ( ) ) != ( rsrc.getUser ( ) ) ) { permissionBackend.user ( self ) . check ( GlobalPermission.ADMINISTRATE_SERVER ) ; } return apply ( rsrc.getUser ( ) , input ) ; }
void setDiffPrefs ( final com.google.gerrit.extensions.client.DiffPreferencesInfo dp ) { diffPrefs = dp ; context = diffPrefs.context ; if ( ( context ) == ( com.google.gerrit.extensions.client.DiffPreferencesInfo.WHOLE_FILE_CONTEXT ) ) { context = com.google.gerrit.server.patch.PatchScriptBuilder.MAX_CONTEXT ; } else if ( ( context ) > ( com.google.gerrit.server.patch.PatchScriptBuilder.MAX_CONTEXT ) ) { context = com.google.gerrit.server.patch.PatchScriptBuilder.MAX_CONTEXT ; } }
public void deleteBranchesNotFound ( ) throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DeleteBranchesInput input = new com.google.gerrit.extensions.api.projects.DeleteBranchesInput ( ) ; java.util.List < java.lang.String > branches = com.google.common.collect.Lists.newArrayList ( com.google.gerrit.acceptance.rest.project.DeleteBranchesIT.BRANCHES ) ; branches.add ( "refs/heads/does-not-exist" ) ; input.branches = branches ; try { project ( ) . deleteBranches ( input ) ; org.junit.Assert.fail ( "Expected ResourceConflictException" ) ; } catch ( com.google.gerrit.extensions.restapi.ResourceConflictException e ) { com.google.common.truth.Truth.assertThat ( e ) . hasMessageThat ( ) . isEqualTo ( errorMessageForBranches ( com.google.common.collect.ImmutableList.of ( "refs/heads/does-not-exist" ) ) ) ; } assertBranchesDeleted ( ) ; }
private boolean isMergeable ( com.google.gerrit.reviewdb.Change c ) throws com.google.gwtorm.client.OrmException { final com.google.gerrit.server.git.CodeReviewCommit commit = commits.get ( c.getId ( ) ) ; final com.google.gerrit.server.git.CommitMergeStatus s = ( commit != null ) ? commit.statusCode : null ; boolean isMergeable = false ; if ( ( s != null ) && ( ( ( s.equals ( CommitMergeStatus.CLEAN_MERGE ) ) || ( s.equals ( CommitMergeStatus.CLEAN_PICK ) ) ) || ( s.equals ( CommitMergeStatus.ALREADY_MERGED ) ) ) ) { isMergeable = true ; } return isMergeable ; }
static com.google.gerrit.acceptance.GerritServer.Description forTestClass ( com.google.gerrit.acceptance.Description testDesc , java.lang.String configName ) { return new com.google.gerrit.acceptance.AutoValue_GerritServer_Description ( configName , true , ( ! ( com.google.gerrit.acceptance.GerritServer.Description.has ( com.google.gerrit.acceptance.NoHttpd.class , testDesc.getTestClass ( ) ) ) ) , com.google.gerrit.acceptance.GerritServer.Description.has ( com.google.gerrit.acceptance.Sandboxed.class , testDesc.getTestClass ( ) ) , null , null ) ; }
void onHideTaggedComments ( @ java.lang.SuppressWarnings ( value = "unused" ) com.google.gwt.event.dom.client.ClickEvent e ) { hideTaggedComments.setVisible ( false ) ; showTaggedComments.setVisible ( true ) ; int n = history.getWidgetCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { com.google.gerrit.client.change.Message m = ( ( com.google.gerrit.client.change.Message ) ( history.getWidget ( i ) ) ) ; if ( ( m.getMessageInfo ( ) . tag ( ) ) != null ) { m.setVisible ( false ) ; } } }
private void setupCommonMocks ( ) { org.easymock.EasyMock.expect ( itsConfig.getIssuePattern ( ) ) . andReturn ( java.util.regex.Pattern.compile ( "bug#(\\d+)" ) ) . anyTimes ( ) ; com.google.gerrit.reviewdb.client.Project.NameKey projectNK = new com.google.gerrit.reviewdb.client.Project.NameKey ( "myProject" ) ; org.easymock.EasyMock.expect ( itsConfig.isEnabled ( projectNK , null ) ) . andReturn ( true ) . anyTimes ( ) ; }
public static int findApproval ( com.googlecode.prolog_cafe.lang.Prolog engine , int minVoteLevel ) { try { com.google.gerrit.server.account.AccountCache accountCache = StoredValues.ACCOUNT_CACHE.get ( engine ) ; com.google.gerrit.server.account.Accounts accounts = StoredValues.ACCOUNTS.get ( engine ) ; com.google.gerrit.server.query.change.ChangeData changeData = StoredValues.CHANGE_DATA.get ( engine ) ; org.eclipse.jgit.lib.Repository repository = StoredValues.REPOSITORY.get ( engine ) ; return new com.googlesource.gerrit.plugins.findowners.Checker ( repository , changeData , minVoteLevel ) . findApproval ( accountCache , accounts ) ; } catch ( com.google.gwtorm.server.OrmException e ) { com.googlesource.gerrit.plugins.findowners.Checker.log.error ( "Exception" , e ) ; return 0 ; } }
private javax.net.ssl.SSLContext buildSslContext ( ) { try { javax.net.ssl.TrustManager [ ] trustAllCerts = new javax.net.ssl.TrustManager [ ] { new com.ericsson.gerrit.plugins.highavailability.HttpClientProvider.DummyX509TrustManager ( ) } ; javax.net.ssl.SSLContext context = javax.net.ssl.SSLContext.getInstance ( "TLS" ) ; context.init ( null , trustAllCerts , null ) ; return context ; } catch ( java.security.KeyManagementException | java.security.NoSuchAlgorithmException e ) { com.ericsson.gerrit.plugins.highavailability.HttpClientProvider.log.warn ( "Error building SSLContext object" , e ) ; return null ; } }
private boolean hasOneParent ( org.eclipse.jgit.revwalk.RevWalk rw , com.google.gerrit.reviewdb.client.PatchSet ps ) throws java.io.IOException { org.eclipse.jgit.revwalk.RevCommit c = rw.parseCommit ( org.eclipse.jgit.lib.ObjectId.fromString ( ps.getRevision ( ) . get ( ) ) ) ; return ( c.getParentCount ( ) ) == 1 ; }
protected void parseCommandLine ( ) throws com.google.gerrit.sshd.commands.UnloggedFailure { processor.setOutput ( out , OutputFormat.TEXT ) ; super . parseCommandLine ( ) ; if ( ( processor.getIncludeFiles ( ) ) && ( ! ( ( processor.getIncludePatchSets ( ) ) || ( processor.getIncludeCurrentPatchSet ( ) ) ) ) ) { throw new com.google.gerrit.sshd.commands.UnloggedFailure ( 1 , "--files option needs --patch-sets or --current-patch-set" ) ; } }
protected void configure ( ) { factory ( ReviewerResource.Factory.class ) ; factory ( AccountInfo.Loader.Factory.class ) ; factory ( EmailReviewComments.Factory.class ) ; factory ( ChangeInserter.Factory.class ) ; factory ( PatchSetInserter.Factory.class ) ; factory ( ChangeEdits.Create.Factory.class ) ; }
private void addEmail ( java.lang.String email ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.sshd.commands.UnloggedFailure , com.google.gwtorm.server.OrmException { com.google.gerrit.extensions.api.accounts.EmailInput in = new com.google.gerrit.extensions.api.accounts.EmailInput ( ) ; in.email = email ; in.noConfirmation = true ; try { createEmailFactory.create ( email ) . apply ( rsrc , in ) ; } catch ( com.google.gerrit.common.errors.EmailException e ) { throw die ( e.getMessage ( ) ) ; } }
protected void configureServlets ( ) { rpc ( com.google.gerrit.server.rpc.AccountServiceImpl.class ) ; rpc ( com.google.gerrit.server.rpc.AccountSecurityImpl.class ) ; rpc ( com.google.gerrit.server.rpc.GroupAdminServiceImpl.class ) ; rpc ( com.google.gerrit.server.rpc.ChangeListServiceImpl.class ) ; rpc ( com.google.gerrit.server.rpc.ChangeManageServiceImpl.class ) ; rpc ( com.google.gerrit.server.patch.PatchDetailServiceImpl.class ) ; rpc ( com.google.gerrit.server.rpc.ProjectAdminServiceImpl.class ) ; rpc ( com.google.gerrit.server.rpc.SuggestServiceImpl.class ) ; rpc ( com.google.gerrit.server.rpc.SystemInfoServiceImpl.class ) ; install ( new com.google.gerrit.server.rpc.changedetail.ChangeDetailModule ( ) ) ; }
public void onFailure ( final java.lang.Throwable caught ) { text.setReadOnly ( false ) ; text.setFocus ( true ) ; save.setEnabled ( true ) ; cancel.setEnabled ( true ) ; discard.setEnabled ( true ) ; super . onFailure ( caught ) ; onSave.onFailure ( caught ) ; }
public void onSuccess ( final com.google.gwtjsonrpc.client.VoidResult result ) { for ( int row = 1 ; row < ( table.getRowCount ( ) ) ; ) { final com.google.gerrit.client.account.AccountProjectWatchInfo k = getRowItem ( row ) ; if ( ( k != null ) && ( ids.contains ( k.getWatch ( ) . getKey ( ) ) ) ) { table.removeRow ( row ) ; } else { row ++ ; } } }
private static com.google.gerrit.server.account.AccountState missing ( com.google.gerrit.reviewdb.client.Account.Id accountId ) { com.google.gerrit.reviewdb.client.Account account = new com.google.gerrit.reviewdb.client.Account ( accountId , com.google.gerrit.common.TimeUtil.nowTs ( ) ) ; java.util.Collection < com.google.gerrit.reviewdb.client.AccountExternalId > ids = java.util.Collections.emptySet ( ) ; java.util.Set < com.google.gerrit.reviewdb.client.AccountGroup.UUID > anon = com.google.common.collect.ImmutableSet.of ( ) ; return new com.google.gerrit.server.account.AccountState ( account , anon , ids ) ; }
public boolean is ( com.google.gerrit.reviewdb.client.BooleanProjectConfig config ) { for ( com.google.gerrit.server.project.ProjectState s : tree ( ) ) { switch ( s.getProject ( ) . getBooleanConfig ( config ) ) { case TRUE : return true ; case FALSE : return false ; case INHERIT : default : continue ; } } return false ; }
public void testVerifyAgainstDifferentObjectId ( ) throws java.lang.Exception { com.googlesource.gerrit.plugins.lfs.fs.LfsFsRequestAuthorizer.AuthInfo info = auth.generateAuthInfo ( "o" , org.eclipse.jgit.lfs.lib.LongObjectId.zeroId ( ) , 1 ) ; com.google.common.truth.Truth.assertThat ( auth.verifyAuthInfo ( info.authToken , "o" , org.eclipse.jgit.lfs.lib.LongObjectId.fromString ( ( "123456789012345678901234567890" + ( "123456789012345678901234567890" + "1234" ) ) ) ) ) . isFalse ( ) ; }
public SiteIndexer.Result indexAll ( final com.google.gerrit.index.project.ProjectIndex index ) { org.eclipse.jgit.lib.ProgressMonitor progress = new org.eclipse.jgit.lib.TextProgressMonitor ( new java.io.PrintWriter ( progressOut ) ) ; progress.start ( 2 ) ; java.util.List < com.google.gerrit.reviewdb.client.Project.NameKey > names = collectProjects ( progress ) ; return reindexProjects ( index , names , progress ) ; }
public void testBulletList4 ( ) { final com.google.gwtexpui.safehtml.client.SafeHtml o = com.google.gwtexpui.safehtml.client.SafeHtml_WikifyListTest.html ( ( "To see this bug, you have to:\n" + ( "* Be on IMAP or EAS (not on POP)\n" + "* Be very unlucky\n" ) ) ) ; final com.google.gwtexpui.safehtml.client.SafeHtml n = o.wikify ( ) ; com.google.common.truth.Truth.assertThat ( o ) . isNotSameAs ( n ) ; com.google.common.truth.Truth.assertThat ( n.asString ( ) ) . isEqualTo ( ( ( ( ( "<p>To see this bug, you have to:</p>" + ( com.google.gwtexpui.safehtml.client.SafeHtml_WikifyListTest.BEGIN_LIST ) ) + ( com.google.gwtexpui.safehtml.client.SafeHtml_WikifyListTest.item ( "Be on IMAP or EAS (not on POP)" ) ) ) + ( com.google.gwtexpui.safehtml.client.SafeHtml_WikifyListTest.item ( "Be very unlucky" ) ) ) + ( com.google.gwtexpui.safehtml.client.SafeHtml_WikifyListTest.END_LIST ) ) ) ; }
private com.google.protobuf.ByteString deflate ( final byte [ ] buf ) { final com.google.protobuf.ByteString.Output r = com.google.protobuf.ByteString.newOutput ( ) ; final java.util.zip.DeflaterOutputStream out ; out = new java.util.zip.DeflaterOutputStream ( r , patchDeflater ) ; try { out.write ( buf ) ; out.close ( ) ; } catch ( java.io.IOException err ) { throw new com.google.codereview.manager.StopProcessingException ( "Unexpected IO error" , err ) ; } finally { patchDeflater.reset ( ) ; } return r.toByteString ( ) ; }
private static boolean onSupportedJavaVersion ( ) { final java.lang.String version = java.lang.System.getProperty ( "java.specification.version" ) ; if ( 1.8 <= ( Main.parse ( version ) ) ) { return true ; } java.lang.System.err.println ( "fatal: Gerrit Code Review requires Java 8 or later" ) ; java.lang.System.err.println ( ( ( " (trying to run on Java " + version ) + ")" ) ) ; return false ; }
public java.util.concurrent.ScheduledThreadPoolExecutor get ( ) { final java.util.concurrent.ScheduledThreadPoolExecutor executor ; executor = queues.createQueue ( poolSize , "SSH-Stream-Worker" ) ; final java.util.concurrent.ThreadFactory parent = executor.getThreadFactory ( ) ; executor.setThreadFactory ( new java.util.concurrent.ThreadFactory ( ) { @ java.lang.Override public java.lang.Thread newThread ( java.lang.Runnable task ) { final java.lang.Thread t = parent.newThread ( task ) ; t.setPriority ( java.lang.Thread.MIN_PRIORITY ) ; return t ; } } ) ; return executor ; }
private java.lang.String getGerritHost ( ) { if ( ( getGerritUrl ( ) ) != null ) { try { return new java.net.URL ( getGerritUrl ( ) ) . getHost ( ) ; } catch ( java.net.MalformedURLException e ) { } } return org.spearce.jgit.util.SystemReader.getInstance ( ) . getHostname ( ) ; }
private java.util.Set < com.google.gerrit.reviewdb.client.Account.Id > getReviewers ( java.lang.String changeId ) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.common.ChangeInfo ci = gApi.changes ( ) . id ( changeId ) . get ( ) ; java.util.Set < com.google.gerrit.reviewdb.client.Account.Id > result = com.google.common.collect.Sets.newHashSet ( ) ; for ( com.google.gerrit.extensions.common.LabelInfo li : ci.labels.values ( ) ) { for ( com.google.gerrit.extensions.common.ApprovalInfo ai : li.all ) { result.add ( new com.google.gerrit.reviewdb.client.Account.Id ( ai._accountId ) ) ; } } return result ; }
protected void configure ( ) { bind ( com.google.gerrit.acceptance.AccountCreator.class ) ; factory ( PushOneCommit.Factory.class ) ; factory ( SubmoduleOp.Factory.class ) ; install ( com.google.gerrit.acceptance.InProcessProtocol.module ( ) ) ; install ( new com.google.gerrit.server.ssh.NoSshModule ( ) ) ; install ( new com.google.gerrit.server.git.AsyncReceiveCommits.Module ( ) ) ; }
private void setOnline ( boolean online ) { this . online = online ; setUp ( ) ; if ( ! online ) { checkConnTask = pool.scheduleWithFixedDelay ( new com.ericsson.gerrit.plugins.eventslog.sql.SQLStore.CheckConnectionTask ( ) , 0 , connectTime , java.util.concurrent.TimeUnit.MILLISECONDS ) ; } else { cancelCheckConnectionTaskIfScheduled ( false ) ; } }
protected void configure ( ) { factory ( AbandonChangeHandler.Factory.class ) ; factory ( RestoreChangeHandler.Factory.class ) ; factory ( RevertChange.Factory.class ) ; factory ( ChangeDetailFactory.Factory.class ) ; factory ( IncludedInDetailFactory.Factory.class ) ; factory ( PatchSetDetailFactory.Factory.class ) ; factory ( PatchSetPublishDetailFactory.Factory.class ) ; factory ( SubmitAction.Factory.class ) ; factory ( PublishAction.Factory.class ) ; factory ( DeleteDraftChange.Factory.class ) ; }
protected void configure ( ) { final com.google.gerrit.sshd.CommandName gerrit = com.google.gerrit.sshd.Commands.named ( "gerrit" ) ; command ( gerrit , "approve" ) . to ( com.google.gerrit.sshd.commands.ErrorSlaveMode.class ) ; command ( gerrit , "create-project" ) . to ( com.google.gerrit.sshd.commands.ErrorSlaveMode.class ) ; command ( gerrit , "gsql" ) . to ( com.google.gerrit.sshd.commands.ErrorSlaveMode.class ) ; command ( gerrit , "receive-pack" ) . to ( com.google.gerrit.sshd.commands.ErrorSlaveMode.class ) ; command ( gerrit , "replicate" ) . to ( com.google.gerrit.sshd.commands.ErrorSlaveMode.class ) ; }
public void isEnabledForRegexRef ( ) throws java.lang.Exception { com.googlesource.gerrit.plugins.uploadvalidator.ValidatorConfig config = getConfig ( ( "[plugin \"uploadvalidator\"]\n" + ( " ref = ^refs/heads/mybranch.*\n" + " blockedFileExtension = jar" ) ) ) ; com.google.common.truth.Truth.assertThat ( config.isEnabledForRef ( projectName , "refs/heads/anotherref" , "blockedFileExtension" ) ) . isFalse ( ) ; com.google.common.truth.Truth.assertThat ( config.isEnabledForRef ( projectName , "refs/heads/mybranch123" , "blockedFileExtension" ) ) . isTrue ( ) ; }
private void insertEmptyLines ( net.codemirror.lib.CodeMirror cm , int nextLine , int cnt ) { addPaddingWidget ( cm , diffTable.style.padding ( ) , ( nextLine - 1 ) , cnt , Unit.EM ) ; }
private static java.util.List < java.lang.String > parseChangeTableColumns ( org.eclipse.jgit.lib.Config cfg , @ com.google.gerrit.common.Nullable org.eclipse.jgit.lib.Config defaultCfg ) { java.util.List < java.lang.String > changeTable = com.google.gerrit.server.account.Preferences.changeTable ( cfg ) ; if ( ( changeTable == null ) && ( defaultCfg != null ) ) { changeTable = com.google.gerrit.server.account.Preferences.changeTable ( defaultCfg ) ; } return changeTable ; }
public void testUsernamePatternWithRegex ( ) { com.google.gerrit.server.project.Util.allow ( local , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.project.Util.DEVS , "^refs/sb/${username}/heads/.*" ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , "d.v" , com.google.gerrit.server.project.Util.DEVS ) ; com.google.gerrit.server.project.ProjectControl d = util.user ( local , "dev" , com.google.gerrit.server.project.Util.DEVS ) ; assertCannotRead ( "refs/sb/dev/heads/foobar" , u ) ; assertCanRead ( "refs/sb/dev/heads/foobar" , d ) ; }
private java.lang.String buildText ( java.lang.String pathAndQuery , java.lang.String expectedMode ) throws java.lang.Exception { com.google.gitiles.TestViewFilter.Result res = service ( pathAndQuery ) ; org.junit.Assert.assertEquals ( "text/plain" , res.getResponse ( ) . getHeader ( com.google.common.net.HttpHeaders.CONTENT_TYPE ) ) ; org.junit.Assert.assertEquals ( expectedMode , res.getResponse ( ) . getHeader ( PathServlet.MODE_HEADER ) ) ; return res.getResponse ( ) . getActualBodyString ( ) ; }
public void writeNoChanges ( ) throws java.lang.Exception { org.junit.Assert.assertEquals ( RefUpdate.Result.NEW , modifier.createEdit ( change , ps ) ) ; try { modifier.modifyFile ( editUtil.byChange ( change ) . get ( ) , com.google.gerrit.acceptance.edit.ChangeEditIT.FILE_NAME , com.google.gerrit.acceptance.edit.ChangeEditIT.CONTENT_OLD ) ; org.junit.Assert.fail ( ) ; } catch ( com.google.gerrit.server.project.InvalidChangeOperationException e ) { org.junit.Assert.assertEquals ( "no changes were made" , e.getMessage ( ) ) ; } }
public void defaultGroupsCreated_ssh ( ) throws java.lang.Exception { com.google.gerrit.acceptance.SshSession session = new com.google.gerrit.acceptance.SshSession ( server , admin ) ; java.lang.String result = session.exec ( "gerrit ls-groups" ) ; com.google.common.truth.Truth.assert_ ( ) . withFailureMessage ( session.getError ( ) ) . that ( session.hasError ( ) ) . isFalse ( ) ; com.google.common.truth.Truth.assertThat ( result ) . contains ( "Administrators" ) ; com.google.common.truth.Truth.assertThat ( result ) . contains ( "Non-Interactive Users" ) ; session.close ( ) ; }
private com.google.gerrit.server.project.ChangeControl controlFor ( com.google.gerrit.server.change.RevisionResource rsrc , com.google.gerrit.reviewdb.client.Change.Id id ) throws com.google.gwtorm.server.OrmException { if ( rsrc.getChange ( ) . getId ( ) . equals ( id ) ) { return rsrc.getControl ( ) ; } com.google.gerrit.server.notedb.ChangeNotes notes = notesFactory.create ( dbProvider.get ( ) , rsrc.getProject ( ) , id ) ; return rsrc.getControl ( ) . getProjectControl ( ) . controlFor ( notes ) ; }
public void addReviewer ( ) throws com.google.gerrit.extensions.restapi.RestApiException , java.io.IOException , org.eclipse.jgit.api.errors.GitAPIException { com.google.gerrit.acceptance.PushOneCommit.Result r = createChange ( ) ; com.google.gerrit.extensions.api.changes.AddReviewerInput in = new com.google.gerrit.extensions.api.changes.AddReviewerInput ( ) ; in.reviewer = user.email ; com.google.gerrit.extensions.api.changes.ChangeApi cApi = gApi.changes ( ) . id ( ( "p~master~" + ( r.getChangeId ( ) ) ) ) ; cApi.addReviewer ( in ) ; org.junit.Assert.assertEquals ( com.google.common.collect.ImmutableSet.of ( user.id ) , com.google.gerrit.acceptance.api.change.ChangeIT.getReviewers ( cApi.get ( ) ) ) ; }
public void testUnblockVisibilityByREGISTEREDUsers ( ) { com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.project.Util.ANONYMOUS , "refs/heads/*" ) . setBlock ( ) ; com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.project.Util.REGISTERED , "refs/heads/*" ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.project.Util.REGISTERED ) ; org.junit.Assert.assertTrue ( "u can read" , u.controlForRef ( "refs/heads/master" ) . isVisibleByRegisteredUsers ( ) ) ; }
public void testBlockRule_ParentBlocksChildEvenIfAlreadyBlockedInChild ( ) { com.google.gerrit.server.project.Util.allow ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.Util.DEVS , "refs/tags/*" ) ; com.google.gerrit.server.project.Util.block ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/tags/*" ) ; com.google.gerrit.server.project.Util.block ( parent , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/tags/*" ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.project.Util.DEVS ) ; org.junit.Assert.assertFalse ( "u can't update tag" , u.controlForRef ( "refs/tags/V10" ) . canUpdate ( ) ) ; }
private java.util.Map < java.lang.String , com.google.gerrit.reviewdb.client.PatchLineComment > patchSetDrafts ( com.google.gerrit.server.git.BatchUpdate.ChangeContext ctx ) throws com.google.gwtorm.server.OrmException { java.util.Map < java.lang.String , com.google.gerrit.reviewdb.client.PatchLineComment > drafts = new java.util.HashMap < > ( ) ; for ( com.google.gerrit.reviewdb.client.PatchLineComment c : plcUtil.draftByPatchSetAuthor ( ctx.getDb ( ) , psId , user.getAccountId ( ) , ctx.getNotes ( ) ) ) { drafts.put ( c.getKey ( ) . get ( ) , c ) ; } return drafts ; }
public void testGetMultiple ( ) throws java.lang.Exception { com.google.gerrit.gpg.testutil.TestKey key1 = com.google.gerrit.gpg.testutil.TestKey.key1 ( ) ; com.google.gerrit.gpg.testutil.TestKey key2 = com.google.gerrit.gpg.testutil.TestKey.key2 ( ) ; tr.branch ( com.google.gerrit.gpg.PublicKeyStore.REFS_GPG_KEYS ) . commit ( ) . add ( com.google.gerrit.gpg.PublicKeyStore.keyObjectId ( key1.getKeyId ( ) ) . name ( ) , ( ( key1.getPublicKeyArmored ( ) ) + ( key2.getPublicKeyArmored ( ) ) ) ) . create ( ) ; assertKeys ( key1.getKeyId ( ) , key1 , key2 ) ; }
private boolean isNew ( ) { return ( comment.id ( ) ) == null ; }
public void setUp ( ) { java.lang.String tz = "US/Eastern" ; systemTimeZoneProperty = java.lang.System.setProperty ( "user.timezone" , tz ) ; systemTimeZone = java.util.TimeZone.getDefault ( ) ; java.util.TimeZone.setDefault ( java.util.TimeZone.getTimeZone ( tz ) ) ; long maxMs = ChangeRebuilder.MAX_WINDOW_MS ; com.google.common.truth.Truth.assertThat ( maxMs ) . isGreaterThan ( 1000L ) ; com.google.gerrit.testutil.TestTimeUtil.resetWithClockStep ( ( maxMs * 2 ) , java.util.concurrent.TimeUnit.MILLISECONDS ) ; project = new com.google.gerrit.reviewdb.client.Project.NameKey ( "project" ) ; accountId = new com.google.gerrit.reviewdb.client.Account.Id ( 100 ) ; }
public void onSuccess ( com.googlesource.gerrit.plugins.verifystatus.client.ConfigInfo info ) { if ( info.showJobsSummaryPanel ( ) ) { com.google.gerrit.plugin.client.Plugin.get ( ) . panel ( GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK , new com.googlesource.gerrit.plugins.verifystatus.client.JobsSummaryPanel.Factory ( ) ) ; } if ( info.showJobsPanel ( ) ) { com.google.gerrit.plugin.client.Plugin.get ( ) . panel ( GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK , new com.googlesource.gerrit.plugins.verifystatus.client.JobsPanel.Factory ( ) ) ; } if ( info.showJobsDropDownPanel ( ) ) { com.google.gerrit.plugin.client.Plugin.get ( ) . panel ( GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS , new com.googlesource.gerrit.plugins.verifystatus.client.JobsDropDownPanel.Factory ( ) ) ; } }
public static java.lang.String refsUsers ( com.google.gerrit.reviewdb.client.Account.Id accountId ) { java.lang.StringBuilder r = new java.lang.StringBuilder ( ) ; r.append ( com.google.gerrit.reviewdb.client.RefNames.REFS_USERS ) ; r.append ( com.google.gerrit.reviewdb.client.RefNames.shard ( accountId.get ( ) ) ) ; return r.toString ( ) ; }
public void testSubscriptionToEmptyRepo ( ) throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository < ? > superRepo = createProjectWithPush ( "super-project" ) ; org.eclipse.jgit.junit.TestRepository < ? > subRepo = createProjectWithPush ( "subscribed-to-project" ) ; allowSubmoduleSubscription ( "subscribed-to-project" , "refs/heads/master" , "super-project" , "refs/heads/master" ) ; createSubmoduleSubscription ( superRepo , "master" , "subscribed-to-project" , "master" ) ; pushChangeTo ( subRepo , "master" ) ; org.eclipse.jgit.lib.ObjectId subHEAD = pushChangeTo ( subRepo , "master" ) ; com.google.common.truth.Truth.assertThat ( hasSubmodule ( superRepo , "master" , "subscribed-to-project" ) ) . isTrue ( ) ; expectToHaveSubmoduleState ( superRepo , "master" , "subscribed-to-project" , subHEAD ) ; }
private static boolean isReviewer ( final org.eclipse.jgit.revwalk.FooterLine candidateFooterLine ) { return ( ( ( candidateFooterLine.matches ( FooterKey.SIGNED_OFF_BY ) ) || ( candidateFooterLine.matches ( FooterKey.ACKED_BY ) ) ) || ( candidateFooterLine.matches ( FooterConstants.REVIEWED_BY ) ) ) || ( candidateFooterLine.matches ( FooterConstants.TESTED_BY ) ) ; }
public static boolean isChild ( final com.google.gerrit.server.ssh.CommandName parent , final com.google.gerrit.server.ssh.CommandName name ) { if ( name instanceof com.google.gerrit.server.ssh.Commands.NestedCommandNameImpl ) { return parent.equals ( ( ( com.google.gerrit.server.ssh.Commands.NestedCommandNameImpl ) ( name ) ) . parent ) ; } if ( parent == ( com.google.gerrit.server.ssh.Commands.CMD_ROOT ) ) { return true ; } return false ; }
public void run ( ) { net.codemirror.lib.CodeMirror.Viewport fromTo = cm.getViewport ( ) ; int size = ( ( fromTo.getTo ( ) ) - ( fromTo.getFrom ( ) ) ) + 1 ; if ( ( cm.getOldViewportSize ( ) ) == size ) { return ; } cm.setOldViewportSize ( size ) ; diffTable.sidePanel.adjustGutters ( cmB ) ; }
private void assertProblems ( com.google.gerrit.gpg.PublicKeyChecker checker , com.google.gerrit.gpg.testing.TestKey k , java.lang.String first , java.lang.String ... rest ) { com.google.gerrit.gpg.CheckResult result = checker.setStore ( store ) . check ( k.getPublicKey ( ) ) ; org.junit.Assert.assertEquals ( com.google.gerrit.gpg.PublicKeyCheckerTest.list ( first , rest ) , result.getProblems ( ) ) ; }
private static org.apache.lucene.store.Directory dir ( com.google.gerrit.index.Schema < com.google.gerrit.reviewdb.client.AccountGroup > schema , org.eclipse.jgit.lib.Config cfg , com.google.gerrit.server.config.SitePaths sitePaths ) throws java.io.IOException { if ( com.google.gerrit.lucene.LuceneIndexModule.isInMemoryTest ( cfg ) ) { return new org.apache.lucene.store.RAMDirectory ( ) ; } java.nio.file.Path indexDir = com.google.gerrit.lucene.LuceneVersionManager.getDir ( sitePaths , com.google.gerrit.lucene.LuceneGroupIndex.GROUPS , schema ) ; return org.apache.lucene.store.FSDirectory.open ( indexDir ) ; }
public void groupCannotBeRenamedWhenOldNameIsWrong ( ) throws java.lang.Exception { createGroup ( groupUuid , groupName ) ; com.google.gerrit.reviewdb.client.AccountGroup.NameKey anotherOldName = new com.google.gerrit.reviewdb.client.AccountGroup.NameKey ( "contributors" ) ; com.google.gerrit.reviewdb.client.AccountGroup.NameKey anotherName = new com.google.gerrit.reviewdb.client.AccountGroup.NameKey ( "admins" ) ; expectedException.expect ( org.eclipse.jgit.errors.ConfigInvalidException.class ) ; expectedException.expectMessage ( anotherOldName.get ( ) ) ; com.google.gerrit.server.group.db.GroupNameNotes.forRename ( repo , groupUuid , anotherOldName , anotherName ) ; }
public void onMouseMove ( com.google.gwt.event.dom.client.MouseMoveEvent event ) { int h = editArea.getOffsetHeight ( ) ; if ( ( isEdit ( ) ) && ( h != ( editAreaHeight ) ) ) { getCommentGroup ( ) . resize ( ) ; resizeTimer.scheduleRepeating ( 50 ) ; editAreaHeight = h ; } }
public com.google.gerrit.server.notedb.ChangeNotes createWithAutoRebuildingDisabled ( com.google.gerrit.reviewdb.client.Change change ) throws com.google.gwtorm.server.OrmException { return new com.google.gerrit.server.notedb.ChangeNotes ( args , change.getProject ( ) , change , false ) . load ( ) ; }
public void run ( ) { skipManager.removeAll ( ) ; clearMarkers ( ) ; diffTable.sidePanel.clearDiffGutters ( ) ; setShowIntraline ( prefs.intralineDifference ( ) ) ; render ( diff ) ; skipManager.render ( prefs.context ( ) , diff ) ; }
private com.google.gerrit.extensions.common.CommentInfo addDraft ( java.lang.String changeId , java.lang.String revId , com.google.gerrit.extensions.api.changes.DraftInput in ) throws java.lang.Exception { return gApi.changes ( ) . id ( changeId ) . revision ( revId ) . createDraft ( in ) . get ( ) ; }
public void missingOwner ( ) throws java.lang.Exception { com.google.gerrit.acceptance.TestAccount owner = accounts.create ( "missing" ) ; com.google.gerrit.server.project.ChangeControl ctl = insertChange ( owner ) ; db.accounts ( ) . deleteKeys ( java.util.Collections.singleton ( owner.getId ( ) ) ) ; assertProblems ( ctl , null , com.google.gerrit.acceptance.server.change.ConsistencyCheckerIT.problem ( ( "Missing change owner: " + ( owner.getId ( ) ) ) ) ) ; }
public void markReady ( boolean ready ) throws java.io.IOException { org.eclipse.jgit.storage.file.FileBasedConfig cfg = new org.eclipse.jgit.storage.file.FileBasedConfig ( com.google.gerrit.solr.IndexVersionCheck.solrIndexConfig ( sitePaths ) . toFile ( ) , org.eclipse.jgit.util.FS.detect ( ) ) ; for ( java.util.Map.Entry < java.lang.String , java.lang.Integer > e : com.google.gerrit.solr.IndexVersionCheck.SCHEMA_VERSIONS.entrySet ( ) ) { cfg.setInt ( "index" , e.getKey ( ) , "schemaVersion" , ( ready ? e.getValue ( ) : - 1 ) ) ; } cfg.save ( ) ; }
private static java.lang.String format ( com.google.gerrit.server.git.WorkQueue.Task.State state ) { switch ( state ) { case DONE : return "....... done" ; case CANCELLED : return "..... killed" ; case RUNNING : return "" ; case READY : return "waiting ...." ; case SLEEPING : return "sleeping" ; case OTHER : default : return state.toString ( ) ; } }
protected void configureServlets ( ) { rpc ( com.google.gerrit.server.rpc.AccountServiceImpl.class ) ; rpc ( com.google.gerrit.server.rpc.AccountSecurityImpl.class ) ; rpc ( com.google.gerrit.server.rpc.GroupAdminServiceImpl.class ) ; rpc ( com.google.gerrit.server.rpc.ChangeListServiceImpl.class ) ; rpc ( com.google.gerrit.server.rpc.SuggestServiceImpl.class ) ; rpc ( com.google.gerrit.server.rpc.SystemInfoServiceImpl.class ) ; install ( new com.google.gerrit.server.rpc.changedetail.ChangeDetailModule ( ) ) ; install ( new com.google.gerrit.server.patch.PatchModule ( ) ) ; install ( new com.google.gerrit.server.rpc.project.ProjectModule ( ) ) ; }
public com.google.gerrit.server.notedb.ChangeNotes createChecked ( com.google.gerrit.reviewdb.server.ReviewDb db , com.google.gerrit.reviewdb.client.Project.NameKey project , com.google.gerrit.reviewdb.client.Change.Id changeId ) throws com.google.gerrit.server.project.NoSuchChangeException , com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.Change change = com.google.gerrit.server.notedb.ChangeNotes.readOneReviewDbChange ( db , changeId ) ; if ( ( change == null ) || ( ! ( change.getProject ( ) . equals ( project ) ) ) ) { throw new com.google.gerrit.server.project.NoSuchChangeException ( changeId ) ; } return new com.google.gerrit.server.notedb.ChangeNotes ( args , change ) . load ( ) ; }
public void createdOnIsPopulatedForGroupsCreatedBeforeAudit ( ) throws java.lang.Exception { com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = createGroup ( "Ancient group for schema migration" ) ; setCreatedOnToVeryOldTimestamp ( groupId ) ; removeAuditEntriesFor ( groupId ) ; schema151.migrateData ( db , new com.google.gerrit.server.schema.Schema_150_to_151_Test.TestUpdateUI ( ) ) ; com.google.gerrit.reviewdb.client.AccountGroup group = db.accountGroups ( ) . get ( groupId ) ; com.google.common.truth.Truth.assertThat ( group.getCreatedOn ( ) ) . isEqualTo ( com.google.gerrit.reviewdb.client.AccountGroup.auditCreationInstantTs ( ) ) ; }
public void rebase ( ) throws com.google.gerrit.extensions.restapi.RestApiException , java.io.IOException , org.eclipse.jgit.api.errors.GitAPIException { com.google.gerrit.acceptance.git.PushOneCommit.Result r = createChange ( ) ; gApi.changes ( ) . id ( ( "p~master~" + ( r.getChangeId ( ) ) ) ) . revision ( r.getCommit ( ) . name ( ) ) . rebase ( ) ; }
public void onSuccess ( com.google.gerrit.client.diff.DiffInfo info ) { new net.codemirror.lib.ModeInjector ( ) . add ( getContentType ( info.meta_a ( ) ) ) . add ( getContentType ( info.meta_b ( ) ) ) . inject ( com.google.gerrit.client.rpc.CallbackGroup.< java.lang.Void > emptyCallback ( ) ) ; }
public void suggestReviewersWithoutLimitOptionSpecified ( ) throws java.lang.Exception { java.lang.String changeId = createChange ( ) . getChangeId ( ) ; java.lang.String query = user3.username ; java.util.List < com.google.gerrit.extensions.common.SuggestedReviewerInfo > suggestedReviewerInfos = gApi.changes ( ) . id ( changeId ) . suggestReviewers ( query ) . get ( ) ; com.google.common.truth.Truth.assertThat ( suggestedReviewerInfos ) . hasSize ( 1 ) ; }
private void checkRemoveReviewer ( com.google.gerrit.server.notedb.ChangeNotes notes , com.google.gerrit.server.CurrentUser currentUser , com.google.gerrit.reviewdb.client.Account.Id reviewer , int val ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.server.permissions.PermissionBackendException { if ( com.google.gerrit.server.project.RemoveReviewerControl.canRemoveReviewerWithoutPermissionCheck ( permissionBackend , notes.getChange ( ) , currentUser , reviewer , val ) ) { return ; } permissionBackend.user ( currentUser ) . change ( notes ) . database ( dbProvider ) . check ( ChangePermission.REMOVE_REVIEWER ) ; }
public java.util.Collection < com.google.gerrit.client.reviewdb.ProjectRight > getProjectRights ( final com.google.gerrit.client.reviewdb.ApprovalCategory.Id id ) { if ( ( projectRights ) == null ) { projectRights = com.google.gerrit.server.workflow.FunctionState.index ( project.getLocalRights ( ) ) ; } final java.util.Collection < com.google.gerrit.client.reviewdb.ProjectRight > l = projectRights.get ( id ) ; return l != null ? l : java.util.Collections.< com.google.gerrit.client.reviewdb.ProjectRight > emptySet ( ) ; }
public void defaultMessage ( ) throws com.google.gerrit.extensions.restapi.RestApiException , java.io.IOException , org.eclipse.jgit.api.errors.GitAPIException { java.lang.String changeId = createChange ( ) ; com.google.gerrit.extensions.common.ChangeInfo c = getChangeAll ( ( "p~master~" + changeId ) ) ; org.junit.Assert.assertNotNull ( c.messages ) ; org.junit.Assert.assertEquals ( 1 , c.messages.size ( ) ) ; org.junit.Assert.assertEquals ( "Uploaded patch set 1." , c.messages.iterator ( ) . next ( ) . message ) ; }
public static void createTableIfNotExists ( java.lang.String url ) throws com.google.gwtorm.server.OrmException { try ( java.sql.Connection con = java.sql.DriverManager.getConnection ( url ) ; java.sql.Statement stmt = con.createStatement ( ) ) { com.google.gerrit.server.schema.H2AccountPatchReviewStore.doCreateTable ( stmt ) ; } catch ( java.sql.SQLException e ) { throw com.google.gerrit.server.schema.H2AccountPatchReviewStore.convertError ( "create" , e ) ; } }
public void bothDateTime ( ) throws java.lang.Exception { java.util.Map < java.lang.String , java.lang.String > params = new java.util.HashMap < > ( ) ; params.put ( "t1" , "2013-10-10 10:00:00" ) ; params.put ( "t2" , "2014-10-10 10:00:00" ) ; java.lang.String query = com.ericsson.gerrit.plugins.eventslog.QueryMakerTest.queryMaker.formQueryFromRequestParameters ( params ) ; com.google.common.truth.Truth.assertThat ( query ) . isNotEqualTo ( com.ericsson.gerrit.plugins.eventslog.QueryMakerTest.defaultQuery ) ; }
public void parseInvalidWatchConfig ( ) throws java.lang.Exception { org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config ( ) ; cfg.fromText ( ( "[project \"myProject\"]\n" + ( ( ( " notify = * [ALL_COMMENTS, NEW_PATCHSETS]\n" + " notify = branch:master [INVALID, NEW_CHANGES]\n" ) + "[project \"otherProject\"]\n" ) + " notify = [NEW_PATCHSETS]\n" ) ) ) ; com.google.gerrit.server.account.ProjectWatches.parse ( new com.google.gerrit.reviewdb.client.Account.Id ( 1000000 ) , cfg , this ) ; com.google.common.truth.Truth.assertThat ( validationErrors ) . hasSize ( 1 ) ; com.google.common.truth.Truth.assertThat ( validationErrors.get ( 0 ) . getMessage ( ) ) . isEqualTo ( ( "watch.config: Invalid notify type INVALID in project watch of" + ( " account 1000000 for project myProject: branch:master" + " [INVALID, NEW_CHANGES]" ) ) ) ; }
private void executePostOps ( ) throws java.lang.Exception { com.google.gerrit.server.git.BatchUpdate.Context ctx = new com.google.gerrit.server.git.BatchUpdate.Context ( ) ; for ( com.google.gerrit.server.git.BatchUpdate.Op op : ops.values ( ) ) { op.postUpdate ( ctx ) ; } for ( com.google.gerrit.server.git.BatchUpdate.RepoOnlyOp op : repoOnlyOps ) { op.postUpdate ( ctx ) ; } }
void onSave ( @ java.lang.SuppressWarnings ( value = "unused" ) com.google.gwt.event.dom.client.ClickEvent e ) { save ( ) . run ( ) ; }
public java.lang.String getSqlType ( final com.google.gwtorm.schema.ColumnModel col , final com.google.gwtorm.schema.sql.SqlDialect dialect ) { final java.lang.StringBuilder r = new java.lang.StringBuilder ( ) ; r.append ( dialect.getSqlTypeName ( getSqlTypeConstant ( ) ) ) ; if ( col.isNotNull ( ) ) { r.append ( " DEFAULT ''" ) ; r.append ( " NOT NULL" ) ; } return r.toString ( ) ; }
public void changeMessageWithTrailingDoubleNewline ( ) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Change c = newChange ( ) ; com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate ( c , changeOwner ) ; update.setChangeMessage ( ( "Testing trailing double newline\n" + "\n" ) ) ; update.commit ( ) ; assertBodyEquals ( ( "Update patch set 1\n" + ( ( ( ( ( "\n" + "Testing trailing double newline\n" ) + "\n" ) + "\n" ) + "\n" ) + "Patch-set: 1\n" ) ) , update.getResult ( ) ) ; }
protected void includeWatchers ( com.google.gerrit.reviewdb.client.AccountProjectWatch.NotifyType type ) { try { com.google.gerrit.server.mail.ProjectWatch.Watchers matching = getWatchers ( type ) ; add ( RecipientType.TO , matching.to ) ; add ( RecipientType.CC , matching.cc ) ; add ( RecipientType.BCC , matching.bcc ) ; } catch ( com.google.gwtorm.server.OrmException err ) { com.google.gerrit.server.mail.ChangeEmail.log.warn ( ( "Cannot BCC watchers for " + type ) , err ) ; } }
public static com.google.gerrit.extensions.events.LifecycleListener start ( final java.nio.file.Path sitePath , final org.eclipse.jgit.lib.Config config ) throws java.io.IOException { java.nio.file.Path logdir = com.google.gerrit.common.FileUtil.mkdirsOrDie ( new com.google.gerrit.server.config.SitePaths ( sitePath ) . logs_dir , "Cannot create log directory" ) ; if ( com.google.gerrit.server.util.SystemLog.shouldConfigure ( ) ) { com.google.gerrit.pgm.util.ErrorLogFile.initLogSystem ( logdir , config ) ; } return new com.google.gerrit.extensions.events.LifecycleListener ( ) { @ java.lang.Override public void start ( ) { } @ java.lang.Override public void stop ( ) { org.apache.log4j.LogManager.shutdown ( ) ; } } ; }
public final SubmitRecord.Label.Status status ( ) { if ( ( approved ( ) ) != null ) { return SubmitRecord.Label.Status.OK ; } else if ( ( rejected ( ) ) != null ) { return SubmitRecord.Label.Status.REJECT ; } else if ( optional ( ) ) { return SubmitRecord.Label.Status.MAY ; } else { return SubmitRecord.Label.Status.NEED ; } }
public void myExternalIds ( com.google.gwt.user.client.rpc.AsyncCallback < java.util.List < com.google.gerrit.client.reviewdb.AccountExternalId > > callback ) { externalIdDetailFactory.create ( ) . to ( callback ) ; }
public void addComment ( final java.lang.String issueId , final java.lang.String comment ) throws java.io.IOException { int story_id = getStoryId ( issueId ) ; com.googlesource.gerrit.plugins.its.storyboard.StoryboardClient.log.debug ( "Posting comment with data: ({},{})" , story_id , comment ) ; final java.lang.String url = ( ( ( ( baseUrl ) + ( com.googlesource.gerrit.plugins.its.storyboard.StoryboardClient.STORIES_ENDPOINT ) ) + "/" ) + story_id ) + "/comments" ; final java.lang.String escapedComment = comment.replace ( "\n" , "\\n" ) ; final java.lang.String json = ( ( ( "{\"story_id\":\"" + issueId ) + "\",\"content\":\"" ) + escapedComment ) + "\"}" ; postData ( url , json ) ; }
public void submitOnPush ( ) throws com.google.gwtorm.server.OrmException , java.io.IOException , org.eclipse.jgit.api.errors.GitAPIException , org.eclipse.jgit.errors.ConfigInvalidException { grant ( Permission.SUBMIT , project , "refs/for/refs/heads/master" ) ; com.google.gerrit.acceptance.git.PushOneCommit.Result r = pushTo ( "refs/for/master%submit" ) ; r.assertOkStatus ( ) ; r.assertChange ( Change.Status.MERGED , null , admin ) ; assertSubmitApproval ( r.getPatchSetId ( ) ) ; assertCommit ( project , "refs/heads/master" ) ; }
public java.lang.String [ ] getMoreStable ( java.lang.String branch ) { int i = order.indexOf ( com.google.gerrit.reviewdb.client.RefNames.fullName ( branch ) ) ; if ( 0 <= i ) { java.util.List < java.lang.String > r = order.subList ( ( i + 1 ) , order.size ( ) ) ; return r.toArray ( new java.lang.String [ r.size ( ) ] ) ; } return new java.lang.String [ ] { } ; }
public static com.google.gerrit.common.data.PermissionRule remove ( com.google.gerrit.server.project.ProjectConfig project , java.lang.String capabilityName , com.google.gerrit.reviewdb.client.AccountGroup.UUID group ) { com.google.gerrit.common.data.PermissionRule rule = com.google.gerrit.server.project.testing.Util.newRule ( project , group ) ; project.getAccessSection ( AccessSection.GLOBAL_CAPABILITIES , true ) . getPermission ( capabilityName , true ) . remove ( rule ) ; return rule ; }
public void insertedWhitespaceIsRecognizedInMultipleLines ( ) throws java.lang.Exception { java.lang.String a = " int *foobar\n int *foobar\n" ; java.lang.String b = " int * foobar\n int * foobar\n" ; com.google.common.truth.Truth.assertThat ( com.google.gerrit.server.patch.IntraLineLoaderTest.intraline ( a , b ) ) . isEqualTo ( com.google.gerrit.server.patch.IntraLineLoaderTest.ref ( ) . common ( " int *" ) . insert ( " " ) . common ( "foobar\n" ) . common ( " int *" ) . insert ( " " ) . common ( "foobar\n" ) . edits ) ; }
private PushOneCommit.Result push ( java.lang.String content , java.lang.String baseChangeId ) throws java.lang.Exception { java.lang.String subject = "Change subject" ; java.lang.String fileName = "a.txt" ; com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create ( db , admin.getIdent ( ) , testRepo , subject , fileName , content , baseChangeId ) ; com.google.gerrit.acceptance.PushOneCommit.Result r = push.to ( "refs/for/master" ) ; r.assertOkStatus ( ) ; return r ; }
private void printCommits ( java.util.List < java.lang.String > commits , java.lang.String message ) { if ( org.apache.commons.collections.CollectionUtils.isNotEmpty ( commits ) ) { stdout.print ( ( message + ":\n" ) ) ; stdout.print ( com.google.common.base.Joiner.on ( ",\n" ) . join ( commits ) ) ; stdout.print ( "\n\n" ) ; } }
public void testChangeRefReplicated ( ) throws com.google.gwtorm.server.OrmException , java.net.URISyntaxException { org.easymock.EasyMock.reset ( dispatcherMock ) ; com.googlesource.gerrit.plugins.replication.RefReplicatedEvent expectedEvent = new com.googlesource.gerrit.plugins.replication.RefReplicatedEvent ( "someProject" , "refs/changes/01/1/1" , "someHost" , com.googlesource.gerrit.plugins.replication.ReplicationState.RefPushResult.FAILED , RemoteRefUpdate.Status.REJECTED_NONFASTFORWARD ) ; dispatcherMock.postEvent ( com.googlesource.gerrit.plugins.replication.RefReplicatedEventEquals.eqEvent ( expectedEvent ) , org.easymock.EasyMock.anyObject ( com.google.gerrit.reviewdb.server.ReviewDb.class ) ) ; org.easymock.EasyMock.expectLastCall ( ) . once ( ) ; org.easymock.EasyMock.replay ( dispatcherMock ) ; gitUpdateProcessing.onRefReplicatedToOneNode ( "someProject" , "refs/changes/01/1/1" , new org.eclipse.jgit.transport.URIish ( "git://someHost/someProject.git" ) , RefPushResult.FAILED , RemoteRefUpdate.Status.REJECTED_NONFASTFORWARD ) ; org.easymock.EasyMock.verify ( dispatcherMock ) ; }
private static boolean isChangeScreen2 ( ) { if ( ! ( com.google.gerrit.client.Gerrit.getConfig ( ) . getNewFeatures ( ) ) ) { return false ; } else if ( com.google.gerrit.client.Dispatcher.changeScreen2 ) { return true ; } com.google.gerrit.reviewdb.client.AccountGeneralPreferences.ChangeScreen ui = null ; if ( com.google.gerrit.client.Gerrit.isSignedIn ( ) ) { ui = com.google.gerrit.client.Gerrit.getUserAccount ( ) . getGeneralPreferences ( ) . getChangeScreen ( ) ; } if ( ui == null ) { ui = com.google.gerrit.client.Gerrit.getConfig ( ) . getChangeScreen ( ) ; } return ui == ( com.google.gerrit.client.changes.ChangeScreen.CHANGE_SCREEN2 ) ; }
public void asyncStarredChanges ( ) { if ( ( ( starredChanges ) == null ) && ( ( starredChangesUtil ) != null ) ) { starredQuery = starredChangesUtil.query ( accountId ) ; } }
protected < T > org.elasticsearch.index.query.QueryBuilder toQueryBuilder ( com.google.gerrit.index.query.Predicate < T > p ) throws com.google.gerrit.index.query.QueryParseException { if ( p instanceof com.google.gerrit.index.query.AndPredicate ) { return and ( p ) ; } else if ( p instanceof com.google.gerrit.index.query.OrPredicate ) { return or ( p ) ; } else if ( p instanceof com.google.gerrit.index.query.NotPredicate ) { return not ( p ) ; } else if ( p instanceof com.google.gerrit.index.query.IndexPredicate ) { return fieldQuery ( ( ( com.google.gerrit.index.query.IndexPredicate < T > ) ( p ) ) ) ; } else { throw new com.google.gerrit.index.query.QueryParseException ( ( "cannot create query for index: " + p ) ) ; } }
private static com.google.gerrit.extensions.client.EditPreferencesInfo parseEditPreferences ( org.eclipse.jgit.lib.Config cfg , @ com.google.gerrit.common.Nullable org.eclipse.jgit.lib.Config defaultCfg , @ com.google.gerrit.common.Nullable com.google.gerrit.extensions.client.EditPreferencesInfo input ) throws org.eclipse.jgit.errors.ConfigInvalidException { return com.google.gerrit.server.config.ConfigUtil.loadSection ( cfg , UserConfigSections.EDIT , null , new com.google.gerrit.extensions.client.EditPreferencesInfo ( ) , ( defaultCfg != null ? com.google.gerrit.server.account.Preferences.parseDefaultEditPreferences ( defaultCfg , input ) : com.google.gerrit.extensions.client.EditPreferencesInfo.defaults ( ) ) , input ) ; }
public void testToString ( ) { final com.google.gerrit.server.query.TestPredicate a = f ( "q" , "alice" ) ; final com.google.gerrit.server.query.TestPredicate b = f ( "q" , "bob" ) ; final com.google.gerrit.server.query.TestPredicate c = f ( "q" , "charlie" ) ; org.junit.Assert.assertEquals ( "(q:alice OR q:bob)" , com.google.gerrit.server.query.Predicate.or ( a , b ) . toString ( ) ) ; org.junit.Assert.assertEquals ( "(q:alice OR q:bob OR q:charlie)" , com.google.gerrit.server.query.Predicate.or ( a , b , c ) . toString ( ) ) ; }
public void handle ( net.codemirror.lib.CodeMirror instance , int line , java.lang.String gutter , com.google.gwt.event.dom.client.MouseDownEvent clickEvent ) { instance.setCursor ( net.codemirror.lib.LineCharacter.create ( line ) ) ; instance.setActiveLine ( instance.getLineHandle ( line ) ) ; insertNewDraft ( instance ) . run ( ) ; }
public void onShowView ( ) { super . onShowView ( ) ; commit.onShowView ( ) ; related.setMaxHeight ( commit.getElement ( ) . getParentElement ( ) . getOffsetHeight ( ) ) ; if ( openReplyBox ) { onReply ( ) ; } else { java.lang.String prior = com.google.gerrit.client.Gerrit.getPriorView ( ) ; if ( ( prior != null ) && ( prior.startsWith ( "/c/" ) ) ) { scrollToPath ( prior.substring ( 3 ) ) ; } } startPoller ( ) ; }
protected void run ( ) throws com.google.gerrit.sshd.commands.UnloggedFailure { try { if ( luceneVersionManager.activateLatestIndex ( name ) ) { stdout.println ( "Activated latest index version" ) ; } else { stdout.println ( "Not activating index, already using latest version" ) ; } } catch ( com.google.gerrit.lucene.ReindexerAlreadyRunningException e ) { throw die ( ( "Failed to activate latest index: " + ( e.getMessage ( ) ) ) ) ; } }
private boolean isVisible ( com.google.gerrit.reviewdb.server.ReviewDb db , @ com.google.gerrit.common.Nullable com.google.gerrit.server.query.change.ChangeData cd ) throws com.google.gwtorm.server.OrmException { if ( ( getChange ( ) . isPrivate ( ) ) && ( ! ( isPrivateVisible ( db , cd ) ) ) ) { return false ; } return ( refControl.isVisible ( ) ) && ( getProjectControl ( ) . getProject ( ) . getState ( ) . permitsRead ( ) ) ; }
private java.util.Map < java.lang.String , com.google.gerrit.server.dashboard.ListDashboards.DashboardInfo > addProjectDashboards ( final com.google.gerrit.server.project.ProjectState projectState , java.util.Map < java.lang.String , com.google.gerrit.server.dashboard.ListDashboards.DashboardInfo > all , final java.lang.String defaultId ) { final java.util.Map < java.lang.String , com.google.gerrit.server.dashboard.ListDashboards.DashboardInfo > dashboards = projectDashboards ( projectState , defaultId ) ; dashboards.putAll ( all ) ; return dashboards ; }
public static void grant ( com.google.gerrit.server.git.ProjectConfig config , com.google.gerrit.common.data.AccessSection section , java.lang.String permission , boolean force , java.lang.Boolean exclusive , com.google.gerrit.common.data.GroupReference ... groupList ) { com.google.gerrit.common.data.Permission p = section.getPermission ( permission , true ) ; if ( exclusive != null ) { p.setExclusiveGroup ( exclusive ) ; } for ( com.google.gerrit.common.data.GroupReference group : groupList ) { if ( group != null ) { com.google.gerrit.common.data.PermissionRule r = com.google.gerrit.server.schema.AclUtil.rule ( config , group ) ; r.setForce ( force ) ; p.add ( r ) ; } } }
public UiAction.Description getDescription ( com.google.gerrit.server.change.ChangeResource resource ) { return new com.google.gerrit.extensions.webui.UiAction.Description ( ) . setLabel ( "Revert" ) . setTitle ( "Revert the change" ) . setVisible ( ( ( ( resource.getChange ( ) . getStatus ( ) ) == ( com.google.gerrit.reviewdb.client.Change.Status.MERGED ) ) && ( resource.getControl ( ) . getRefControl ( ) . canUpload ( ) ) ) ) ; }
static com.google.gerrit.acceptance.GerritServer.Description forTestClass ( com.google.gerrit.acceptance.Description testDesc , java.lang.String configName ) { return new com.google.gerrit.acceptance.AutoValue_GerritServer_Description ( configName , true , ( ! ( com.google.gerrit.acceptance.GerritServer.Description.has ( com.google.gerrit.acceptance.NoHttpd.class , testDesc.getTestClass ( ) ) ) ) , com.google.gerrit.acceptance.GerritServer.Description.has ( com.google.gerrit.acceptance.Sandboxed.class , testDesc.getTestClass ( ) ) , null , null ) ; }
public static com.google.gerrit.server.query.change.QueryOptions create ( com.google.gerrit.server.index.IndexConfig config , int start , int limit , java.util.Set < java.lang.String > fields ) { com.google.common.base.Preconditions.checkArgument ( ( start >= 0 ) , "start must be nonnegative: %s" , start ) ; com.google.common.base.Preconditions.checkArgument ( ( limit > 0 ) , "limit must be positive: %s" , limit ) ; return new com.google.gerrit.server.query.change.AutoValue_QueryOptions ( config , start , limit , com.google.common.collect.ImmutableSet.copyOf ( fields ) ) ; }
protected void createFileCommentEditorOnSideA ( ) { createCommentEditor ( ( ( R_HEAD ) + 1 ) , com.google.gerrit.client.patches.UnifiedDiffTable.PC , com.google.gerrit.client.patches.R_HEAD , com.google.gerrit.client.patches.FILE_SIDE_A ) ; return ; }
public com.google.gerrit.extensions.restapi.BinaryResult apply ( com.google.gerrit.server.change.FileResource rsrc ) throws com.google.gerrit.extensions.restapi.ResourceNotFoundException , com.google.gerrit.server.project.NoSuchChangeException , com.google.gwtorm.server.OrmException , java.io.IOException { java.lang.String path = rsrc.getPatchKey ( ) . get ( ) ; com.google.gerrit.server.change.RevisionResource rev = rsrc.getRevision ( ) ; org.eclipse.jgit.lib.ObjectId revstr = org.eclipse.jgit.lib.ObjectId.fromString ( rev.getPatchSet ( ) . getRevision ( ) . get ( ) ) ; return fileContentUtil.downloadContent ( projectCache.checkedGet ( rev.getProject ( ) ) , revstr , path , parent ) ; }
public void onSuccess ( final com.google.gwtjsonrpc.client.VoidResult result ) { }
private com.google.gerrit.server.query.change.ChangeData makeChangeData ( ) { com.google.gerrit.server.query.change.ChangeData cd = com.google.gerrit.server.query.change.ChangeData.createForTest ( project , new com.google.gerrit.reviewdb.client.Change.Id ( 1 ) , 1 ) ; cd.setChange ( com.google.gerrit.testing.TestChanges.newChange ( project , admin.id ) ) ; return cd ; }
public static com.google.gerrit.reviewdb.client.Change newChange ( com.google.gerrit.reviewdb.client.Project.NameKey project , com.google.gerrit.server.IdentifiedUser user , int id ) { com.google.gerrit.reviewdb.client.Change.Id changeId = new com.google.gerrit.reviewdb.client.Change.Id ( id ) ; com.google.gerrit.reviewdb.client.Change c = new com.google.gerrit.reviewdb.client.Change ( new com.google.gerrit.reviewdb.client.Change.Key ( "Iabcd1234abcd1234abcd1234abcd1234abcd1234" ) , changeId , user.getAccount ( ) . getId ( ) , new com.google.gerrit.reviewdb.client.Branch.NameKey ( project , "master" ) , com.google.gerrit.common.TimeUtil.nowTs ( ) ) ; com.google.gerrit.testutil.TestChanges.incrementPatchSet ( c ) ; return c ; }
protected void parseCommandLine ( ) throws com.google.gerrit.sshd.commands.UnloggedFailure { processor.setOutput ( out , QueryProcessor.OutputFormat.TEXT ) ; super . parseCommandLine ( ) ; if ( ( processor.getIncludeFiles ( ) ) && ( ! ( ( processor.getIncludePatchSets ( ) ) || ( processor.getIncludeCurrentPatchSet ( ) ) ) ) ) { throw new com.google.gerrit.sshd.commands.UnloggedFailure ( 1 , "--files option needs --patch-sets or --current-patch-set" ) ; } }
public boolean hasRepositoryPermission ( java.lang.String name ) { boolean result = false ; try { name = getRepositoryName ( name ) ; com.google.gerrit.server.project.ProjectControl control = projectControlFactory.controlFor ( new com.google.gerrit.reviewdb.client.Project.NameKey ( name ) ) ; result = ( control != null ) && ( ! ( control.getProject ( ) . getState ( ) . equals ( ProjectState.HIDDEN ) ) ) ; } catch ( com.google.gerrit.server.project.NoSuchProjectException e ) { result = false ; } return result ; }
public java.sql.Timestamp getCreatedOn ( ) { return group.getCreatedOn ( ) ; }
public com.google.common.collect.ListMultimap < com.google.gerrit.reviewdb.client.PatchSet.Id , com.google.gerrit.reviewdb.client.PatchSetApproval > allApprovalsMap ( ) throws com.google.gwtorm.server.OrmException { if ( ( allApprovals ) == null ) { allApprovals = com.google.common.collect.ArrayListMultimap.create ( ) ; for ( com.google.gerrit.reviewdb.client.PatchSetApproval psa : com.google.gerrit.server.ApprovalsUtil.sortApprovals ( db.patchSetApprovals ( ) . byChange ( legacyId ) ) ) { allApprovals.put ( psa.getPatchSetId ( ) , psa ) ; } } return allApprovals ; }
public void testIsSuccessful ( ) throws java.lang.Exception { org.apache.http.HttpResponse response = setupMocks ( com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpResponseHandlerTest.NO_CONTENT , com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpResponseHandlerTest.EMPTY_ENTITY ) ; com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpResponseHandler.HttpResult result = handler.handleResponse ( response ) ; com.google.common.truth.Truth.assertThat ( result.isSuccessful ( ) ) . isTrue ( ) ; com.google.common.truth.Truth.assertThat ( result.getMessage ( ) ) . isEmpty ( ) ; }
protected com.google.gerrit.extensions.common.ChangeInfo get ( java.lang.String id , com.google.gerrit.extensions.common.ListChangesOption ... options ) throws com.google.gerrit.extensions.restapi.RestApiException { java.util.EnumSet < com.google.gerrit.extensions.common.ListChangesOption > s = java.util.EnumSet.noneOf ( com.google.gerrit.extensions.common.ListChangesOption.class ) ; s.addAll ( java.util.Arrays.asList ( options ) ) ; return gApi.changes ( ) . id ( id ) . get ( s ) ; }
public void onPreMerge ( org.eclipse.jgit.lib.Repository repo , com.google.gerrit.server.git.CodeReviewCommit commit , com.google.gerrit.server.project.ProjectState destProject , com.google.gerrit.reviewdb.client.Branch.NameKey destBranch , com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId , com.google.gerrit.server.IdentifiedUser caller ) throws com.google.gerrit.server.git.validators.MergeValidationException { if ( ( ! ( allUsersName.equals ( destProject.getNameKey ( ) ) ) ) || ( ( ! ( destBranch.get ( ) . startsWith ( RefNames.REFS_GROUPS ) ) ) && ( ! ( destBranch.get ( ) . equals ( RefNames.REFS_GROUPNAMES ) ) ) ) ) { return ; } throw new com.google.gerrit.server.git.validators.MergeValidationException ( "group update not allowed" ) ; }
public T get ( ) { final com.google.gerrit.server.ssh.SshScopes.Context ctx = com.google.gerrit.server.ssh.SshScopes.getContext ( ) ; final java.util.Map < com.google.inject.Key < ? > , java.lang.Object > map = ctx.session.getAttribute ( com.google.gerrit.server.ssh.SshScopes.sessionMap ) ; synchronized ( map ) { @ java.lang.SuppressWarnings ( value = "unchecked" ) T t = ( ( T ) ( map.get ( key ) ) ) ; if ( t == null ) { t = creator.get ( ) ; map.put ( key , t ) ; } return t ; } }
private void postMessage ( java.lang.String changeId , java.lang.String msg , java.lang.String tag ) throws java.lang.Exception { com.google.gerrit.extensions.api.changes.ReviewInput in = new com.google.gerrit.extensions.api.changes.ReviewInput ( ) ; in.message = msg ; in.tag = tag ; gApi.changes ( ) . id ( changeId ) . current ( ) . review ( in ) ; }
public void testSyncUrlProvider ( ) { com.ericsson.gerrit.plugins.syncindex.Configuration configMock = org.mockito.Mockito.mock ( com.ericsson.gerrit.plugins.syncindex.Configuration.class ) ; java.lang.String expected = "someUrl" ; org.mockito.Mockito.when ( configMock.getUrl ( ) ) . thenReturn ( expected ) ; com.ericsson.gerrit.plugins.syncindex.Module module = new com.ericsson.gerrit.plugins.syncindex.Module ( ) ; com.google.common.truth.Truth.assertThat ( module.syncUrl ( configMock ) ) . isEqualTo ( expected ) ; }
private void saveLabelConfig ( ) throws java.lang.Exception { com.google.gerrit.server.project.ProjectConfig cfg = projectCache.checkedGet ( project ) . getConfig ( ) ; cfg.getLabelSections ( ) . put ( label.getName ( ) , label ) ; cfg.getLabelSections ( ) . put ( P.getName ( ) , P ) ; saveProjectConfig ( project , cfg ) ; }
private void parseDelete ( final org.eclipse.jgit.transport.ReceiveCommand cmd ) { com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef ( cmd.getRefName ( ) ) ; if ( ctl.canDelete ( ) ) { if ( ( cmd.getResult ( ) ) == ( org.eclipse.jgit.transport.ReceiveCommand.Result.NOT_ATTEMPTED ) ) { cmd.execute ( rp ) ; } } else { reject ( cmd , "can not delete references" ) ; } }
public void empty1 ( ) { final java.lang.String name = "empty-file" ; final com.google.gerrit.server.diff.PatchListEntry e = com.google.gerrit.server.diff.PatchListEntry.empty ( name ) ; org.junit.Assert.assertNull ( e.getOldName ( ) ) ; org.junit.Assert.assertEquals ( name , e.getNewName ( ) ) ; org.junit.Assert.assertSame ( Patch.PatchType.UNIFIED , e.getPatchType ( ) ) ; org.junit.Assert.assertSame ( Patch.ChangeType.MODIFIED , e.getChangeType ( ) ) ; org.junit.Assert.assertTrue ( e.getEdits ( ) . isEmpty ( ) ) ; }
public java.util.Map < java.lang.String , com.google.gerrit.extensions.common.ActionInfo > format ( com.google.gerrit.server.change.RevisionResource rsrc ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.extensions.common.ChangeInfo changeInfo = null ; com.google.gerrit.extensions.common.RevisionInfo revisionInfo = null ; java.util.List < com.google.gerrit.extensions.api.changes.ActionVisitor > visitors = visitors ( ) ; if ( ! ( visitors.isEmpty ( ) ) ) { changeInfo = changeJson ( ) . format ( rsrc ) ; revisionInfo = com.google.common.base.Preconditions.checkNotNull ( com.google.common.collect.Iterables.getOnlyElement ( changeInfo.revisions.values ( ) ) ) ; changeInfo.revisions = null ; } return toActionMap ( rsrc , visitors , changeInfo , revisionInfo ) ; }
private static java.lang.String stripPrefix ( @ javax.annotation.Nullable java.lang.String prefix , java.lang.String name ) { if ( ( prefix != null ) && ( name.startsWith ( prefix ) ) ) { return name.substring ( ( ( prefix.length ( ) ) + 1 ) ) ; } return name ; }
private com.google.gwtorm.jdbc.JdbcSchema setupSchema ( final com.google.gwtorm.schema.sql.SqlDialect dialect ) { @ java.lang.SuppressWarnings ( value = "rawtypes" ) com.google.gwtorm.jdbc.Database db = org.mockito.Mockito.mock ( com.google.gwtorm.jdbc.Database.class ) ; try { org.mockito.Mockito.when ( db.getDialect ( ) ) . thenReturn ( dialect ) ; org.mockito.Mockito.when ( db.newConnection ( ) ) . thenReturn ( conn ) ; com.google.gwtorm.jdbc.JdbcSchema schema = new com.google.gwtorm.jdbc.TestJdbcAccess.Schema ( db ) ; return schema ; } catch ( com.google.gwtorm.server.OrmException e ) { throw new java.lang.RuntimeException ( e ) ; } }
static void link ( com.google.gerrit.client.diff.PaddingManager a , com.google.gerrit.client.diff.PaddingManager b ) { if ( ! ( a.others.contains ( b ) ) ) { a.others.add ( b ) ; } if ( ! ( b.others.contains ( a ) ) ) { b.others.add ( a ) ; } }
public void onSuccess ( com.googlesource.gerrit.plugins.xdocs.client.ChangeInfo.EditInfo edit ) { if ( edit != null ) { change.revisions ( ) . put ( edit.name ( ) , com.googlesource.gerrit.plugins.xdocs.client.ChangeInfo.RevisionInfo.fromEdit ( edit ) ) ; } initRevisionsAndShow ( change ) ; }
private boolean finite ( java.lang.String pattern ) { if ( com.google.gerrit.server.project.RefControl.isRE ( pattern ) ) { return com.google.gerrit.server.project.RefControl.toRegExp ( pattern ) . toAutomaton ( ) . isFinite ( ) ; } else if ( pattern.endsWith ( "/*" ) ) { return false ; } else { return true ; } }
private void bccWatchesNotifySubmittedChanges ( ) { try { for ( final com.google.gerrit.reviewdb.AccountProjectWatch w : getWatches ( ) ) { if ( w.isNotify ( NotifyType.SUBMITTED_CHANGES ) ) { add ( RecipientType.BCC , w.getAccountId ( ) ) ; } } } catch ( com.google.gwtorm.client.OrmException err ) { } }
public void missingKey ( ) throws java.lang.Exception { com.google.gerrit.gpg.testutil.TestKey key2 = com.google.gerrit.gpg.testutil.TestKeys.validKeyWithExpiration ( ) ; org.eclipse.jgit.transport.PushCertificate cert = newSignedCert ( validNonce ( ) , key2 ) ; assertProblems ( cert , ( "No public keys found for key ID " + ( com.google.gerrit.gpg.PublicKeyStore.keyIdToString ( key2.getKeyId ( ) ) ) ) ) ; }
public void index ( com.google.gerrit.reviewdb.client.Account.Id id ) throws java.io.IOException { for ( com.google.gerrit.index.Index < com.google.gerrit.reviewdb.client.Account.Id , com.google.gerrit.server.account.AccountState > i : getWriteIndexes ( ) ) { com.google.gerrit.server.account.AccountState accountState = byIdCache.getOrNull ( id ) ; if ( accountState != null ) { i.replace ( accountState ) ; } else { i.delete ( id ) ; } } fireAccountIndexedEvent ( id.get ( ) ) ; }
private org.eclipse.jgit.transport.PushCertificate newSignedCert ( java.lang.String nonce , com.google.gerrit.gpg.testutil.TestKey signingKey ) throws java.lang.Exception { org.eclipse.jgit.transport.PushCertificateIdent ident = new org.eclipse.jgit.transport.PushCertificateIdent ( signingKey.getFirstUserId ( ) , java.lang.System.currentTimeMillis ( ) , ( ( - 7 ) * 60 ) ) ; java.lang.String payload = ( ( ( ( ( ( ( ( ( ( "certificate version 0.1\n" + "pusher " ) + ( ident.getRaw ( ) ) ) + "\n" ) + "pushee test://localhost/repo.git\n" ) + "nonce " ) + nonce ) + "\n" ) + "\n" ) + "0000000000000000000000000000000000000000" ) + " deadbeefdeadbeefdeadbeefdeadbeefdeadbeef" ) + " refs/heads/master\n" ; org.bouncycastle.openpgp.PGPSignatureGenerator gen = new org.bouncycastle.openpgp.PGPSignatureGenerator ( new org.bouncycastle.openpgp.operator.bc.BcPGPContentSignerBuilder ( signingKey.getPublicKey ( ) . getAlgorithm ( ) , org.bouncycastle.openpgp.PGPUtil.SHA1 ) ) ; gen.init ( PGPSignature.BINARY_DOCUMENT , signingKey.getPrivateKey ( ) ) ; gen.update ( payload.getBytes ( java.nio.charset.StandardCharsets.UTF_8 ) ) ; org.bouncycastle.openpgp.PGPSignature sig = gen.generate ( ) ; java.io.ByteArrayOutputStream bout = new java.io.ByteArrayOutputStream ( ) ; try ( org.bouncycastle.bcpg.BCPGOutputStream out = new org.bouncycastle.bcpg.BCPGOutputStream ( new org.bouncycastle.bcpg.ArmoredOutputStream ( bout ) ) ) { sig.encode ( out ) ; } java.lang.String cert = payload + ( new java.lang.String ( bout.toByteArray ( ) , java.nio.charset.StandardCharsets.UTF_8 ) ) ; java.io.Reader reader = new java.io.InputStreamReader ( new java.io.ByteArrayInputStream ( cert.getBytes ( java.nio.charset.StandardCharsets.UTF_8 ) ) ) ; org.eclipse.jgit.transport.PushCertificateParser parser = new org.eclipse.jgit.transport.PushCertificateParser ( tr.getRepository ( ) , signedPushConfig ) ; return parser.parse ( reader ) ; }
private void index ( com.google.gerrit.server.project.ProjectControl projectControl ) { try { index.apply ( new com.google.gerrit.server.project.ProjectResource ( projectControl.getProjectState ( ) , projectControl.getUser ( ) ) , null ) ; } catch ( java.lang.Exception e ) { writeError ( "error" , java.lang.String.format ( "Unable to index %s: %s" , projectControl.getProject ( ) . getName ( ) , e.getMessage ( ) ) ) ; } }
private void deleteTags ( final java.util.Set < java.lang.String > tags ) { com.google.gerrit.client.projects.ProjectApi.deleteTags ( getProjectKey ( ) , tags , new com.google.gerrit.client.rpc.GerritCallback < com.google.gerrit.client.VoidResult > ( ) { @ java.lang.Override public void onSuccess ( com.google.gerrit.client.VoidResult result ) { query = new com.google.gerrit.client.admin.ProjectTagsScreen.Query ( match ) . start ( start ) . run ( ) ; } @ java.lang.Override public void onFailure ( java.lang.Throwable caught ) { query = new com.google.gerrit.client.admin.ProjectTagsScreen.Query ( match ) . start ( start ) . run ( ) ; super . onFailure ( caught ) ; } } ) ; }
void setRoot ( org.commonmark.node.Node doc ) { outline = new java.util.ArrayList < > ( ) ; com.google.common.collect.Multimap < java.lang.String , com.google.gitiles.doc.TocFormatter.TocEntry > entries = com.google.common.collect.ArrayListMultimap.create ( 16 , 4 ) ; scan ( doc , entries , new java.util.ArrayDeque < org.commonmark.node.Heading > ( ) ) ; ids = generateIds ( entries ) ; }
protected com.google.gerrit.server.project.ProjectData fromDocument ( com.google.gson.JsonObject json , java.util.Set < java.lang.String > fields ) { com.google.gson.JsonElement source = json.get ( "_source" ) ; if ( source == null ) { source = json.getAsJsonObject ( ) . get ( "fields" ) ; } com.google.gerrit.reviewdb.client.Project.NameKey nameKey = new com.google.gerrit.reviewdb.client.Project.NameKey ( source.getAsJsonObject ( ) . get ( ProjectField.NAME.getName ( ) ) . getAsString ( ) ) ; return projectCache.get ( ) . get ( nameKey ) . toProjectData ( ) ; }
private java.util.Map < com.google.gerrit.reviewdb.client.Change.Key , com.google.gerrit.reviewdb.client.Change.Id > openChangesByKey ( com.google.gerrit.reviewdb.client.Branch.NameKey branch ) throws com.google.gwtorm.server.OrmException { final java.util.Map < com.google.gerrit.reviewdb.client.Change.Key , com.google.gerrit.reviewdb.client.Change.Id > r = new java.util.HashMap < com.google.gerrit.reviewdb.client.Change.Key , com.google.gerrit.reviewdb.client.Change.Id > ( ) ; for ( com.google.gerrit.reviewdb.client.Change c : db.changes ( ) . byBranchOpenAll ( branch ) ) { r.put ( c.getKey ( ) , c.getId ( ) ) ; } return r ; }
public void updateRepo ( com.google.gerrit.server.update.RepoContext ctx ) throws java.lang.Exception { com.google.gerrit.server.git.CodeReviewCommit c = composeGitlinksCommit ( branch ) ; if ( c != null ) { ctx.addRefUpdate ( new org.eclipse.jgit.transport.ReceiveCommand ( c.getParent ( 0 ) , c , branch.get ( ) ) ) ; addBranchTip ( branch , c ) ; } }
public int run ( ) throws java.lang.Exception { final com.google.inject.Injector injector = com.google.inject.Guice.createInjector ( new com.google.gerrit.server.config.GerritServerModule ( ) , new com.google.gerrit.server.ssh.SshDaemonModule ( ) ) ; com.google.gerrit.client.rpc.Common.setGerritConfig ( injector.getInstance ( com.google.gerrit.client.data.GerritConfig.class ) ) ; injector.getInstance ( com.google.gerrit.server.ssh.GerritSshDaemon.class ) . start ( ) ; return never ( ) ; }
private com.google.gerrit.reviewdb.client.Change.Id getOrRegisterAccount ( com.google.gerrit.reviewdb.server.ReviewDb db , java.lang.String login , java.lang.String name , java.lang.String email ) throws com.google.gerrit.extensions.restapi.BadRequestException , com.google.gerrit.extensions.restapi.ResourceConflictException , com.google.gerrit.extensions.restapi.UnprocessableEntityException , com.google.gwtorm.server.OrmException , java.io.IOException { com.google.gerrit.reviewdb.client.AccountExternalId.Key userExtKey = new com.google.gerrit.reviewdb.client.AccountExternalId.Key ( com.google.gerrit.reviewdb.client.AccountExternalId.SCHEME_USERNAME , login ) ; com.google.gerrit.reviewdb.server.AccountExternalIdAccess gerritExtIds = db.accountExternalIds ( ) ; com.google.gerrit.reviewdb.client.AccountExternalId userExtId = gerritExtIds.get ( userExtKey ) ; if ( userExtId == null ) { return accountImporter.importAccount ( login , name , email ) ; } else { return userExtId.getAccountId ( ) ; } }
public void listNonEmptyGroupIncludes ( ) throws java.lang.Exception { java.lang.String gx = group ( "gx" , "Administrators" ) ; java.lang.String gy = group ( "gy" , "Administrators" ) ; java.lang.String gz = group ( "gz" , "Administrators" ) ; PUT ( ( ( ( "/groups/" + gx ) + "/groups/" ) + gy ) ) ; PUT ( ( ( ( "/groups/" + gx ) + "/groups/" ) + gz ) ) ; assertIncludes ( GET ( ( ( "/groups/" + gx ) + "/groups/" ) ) , gy , gz ) ; }
public boolean hasNext ( ) { while ( ( ( next ) == null ) && ( itr.hasNext ( ) ) ) { com.google.inject.Provider < T > p = itr.next ( ) . get ( ) ; if ( p != null ) { try { next = p.get ( ) ; } catch ( java.lang.RuntimeException e ) { com.google.gerrit.extensions.registration.DynamicSet.log.error ( ( ( "Cannot get iterated object from provider " + p ) + ": object discared" ) , e ) ; } } } return ( next ) != null ; }
private void call ( com.googlecode.prolog_cafe.lang.BufferingPrologControl env , java.lang.String name ) { com.googlecode.prolog_cafe.lang.StructureTerm head = com.googlecode.prolog_cafe.lang.SymbolTerm.create ( pkg , name , 0 ) ; com.google.common.truth.Truth.assertWithMessage ( ( ( ( "Cannot invoke " + ( pkg ) ) + ":" ) + name ) ) . that ( env.execute ( Prolog.BUILTIN , "call" , head ) ) . isTrue ( ) ; }
public void onSuccess ( com.google.gerrit.client.groups.GroupMap result ) { priorResults.clear ( ) ; java.util.ArrayList < com.google.gerrit.client.ui.AccountGroupSuggestOracle.AccountGroupSuggestion > r = new java.util.ArrayList ( result.size ( ) ) ; for ( com.google.gerrit.client.info.GroupInfo group : com.google.gerrit.client.rpc.Natives.asList ( result.values ( ) ) ) { r.add ( new com.google.gerrit.client.ui.AccountGroupSuggestOracle.AccountGroupSuggestion ( group ) ) ; priorResults.put ( group.name ( ) , group.getGroupUUID ( ) ) ; } callback.onSuggestionsReady ( req , new com.google.gerrit.client.ui.Response ( r ) ) ; }
protected void configure ( ) { try { final com.google.gerrit.server.GerritServer gs = com.google.gerrit.server.GerritServer.getInstance ( true ) ; bind ( com.google.gerrit.server.GerritServer.class ) . toInstance ( gs ) ; bind ( com.google.gerrit.server.ContactStore.class ) . toInstance ( com.google.gerrit.server.EncryptedContactStore.create ( gs ) ) ; } catch ( com.google.gwtorm.client.OrmException e ) { addError ( e ) ; } catch ( com.google.gwtjsonrpc.server.XsrfException e ) { addError ( e ) ; } }
public void onSuccess ( java.lang.Void result ) { if ( ( ( base ) == null ) && ( ( rev.commit ( ) . parents ( ) . length ( ) ) > 1 ) ) { base = com.google.gerrit.client.Gerrit.getUserPreferences ( ) . defaultBaseForMerges ( ) . getBase ( ) ; } loadConfigInfo ( info , base ) ; }
public void listGpgKeys ( ) throws java.lang.Exception { java.util.List < com.google.gerrit.gpg.testutil.TestKey > keys = com.google.gerrit.gpg.testutil.TestKey.allValidKeys ( ) ; java.util.List < java.lang.String > toAdd = new java.util.ArrayList ( keys.size ( ) ) ; for ( com.google.gerrit.gpg.testutil.TestKey key : keys ) { addExternalIdEmail ( admin , org.eclipse.jgit.transport.PushCertificateIdent.parse ( key.getFirstUserId ( ) ) . getEmailAddress ( ) ) ; toAdd.add ( key.getPublicKeyArmored ( ) ) ; } gApi.accounts ( ) . self ( ) . putGpgKeys ( toAdd , com.google.common.collect.ImmutableList.< java.lang.String > of ( ) ) ; assertKeys ( keys ) ; }
public void onFailure ( java.lang.Exception reason ) { com.google.gerrit.client.ErrorDialog d ; if ( reason instanceof com.google.gwt.core.client.CodeDownloadException ) { d = new com.google.gerrit.client.ErrorDialog ( com.google.gerrit.client.Gerrit.M.cannotDownloadPlugin ( url ) ) ; } else { d = new com.google.gerrit.client.ErrorDialog ( com.google.gerrit.client.Gerrit.M.pluginFailed ( url ) ) ; } d.center ( ) ; }
public void setNonExistingParent_UnprocessibleEntity ( ) throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = adminSession.put ( ( ( "/projects/" + ( project.get ( ) ) ) + "/parent" ) , newParentInput ( "non-existing" ) ) ; r.assertUnprocessableEntity ( ) ; r.consume ( ) ; }
public void testUpsertTwoBothExisting ( ) throws com.google.gwtorm.server.OrmException , java.sql.SQLException { java.sql.PreparedStatement update = stubStatementWithUpdateCounts ( com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE , 1 , 1 ) ; java.sql.PreparedStatement insert = stubStatementWithUpdateCounts ( com.google.gwtorm.jdbc.TestJdbcAccess.INSERT ) ; createClassUnderTest ( ) . upsert ( twoRows ) ; com.google.gwtorm.jdbc.TestJdbcAccess.assertUsedBatchingOnly ( update ) ; com.google.gwtorm.jdbc.TestJdbcAccess.assertNotUsed ( insert ) ; }
protected void assertApproved ( java.lang.String changeId ) throws java.io.IOException { com.google.gerrit.extensions.common.ChangeInfo c = getChange ( changeId , com.google.gerrit.extensions.common.ListChangesOption.DETAILED_LABELS ) ; com.google.gerrit.extensions.common.LabelInfo cr = c.labels.get ( "Code-Review" ) ; com.google.common.truth.Truth.assertThat ( cr.all ) . hasSize ( 1 ) ; com.google.common.truth.Truth.assertThat ( cr.all.get ( 0 ) . value.intValue ( ) ) . isEqualTo ( 2 ) ; com.google.common.truth.Truth.assertThat ( new com.google.gerrit.reviewdb.client.Account.Id ( cr.all.get ( 0 ) . _accountId ) ) . isEqualTo ( admin.getId ( ) ) ; }
public com.google.gwtorm.server.OrmException convertError ( java.lang.String op , java.sql.SQLException err ) { switch ( getSQLStateInt ( err ) ) { case 23001 : case 23505 : return new com.google.gwtorm.server.OrmDuplicateKeyException ( "account_patch_reviews" , err ) ; default : if ( ( ( err.getCause ( ) ) == null ) && ( ( err.getNextException ( ) ) != null ) ) { err.initCause ( err.getNextException ( ) ) ; } return new com.google.gwtorm.server.OrmException ( ( op + " failure on account_patch_reviews" ) , err ) ; } }
private void openRepos ( java.util.Collection < com.google.gerrit.reviewdb.client.Project.NameKey > projects ) throws com.google.gerrit.server.git.IntegrationException { for ( com.google.gerrit.reviewdb.client.Project.NameKey project : projects ) { try { orm.openRepo ( project , true ) ; } catch ( com.google.gerrit.server.project.NoSuchProjectException noProject ) { logWarn ( ( ( ( "Project " + ( noProject.project ( ) ) ) + " no longer exists, " ) + "abandoning open changes" ) ) ; abandonAllOpenChangeForDeletedProject ( noProject.project ( ) ) ; } catch ( java.io.IOException e ) { throw new com.google.gerrit.server.git.IntegrationException ( ( "Error opening project " + project ) , e ) ; } } }
private void delete ( final java.util.List < org.eclipse.jgit.transport.RemoteRefUpdate > cmds , final org.eclipse.jgit.transport.RefSpec spec ) throws java.io.IOException { final java.lang.String dst = spec.getDestination ( ) ; final boolean force = spec.isForceUpdate ( ) ; cmds.add ( new org.eclipse.jgit.transport.RemoteRefUpdate ( db , ( ( org.eclipse.jgit.lib.Ref ) ( null ) ) , dst , force , null , null ) ) ; }
private void printOne ( java.nio.file.Path p ) { try { java.nio.file.Files.copy ( p , out ) ; } catch ( java.io.IOException e ) { try ( java.io.PrintWriter w = new java.io.PrintWriter ( err ) ) { w.write ( "Error reading contents of " ) ; w.write ( p.toAbsolutePath ( ) . toString ( ) ) ; w.write ( ": \n" ) ; e.printStackTrace ( w ) ; } } }
private static void validateLabels ( java.util.Collection < java.lang.String > labels ) { if ( labels == null ) { return ; } java.util.SortedSet < java.lang.String > invalidLabels = new java.util.TreeSet < > ( ) ; for ( java.lang.String label : labels ) { if ( com.google.common.base.CharMatcher.whitespace ( ) . matchesAnyOf ( label ) ) { invalidLabels.add ( label ) ; } } if ( ! ( invalidLabels.isEmpty ( ) ) ) { throw new com.google.gerrit.server.StarredChangesUtil.InvalidLabelsException ( invalidLabels ) ; } }
void init ( javax.servlet.ServletContext context ) { runtime.setBaseFolder ( sitePaths.site_path.toFile ( ) ) ; runtime.getStatus ( ) . servletContainer = context.getServerInfo ( ) ; runtime.start ( ) ; startManager ( notificationManager ) ; startManager ( userManager ) ; startManager ( authenticationManager ) ; startManager ( repositoryManager ) ; startManager ( projectManager ) ; startManager ( gitblit ) ; logger.info ( "All Gitblit managers started." ) ; }
public boolean isReviewer ( com.google.gerrit.reviewdb.server.ReviewDb db , @ com.google.gerrit.common.Nullable com.google.gerrit.server.query.change.ChangeData cd ) throws com.google.gwtorm.server.OrmException { if ( getUser ( ) . isIdentifiedUser ( ) ) { java.util.Collection < com.google.gerrit.reviewdb.client.Account.Id > results = changeData ( db , cd ) . reviewers ( ) . all ( ) ; return results.contains ( getUser ( ) . getAccountId ( ) ) ; } return false ; }
public com.google.gerrit.extensions.common.ChangeInfo createMergePatchSet ( com.google.gerrit.extensions.common.MergePatchSetInput in ) throws com.google.gerrit.extensions.restapi.RestApiException { try { return updateByMerge.apply ( change , in ) . value ( ) ; } catch ( java.lang.Exception e ) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException ( "Cannot update change by merge" , e ) ; } }
public void set ( com.google.gerrit.reviewdb.client.PatchSet.Id base , com.google.gerrit.reviewdb.client.PatchSet.Id curr , com.google.gerrit.client.change.ChangeScreen2.Style style , com.google.gwt.user.client.ui.Widget editButton , com.google.gwt.user.client.ui.Widget replyButton , boolean editExists ) { this . base = base ; this . curr = curr ; this . style = style ; this . editButton = editButton ; this . replyButton = replyButton ; this . editExists = editExists ; }
public void setUp ( ) throws java.lang.Exception { executorMock = org.mockito.Mockito.mock ( WorkQueue.Executor.class ) ; com.google.gerrit.server.git.WorkQueue workQueueMock = org.mockito.Mockito.mock ( com.google.gerrit.server.git.WorkQueue.class ) ; org.mockito.Mockito.when ( workQueueMock.createQueue ( 4 , "Sync remote index" ) ) . thenReturn ( executorMock ) ; com.ericsson.gerrit.plugins.syncindex.Configuration configMock = org.mockito.Mockito.mock ( com.ericsson.gerrit.plugins.syncindex.Configuration.class ) ; org.mockito.Mockito.when ( configMock.getThreadPoolSize ( ) ) . thenReturn ( 4 ) ; syncIndexExecutorProvider = new com.ericsson.gerrit.plugins.syncindex.SyncIndexExecutorProvider ( workQueueMock , configMock ) ; }
public void testBlockPushDrafts ( ) { com.google.gerrit.server.project.Util.grant ( util.getParentConfig ( ) , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS , "refs/for/refs/*" ) ; com.google.gerrit.server.project.Util.grant ( util.getParentConfig ( ) , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/drafts/*" ) . setBlock ( ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local ) ; org.junit.Assert.assertTrue ( "can upload refs/heads/master" , u.controlForRef ( "refs/heads/master" ) . canUpload ( ) ) ; org.junit.Assert.assertTrue ( "push is blocked to refs/drafts/master" , u.controlForRef ( "refs/drafts/refs/heads/master" ) . isBlocked ( com.google.gerrit.common.data.Permission.PUSH ) ) ; }
public void blockPushDraftsUnblockAdmin ( ) { com.google.gerrit.server.project.testing.Util.block ( parent , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/drafts/*" ) ; com.google.gerrit.server.project.testing.Util.allow ( parent , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.testing.Util.ADMIN , "refs/drafts/*" ) ; com.google.gerrit.server.project.ProjectControl u = user ( local ) ; com.google.gerrit.server.project.ProjectControl a = user ( local , "a" , com.google.gerrit.server.project.testing.Util.ADMIN ) ; assertBlocked ( com.google.gerrit.common.data.Permission.PUSH , "refs/drafts/refs/heads/master" , u ) ; assertNotBlocked ( com.google.gerrit.common.data.Permission.PUSH , "refs/drafts/refs/heads/master" , a ) ; }
com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpResponseHandler.HttpResult send ( ) throws java.io.IOException { return httpSession.delete ( buildIndexEndpoint ( changeId ) ) ; }
public void onSuccess ( com.google.gerrit.client.diff.DiffInfo diffInfo ) { diff = diffInfo ; new net.codemirror.lib.ModeInjector ( ) . add ( com.google.gerrit.client.diff.CodeMirrorDemo.getContentType ( diff.meta_a ( ) ) ) . add ( com.google.gerrit.client.diff.CodeMirrorDemo.getContentType ( diff.meta_b ( ) ) ) . inject ( modeInjectorCb ) ; }
private java.lang.String readEmail ( java.lang.String defaultEmail ) { java.lang.String email = ui.readString ( defaultEmail , "email" ) ; if ( ( email != null ) && ( ! ( org.apache.commons.validator.routines.EmailValidator.getInstance ( ) . isValid ( email ) ) ) ) { ui.message ( "error: invalid email address\n" ) ; return readEmail ( defaultEmail ) ; } return email ; }
private void addExtensionPoints ( com.google.gerrit.client.info.ChangeInfo change , com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev ) { addExtensionPoint ( GerritUiExtensionPoint.CHANGE_SCREEN_HEADER , headerExtension , change , rev ) ; addExtensionPoint ( GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_BUTTONS , headerExtensionMiddle , change , rev ) ; addExtensionPoint ( GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS , headerExtensionRight , change , rev ) ; addExtensionPoint ( GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK , changeExtension , change , rev ) ; addExtensionPoint ( GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_RELATED_INFO_BLOCK , relatedExtension , change , rev ) ; addExtensionPoint ( GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_COMMIT_INFO_BLOCK , commitExtension , change , rev ) ; addExtensionPoint ( GerritUiExtensionPoint.CHANGE_SCREEN_HISTORY_RIGHT_OF_BUTTONS , historyExtensionRight , change , rev ) ; }
private com.google.gerrit.acceptance.RestResponse publishPatchSet ( java.lang.String changeId ) throws java.lang.Exception { com.google.gerrit.reviewdb.client.PatchSet patchSet = com.google.common.collect.Iterables.getOnlyElement ( queryProvider.get ( ) . byKeyPrefix ( changeId ) ) . currentPatchSet ( ) ; return adminRestSession.post ( ( ( ( ( "/changes/" + changeId ) + "/revisions/" ) + ( patchSet.getRevision ( ) . get ( ) ) ) + "/publish" ) ) ; }
private java.util.Collection < com.google.gerrit.reviewdb.client.ChangeMessage > filterChangeMessages ( ) { final com.google.common.base.Predicate < com.google.gerrit.reviewdb.client.PatchSet.Id > validPatchSet = validPatchSetPredicate ( ) ; return com.google.common.collect.Collections2.filter ( changeMessages , new com.google.common.base.Predicate < com.google.gerrit.reviewdb.client.ChangeMessage > ( ) { @ java.lang.Override public boolean apply ( com.google.gerrit.reviewdb.client.ChangeMessage in ) { com.google.gerrit.reviewdb.client.PatchSet.Id psId = in.getPatchSetId ( ) ; if ( psId == null ) { return true ; } return validPatchSet.apply ( psId ) ; } } ) ; }
protected abstract com.google.gwt.core.client.JsArray < com.google.gerrit.client.change.RelatedChanges.ChangeAndCommit > convert ( T result ) ;
private com.google.gerrit.extensions.common.GroupInfo GET_ONE ( java.lang.String endpoint ) throws java.io.IOException { com.google.gerrit.acceptance.RestResponse r = adminSession.get ( endpoint ) ; com.google.common.truth.Truth.assertThat ( r.getStatusCode ( ) ) . isEqualTo ( HttpStatus.SC_OK ) ; return newGson ( ) . fromJson ( r.getReader ( ) , com.google.gerrit.extensions.common.GroupInfo.class ) ; }
private static boolean isUnifiedPatchLink ( final com.google.gerrit.reviewdb.client.Patch patch ) { return ( patch.getPatchType ( ) . equals ( PatchType.BINARY ) ) || ( ( com.google.gerrit.client.Gerrit.isSignedIn ( ) ) && ( com.google.gerrit.client.Gerrit.getUserAccount ( ) . getGeneralPreferences ( ) . getDiffView ( ) . equals ( DiffView.UNIFIED_DIFF ) ) ) ; }
public void run ( ) { try { com.google.gerrit.server.mail.CreateChangeSender cm = createChangeSenderFactory.create ( change.getProject ( ) , change.getId ( ) ) ; cm.setFrom ( change.getOwner ( ) ) ; cm.setPatchSet ( patchSet , patchSetInfo ) ; cm.setNotify ( notify ) ; cm.addReviewers ( reviewers ) ; cm.addExtraCC ( extraCC ) ; cm.send ( ) ; } catch ( java.lang.Exception e ) { com.google.gerrit.server.change.ChangeInserter.log.error ( ( "Cannot send email for new change " + ( change.getId ( ) ) ) , e ) ; } }
public static java.nio.file.Path storeInTemp ( java.lang.String pluginName , java.io.InputStream in , com.google.gerrit.server.config.SitePaths sitePaths ) throws java.io.IOException { if ( ! ( java.nio.file.Files.exists ( sitePaths.tmp_dir ) ) ) { java.nio.file.Files.createDirectories ( sitePaths.tmp_dir ) ; } return com.google.gerrit.server.plugins.PluginLoader.asTemp ( in , com.google.gerrit.server.plugins.JarPluginProvider.tempNameFor ( pluginName ) , ".jar" , sitePaths.tmp_dir ) ; }
private int getEffectiveLimit ( com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > p ) { java.util.List < java.lang.Integer > possibleLimits = new java.util.ArrayList < > ( 3 ) ; possibleLimits.add ( permittedLimit ) ; if ( ( limitFromCaller ) > 0 ) { possibleLimits.add ( limitFromCaller ) ; } java.lang.Integer limitFromPredicate = com.google.gerrit.server.query.change.LimitPredicate.getLimit ( p ) ; if ( limitFromPredicate != null ) { possibleLimits.add ( limitFromPredicate ) ; } return com.google.common.collect.Ordering.natural ( ) . min ( possibleLimits ) ; }
public void rejectMissingEmail ( ) throws java.lang.Exception { com.google.common.truth.TruthJUnit.assume ( ) . that ( notesMigration.readChanges ( ) ) . isTrue ( ) ; com.google.gerrit.acceptance.PushOneCommit.Result r = createChange ( ) ; exception.expect ( com.google.gerrit.extensions.restapi.UnprocessableEntityException.class ) ; exception.expectMessage ( "email invalid" ) ; gApi.changes ( ) . id ( r.getChangeId ( ) ) . addReviewer ( "" ) ; }
private static java.util.List < com.google.gerrit.reviewdb.client.Change > scanChangesFromNotedb ( com.google.gerrit.server.notedb.ChangeNotes.Factory notesFactory , org.eclipse.jgit.lib.Repository repo , com.google.gerrit.reviewdb.server.ReviewDb db , com.google.gerrit.reviewdb.client.Project.NameKey project ) throws com.google.gwtorm.server.OrmException , java.io.IOException { java.util.List < com.google.gerrit.server.notedb.ChangeNotes > changeNotes = com.google.gerrit.server.git.ScanningChangeCacheImpl.scanNotedb ( notesFactory , repo , db , project ) ; return com.google.common.collect.Lists.transform ( changeNotes , new com.google.common.base.Function < com.google.gerrit.server.notedb.ChangeNotes , com.google.gerrit.reviewdb.client.Change > ( ) { @ java.lang.Override public com.google.gerrit.reviewdb.client.Change apply ( com.google.gerrit.server.notedb.ChangeNotes notes ) { return notes.getChange ( ) ; } } ) ; }
public static com.google.common.cache.CacheBuilder < com.google.gitiles.blame.BlameCacheImpl.Key , java.util.List < com.google.gitiles.blame.Region > > weigher ( com.google.common.cache.CacheBuilder < ? super com.google.gitiles.blame.BlameCacheImpl.Key , ? super java.util.List < com.google.gitiles.blame.Region > > builder ) { return builder.weigher ( ( k , v ) -> v.size ( ) ) ; }
public void testUnblockInLocalVisibilityByRegisteredUsers_Fails ( ) { com.google.gerrit.server.project.Util.block ( parent , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/heads/*" ) ; com.google.gerrit.server.project.Util.allow ( local , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS , "refs/heads/*" ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS ) ; com.google.common.truth.Truth.assertThat ( u.controlForRef ( "refs/heads/master" ) . isVisibleByRegisteredUsers ( ) ) . named ( "u can't read" ) . isFalse ( ) ; }
public com.google.gerrit.extensions.api.changes.ChangeApi revert ( com.google.gerrit.extensions.api.changes.RevertInput in ) throws com.google.gerrit.extensions.restapi.RestApiException { try { return changeApi.id ( revert.apply ( change , in ) . _number ) ; } catch ( java.lang.Exception e ) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException ( "Cannot revert change" , e ) ; } }
public com.googlesource.gerrit.plugins.lfs.LfsProjectConfigInfo apply ( com.google.gerrit.server.project.ProjectResource resource ) throws com.google.gerrit.extensions.restapi.RestApiException { com.googlesource.gerrit.plugins.lfs.LfsProjectConfigInfo info = new com.googlesource.gerrit.plugins.lfs.LfsProjectConfigInfo ( ) ; com.googlesource.gerrit.plugins.lfs.LfsProjectConfigSection config = lfsConfigFactory.getProjectsConfig ( ) . getForProject ( resource.getNameKey ( ) ) ; if ( config != null ) { info.enabled = config.isEnabled ( ) ; info.maxObjectSize = config.getMaxObjectSize ( ) ; info.readOnly = config.isReadOnly ( ) ; } return info ; }
public void publishesWhenMessageMatchesIgnore ( ) throws java.lang.Exception { com.cisco.gerrit.plugins.slack.config.ProjectConfig config = getConfig ( ) ; mockEvent.change = com.google.common.base.Suppliers.ofInstance ( mockChange ) ; mockChange.commitMessage = "WIP:This is a title\nand a the body." ; com.cisco.gerrit.plugins.slack.message.MessageGenerator messageGenerator ; messageGenerator = com.cisco.gerrit.plugins.slack.message.MessageGeneratorFactory.newInstance ( mockEvent , config ) ; org.junit.Assert.assertThat ( messageGenerator.shouldPublish ( ) , org.hamcrest.core.Is.is ( true ) ) ; }
public void testRejectJavaScript_AnchorHref ( ) { final java.lang.String href = "javascript:window.close();" ; try { new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder ( ) . openAnchor ( ) . setAttribute ( "href" , href ) ; org.junit.Assert.fail ( "accepted javascript in a href" ) ; } catch ( java.lang.RuntimeException e ) { org.junit.Assert.assertEquals ( ( "javascript unsafe in href: " + href ) , e.getMessage ( ) ) ; } }
public < T > com.google.gerrit.client.rpc.HttpCallback < T > add ( com.google.gerrit.client.rpc.HttpCallback < T > cb ) { checkFinalAdded ( ) ; if ( failed ) { cb.onFailure ( failedThrowable ) ; return new com.google.gerrit.client.rpc.HttpCallback < T > ( ) { @ java.lang.Override public void onSuccess ( com.google.gerrit.client.rpc.HttpResponse < T > result ) { } @ java.lang.Override public void onFailure ( java.lang.Throwable caught ) { } } ; } com.google.gerrit.client.rpc.CallbackGroup.HttpCallbackImpl < T > w = new com.google.gerrit.client.rpc.CallbackGroup.HttpCallbackImpl ( cb ) ; callbacks.add ( w ) ; remaining.add ( w ) ; return w ; }
protected void configure ( ) { com.google.gerrit.extensions.registration.DynamicSet.bind ( binder ( ) , com.google.gerrit.extensions.webui.TopMenu.class ) . to ( com.googlesource.gerrit.plugins.cookbook.HelloTopMenu.class ) ; install ( new com.google.gerrit.extensions.restapi.RestApiModule ( ) { @ java.lang.Override protected void configure ( ) { post ( com.google.gerrit.server.change.RevisionResource.REVISION_KIND , "say-hello" ) . to ( com.googlesource.gerrit.plugins.cookbook.HelloWorldAction.class ) ; } } ) ; }
public com.google.gerrit.client.diff.DiffApi base ( com.google.gerrit.reviewdb.client.PatchSet.Id id ) { if ( id != null ) { if ( ( id.get ( ) ) < 0 ) { call.addParameter ( "parent" , ( - ( id.get ( ) ) ) ) ; } else { call.addParameter ( "base" , id.get ( ) ) ; } } return this ; }
protected void onPostExecute ( java.lang.String errorMsg ) { if ( errorMsg != null ) { widgetUtil.showError ( errorMsg ) ; } else { widgetUtil.toast ( R.string.reviewer_added ) ; com.google.reviewit.AddReviewerFragment fragment = new com.google.reviewit.AddReviewerFragment ( ) ; android.os.Bundle bundle = new android.os.Bundle ( ) ; bundle.putAll ( getArguments ( ) ) ; fragment.setArguments ( bundle ) ; display ( fragment , false ) ; } }
public void testUnblockForce ( ) { com.google.gerrit.common.data.PermissionRule r = com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.Util.ANONYMOUS , "refs/heads/*" ) ; r.setBlock ( ) ; r.setForce ( true ) ; com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.Util.DEVS , "refs/heads/*" ) . setForce ( true ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.project.Util.DEVS ) ; org.junit.Assert.assertTrue ( "u can force push" , u.controlForRef ( "refs/heads/master" ) . canForceUpdate ( ) ) ; }
private com.google.gerrit.client.diff.DraftBox addDraftBox ( com.google.gerrit.client.changes.CommentInfo info , boolean doSave ) { com.google.gerrit.client.diff.DraftBox box = new com.google.gerrit.client.diff.DraftBox ( this , revision , info , commentLinkProcessor , true , doSave ) ; addCommentBox ( info , box ) ; if ( ! doSave ) { box.setEdit ( true ) ; } net.codemirror.lib.CodeMirror.LineHandle handle = getCmFromSide ( info.side ( ) ) . getLineHandle ( ( ( info.line ( ) ) - 1 ) ) ; lineActiveBoxMap.put ( handle , box ) ; return box ; }
public boolean match ( T object ) throws com.google.gwtorm.server.OrmException { for ( com.google.gerrit.index.query.Predicate < T > c : children ) { com.google.common.base.Preconditions.checkState ( c.isMatchable ( ) , "match invoked, but child predicate %s doesn't implement %s" , c , com.google.gerrit.index.query.Matchable.class . getName ( ) ) ; if ( c.asMatchable ( ) . match ( object ) ) { return true ; } } return false ; }
public void onOk ( ) { deleteBranches ( ids ) ; }
public void badRequest ( ) throws java.lang.Exception { org.mockito.Mockito.when ( request.getPathInfo ( ) ) . thenReturn ( "/someCache" ) ; java.lang.String errorMessage = "someError" ; org.mockito.Mockito.doThrow ( new java.io.IOException ( errorMessage ) ) . when ( request ) . getReader ( ) ; servlet.doPost ( request , response ) ; org.mockito.Mockito.verify ( response ) . sendError ( javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST , errorMessage ) ; }
public java.lang.Void call ( ) throws java.io.IOException { for ( com.google.gerrit.server.index.change.ChangeIndex i : getWriteIndexes ( ) ) { i.delete ( id ) ; } com.google.gerrit.server.index.change.ChangeIndexer.log.info ( "Deleted change {} from index." , id.get ( ) ) ; fireChangeDeletedFromIndexEvent ( id.get ( ) ) ; return null ; }
public com.google.common.collect.ImmutableSetMultimap < com.google.gerrit.server.notedb.ReviewerState , com.google.gerrit.reviewdb.client.Account.Id > getReviewers ( com.google.gerrit.server.notedb.ChangeNotes notes , java.lang.Iterable < com.google.gerrit.reviewdb.client.PatchSetApproval > allApprovals ) throws com.google.gwtorm.server.OrmException { if ( ! ( migration.readChanges ( ) ) ) { return com.google.gerrit.server.ApprovalsUtil.getReviewers ( allApprovals ) ; } return notes.load ( ) . getReviewers ( ) ; }
public void onSuccess ( com.google.gerrit.client.info.AccountPreferencesInfo prefs ) { com.google.gerrit.client.Gerrit.myPrefs = prefs ; onModuleLoad2 ( result ) ; }
public void newPatchSetByOtherOnReviewableChangeInReviewDb ( ) throws java.lang.Exception { com.google.common.truth.TruthJUnit.assume ( ) . that ( notesMigration.readChanges ( ) ) . isFalse ( ) ; com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange ( ) ; pushTo ( sc , "refs/for/master" , other ) ; assertThat ( sender ) . sent ( "newpatchset" , sc ) . notTo ( sc.owner ) . to ( sc.reviewer , sc.ccer , other ) . notTo ( sc.reviewerByEmail , sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.NEW_PATCHSETS ) . noOneElse ( ) ; }
public java.util.Set < com.google.gerrit.reviewdb.client.Account.Id > byChange ( com.google.gerrit.reviewdb.client.Change.Id changeId ) throws com.google.gwtorm.server.OrmException { return com.google.common.collect.FluentIterable.from ( getRefNames ( com.google.gerrit.reviewdb.client.RefNames.refsStarredChangesPrefix ( changeId ) ) ) . transform ( new com.google.common.base.Function < java.lang.String , com.google.gerrit.reviewdb.client.Account.Id > ( ) { @ java.lang.Override public Account.Id apply ( java.lang.String refPart ) { return Account.Id.parse ( refPart ) ; } } ) . toSet ( ) ; }
protected org.apache.sshd.common.session.AbstractSession createSession ( final org.apache.mina.core.session.IoSession io ) throws java.lang.Exception { if ( ( io.getConfig ( ) ) instanceof org.apache.mina.transport.socket.SocketSessionConfig ) { final org.apache.mina.transport.socket.SocketSessionConfig c = ( ( org.apache.mina.transport.socket.SocketSessionConfig ) ( io.getConfig ( ) ) ) ; c.setKeepAlive ( keepAlive ) ; } final org.apache.sshd.common.session.AbstractSession s = super . createSession ( io ) ; s.setAttribute ( SshUtil.REMOTE_PEER , io.getRemoteAddress ( ) ) ; return s ; }
public void testUnblockInParentBlockInLocal ( ) { com.google.gerrit.server.project.Util.block ( util.getParentConfig ( ) , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/heads/*" ) ; com.google.gerrit.server.project.Util.allow ( util.getParentConfig ( ) , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.Util.DEVS , "refs/heads/*" ) ; com.google.gerrit.server.project.Util.block ( local , com.google.gerrit.common.data.Permission.PUSH , com.google.gerrit.server.project.Util.DEVS , "refs/heads/*" ) ; com.google.gerrit.server.project.ProjectControl d = util.user ( local , com.google.gerrit.server.project.Util.DEVS ) ; org.junit.Assert.assertFalse ( "u can't push" , d.controlForRef ( "refs/heads/master" ) . canUpdate ( ) ) ; }
protected org.eclipse.jgit.revwalk.RevCommit getRemoteHead ( ) throws java.lang.Exception { return getRemoteHead ( project , "master" ) ; }
private void addSuggestion ( java.util.Map < com.google.gerrit.reviewdb.client.Account.Id , com.google.gerrit.common.data.AccountInfo > map , com.google.gerrit.reviewdb.client.Account account , com.google.gerrit.common.data.AccountInfo info , java.lang.Boolean active , com.google.gerrit.httpd.rpc.SuggestServiceImpl.VisibilityControl visibilityControl ) throws com.google.gwtorm.server.OrmException { if ( map.containsKey ( account.getId ( ) ) ) { return ; } if ( ( active != null ) && ( active != ( account.isActive ( ) ) ) ) { return ; } if ( visibilityControl.isVisible ( account ) ) { map.put ( account.getId ( ) , info ) ; } }
public void stop ( ) { scanner.end ( ) ; synchronized ( this ) { boolean clean = ! ( running.isEmpty ( ) ) ; for ( com.google.gerrit.server.plugins.Plugin p : running.values ( ) ) { p.stop ( ) ; } running.clear ( ) ; broken.clear ( ) ; if ( clean ) { java.lang.System.gc ( ) ; processPendingCleanups ( ) ; } } }
private void testPushForNonExistingBranch ( com.google.gerrit.acceptance.git.PushForReviewIT.Protocol p ) throws com.google.gwtorm.server.OrmException , java.io.IOException , org.eclipse.jgit.api.errors.GitAPIException { selectProtocol ( p ) ; java.lang.String branchName = "non-existing" ; com.google.gerrit.acceptance.git.PushOneCommit.Result r = pushTo ( ( "refs/for/" + branchName ) ) ; r.assertErrorStatus ( ( ( "branch " + branchName ) + " not found" ) ) ; }
private com.google.gerrit.reviewdb.client.Account getAccount ( com.google.gerrit.server.git.CodeReviewCommit codeReviewCommit ) { com.google.gerrit.reviewdb.client.Account account = null ; com.google.gerrit.reviewdb.client.PatchSetApproval submitter = approvalsUtil.getSubmitter ( db , codeReviewCommit.notes ( ) , codeReviewCommit.getPatchsetId ( ) ) ; if ( submitter != null ) { account = accountCache.get ( submitter.getAccountId ( ) ) . getAccount ( ) ; } return account ; }
protected com.google.gerrit.server.notedb.LoadHandle openHandle ( org.eclipse.jgit.lib.Repository repo ) throws java.io.IOException { if ( autoRebuild ) { com.google.gerrit.server.notedb.NoteDbChangeState state = com.google.gerrit.server.notedb.NoteDbChangeState.parse ( change ) ; com.google.gerrit.server.git.RefCache refs = ( ( this . refs ) != null ) ? this . refs : new com.google.gerrit.server.git.RepoRefCache ( repo ) ; if ( ( state == null ) || ( ! ( state.isChangeUpToDate ( refs ) ) ) ) { return rebuildAndOpen ( repo ) ; } } return super . openHandle ( repo ) ; }
protected java.util.List < org.eclipse.jgit.revwalk.RevCommit > getRemoteLog ( ) throws java.io.IOException { return getRemoteLog ( project , "master" ) ; }
public java.lang.String decode ( java.lang.String s ) { try { javax.crypto.Cipher encoder = getCipher ( ) ; java.security.Key sKey = generateKey ( ) ; encoder.init ( javax.crypto.Cipher.DECRYPT_MODE , sKey , getCipherParameterSpec ( ) ) ; return new java.lang.String ( encoder.doFinal ( org.apache.commons.codec.binary.Base64.decodeBase64 ( s ) ) , config.getEncoding ( ) ) ; } catch ( java.lang.Exception e ) { com.googlesource.gerrit.plugins.secureconfig.PBECodec.log.error ( "decode() failed" , e ) ; throw new java.lang.IllegalArgumentException ( "encode() failed" , e ) ; } }
public void apply ( org.eclipse.jgit.dircache.DirCacheEntry ent ) { if ( ( ent.getRawMode ( ) ) == 0 ) { ent.setFileMode ( FileMode.REGULAR_FILE ) ; } ent.setObjectId ( content ) ; }
public void display ( final com.google.gwt.core.client.JsArray < com.google.gerrit.client.account.ProjectWatchInfo > result ) { while ( 2 < ( table.getRowCount ( ) ) ) { table.removeRow ( ( ( table.getRowCount ( ) ) - 1 ) ) ; } for ( com.google.gerrit.client.account.ProjectWatchInfo info : com.google.gerrit.client.rpc.Natives.asList ( result ) ) { final int row = table.getRowCount ( ) ; table.insertRow ( row ) ; applyDataRowStyle ( row ) ; populate ( row , info ) ; } }
public void setStars ( java.lang.String changeId , com.google.gerrit.extensions.api.changes.StarsInput input ) throws com.google.gerrit.extensions.restapi.RestApiException { try { com.google.gerrit.server.account.AccountResource.Star rsrc = stars.parse ( account , com.google.gerrit.extensions.restapi.IdString.fromUrl ( changeId ) ) ; starsPost.apply ( rsrc , input ) ; } catch ( java.lang.Exception e ) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException ( "Cannot post stars" , e ) ; } }
public void createDraftChangeNotAllowed ( ) throws java.lang.Exception { com.google.common.truth.TruthJUnit.assume ( ) . that ( isAllowDrafts ( ) ) . isFalse ( ) ; com.google.gerrit.extensions.common.ChangeInfo ci = newChangeInfo ( ChangeStatus.DRAFT ) ; assertCreateFails ( ci , com.google.gerrit.extensions.restapi.MethodNotAllowedException.class , "draft workflow is disabled" ) ; }
private com.google.gitiles.GitilesView getView ( java.lang.String pathAndQuery ) throws java.io.IOException , javax.servlet.ServletException { com.google.gitiles.TestViewFilter.Result result = com.google.gitiles.TestViewFilter.service ( repo , pathAndQuery ) ; com.google.gitiles.FakeHttpServletResponse resp = result.getResponse ( ) ; com.google.common.truth.Truth.assertWithMessage ( ( "expected non-redirect status, got " + ( resp.getStatus ( ) ) ) ) . that ( ( ( ( resp.getStatus ( ) ) < 300 ) || ( ( resp.getStatus ( ) ) >= 400 ) ) ) . isTrue ( ) ; return result.getView ( ) ; }
protected void authorizeUser ( com.google.gerrit.server.project.ProjectState state , com.google.gerrit.server.CurrentUser user ) throws org.eclipse.jgit.lfs.errors.LfsUnauthorized { try { permissionBackend.user ( user ) . project ( state.getNameKey ( ) ) . check ( com.google.gerrit.server.permissions.ProjectPermission.PUSH_AT_LEAST_ONE_REF ) ; } catch ( com.google.gerrit.extensions.restapi.AuthException | com.google.gerrit.server.permissions.PermissionBackendException e ) { throwUnauthorizedOp ( action.getName ( ) , state , user ) ; } }
public GroupDescription.Basic parse ( java.lang.String id ) throws com.google.gerrit.extensions.restapi.UnprocessableEntityException { com.google.gerrit.common.data.GroupDescription.Basic group = parseId ( id ) ; if ( ( group == null ) || ( ! ( groupControlFactory.controlFor ( group ) . isVisible ( ) ) ) ) { throw new com.google.gerrit.extensions.restapi.UnprocessableEntityException ( java.lang.String.format ( "Group Not Found: %s" , id ) ) ; } return group ; }
protected void onOpenRow ( final int row ) { final java.lang.Object item = getRowItem ( row ) ; if ( item instanceof com.google.gerrit.client.patches.AbstractPatchContentTable.CommentList ) { for ( final com.google.gerrit.client.ui.CommentPanel p : ( ( com.google.gerrit.client.patches.AbstractPatchContentTable.CommentList ) ( item ) ) . panels ) { p.setOpen ( ( ! ( p.isOpen ( ) ) ) ) ; } } }
public void update ( int completed ) { if ( ( totUnits ) == 0 ) { return ; } currUnit += completed ; int percentage = ( ( currUnit ) * 100 ) / ( totUnits ) ; if ( percentage > ( lastPercentage ) ) { lastPercentage = percentage ; } status.update ( Code.SYNC , status.getShortDescription ( ) , getStatusDescription ( ) ) ; }
private void initProviderBouncyCastle ( org.eclipse.jgit.lib.Config cfg ) { org.apache.sshd.common.NamedFactory < org.apache.sshd.common.random.Random > factory ; if ( cfg.getBoolean ( "sshd" , null , "testUseInsecureRandom" , false ) ) { factory = new com.google.gerrit.sshd.SshDaemon.InsecureBouncyCastleRandom.Factory ( ) ; } else { factory = org.apache.sshd.common.util.security.SecurityUtils.getRandomFactory ( ) ; } setRandomFactory ( new org.apache.sshd.common.random.SingletonRandomFactory ( factory ) ) ; }
private java.util.List < com.google.gerrit.client.reviewdb.AccountGroup > myOwnedGroups ( final com.google.gerrit.client.reviewdb.ReviewDb db ) throws com.google.gwtorm.client.OrmException { final com.google.gerrit.client.reviewdb.Account.Id me = com.google.gerrit.client.rpc.Common.getAccountId ( ) ; final java.util.List < com.google.gerrit.client.reviewdb.AccountGroup > own = new java.util.ArrayList < com.google.gerrit.client.reviewdb.AccountGroup > ( ) ; for ( final com.google.gerrit.client.reviewdb.AccountGroup.Id groupId : groupCache.getGroups ( me ) ) { for ( final com.google.gerrit.client.reviewdb.AccountGroup g : db.accountGroups ( ) . ownedByGroup ( groupId ) ) { own.add ( g ) ; } } return own ; }
public void stop ( ) { if ( ( scanner ) != null ) { scanner.end ( ) ; } srvInfoImpl.state = ServerInformation.State.SHUTDOWN ; synchronized ( this ) { for ( com.google.gerrit.server.plugins.Plugin p : running.values ( ) ) { p.stop ( ) ; } running.clear ( ) ; broken.clear ( ) ; if ( ( cleanupHandles.size ( ) ) > ( running.size ( ) ) ) { java.lang.System.gc ( ) ; processPendingCleanups ( ) ; } } }
private static void assertBadRequest ( com.google.gerrit.extensions.api.projects.Projects.ListRequest req ) throws java.lang.Exception { try { req.get ( ) ; } catch ( com.google.gerrit.extensions.restapi.BadRequestException expected ) { } }
public boolean equals ( java.lang.Object obj ) { if ( obj == null ) { return false ; } if ( ( getClass ( ) ) != ( obj.getClass ( ) ) ) { return false ; } final com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.AccessToken other = ( ( com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.AccessToken ) ( obj ) ) ; return ( ( java.util.Objects.equals ( this . accessToken , other.accessToken ) ) && ( java.util.Objects.equals ( this . raw , other.raw ) ) ) && ( java.util.Objects.equals ( this . tokenType , other.tokenType ) ) ; }
private void enableForm ( final boolean canModifyAgreements , final boolean canModifyDescription , final boolean canModifyMergeType , final boolean canModifyState ) { submitType.setEnabled ( canModifyMergeType ) ; state.setEnabled ( canModifyState ) ; useContentMerge.setEnabled ( canModifyMergeType ) ; descTxt.setEnabled ( canModifyDescription ) ; useContributorAgreements.setEnabled ( canModifyAgreements ) ; useSignedOffBy.setEnabled ( canModifyAgreements ) ; requireChangeID.setEnabled ( canModifyMergeType ) ; }
private void addExtensionPoints ( com.google.gerrit.client.info.ChangeInfo change , com.google.gerrit.client.info.ChangeInfo.RevisionInfo rev ) { addExtensionPoint ( GerritUiExtensionPoint.CHANGE_SCREEN_HEADER , headerExtension , change , rev ) ; addExtensionPoint ( GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_BUTTONS , headerExtensionMiddle , change , rev ) ; addExtensionPoint ( GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS , headerExtensionRight , change , rev ) ; addExtensionPoint ( GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK , changeExtension , change , rev ) ; addExtensionPoint ( GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_RELATED_INFO_BLOCK , relatedExtension , change , rev ) ; addExtensionPoint ( GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_COMMIT_INFO_BLOCK , commitExtension , change , rev ) ; addExtensionPoint ( GerritUiExtensionPoint.CHANGE_SCREEN_HISTORY_RIGHT_OF_BUTTONS , historyExtensionRight , change , rev ) ; }
public void setUp ( ) throws java.lang.Exception { normalProject = createProject ( "normal" ) ; secretProject = createProject ( "secret" ) ; secretRefProject = createProject ( "secretRef" ) ; privilegedGroup = groupCache.get ( new com.google.gerrit.reviewdb.client.AccountGroup.NameKey ( createGroup ( "privilegedGroup" ) ) ) ; privilegedUser = accountCreator.create ( "privilegedUser" , "snowden@nsa.gov" , "Ed Snowden" ) ; gApi.groups ( ) . id ( privilegedGroup.getGroupUUID ( ) . get ( ) ) . addMembers ( privilegedUser.username ) ; com.google.common.truth.Truth.assertThat ( gApi.groups ( ) . id ( privilegedGroup.getGroupUUID ( ) . get ( ) ) . members ( ) . get ( 0 ) . email ) . contains ( "snowden" ) ; grant ( secretProject , "refs/*" , Permission.READ , false , privilegedGroup.getGroupUUID ( ) ) ; block ( secretProject , "refs/*" , Permission.READ , SystemGroupBackend.REGISTERED_USERS ) ; deny ( secretRefProject , "refs/*" , Permission.READ , SystemGroupBackend.ANONYMOUS_USERS ) ; grant ( secretRefProject , "refs/heads/secret/*" , Permission.READ , false , privilegedGroup.getGroupUUID ( ) ) ; block ( secretRefProject , "refs/heads/secret/*" , Permission.READ , SystemGroupBackend.REGISTERED_USERS ) ; grant ( secretRefProject , "refs/heads/*" , Permission.READ , false , SystemGroupBackend.REGISTERED_USERS ) ; }
public void byProjectPrefix ( ) throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository < com.google.gerrit.testutil.InMemoryRepositoryManager.Repo > repo1 = createProject ( "repo1" ) ; org.eclipse.jgit.junit.TestRepository < com.google.gerrit.testutil.InMemoryRepositoryManager.Repo > repo2 = createProject ( "repo2" ) ; com.google.gerrit.reviewdb.client.Change change1 = insert ( newChange ( repo1 , null , null , null , null ) ) ; com.google.gerrit.reviewdb.client.Change change2 = insert ( newChange ( repo2 , null , null , null , null ) ) ; assertQuery ( "projects:foo" ) ; assertQuery ( "projects:repo1" , change1 ) ; assertQuery ( "projects:repo2" , change2 ) ; assertQuery ( "projects:repo" , change2 , change1 ) ; }
private void dropRemovedDisabledPlugins ( java.util.List < java.io.File > jars ) { java.util.Set < java.lang.String > unload = com.google.common.collect.Sets.newHashSet ( disabled.keySet ( ) ) ; for ( java.io.File jar : jars ) { if ( jar.getName ( ) . endsWith ( ".disabled" ) ) { unload.remove ( com.google.gerrit.server.plugins.PluginLoader.nameOf ( jar ) ) ; } } for ( java.lang.String name : unload ) { disabled.remove ( name ) ; } }
public void onSuccess ( java.lang.String result ) { type = result ; injectMode ( result , modeInjectorCb ) ; }
protected void afterExecute ( java.lang.Runnable r , java.lang.Throwable t ) { if ( r instanceof com.google.gerrit.server.git.WorkQueue.Task ) { final com.google.gerrit.server.git.WorkQueue.Task < ? > task = ( ( com.google.gerrit.server.git.WorkQueue.Task < ? > ) ( r ) ) ; if ( ! ( task.isPeriodic ( ) ) ) { remove ( task ) ; } } else { com.google.gerrit.server.git.WorkQueue.log.error ( ( ( ( "Non task object in queue: " + ( r.getClass ( ) ) ) + ": " ) + r ) ) ; } super . afterExecute ( r , t ) ; }
private void initSequences ( org.eclipse.jgit.lib.Repository git , org.eclipse.jgit.lib.BatchRefUpdate bru ) throws java.io.IOException { if ( ( notesMigration.readChangeSequence ( ) ) && ( ( git.exactRef ( ( ( com.google.gerrit.reviewdb.client.RefNames.REFS_SEQUENCES ) + ( com.google.gerrit.server.Sequences.CHANGES ) ) ) ) == null ) ) { try ( org.eclipse.jgit.lib.ObjectInserter ins = git.newObjectInserter ( ) ) { bru.addCommand ( com.google.gerrit.server.notedb.RepoSequence.storeNew ( ins , Sequences.CHANGES , firstChangeId ) ) ; ins.flush ( ) ; } } }
private void initTopicLink ( com.google.gerrit.client.changes.ChangeInfo info ) { text.setText ( info.topic ( ) ) ; text.setTargetHistoryToken ( com.google.gerrit.common.PageLinks.toChangeQuery ( com.google.gerrit.client.ui.BranchLink.query ( info.project_name_key ( ) , info.status ( ) , info.branch ( ) , info.topic ( ) ) ) ) ; }
protected void ccExistingReviewers ( ) { if ( ( ! ( NotifyHandling.ALL.equals ( notify ) ) ) && ( ! ( NotifyHandling.OWNER_REVIEWERS.equals ( notify ) ) ) ) { return ; } try { for ( com.google.gerrit.reviewdb.client.Account.Id id : changeData.reviewers ( ) . byState ( com.google.gerrit.server.notedb.ReviewerStateInternal.REVIEWER ) ) { add ( RecipientType.CC , id ) ; } } catch ( com.google.gwtorm.server.OrmException err ) { com.google.gerrit.server.mail.ChangeEmail.log.warn ( "Cannot CC users that commented on updated change" , err ) ; } }
public boolean canRebase ( ) throws com.google.gerrit.extensions.restapi.RestApiException { try ( org.eclipse.jgit.lib.Repository repo = repoManager.openRepository ( revision.getProject ( ) ) ; org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk ( repo ) ) { return rebaseUtil.canRebase ( revision.getPatchSet ( ) , revision.getChange ( ) . getDest ( ) , repo , rw ) ; } catch ( java.io.IOException e ) { throw new com.google.gerrit.extensions.restapi.RestApiException ( "Cannot check if rebase is possible" , e ) ; } }
public com.google.gerrit.extensions.common.GroupInfo format ( com.google.gerrit.common.data.GroupDescription.Basic group ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.extensions.common.GroupInfo info = init ( group ) ; if ( ( options.contains ( com.google.gerrit.extensions.client.ListGroupsOption.MEMBERS ) ) || ( options.contains ( com.google.gerrit.extensions.client.ListGroupsOption.INCLUDES ) ) ) { com.google.gerrit.server.group.GroupResource rsrc = new com.google.gerrit.server.group.GroupResource ( groupControlFactory.controlFor ( group ) ) ; initMembersAndIncludes ( rsrc , info ) ; } return info ; }
public void onClick ( com.google.gwt.event.dom.client.ClickEvent event ) { double y = cm.heightAtLine ( line , "local" ) ; double viewport = cm.getScrollInfo ( ) . getClientHeight ( ) ; cm.setCursor ( net.codemirror.lib.LineCharacter.create ( line ) ) ; cm.scrollToY ( ( y - ( 0.5 * viewport ) ) ) ; cm.focus ( ) ; }
private void deleteAll ( ) throws java.io.IOException { for ( java.lang.String index : com.google.gerrit.lucene.IndexVersionCheck.SCHEMA_VERSIONS.keySet ( ) ) { java.io.File file = new java.io.File ( sitePaths.index_dir , index ) ; if ( file.exists ( ) ) { org.apache.lucene.store.Directory dir = org.apache.lucene.store.FSDirectory.open ( file ) ; try { for ( java.lang.String name : dir.listAll ( ) ) { dir.deleteFile ( name ) ; } } finally { dir.close ( ) ; } } } }
private com.google.gerrit.reviewdb.client.AccountGroup createAccountGroup ( com.google.gerrit.extensions.common.GroupInfo info ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.AccountGroup.Id groupId = new com.google.gerrit.reviewdb.client.AccountGroup.Id ( db.nextAccountGroupId ( ) ) ; com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID ( info.id ) ; com.google.gerrit.reviewdb.client.AccountGroup group = new com.google.gerrit.reviewdb.client.AccountGroup ( new com.google.gerrit.reviewdb.client.AccountGroup.NameKey ( info.name ) , groupId , uuid , com.google.gerrit.common.TimeUtil.nowTs ( ) ) ; group.setVisibleToAll ( cfg.getBoolean ( "groups" , "newGroupsVisibleToAll" , false ) ) ; group.setDescription ( info.description ) ; return group ; }
private void assertNotFound ( org.eclipse.jgit.lib.ObjectId id ) throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = userSession.get ( ( ( ( "/projects/" + ( project.get ( ) ) ) + "/commits/" ) + ( id.name ( ) ) ) ) ; org.junit.Assert.assertEquals ( HttpStatus.SC_NOT_FOUND , r.getStatusCode ( ) ) ; }
protected PushOneCommit.Result createChange ( java.lang.String subject , java.lang.String fileName , java.lang.String content , java.lang.String topic ) throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create ( db , admin.getIdent ( ) , testRepo , subject , fileName , content ) ; return push.to ( ( "refs/for/master/" + ( name ( topic ) ) ) ) ; }
private com.google.gerrit.httpd.rpc.patch.PatchScriptBuilder newBuilder ( final com.google.gerrit.server.patch.PatchList list , org.eclipse.jgit.lib.Repository git ) { final com.google.gerrit.reviewdb.AccountDiffPreference dp = new com.google.gerrit.reviewdb.AccountDiffPreference ( diffPrefs ) ; final com.google.gerrit.httpd.rpc.patch.PatchScriptBuilder b = builderFactory.get ( ) ; b.setRepository ( git ) ; b.setChange ( change ) ; b.setDiffPrefs ( dp ) ; b.setTrees ( list.isAgainstParent ( ) , list.getOldId ( ) , list.getNewId ( ) ) ; return b ; }
public static com.google.gerrit.reviewdb.server.ReviewDb unwrapDb ( com.google.gerrit.reviewdb.server.ReviewDb db ) { if ( db instanceof com.google.gerrit.reviewdb.server.DisallowReadFromChangesReviewDbWrapper ) { return com.google.gerrit.reviewdb.server.ReviewDbUtil.unwrapDb ( ( ( com.google.gerrit.reviewdb.server.DisallowReadFromChangesReviewDbWrapper ) ( db ) ) . unsafeGetDelegate ( ) ) ; } if ( db instanceof com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper ) { return com.google.gerrit.reviewdb.server.ReviewDbUtil.unwrapDb ( ( ( com.google.gerrit.reviewdb.server.DisallowReadFromGroupsReviewDbWrapper ) ( db ) ) . unsafeGetDelegate ( ) ) ; } return db ; }
private com.google.gerrit.reviewdb.client.AccountGroup newGroup ( com.google.gerrit.reviewdb.server.ReviewDb c , java.lang.String name , com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid ) throws com.google.gwtorm.server.OrmException { if ( uuid == null ) { uuid = com.google.gerrit.server.account.GroupUUID.make ( name , serverUser ) ; } return new com.google.gerrit.reviewdb.client.AccountGroup ( new com.google.gerrit.reviewdb.client.AccountGroup.NameKey ( name ) , new com.google.gerrit.reviewdb.client.AccountGroup.Id ( c.nextAccountGroupId ( ) ) , uuid ) ; }
protected void configureServlets ( ) { java.lang.Class < ? extends javax.servlet.Filter > authFilter ; if ( authConfig.isTrustContainerAuth ( ) ) { authFilter = com.google.gerrit.httpd.ContainerAuthFilter.class ; } else if ( authConfig.isGitBasichAuth ( ) ) { authFilter = com.google.gerrit.httpd.ProjectBasicAuthFilter.class ; } else { authFilter = com.google.gerrit.httpd.ProjectDigestFilter.class ; } java.lang.String git = GitOverHttpServlet.URL_REGEX ; filterRegex ( git ) . through ( authFilter ) ; serveRegex ( git ) . with ( com.google.gerrit.httpd.GitOverHttpServlet.class ) ; filter ( "/a/*" ) . through ( authFilter ) ; }
public com.google.gerrit.server.notedb.ChangeNotes notes ( ) throws com.google.gwtorm.server.OrmException { if ( ( notes ) == null ) { if ( ! ( lazyLoad ) ) { throw new com.google.gwtorm.server.OrmException ( "ChangeNotes not available, lazyLoad = false" ) ; } notes = notesFactory.create ( db , project ( ) , legacyId ) ; } return notes ; }
private void extractMailExample ( java.lang.String orig ) throws java.lang.Exception { java.nio.file.Path ex = site.mail_dir.resolve ( ( orig + ".example" ) ) ; com.google.gerrit.pgm.init.api.InitUtil.extract ( ex , com.google.gerrit.server.mail.OutgoingEmail.class , orig ) ; com.google.gerrit.common.FileUtil.chmod ( 292 , ex ) ; }
private boolean canPushWithForce ( ) { if ( ( GitRepositoryManager.REF_CONFIG.equals ( refName ) ) && ( ! ( projectControl.isOwner ( ) ) ) ) { return false ; } boolean result = false ; for ( com.google.gerrit.common.data.PermissionRule rule : access ( Permission.PUSH ) ) { if ( rule.isBlock ( ) ) { return false ; } if ( rule.getForce ( ) ) { result = true ; } } return result ; }
public static org.eclipse.jgit.lib.Config allEnabledConfig ( ) { org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config ( ) ; cfg.setBoolean ( com.google.gerrit.server.notedb.ConfigNotesMigration.NOTE_DB , com.google.gerrit.server.notedb.NoteDbTable.CHANGES.key ( ) , com.google.gerrit.server.notedb.ConfigNotesMigration.WRITE , true ) ; cfg.setBoolean ( com.google.gerrit.server.notedb.ConfigNotesMigration.NOTE_DB , com.google.gerrit.server.notedb.NoteDbTable.CHANGES.key ( ) , com.google.gerrit.server.notedb.ConfigNotesMigration.READ , true ) ; return cfg ; }
public void onFailure ( java.lang.Throwable err ) { com.google.gerrit.client.change.ChangeActions.setEnabled ( true , draftButtons ) ; if ( com.google.gerrit.client.change.SubmitFailureDialog.isConflict ( err ) ) { new com.google.gerrit.client.change.SubmitFailureDialog ( err.getMessage ( ) ) . center ( ) ; com.google.gerrit.client.Gerrit.display ( PageLinks.MINE ) ; } else { super . onFailure ( err ) ; } }
private void enableForm ( final boolean canModifyAgreements , final boolean canModifyDescription , final boolean canModifyMergeType ) { submitType.setEnabled ( canModifyMergeType ) ; useContentMerge.setEnabled ( canModifyMergeType ) ; descTxt.setEnabled ( canModifyDescription ) ; useContributorAgreements.setEnabled ( canModifyAgreements ) ; useSignedOffBy.setEnabled ( canModifyAgreements ) ; requireChangeID.setEnabled ( canModifyMergeType ) ; }
private static int index ( com.google.gerrit.common.data.Permission a ) { if ( com.google.gerrit.common.data.Permission.isLabel ( a.getName ( ) ) ) { return com.google.gerrit.common.data.Permission.LABEL_INDEX ; } else if ( com.google.gerrit.common.data.Permission.isLabelAs ( a.getName ( ) ) ) { return com.google.gerrit.common.data.Permission.LABEL_AS_INDEX ; } int index = com.google.gerrit.common.data.Permission.NAMES_LC.indexOf ( a.getName ( ) . toLowerCase ( ) ) ; return 0 <= index ? index : com.google.gerrit.common.data.Permission.NAMES_LC.size ( ) ; }
public void parseMetadataFromHeader ( ) { com.google.gerrit.server.mail.receive.MailMessage.Builder b = com.google.gerrit.server.mail.receive.MailMessage.builder ( ) ; b.id ( "" ) ; b.dateReceived ( java.time.Instant.now ( ) ) ; b.subject ( "" ) ; b.addAdditionalHeader ( ( ( MailHeader.CHANGE_NUMBER.fieldWithDelimiter ( ) ) + "123" ) ) ; b.addAdditionalHeader ( ( ( MailHeader.PATCH_SET.fieldWithDelimiter ( ) ) + "1" ) ) ; b.addAdditionalHeader ( ( ( MailHeader.MESSAGE_TYPE.fieldWithDelimiter ( ) ) + "comment" ) ) ; b.addAdditionalHeader ( ( ( MailHeader.COMMENT_DATE.fieldWithDelimiter ( ) ) + "Tue, 25 Oct 2016 02:11:35 -0700" ) ) ; com.google.gerrit.server.mail.Address author = new com.google.gerrit.server.mail.Address ( "Diffy" , "test@gerritcodereview.com" ) ; b.from ( author ) ; com.google.gerrit.server.mail.receive.MailMetadata meta = com.google.gerrit.server.mail.receive.MailHeaderParser.parse ( b.build ( ) ) ; com.google.common.truth.Truth.assertThat ( meta.author ) . isEqualTo ( author.getEmail ( ) ) ; com.google.common.truth.Truth.assertThat ( meta.changeNumber ) . isEqualTo ( 123 ) ; com.google.common.truth.Truth.assertThat ( meta.patchSet ) . isEqualTo ( 1 ) ; com.google.common.truth.Truth.assertThat ( meta.messageType ) . isEqualTo ( "comment" ) ; com.google.common.truth.Truth.assertThat ( meta.timestamp.toInstant ( ) ) . isEqualTo ( java.time.LocalDateTime.of ( 2016 , java.time.Month.OCTOBER , 25 , 9 , 11 , 35 ) . atOffset ( java.time.ZoneOffset.UTC ) . toInstant ( ) ) ; }
private com.google.inject.Injector getPluginInjector ( java.nio.file.Path jarPath ) throws java.io.IOException { final java.lang.String pluginName = com.google.common.base.MoreObjects.firstNonNull ( com.google.gerrit.server.plugins.JarPluginProvider.getJarPluginName ( jarPath ) , com.google.gerrit.server.plugins.PluginLoader.nameOf ( jarPath ) ) ; return initInjector.createChildInjector ( new com.google.inject.AbstractModule ( ) { @ java.lang.Override protected void configure ( ) { bind ( java.lang.String.class ) . annotatedWith ( com.google.gerrit.extensions.annotations.PluginName.class ) . toInstance ( pluginName ) ; } } ) ; }
private com.google.gerrit.server.plugins.ServerPlugin loadExternalPlugin ( java.io.File scriptFile , org.eclipse.jgit.internal.storage.file.FileSnapshot snapshot ) throws com.google.gerrit.server.plugins.InvalidPluginException { java.lang.String name = externalPluginFactory.getPluginName ( scriptFile ) ; return externalPluginFactory.get ( scriptFile , snapshot , new com.google.gerrit.server.plugins.ServerPluginProvider.PluginDescription ( pluginUserFactory.create ( name ) , getPluginCanonicalWebUrl ( name ) , getPluginDataDir ( name ) ) ) ; }
public void postRun ( ) throws java.lang.Exception { org.eclipse.jgit.lib.Config cfg = allProjectsConfig.load ( ) . getConfig ( ) ; if ( installVerified ) { cfg.setString ( com.google.gerrit.pgm.init.InitLabels.KEY_LABEL , com.google.gerrit.pgm.init.InitLabels.LABEL_VERIFIED , com.google.gerrit.pgm.init.InitLabels.KEY_FUNCTION , com.google.gerrit.common.data.LabelFunction.MAX_WITH_BLOCK.getFunctionName ( ) ) ; cfg.setStringList ( com.google.gerrit.pgm.init.InitLabels.KEY_LABEL , com.google.gerrit.pgm.init.InitLabels.LABEL_VERIFIED , com.google.gerrit.pgm.init.InitLabels.KEY_VALUE , java.util.Arrays.asList ( new java.lang.String [ ] { "-1 Fails" , " 0 No score" , "+1 Verified" } ) ) ; cfg.setBoolean ( com.google.gerrit.pgm.init.InitLabels.KEY_LABEL , com.google.gerrit.pgm.init.InitLabels.LABEL_VERIFIED , com.google.gerrit.pgm.init.InitLabels.KEY_COPY_ALL_SCORES_IF_NO_CODE_CHANGE , true ) ; allProjectsConfig.save ( "Configure 'Verified' label" ) ; } }
public void onLoad ( com.google.gerrit.plugin.client.screen.Screen screen ) { java.lang.String projectName = com.google.gwt.http.client.URL.decodeQueryString ( screen.getToken ( 1 ) ) ; java.lang.String path = com.google.gwt.http.client.URL.decode ( screen.getToken ( 2 ) ) ; screen.show ( new com.googlesource.gerrit.plugins.xdocs.client.XDocScreen ( projectName , "HEAD" , path ) ) ; screen.setWindowTitle ( com.googlesource.gerrit.plugins.xdocs.client.FileInfo.getFileName ( path ) ) ; }
public void testInsertOneDBException ( ) throws com.google.gwtorm.server.OrmException , java.sql.SQLException { java.sql.SQLException exception = new java.sql.BatchUpdateException ( ) ; java.sql.PreparedStatement insert = stubStatementThrowExceptionOnExecute ( com.google.gwtorm.jdbc.TestJdbcAccess.INSERT , exception ) ; com.google.gwtorm.jdbc.JdbcAccess < com.google.gwtorm.jdbc.TestJdbcAccess.Data , com.google.gwtorm.jdbc.TestJdbcAccess.Data.DataKey > classUnderTest = createClassUnderTest ( ) ; try { classUnderTest.insert ( oneRow ) ; org.junit.Assert.fail ( "missingException" ) ; } catch ( com.google.gwtorm.server.OrmException e ) { org.junit.Assert.assertSame ( e.getCause ( ) , exception ) ; } com.google.gwtorm.jdbc.TestJdbcAccess.assertUsedBatchingOnly ( insert ) ; }
public void pushForMasterAsDraft ( ) throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r = pushTo ( "refs/drafts/master" ) ; r.assertOkStatus ( ) ; r.assertChange ( Change.Status.DRAFT , null ) ; r = pushTo ( "refs/for/master%draft" ) ; r.assertOkStatus ( ) ; r.assertChange ( Change.Status.DRAFT , null ) ; }
public void hostIndex ( ) throws java.lang.Exception { com.google.gitiles.GitilesView view = getView ( "/" ) ; com.google.common.truth.Truth.assertThat ( view.getType ( ) ) . isEqualTo ( Type.HOST_INDEX ) ; com.google.common.truth.Truth.assertThat ( view.getHostName ( ) ) . isEqualTo ( "test-host" ) ; com.google.common.truth.Truth.assertThat ( view.getRepositoryName ( ) ) . isNull ( ) ; com.google.common.truth.Truth.assertThat ( view.getRevision ( ) ) . isEqualTo ( Revision.NULL ) ; com.google.common.truth.Truth.assertThat ( view.getOldRevision ( ) ) . isEqualTo ( Revision.NULL ) ; com.google.common.truth.Truth.assertThat ( view.getPathPart ( ) ) . isNull ( ) ; }
public static void assertAccountInfo ( com.google.gerrit.acceptance.TestAccount a , com.google.gerrit.server.account.AccountInfo ai ) { org.junit.Assert.assertTrue ( ( ( a.id.get ( ) ) == ( ai._accountId ) ) ) ; org.junit.Assert.assertEquals ( a.fullName , ai.name ) ; org.junit.Assert.assertEquals ( a.email , ai.email ) ; }
com.ericsson.gerrit.plugins.highavailability.forwarder.rest.HttpResponseHandler.HttpResult send ( ) throws java.io.IOException { java.lang.String json = com.ericsson.gerrit.plugins.highavailability.forwarder.rest.GsonParser.toJson ( cacheName , key ) ; return httpSession.post ( com.google.common.base.Joiner.on ( "/" ) . join ( pluginRelativePath , "cache" , cacheName ) , json ) ; }
protected void populate ( final int row , final com.google.gerrit.client.projects.ProjectInfo k ) { final com.google.gwt.user.client.ui.Anchor projectLink = new com.google.gwt.user.client.ui.Anchor ( k.name ( ) ) ; projectLink.addClickHandler ( new com.google.gwt.event.dom.client.ClickHandler ( ) { @ java.lang.Override public void onClick ( com.google.gwt.event.dom.client.ClickEvent event ) { sugestParent.setText ( getRowItem ( row ) . name ( ) ) ; } } ) ; table.setWidget ( row , 1 , projectLink ) ; table.setText ( row , 2 , k.description ( ) ) ; setRowItem ( row , k ) ; }
protected void configure ( ) { bind ( com.google.gerrit.server.config.ProjectConfigEntry.class ) . annotatedWith ( com.google.gerrit.extensions.annotations.Exports.named ( com.googlesource.gerrit.plugins.uploadvalidator.ValidatorConfig.KEY_PROJECT ) ) . toInstance ( new com.google.gerrit.server.config.ProjectConfigEntry ( "Projects" , null , com.google.gerrit.extensions.api.projects.ProjectConfigEntryType.ARRAY , null , false , "Only projects that match this regex will be validated." ) ) ; bind ( com.google.gerrit.server.config.ProjectConfigEntry.class ) . annotatedWith ( com.google.gerrit.extensions.annotations.Exports.named ( com.googlesource.gerrit.plugins.uploadvalidator.ValidatorConfig.KEY_REF ) ) . toInstance ( new com.google.gerrit.server.config.ProjectConfigEntry ( "Refs" , null , com.google.gerrit.extensions.api.projects.ProjectConfigEntryType.ARRAY , null , false , "Only refs that match this regex will be validated." ) ) ; bind ( com.googlesource.gerrit.plugins.uploadvalidator.ValidatorConfig.GroupByNameFinder.class ) . to ( com.googlesource.gerrit.plugins.uploadvalidator.ValidatorConfig.GroupByNameFromIndexFinder.class ) ; }
public void onSuccess ( com.googlesource.gerrit.plugins.serviceuser.client.GroupInfo result ) { updateValue ( ( result != null ? result.name ( ) : "" ) ) ; updateHref ( ( result != null ? result.url ( ) : "" ) ) ; com.google.gerrit.plugin.client.Plugin.get ( ) . refresh ( ) ; }
private void checkCreateCommit ( org.eclipse.jgit.lib.Repository repo , org.eclipse.jgit.revwalk.RevCommit commit , com.google.gerrit.server.project.ProjectState projectState , com.google.gerrit.server.permissions.PermissionBackend.ForRef forRef ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.server.permissions.PermissionBackendException { try { forRef.check ( RefPermission.UPDATE ) ; return ; } catch ( com.google.gerrit.extensions.restapi.AuthException denied ) { } if ( projectState.controlFor ( user.get ( ) ) . isReachableFromHeadsOrTags ( repo , commit ) ) { return ; } throw new com.google.gerrit.extensions.restapi.AuthException ( java.lang.String.format ( "%s for creating new commit object not permitted" , RefPermission.UPDATE.describeForException ( ) ) ) ; }
public void set ( final boolean s ) { if ( ( com.google.gerrit.client.Gerrit.isSignedIn ( ) ) && ( s != ( get ( ) ) ) ) { final com.google.gerrit.common.data.ToggleStarRequest req = new com.google.gerrit.common.data.ToggleStarRequest ( ) ; req.toggle ( cache.getChangeId ( ) , s ) ; Util.LIST_SVC.toggleStars ( req , new com.google.gerrit.client.rpc.GerritCallback < com.google.gwtjsonrpc.client.VoidResult > ( ) { public void onSuccess ( final com.google.gwtjsonrpc.client.VoidResult result ) { setStarred ( s ) ; fireEvent ( new com.google.gwt.event.logical.shared.ValueChangeEvent < java.lang.Boolean > ( s ) { } ) ; } } ) ; } }
public void patchScript ( final com.google.gerrit.reviewdb.Patch.Key patchKey , final com.google.gerrit.reviewdb.PatchSet.Id psa , final com.google.gerrit.reviewdb.PatchSet.Id psb , final com.google.gerrit.reviewdb.AccountDiffPreference dp , final com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.common.data.PatchScript > callback ) { if ( psb == null ) { callback.onFailure ( new com.google.gerrit.common.errors.NoSuchEntityException ( ) ) ; return ; } patchScriptFactoryFactory.create ( patchKey , psa , psb , dp ) . to ( callback ) ; }
public void testCreateProjectHttpWithInvalidRefName_BadRequest ( ) throws java.lang.Exception { com.google.gerrit.extensions.api.projects.ProjectInput in = new com.google.gerrit.extensions.api.projects.ProjectInput ( ) ; in.branches = java.util.Collections.singletonList ( name ( "invalid ref name" ) ) ; adminRestSession.put ( ( "/projects/" + ( name ( "newProject" ) ) ) , in ) . assertBadRequest ( ) ; }
public void testUnblockVisibilityByREGISTEREDUsers ( ) { com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.ANONYMOUS_USERS , "refs/heads/*" ) . setBlock ( ) ; com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.READ , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS , "refs/heads/*" ) ; com.google.gerrit.server.project.ProjectControl u = util.user ( local , com.google.gerrit.server.group.SystemGroupBackend.REGISTERED_USERS ) ; org.junit.Assert.assertTrue ( "u can read" , u.controlForRef ( "refs/heads/master" ) . isVisibleByRegisteredUsers ( ) ) ; }
private com.google.gerrit.extensions.common.CommitInfo getCommit ( org.eclipse.jgit.lib.ObjectId id ) throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = userSession.get ( ( ( ( "/projects/" + ( project.get ( ) ) ) + "/commits/" ) + ( id.name ( ) ) ) ) ; com.google.common.truth.Truth.assertThat ( r.getStatusCode ( ) ) . isEqualTo ( HttpStatus.SC_OK ) ; com.google.gerrit.extensions.common.CommitInfo result = newGson ( ) . fromJson ( r.getReader ( ) , com.google.gerrit.extensions.common.CommitInfo.class ) ; r.consume ( ) ; return result ; }
public void testInheritRead_SingleBranchDoesNotOverrideInherited ( ) { inherited.add ( grant ( com.google.gerrit.reviewdb.ApprovalCategory.READ , registered , "refs/*" , 1 , 2 ) ) ; local.add ( grant ( com.google.gerrit.reviewdb.ApprovalCategory.READ , registered , "refs/heads/foobar" , 1 , 1 ) ) ; com.google.gerrit.server.project.ProjectControl u = user ( ) ; assertTrue ( "can upload" , u.canPushToAtLeastOneRef ( ) ) ; assertTrue ( "can upload refs/heads/master" , u.controlForRef ( "refs/heads/master" ) . canUpload ( ) ) ; assertTrue ( "can upload refs/heads/foobar" , u.controlForRef ( "refs/heads/foobar" ) . canUpload ( ) ) ; }
private java.util.List < com.google.gerrit.extensions.common.SuggestedReviewerInfo > suggestReviewers ( com.google.gerrit.server.api.changes.SuggestedReviewersRequest r ) throws com.google.gerrit.extensions.restapi.RestApiException { try { suggestReviewers.setQuery ( r.getQuery ( ) ) ; suggestReviewers.setLimit ( r.getLimit ( ) ) ; return suggestReviewers.apply ( change ) ; } catch ( java.lang.Exception e ) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException ( "Cannot retrieve suggested reviewers" , e ) ; } }
public boolean rollback ( ) { java.io.File gitDirectory = destinationDirectory ; if ( ! ( gitDirectory.exists ( ) ) ) { return false ; } try { org.apache.commons.io.FileUtils.deleteDirectory ( gitDirectory ) ; return true ; } catch ( java.io.IOException e ) { com.googlesrouce.gerrit.plugins.github.git.GitCloneStep.LOG.error ( ( "Cannot clean-up output Git directory " + gitDirectory ) ) ; return false ; } }
public static void setReady ( com.google.gerrit.server.config.SitePaths sitePaths , java.lang.String name , int version , boolean ready ) throws java.io.IOException { try { com.google.gerrit.lucene.GerritIndexStatus cfg = new com.google.gerrit.lucene.GerritIndexStatus ( sitePaths ) ; cfg.setReady ( name , version , ready ) ; cfg.save ( ) ; } catch ( org.eclipse.jgit.errors.ConfigInvalidException e ) { throw new java.io.IOException ( e ) ; } }
void setEdit ( boolean edit ) { if ( edit ) { setOpen ( true ) ; removeStyleName ( draftStyle.view ( ) ) ; addStyleName ( draftStyle.edit ( ) ) ; editArea.setText ( contentPanelMessage.getText ( ) ) ; editArea.setFocus ( true ) ; } else { removeStyleName ( draftStyle.edit ( ) ) ; addStyleName ( draftStyle.view ( ) ) ; } resizePaddingWidget ( ) ; }
private void parseUpdate ( final org.eclipse.jgit.transport.ReceiveCommand cmd ) { com.google.gerrit.server.project.RefControl ctl = projectControl.controlForRef ( cmd.getRefName ( ) ) ; if ( ctl.canUpdate ( ) ) { validateNewCommits ( ctl , cmd ) ; } else { com.google.gerrit.server.git.ReceiveCommits.reject ( cmd ) ; } }
protected void configure ( ) { factory ( RenameGroupOp.Factory.class ) ; factory ( MetaDataUpdate.InternalFactory.class ) ; bind ( MetaDataUpdate.Server.class ) ; com.google.gerrit.extensions.registration.DynamicSet.bind ( binder ( ) , org.eclipse.jgit.transport.PostUploadHook.class ) . to ( com.google.gerrit.server.git.UploadPackMetricsHook.class ) ; com.google.gerrit.extensions.registration.DynamicItem.itemOf ( binder ( ) , com.google.gerrit.server.git.ChangeReportFormatter.class ) ; com.google.gerrit.extensions.registration.DynamicItem.bind ( binder ( ) , com.google.gerrit.server.git.ChangeReportFormatter.class ) . to ( com.google.gerrit.server.git.DefaultChangeReportFormatter.class ) ; }
protected void configure ( ) { get ( com.google.gerrit.server.config.ConfigResource.CONFIG_KIND , "config" ) . to ( com.googlesource.gerrit.plugins.verifystatus.server.GetConfig.class ) ; put ( com.google.gerrit.server.config.ConfigResource.CONFIG_KIND , "config" ) . to ( com.googlesource.gerrit.plugins.verifystatus.server.PutConfig.class ) ; get ( com.google.gerrit.server.change.RevisionResource.REVISION_KIND , "verifications" ) . to ( com.googlesource.gerrit.plugins.verifystatus.server.GetVerifications.class ) ; post ( com.google.gerrit.server.change.RevisionResource.REVISION_KIND , "verifications" ) . to ( com.googlesource.gerrit.plugins.verifystatus.server.PostVerification.class ) ; }
private synchronized void runHook ( com.google.gerrit.reviewdb.client.Project.NameKey project , java.nio.file.Path hook , java.util.List < java.lang.String > args ) { if ( ( project != null ) && ( java.nio.file.Files.exists ( hook ) ) ) { hookQueue.execute ( new com.google.gerrit.common.ChangeHookRunner.AsyncHookTask ( project , hook , args ) ) ; } }
private static java.net.URI toURI ( java.lang.String url ) throws java.net.URISyntaxException { final java.net.URI u = new java.net.URI ( url ) ; if ( com.google.gerrit.pgm.Init.isAnyAddress ( u ) ) { final int s = url.indexOf ( '*' ) ; url = ( ( url.substring ( 0 , s ) ) + ( com.google.gerrit.pgm.Init.hostname ( ) ) ) + ( url.substring ( ( s + 1 ) ) ) ; } return new java.net.URI ( url ) ; }
public void parseOptionMap ( java.util.Map < java.lang.String , java.lang.String [ ] > parameters ) throws org.kohsuke.args4j.CmdLineException { com.google.common.collect.Multimap < java.lang.String , java.lang.String > map = com.google.common.collect.LinkedHashMultimap.create ( ) ; for ( java.util.Map.Entry < java.lang.String , java.lang.String [ ] > ent : parameters.entrySet ( ) ) { for ( java.lang.String val : ent.getValue ( ) ) { map.put ( ent.getKey ( ) , val ) ; } } parseOptionMap ( map ) ; }
public void BROKEN_testIsEnabledRefNoParentMatchingBranchMiddleDisabled ( ) { java.lang.String [ ] branches = new java.lang.String [ ] { "^refs/heads/foo.*" , "^refs/heads/test.*" , "^refs/heads/baz.*" } ; setupIsEnabled ( "false" , null , branches ) ; com.googlesource.gerrit.plugins.its.base.its.ItsConfig itsConfig = createItsConfig ( ) ; replayMocks ( ) ; com.google.gerrit.reviewdb.client.Project.NameKey projectNK = new com.google.gerrit.reviewdb.client.Project.NameKey ( "testProject" ) ; assertFalse ( itsConfig.isEnabled ( projectNK , "refs/heads/testBranch" ) ) ; }
com.google.gerrit.client.reviewdb.ContactInformation toContactInformation ( ) { final com.google.gerrit.client.reviewdb.ContactInformation info ; if ( com.google.gerrit.client.Gerrit.getConfig ( ) . isUseContactInfo ( ) ) { info = new com.google.gerrit.client.reviewdb.ContactInformation ( ) ; info.setAddress ( addressTxt.getText ( ) ) ; info.setCountry ( countryTxt.getText ( ) ) ; info.setPhoneNumber ( phoneTxt.getText ( ) ) ; info.setFaxNumber ( faxTxt.getText ( ) ) ; } else { info = null ; } return info ; }
public com.google.gerrit.extensions.common.ChangeInfo apply ( com.google.gerrit.server.change.ChangeResource req , com.google.gerrit.extensions.api.changes.AbandonInput input ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.git.UpdateException , com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl control = req.getControl ( ) ; if ( ! ( control.canAbandon ( dbProvider.get ( ) ) ) ) { throw new com.google.gerrit.extensions.restapi.AuthException ( "abandon not permitted" ) ; } com.google.gerrit.reviewdb.client.Change change = abandon ( control , input.message , input.notify , notifyUtil.resolveAccounts ( input.notifyDetails ) ) ; return json.noOptions ( ) . format ( change ) ; }
java.util.Map < java.lang.String , com.google.gerrit.extensions.common.FileInfo > toFileInfoMap ( com.google.gerrit.reviewdb.client.Change change , org.eclipse.jgit.lib.ObjectId objectId , @ com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.PatchSet base ) throws com.google.gerrit.server.patch.PatchListNotAvailableException { org.eclipse.jgit.lib.ObjectId a = ( base == null ) ? null : org.eclipse.jgit.lib.ObjectId.fromString ( base.getRevision ( ) . get ( ) ) ; return toFileInfoMap ( change , new com.google.gerrit.server.patch.PatchListKey ( a , objectId , com.google.gerrit.extensions.client.DiffPreferencesInfo.Whitespace.IGNORE_NONE ) ) ; }
void stop ( ) throws java.lang.Exception { try { if ( com.google.gerrit.testutil.NoteDbMode.get ( ) . equals ( NoteDbMode.CHECK ) ) { testInjector.getInstance ( com.google.gerrit.testutil.NoteDbChecker.class ) . rebuildAndCheckAllChanges ( ) ; } } finally { daemon.getLifecycleManager ( ) . stop ( ) ; if ( ( daemonService ) != null ) { java.lang.System.out.println ( "Gerrit Server Shutdown" ) ; daemonService.shutdownNow ( ) ; daemonService.awaitTermination ( java.lang.Long.MAX_VALUE , java.util.concurrent.TimeUnit.SECONDS ) ; } org.eclipse.jgit.lib.RepositoryCache.clear ( ) ; } }
protected void bccStarredBy ( ) { if ( ! ( NotifyHandling.ALL.equals ( notify ) ) ) { return ; } try { for ( com.google.gerrit.reviewdb.client.Account.Id accountId : args.starredChangesUtil.byChangeFromIndex ( change.getId ( ) ) ) { super . add ( RecipientType.BCC , accountId ) ; } } catch ( com.google.gwtorm.server.OrmException | com.google.gerrit.server.project.NoSuchChangeException err ) { com.google.gerrit.server.mail.ChangeEmail.log.warn ( "Cannot BCC users that starred updated change" , err ) ; } }
private com.google.inject.Injector createSysInjector ( ) { java.util.List < com.google.inject.Module > modules = com.google.common.collect.Lists.newArrayList ( ) ; com.google.inject.Module changeIndexModule ; switch ( com.google.gerrit.server.index.IndexModule.getIndexType ( dbInjector ) ) { case LUCENE : changeIndexModule = new com.google.gerrit.lucene.LuceneIndexModule ( version , threads , outputBase ) ; break ; case SOLR : changeIndexModule = new com.google.gerrit.solr.SolrIndexModule ( false , threads , outputBase ) ; break ; default : throw new java.lang.IllegalStateException ( "unsupported index.type" ) ; } modules.add ( changeIndexModule ) ; modules.add ( dbInjector.getInstance ( com.google.gerrit.pgm.util.BatchProgramModule.class ) ) ; return dbInjector.createChildInjector ( modules ) ; }
protected void run ( java.lang.String [ ] args ) throws com.google.gerrit.server.ssh.Failure { final com.google.gerrit.client.data.GroupCache gc = com.google.gerrit.client.rpc.Common.getGroupCache ( ) ; if ( gc.isAdministrator ( getAccountId ( ) ) ) { gc.flush ( ) ; com.google.gerrit.client.rpc.Common.getProjectCache ( ) . flush ( ) ; com.google.gerrit.client.rpc.Common.getAccountCache ( ) . flush ( ) ; } else { throw new com.google.gerrit.server.ssh.Failure ( 1 , "fatal: Not a Gerrit administrator" ) ; } }
private < T > java.lang.String printCircularPath ( java.util.LinkedHashSet < T > p , T target ) { java.lang.StringBuilder sb = new java.lang.StringBuilder ( ) ; sb.append ( target ) ; java.util.ArrayList < T > reverseP = new java.util.ArrayList < > ( p ) ; java.util.Collections.reverse ( reverseP ) ; for ( T t : reverseP ) { sb.append ( "->" ) ; sb.append ( t ) ; if ( t.equals ( target ) ) { break ; } } return sb.toString ( ) ; }
public void run ( ) { ( hasNext ? next : up ) . go ( ) ; }
public void ambiguousRelativeToNonBranchOrTagSoy ( ) throws java.lang.Exception { repo.branch ( "refs/foo" ) . commit ( ) . create ( ) ; repo.branch ( "refs/heads/foo" ) . commit ( ) . create ( ) ; repo.branch ( "refs/tags/foo" ) . commit ( ) . create ( ) ; com.google.common.truth.Truth.assertThat ( buildBranchesSoyData ( ) ) . containsExactly ( ref ( "/b/test/+/refs/heads/foo" , "foo" ) ) . inOrder ( ) ; com.google.common.truth.Truth.assertThat ( buildTagsSoyData ( ) ) . containsExactly ( ref ( "/b/test/+/refs/tags/foo" , "foo" ) ) . inOrder ( ) ; }
private com.google.gerrit.server.plugins.Plugin loadPlugin ( java.lang.String name , java.nio.file.Path srcPlugin , org.eclipse.jgit.internal.storage.file.FileSnapshot snapshot ) throws com.google.gerrit.server.plugins.InvalidPluginException { java.lang.String pluginName = srcPlugin.getFileName ( ) . toString ( ) ; if ( com.google.gerrit.server.plugins.PluginLoader.isUiPlugin ( pluginName ) ) { return loadJsPlugin ( name , srcPlugin , snapshot ) ; } else if ( serverPluginFactory.handles ( srcPlugin ) ) { return loadServerPlugin ( srcPlugin , snapshot ) ; } else { throw new com.google.gerrit.server.plugins.InvalidPluginException ( java.lang.String.format ( "Unsupported plugin type: %s" , srcPlugin.getFileName ( ) ) ) ; } }
public void doFilter ( javax.servlet.ServletRequest request , javax.servlet.ServletResponse response , javax.servlet.FilterChain chain ) throws java.io.IOException , javax.servlet.ServletException { com.googlesource.gerrit.plugins.github.oauth.GitHubLogin hubLogin = loginProvider.get ( ) ; if ( ! ( hubLogin.isLoggedIn ( authScopes ) ) ) { hubLogin.login ( request , response , authScopes ) ; return ; } else { chain.doFilter ( request , response ) ; } }
public java.lang.Iterable < com.google.gerrit.extensions.common.WebLinkInfo > getBranchLinks ( java.lang.String project , java.lang.String branch ) { java.util.List < com.google.gerrit.extensions.common.WebLinkInfo > links = com.google.common.collect.Lists.newArrayList ( ) ; for ( com.google.gerrit.extensions.webui.BranchWebLink webLink : branchLinks ) { links.add ( webLink.getBranchWebLink ( project , branch ) ) ; } return links ; }
private void setLabelValues ( com.google.gerrit.common.data.LabelType type , com.google.gerrit.server.change.ChangeJson.LabelInfo label ) { label.values = com.google.common.collect.Maps.newLinkedHashMap ( ) ; for ( com.google.gerrit.common.data.LabelValue v : type.getValues ( ) ) { label.values.put ( v.formatValue ( ) , v.getText ( ) ) ; } if ( com.google.gerrit.server.change.ChangeJson.isOnlyZero ( label.values.keySet ( ) ) ) { label.values = null ; } }
void addRef ( final java.lang.String ref ) { if ( com.google.gerrit.git.PushOp.MIRROR_ALL.equals ( ref ) ) { delta.clear ( ) ; mirror = true ; } else if ( ! ( mirror ) ) { delta.add ( ref ) ; } }
public void missingOwner ( ) throws java.lang.Exception { com.google.gerrit.acceptance.TestAccount owner = accountCreator.create ( "missing" ) ; com.google.gerrit.server.notedb.ChangeNotes notes = insertChange ( owner ) ; accountsUpdate.create ( ) . deleteByKey ( owner.getId ( ) ) ; assertProblems ( notes , null , com.google.gerrit.acceptance.server.change.ConsistencyCheckerIT.problem ( ( "Missing change owner: " + ( owner.getId ( ) ) ) ) ) ; }
private void loadCommit ( final com.google.gerrit.client.changes.ChangeInfo.RevisionInfo rev , com.google.gerrit.client.rpc.CallbackGroup group ) { if ( rev.isEdit ( ) ) { return ; } com.google.gerrit.client.changes.ChangeApi.commitWithLinks ( changeId.get ( ) , rev.name ( ) , group.add ( new com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.client.changes.ChangeInfo.CommitInfo > ( ) { @ java.lang.Override public void onSuccess ( com.google.gerrit.client.changes.ChangeInfo.CommitInfo info ) { rev.setCommit ( info ) ; } @ java.lang.Override public void onFailure ( java.lang.Throwable caught ) { } } ) ) ; }
public void commentOnReviewableChangeByOwnerNotifyOwnerReviewers ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange ( ) ; review ( sc.owner , sc.changeId , com.google.gerrit.extensions.client.GeneralPreferencesInfo.EmailStrategy.ENABLED , com.google.gerrit.extensions.api.changes.NotifyHandling.OWNER_REVIEWERS ) ; assertThat ( sender ) . sent ( "comment" , sc ) . cc ( sc.reviewer , sc.ccer ) . cc ( sc.reviewerByEmail , sc.ccerByEmail ) . noOneElse ( ) ; }
private com.google.gerrit.client.diff.DraftBox addNewDraft ( net.codemirror.lib.CodeMirror cm , int line ) { return addDraftBox ( com.google.gerrit.client.changes.CommentInfo.createLine ( path , getSideFromCm ( cm ) , ( line + 1 ) , null , null ) ) ; }
public static boolean isStale ( com.google.gerrit.server.git.GitRepositoryManager repoManager , com.google.gerrit.reviewdb.client.Change.Id id , com.google.gerrit.reviewdb.client.Change indexChange , @ com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Change reviewDbChange , com.google.common.collect.SetMultimap < com.google.gerrit.reviewdb.client.Project.NameKey , com.google.gerrit.server.index.change.StalenessChecker.RefState > states , com.google.common.collect.ListMultimap < com.google.gerrit.reviewdb.client.Project.NameKey , com.google.gerrit.server.index.change.StalenessChecker.RefStatePattern > patterns ) { return ( com.google.gerrit.server.index.change.StalenessChecker.reviewDbChangeIsStale ( indexChange , reviewDbChange ) ) || ( com.google.gerrit.server.index.change.StalenessChecker.refsAreStale ( repoManager , id , states , patterns ) ) ; }
public void newPatchSetByOtherOnReviewableChangeOwnerSelfCcNotifyOwnerReviewersInNoteDb ( ) throws java.lang.Exception { com.google.common.truth.TruthJUnit.assume ( ) . that ( notesMigration.readChanges ( ) ) . isTrue ( ) ; com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange ( ) ; pushTo ( sc , "refs/for/master%notify=OWNER_REVIEWERS" , other , EmailStrategy.CC_ON_OWN_COMMENTS ) ; assertThat ( sender ) . sent ( "newpatchset" , sc ) . to ( sc.owner , sc.reviewer ) . cc ( sc.ccer ) . cc ( sc.reviewerByEmail , sc.ccerByEmail ) . noOneElse ( ) ; }
public void run ( ) throws java.io.IOException { ui.header ( "Index" ) ; com.google.gerrit.server.index.IndexModule.IndexType type = index.select ( "Type" , "type" , IndexType.LUCENE ) ; if ( ( site.isNew ) && ( type == ( com.google.gerrit.server.index.IndexModule.IndexType.LUCENE ) ) ) { com.google.gerrit.lucene.LuceneChangeIndex.setReady ( site , com.google.gerrit.server.index.ChangeSchemas.getLatest ( ) . getVersion ( ) , true ) ; } else { ui.message ( ( "The index must be built before starting Gerrit:\n" + " java -jar gerrit.war reindex -d site_path\n" ) ) ; initFlags.autoStart = false ; } }
private net.codemirror.lib.CodeMirror otherCM ( net.codemirror.lib.CodeMirror me ) { return me == ( cmA ) ? cmB : cmA ; }
public void defaultGpgCertificationMatchesEmail ( ) throws java.lang.Exception { com.google.gerrit.gpg.testutil.TestKey key = com.google.gerrit.gpg.testutil.TestKeys.key5 ( ) ; com.google.gerrit.gpg.GerritPublicKeyChecker checker = checkerFactory.create ( user ) ; assertProblems ( checker.check ( key.getPublicKey ( ) ) , Status.BAD , ( "Key must contain a valid certification for one of the following " + ( ( "identities:\n" + " gerrit:user\n" ) + " username:user" ) ) ) ; addExternalId ( "test" , "test" , "test5@example.com" ) ; checker = checkerFactory.create ( user ) ; assertNoProblems ( checker.check ( key.getPublicKey ( ) ) ) ; }
private void review ( com.google.gerrit.acceptance.TestAccount account , java.lang.String changeId , com.google.gerrit.extensions.client.GeneralPreferencesInfo.EmailStrategy strategy , @ com.google.gerrit.common.Nullable com.google.gerrit.extensions.api.changes.NotifyHandling notify ) throws java.lang.Exception { setEmailStrategy ( account , strategy ) ; com.google.gerrit.extensions.api.changes.ReviewInput in = com.google.gerrit.extensions.api.changes.ReviewInput.recommend ( ) ; in.notify = notify ; gApi.changes ( ) . id ( changeId ) . revision ( "current" ) . review ( in ) ; }
public com.google.gerrit.reviewdb.client.PatchSetInfo get ( com.google.gerrit.reviewdb.server.ReviewDb db , com.google.gerrit.server.notedb.ChangeNotes notes , com.google.gerrit.reviewdb.client.PatchSet.Id psId ) throws com.google.gerrit.server.patch.PatchSetInfoNotAvailableException { try { com.google.gerrit.reviewdb.client.PatchSet patchSet = psUtil.get ( db , notes , psId ) ; return get ( notes.getProjectName ( ) , patchSet ) ; } catch ( com.google.gwtorm.server.OrmException e ) { throw new com.google.gerrit.server.patch.PatchSetInfoNotAvailableException ( e ) ; } }
public void setUp ( ) throws java.lang.Exception { org.mockito.Mockito.when ( currentUserProviderMock.get ( ) ) . thenReturn ( currentUserMock ) ; org.mockito.Mockito.when ( permissionBackendMock.user ( currentUserMock ) ) . thenReturn ( withUserMock ) ; org.mockito.Mockito.when ( withUserMock.testOrFalse ( com.google.gerrit.server.permissions.GlobalPermission.ADMINISTRATE_SERVER ) ) . thenReturn ( true ) ; servlet = new com.ericsson.gerrit.plugins.highavailability.health.HealthServlet ( currentUserProviderMock , permissionBackendMock , tempFolder.getRoot ( ) . toPath ( ) ) ; }
private void updateSubmoduleSubscriptions ( com.google.gerrit.server.git.MergeOp.OpenBranch ob , com.google.gerrit.server.git.SubmoduleOp subOp ) { com.google.gerrit.server.git.CodeReviewCommit branchTip = ob.oldTip ; com.google.gerrit.server.git.MergeTip mergeTip = ob.mergeTip ; if ( ( mergeTip != null ) && ( ( branchTip == null ) || ( branchTip != ( mergeTip.getCurrentTip ( ) ) ) ) ) { logDebug ( "Updating submodule subscriptions for branch {}" , ob.name ) ; try { subOp.updateSubmoduleSubscriptions ( db , ob.name ) ; } catch ( com.google.gerrit.server.git.SubmoduleException e ) { logError ( ( "The submodule subscriptions were not updated according" + "to the .gitmodules files" ) , e ) ; } } }
public void testUpsertOneExisting ( ) throws com.google.gwtorm.server.OrmException , java.sql.SQLException { java.sql.PreparedStatement update = stubStatementWithUpdateCounts ( com.google.gwtorm.jdbc.TestJdbcAccess.UPDATE , 1 ) ; java.sql.PreparedStatement insert = stubStatementWithUpdateCounts ( com.google.gwtorm.jdbc.TestJdbcAccess.INSERT ) ; createClassUnderTest ( ) . upsert ( oneRow ) ; com.google.gwtorm.jdbc.TestJdbcAccess.assertUsedBatchingOnly ( update ) ; com.google.gwtorm.jdbc.TestJdbcAccess.assertNotUsed ( insert ) ; }
void index ( com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid , com.ericsson.gerrit.plugins.highavailability.forwarder.rest.Operation operation ) throws java.io.IOException { indexer.index ( uuid ) ; com.ericsson.gerrit.plugins.highavailability.forwarder.rest.IndexGroupRestApiServlet.logger.debug ( "Group {} successfully indexed" , uuid ) ; }
public void finishDisplay ( ) { super . finishDisplay ( ) ; display ( ) ; }
public com.google.gerrit.extensions.common.EditInfo toEditInfo ( com.google.gerrit.server.edit.ChangeEdit edit , boolean downloadCommands ) throws java.io.IOException { com.google.gerrit.extensions.common.EditInfo out = new com.google.gerrit.extensions.common.EditInfo ( ) ; out.commit = com.google.gerrit.server.edit.ChangeEditJson.fillCommit ( edit.getEditCommit ( ) ) ; out.baseRevision = edit.getBasePatchSet ( ) . getRevision ( ) . get ( ) ; out.actions = com.google.gerrit.server.edit.ChangeEditJson.fillActions ( edit ) ; if ( downloadCommands ) { out.fetch = fillFetchMap ( edit ) ; } return out ; }
protected void configure ( ) { final java.lang.String cacheName = WebSessionManager.CACHE_NAME ; final com.google.inject.TypeLiteral < com.google.gerrit.server.cache.Cache < com.google.gerrit.server.http.WebSessionManager.Key , com.google.gerrit.server.http.WebSessionManager.Val > > type = new com.google.inject.TypeLiteral < com.google.gerrit.server.cache.Cache < com.google.gerrit.server.http.WebSessionManager.Key , com.google.gerrit.server.http.WebSessionManager.Val > > ( ) { } ; disk ( type , cacheName ) . timeToIdle ( 12 , java.util.concurrent.TimeUnit.HOURS ) . timeToLive ( com.google.gerrit.server.cache.NamedCacheBinding.INFINITE , java.util.concurrent.TimeUnit.HOURS ) ; bind ( com.google.gerrit.server.http.WebSessionManager.class ) ; bind ( com.google.gerrit.server.http.WebSession.class ) . in ( com.google.inject.servlet.RequestScoped.class ) ; }
public void onSuccess ( com.google.gwt.core.client.JsArray < com.google.gerrit.client.account.AccountInfo > in ) { java.util.List < com.google.gerrit.client.ui.AccountSuggestOracle.AccountSuggestion > r = new java.util.ArrayList ( in.length ( ) ) ; for ( com.google.gerrit.client.account.AccountInfo p : com.google.gerrit.client.rpc.Natives.asList ( in ) ) { r.add ( new com.google.gerrit.client.ui.AccountSuggestOracle.AccountSuggestion ( p ) ) ; } cb.onSuggestionsReady ( req , new com.google.gerrit.client.ui.Response ( r ) ) ; }
public com.google.gerrit.rules.PrologEnvironment newPrologEnvironment ( ) throws com.googlecode.prolog_cafe.compiler.CompileException { com.googlecode.prolog_cafe.lang.PrologMachineCopy pmc = rulesMachine ; if ( pmc == null ) { pmc = rulesCache.loadMachine ( getProject ( ) . getNameKey ( ) , config.getRulesId ( ) ) ; rulesMachine = pmc ; } return envFactory.create ( pmc ) ; }
private com.google.gerrit.extensions.api.projects.TagInfo getTag ( java.lang.String ref ) throws java.lang.Exception { return gApi.projects ( ) . name ( project.get ( ) ) . tag ( ref ) . get ( ) ; }
public void setUp ( ) throws java.lang.Exception { mergeResults = com.google.common.collect.Maps.newHashMap ( ) ; com.google.gerrit.server.CurrentUser listenerUser = factory.create ( user.id ) ; eventListener = new com.google.gerrit.common.EventListener ( ) { @ java.lang.Override public void onEvent ( com.google.gerrit.server.events.Event event ) { if ( event instanceof com.google.gerrit.server.events.ChangeMergedEvent ) { com.google.gerrit.server.events.ChangeMergedEvent changeMergedEvent = ( ( com.google.gerrit.server.events.ChangeMergedEvent ) ( event ) ) ; mergeResults.put ( changeMergedEvent.change.get ( ) . number , changeMergedEvent.newRev ) ; } } } ; source.addEventListener ( eventListener , listenerUser ) ; }
public com.googlecode.prolog_cafe.lang.Operation exec ( com.googlecode.prolog_cafe.lang.Prolog engine ) throws com.googlecode.prolog_cafe.lang.PrologException { engine.setB0 ( ) ; com.googlecode.prolog_cafe.lang.Term a1 = arg1.dereference ( ) ; com.googlecode.prolog_cafe.lang.Term topicTerm = com.googlecode.prolog_cafe.lang.Prolog.Nil ; com.google.gerrit.reviewdb.client.Change change = StoredValues.CHANGE_DATA.get ( engine ) . getChange ( ) ; java.lang.String topic = change.getTopic ( ) ; if ( topic != null ) { topicTerm = com.googlecode.prolog_cafe.lang.SymbolTerm.create ( topic ) ; } if ( ! ( a1.unify ( topicTerm , engine.trail ) ) ) { return engine.fail ( ) ; } return cont ; }
public void addApprovals ( com.google.gerrit.server.data.PatchSetAttribute p , com.google.gerrit.reviewdb.client.PatchSet.Id id , java.util.Map < com.google.gerrit.reviewdb.client.PatchSet.Id , java.util.Collection < com.google.gerrit.reviewdb.client.PatchSetApproval > > all , com.google.gerrit.common.data.LabelTypes labelTypes ) { java.util.Collection < com.google.gerrit.reviewdb.client.PatchSetApproval > list = all.get ( id ) ; if ( list != null ) { addApprovals ( p , list , labelTypes ) ; } }
private com.google.gerrit.server.permissions.ProjectControl user ( com.google.gerrit.server.git.ProjectConfig local , java.lang.String name , com.google.gerrit.reviewdb.client.AccountGroup ... memberOf ) { return new com.google.gerrit.server.permissions.ProjectControl ( java.util.Collections.< com.google.gerrit.reviewdb.client.AccountGroup.UUID > emptySet ( ) , java.util.Collections.< com.google.gerrit.reviewdb.client.AccountGroup.UUID > emptySet ( ) , sectionSorter , changeControlFactory , permissionBackend , new com.google.gerrit.server.permissions.RefControlTest.MockUser ( name , memberOf ) , newProjectState ( local ) ) ; }
static < T > void invoke ( final com.google.gwtjsonrpc.client.JsonSerializer < T > resultSerializer , final com.google.gwt.user.client.rpc.AsyncCallback < T > callback , final java.lang.Object encoded ) { final T resobj ; try { resobj = ( encoded != null ) ? resultSerializer.fromJson ( encoded ) : null ; } catch ( java.lang.RuntimeException e ) { callback.onFailure ( new com.google.gwt.user.client.rpc.InvocationException ( "Invalid JSON Response" , e ) ) ; return ; } callback.onSuccess ( resobj ) ; }
public void refresh ( ) { Util.DETAIL_SVC.changeDetail ( changeId , new com.google.gerrit.client.rpc.ScreenLoadCallback < com.google.gerrit.client.data.ChangeDetail > ( ) { public void onSuccess ( final com.google.gerrit.client.data.ChangeDetail r ) { if ( isAttached ( ) ) { display ( r ) ; } } } ) ; }
public void onSuccess ( com.google.gerrit.client.rpc.NativeString result ) { if ( com.google.gerrit.client.Gerrit.getConfig ( ) . testChangeMerge ( ) ) { if ( canSubmit ) { actions.setSubmitEnabled ( changeInfo.mergeable ( ) ) ; if ( status == ( com.google.gerrit.reviewdb.client.Change.Status.NEW ) ) { statusText.setInnerText ( ( changeInfo.mergeable ( ) ? Util.C.readyToSubmit ( ) : Util.C.mergeConflict ( ) ) ) ; } } setVisible ( notMergeable , ( ! ( changeInfo.mergeable ( ) ) ) ) ; } renderSubmitType ( result.asString ( ) ) ; }
public void onError ( com.google.gwt.http.client.Request request , java.lang.Throwable e ) { cb.onFailure ( e ) ; }
public com.google.gerrit.extensions.restapi.Response < ? > apply ( com.google.gerrit.server.change.ChangeResource rsrc , com.google.gerrit.server.change.DeleteChangeEdit.Input input ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.extensions.restapi.ResourceNotFoundException , com.google.gerrit.server.project.InvalidChangeOperationException , java.io.IOException { com.google.common.base.Optional < com.google.gerrit.server.edit.ChangeEdit > edit = editUtil.byChange ( rsrc.getChange ( ) ) ; if ( edit.isPresent ( ) ) { editUtil.delete ( edit.get ( ) ) ; } else { throw new com.google.gerrit.extensions.restapi.ResourceNotFoundException ( ) ; } return com.google.gerrit.extensions.restapi.Response.none ( ) ; }
public com.google.gerrit.extensions.common.ChangeInfo apply ( com.google.gerrit.server.change.ChangeResource req , final com.google.gerrit.extensions.api.changes.AbandonInput input ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.git.UpdateException , com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl control = req.getControl ( ) ; com.google.gerrit.server.IdentifiedUser caller = control.getUser ( ) . asIdentifiedUser ( ) ; if ( ! ( control.canAbandon ( ) ) ) { throw new com.google.gerrit.extensions.restapi.AuthException ( "abandon not permitted" ) ; } com.google.gerrit.reviewdb.client.Change change = abandon ( control , input.message , caller.getAccount ( ) ) ; return json.create ( ChangeJson.NO_OPTIONS ) . format ( change ) ; }
public void testUpsertTwoUpdateCountsAreNull ( ) throws com.google.gwtorm.server.OrmException , java.sql.SQLException { java.sql.PreparedStatement update = stubStatementWithUpdateCounts ( com.google.gwtorm.jdbc.AbstractTestJdbcAccess.UPDATE , null ) ; java.sql.PreparedStatement insert = stubStatementWithUpdateCounts ( com.google.gwtorm.jdbc.AbstractTestJdbcAccess.INSERT , 1 , 1 ) ; classUnderTest.upsert ( twoRows ) ; assertCorrectUpdating ( update , 1 , 2 ) ; assertCorrectUpdating ( insert , 1 , 2 ) ; }
public com.google.gerrit.extensions.api.projects.ChildProjectApi child ( java.lang.String name ) throws com.google.gerrit.extensions.restapi.RestApiException { try { return childApi.create ( children.parse ( checkExists ( ) , com.google.gerrit.extensions.restapi.IdString.fromDecoded ( name ) ) ) ; } catch ( java.lang.Exception e ) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException ( "Cannot parse child project" , e ) ; } }
public com.google.gerrit.extensions.common.DiffInfo diff ( java.lang.String base ) throws com.google.gerrit.extensions.restapi.RestApiException { try { return getDiff.setBase ( base ) . apply ( file ) . value ( ) ; } catch ( java.lang.Exception e ) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException ( "Cannot retrieve diff" , e ) ; } }
private static java.lang.String missingUserIds ( java.util.Set < java.lang.String > allowedUserIds ) { java.lang.StringBuilder sb = new java.lang.StringBuilder ( "Key must contain a valid certification for one of the following identities:\n" ) ; java.util.Iterator < java.lang.String > sorted = allowedUserIds.stream ( ) . sorted ( ) . iterator ( ) ; while ( sorted.hasNext ( ) ) { sb.append ( " " ) . append ( sorted.next ( ) ) ; if ( sorted.hasNext ( ) ) { sb.append ( '\n' ) ; } } return sb.toString ( ) ; }
public com.google.gerrit.extensions.common.SshKeyInfo addSshKey ( java.lang.String key ) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.api.accounts.SshKeyInput in = new com.google.gerrit.extensions.api.accounts.SshKeyInput ( ) ; in.raw = com.google.gerrit.common.RawInputUtil.create ( key ) ; try { return addSshKey.apply ( account , in ) . value ( ) ; } catch ( java.lang.Exception e ) { throw com.google.gerrit.server.api.ApiUtil.asRestApiException ( "Cannot add SSH key" , e ) ; } }
protected void run ( ) { final com.googlesource.gerrit.plugins.verifystatus.VerifyStatusQueryShell shell = factory.create ( in , out ) ; shell.setOutputFormat ( format ) ; if ( ( query ) != null ) { shell.execute ( query ) ; } else { shell.run ( ) ; } }
public void run ( ) { final com.google.gerrit.reviewdb.server.ReviewDb db ; try { db = database.open ( ) ; } catch ( com.google.gwtorm.server.OrmException e ) { e.printStackTrace ( ) ; return ; } try { for ( ; ; ) { final com.google.gerrit.reviewdb.client.AccountExternalId extId = next ( ) ; if ( extId == null ) { break ; } convertLocalUserToLowerCase ( db , extId ) ; synchronized ( monitor ) { monitor.update ( 1 ) ; } } } finally { db.close ( ) ; } }
public void operationComplete ( org.apache.mina.core.future.IoFuture future ) { final com.google.gerrit.sshd.SshScope.Context ctx = new com.google.gerrit.sshd.SshScope.Context ( sd , null ) ; final com.google.gerrit.sshd.SshScope.Context old = com.google.gerrit.sshd.SshScope.set ( ctx ) ; try { log.onLogout ( ) ; } finally { com.google.gerrit.sshd.SshScope.set ( old ) ; } }
private void innerTest ( ) throws java.lang.Exception { try { outer ( ) ; fail ( "should throw" ) ; } catch ( java.lang.IllegalStateException e ) { java.lang.StackTraceElement [ ] trimmed = com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.trimStack ( e.getStackTrace ( ) , java.lang.Thread.currentThread ( ) . getStackTrace ( ) [ 1 ] ) ; java.lang.String str = java.util.Arrays.toString ( trimmed ) ; com.google.common.truth.Truth.assertThat ( str ) . doesNotContain ( "trimStackTrace" ) ; com.google.common.truth.Truth.assertThat ( str ) . contains ( "innerTest" ) ; } }
public void setCommit ( org.eclipse.jgit.revwalk.RevWalk rw , org.eclipse.jgit.lib.ObjectId id , java.lang.String pushCert ) throws java.io.IOException { org.eclipse.jgit.revwalk.RevCommit commit = rw.parseCommit ( id ) ; rw.parseBody ( commit ) ; this . commit = commit.name ( ) ; subject = commit.getShortMessage ( ) ; this . pushCert = pushCert ; }
public int getLineCount ( final int file ) throws com.google.gerrit.client.rpc.CorruptEntityException , com.google.gerrit.client.rpc.NoDifferencesException , com.google.gerrit.client.rpc.NoSuchEntityException , com.google.gwtorm.client.OrmException , java.io.IOException { return ( getLineMap ( file ) . size ( ) ) - 2 ; }
private int limit ( com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > s ) { int n = ( queryBuilder.hasLimit ( s ) ) ? queryBuilder.getLimit ( s ) : maxLimit ; return ( limit ) > 0 ? ( java.lang.Math.min ( n , limit ) ) + 1 : n + 1 ; }
private void streamFile ( javax.servlet.http.HttpServletRequest req , javax.servlet.http.HttpServletResponse res ) throws java.io.IOException { java.io.File f = configFile ( req ) ; res.setStatus ( HttpServletResponse.SC_OK ) ; res.setContentType ( "application/octet-stream" ) ; res.setContentLength ( ( ( int ) ( f.length ( ) ) ) ) ; java.io.OutputStream out = res.getOutputStream ( ) ; try ( java.io.InputStream in = new java.io.FileInputStream ( f ) ) { com.google.common.io.ByteStreams.copy ( in , out ) ; } }
void importGit ( ) throws com.google.gwtorm.client.OrmException , java.io.IOException { if ( flags.importProjects ) { gitProjectImporter.run ( new com.google.gerrit.server.git.GitProjectImporter.Messages ( ) { @ java.lang.Override public void info ( java.lang.String msg ) { java.lang.System.err.println ( msg ) ; java.lang.System.err.flush ( ) ; } @ java.lang.Override public void warning ( java.lang.String msg ) { info ( msg ) ; } } ) ; } }
private void fireHook ( ) { final java.util.Map < com.google.gerrit.reviewdb.ApprovalCategory.Id , com.google.gerrit.reviewdb.ApprovalCategoryValue.Id > changed = new java.util.HashMap < com.google.gerrit.reviewdb.ApprovalCategory.Id , com.google.gerrit.reviewdb.ApprovalCategoryValue.Id > ( ) ; for ( com.google.gerrit.reviewdb.ApprovalCategoryValue.Id v : approvals ) { changed.put ( v.getParentKey ( ) , v ) ; } hooks.doCommentAddedHook ( change , user.getAccount ( ) , patchSet , messageText , changed ) ; }
public com.google.gerrit.reviewdb.client.Change update ( com.google.gerrit.reviewdb.client.Change c ) { c.setStatus ( Change.Status.MERGED ) ; c.setSubmissionId ( submissionId ) ; if ( ! ( merged.equals ( c.currentPatchSetId ( ) ) ) ) { try { c.setCurrentPatchSet ( patchSetInfoFactory.get ( db , notes , merged ) ) ; } catch ( com.google.gerrit.server.patch.PatchSetInfoNotAvailableException e1 ) { logError ( ( "Cannot read merged patch set " + merged ) , e1 ) ; } } com.google.gerrit.server.ChangeUtil.updated ( c ) ; return c ; }
private int getPort ( java.net.URL originalUrl ) { java.lang.String protocol = originalUrl.getProtocol ( ) . toLowerCase ( ) ; int port = originalUrl.getPort ( ) ; if ( port == ( - 1 ) ) { return protocol.equals ( "https" ) ? 443 : 80 ; } return port ; }
public void mergeByOtherNotifyOwnerReviewers ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS , com.google.gerrit.server.account.WatchConfig.NotifyType.SUBMITTED_CHANGES ) ; merge ( sc.changeId , other , com.google.gerrit.extensions.api.changes.NotifyHandling.OWNER_REVIEWERS ) ; assertThat ( sender ) . sent ( "merged" , sc ) . to ( sc.owner ) . cc ( sc.reviewer , sc.ccer ) . cc ( sc.reviewerByEmail , sc.ccerByEmail ) . notTo ( sc.starrer ) . notTo ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS , com.google.gerrit.server.account.WatchConfig.NotifyType.SUBMITTED_CHANGES ) ; }
public void testMIXED_NullUser ( ) { setFrom ( "MIXED" ) ; org.easymock.EasyMock.replay ( accountCache ) ; final com.google.gerrit.server.mail.Address r = create ( ) . from ( null ) ; org.junit.Assert.assertNotNull ( r ) ; org.junit.Assert.assertEquals ( ident.getName ( ) , r.name ) ; org.junit.Assert.assertEquals ( ident.getEmailAddress ( ) , r.email ) ; org.easymock.EasyMock.verify ( accountCache ) ; }
public void commitTime ( ) throws java.lang.Exception { org.eclipse.jgit.revwalk.RevCommit root = repo.commit ( ) . create ( ) ; org.eclipse.jgit.revwalk.RevCommit master = repo.commit ( ) . parent ( root ) . create ( ) ; com.google.common.truth.Truth.assertThat ( getTime ( root ) ) . isEqualTo ( ( ( start ) + 1 ) ) ; com.google.common.truth.Truth.assertThat ( getTime ( master ) ) . isEqualTo ( ( ( start ) + 2 ) ) ; }
public void deleteBranchesNotFoundContinue ( ) throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DeleteBranchesInput input = new com.google.gerrit.extensions.api.projects.DeleteBranchesInput ( ) ; java.util.List < java.lang.String > branches = com.google.common.collect.Lists.newArrayList ( "refs/heads/does-not-exist" ) ; branches.addAll ( com.google.gerrit.acceptance.rest.project.DeleteBranchesIT.BRANCHES ) ; input.branches = branches ; try { project ( ) . deleteBranches ( input ) ; fail ( "Expected ResourceConflictException" ) ; } catch ( com.google.gerrit.extensions.restapi.ResourceConflictException e ) { com.google.common.truth.Truth.assertThat ( e ) . hasMessageThat ( ) . isEqualTo ( errorMessageForBranches ( com.google.common.collect.ImmutableList.of ( "refs/heads/does-not-exist" ) ) ) ; } assertBranchesDeleted ( ) ; }
public java.lang.String fetch ( java.lang.String projectName , java.lang.String commitId ) throws java.io.IOException { try ( org.eclipse.jgit.lib.Repository repo = repoManager.openRepository ( new com.google.gerrit.reviewdb.client.Project.NameKey ( projectName ) ) ; org.eclipse.jgit.revwalk.RevWalk revWalk = new org.eclipse.jgit.revwalk.RevWalk ( repo ) ) { org.eclipse.jgit.revwalk.RevCommit commit = revWalk.parseCommit ( org.eclipse.jgit.lib.ObjectId.fromString ( commitId ) ) ; return commit.getFullMessage ( ) ; } }
public boolean equals ( java.lang.Object o ) { if ( ! ( o instanceof com.google.gerrit.client.change.History.AuthorRevision ) ) { return false ; } com.google.gerrit.client.change.History.AuthorRevision b = ( ( com.google.gerrit.client.change.History.AuthorRevision ) ( o ) ) ; return ( ( author ) == ( b.author ) ) && ( ( revision ) == ( b.revision ) ) ; }
public void getChildProject ( ) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey child = createProject ( "p1" ) ; com.google.gerrit.extensions.common.ProjectInfo childInfo = gApi.projects ( ) . name ( allProjects.get ( ) ) . child ( child.get ( ) ) . get ( ) ; com.google.gerrit.acceptance.rest.project.ProjectAssert.assertProjectInfo ( projectCache.get ( child ) . getProject ( ) , childInfo ) ; }
public synchronized < F1 > com.google.gerrit.metrics.Timer1 < F1 > newTimer ( java.lang.String name , com.google.gerrit.metrics.Description desc , com.google.gerrit.metrics.Field < F1 > field1 ) { com.google.gerrit.metrics.dropwizard.DropWizardMetricMaker.checkTimerDescription ( name , desc ) ; com.google.gerrit.metrics.dropwizard.TimerImpl1 < F1 > m = new com.google.gerrit.metrics.dropwizard.TimerImpl1 ( this , name , desc , field1 ) ; define ( name , desc ) ; bucketed.put ( name , m ) ; return m.timer ( ) ; }
private static void assertSingleWord ( final java.lang.String name , final java.lang.String value , final org.antlr.runtime.tree.Tree r ) { org.junit.Assert.assertEquals ( QueryParser.FIELD_NAME , r.getType ( ) ) ; org.junit.Assert.assertEquals ( name , r.getText ( ) ) ; org.junit.Assert.assertEquals ( 1 , r.getChildCount ( ) ) ; final org.antlr.runtime.tree.Tree c = r.getChild ( 0 ) ; org.junit.Assert.assertEquals ( QueryParser.SINGLE_WORD , c.getType ( ) ) ; org.junit.Assert.assertEquals ( value , c.getText ( ) ) ; org.junit.Assert.assertEquals ( 0 , c.getChildCount ( ) ) ; }
public void testPrefixReducesSearchSpace ( ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.query.change.RegexFilePredicate p = com.google.gerrit.server.query.change.RegexFilePredicateTest.predicate ( "^a/b/.*\\.[ch]" ) ; org.junit.Assert.assertTrue ( p.match ( com.google.gerrit.server.query.change.RegexFilePredicateTest.change ( "a/b/source.c" ) ) ) ; org.junit.Assert.assertFalse ( p.match ( com.google.gerrit.server.query.change.RegexFilePredicateTest.change ( "a/b/source.res" ) ) ) ; org.junit.Assert.assertFalse ( p.match ( com.google.gerrit.server.query.change.RegexFilePredicateTest.change ( "source.res" ) ) ) ; org.junit.Assert.assertTrue ( p.match ( com.google.gerrit.server.query.change.RegexFilePredicateTest.change ( "a/b/a.a" , "a/b/a.d" , "a/b/a.h" ) ) ) ; }
void commitNotes ( ) throws java.io.IOException , org.eclipse.jgit.api.errors.ConcurrentRefUpdateException { try { if ( ( serviceUserNotes ) == null ) { return ; } message.insert ( 0 , "Update notes for service user commits\n\n" ) ; notesBranchUtilFactory.create ( project , git , inserter ) . commitAllNotes ( serviceUserNotes , com.googlesource.gerrit.plugins.serviceuser.CreateServiceUserNotes.REFS_NOTES_SERVICEUSER , gerritServerIdent , message.toString ( ) ) ; } finally { if ( ( inserter ) != null ) { inserter.close ( ) ; } } }
public com.google.gerrit.server.project.ChangeControl controlFor ( com.google.gerrit.reviewdb.client.Change change , com.google.gerrit.server.CurrentUser user ) throws com.google.gerrit.server.project.NoSuchChangeException { final com.google.gerrit.reviewdb.client.Project.NameKey projectKey = change.getProject ( ) ; try { return projectControl.controlFor ( projectKey , user ) . controlFor ( change ) ; } catch ( com.google.gerrit.server.project.NoSuchProjectException e ) { throw new com.google.gerrit.server.project.NoSuchChangeException ( change.getId ( ) , e ) ; } catch ( java.io.IOException e ) { throw new com.google.gerrit.server.project.NoSuchChangeException ( change.getId ( ) , e ) ; } }
public void testHashCode ( ) { org.junit.Assert.assertTrue ( ( ( com.google.gerrit.server.query.FieldPredicateTest.f ( "a" , "bob" ) . hashCode ( ) ) == ( com.google.gerrit.server.query.FieldPredicateTest.f ( "a" , "bob" ) . hashCode ( ) ) ) ) ; org.junit.Assert.assertFalse ( ( ( com.google.gerrit.server.query.FieldPredicateTest.f ( "a" , "bob" ) . hashCode ( ) ) == ( com.google.gerrit.server.query.FieldPredicateTest.f ( "a" , "alice" ) . hashCode ( ) ) ) ) ; }
public void submitOnPushMergeConflict ( ) throws java.lang.Exception { org.eclipse.jgit.lib.ObjectId objectId = repo ( ) . getRef ( "HEAD" ) . getObjectId ( ) ; push ( "refs/heads/master" , "one change" , "a.txt" , "some content" ) ; testRepo.reset ( objectId ) ; grant ( Permission.SUBMIT , project , "refs/for/refs/heads/master" ) ; com.google.gerrit.acceptance.PushOneCommit.Result r = push ( "refs/for/master%submit" , "other change" , "a.txt" , "other content" ) ; r.assertOkStatus ( ) ; r.assertChange ( Change.Status.NEW , null , admin ) ; r.assertMessage ( CommitMergeStatus.PATH_CONFLICT.getMessage ( ) ) ; }
private com.google.gerrit.server.change.GetRelated.ChangeAndCommit changeAndCommit ( com.google.gerrit.reviewdb.client.PatchSet.Id psId , org.eclipse.jgit.lib.ObjectId commitId , int currentRevisionNum ) { com.google.gerrit.server.change.GetRelated.ChangeAndCommit result = new com.google.gerrit.server.change.GetRelated.ChangeAndCommit ( ) ; result.project = project.get ( ) ; result._changeNumber = psId.getParentKey ( ) . get ( ) ; result.commit = new com.google.gerrit.extensions.common.CommitInfo ( ) ; result.commit.commit = commitId.name ( ) ; result._revisionNumber = psId.get ( ) ; result._currentRevisionNumber = currentRevisionNum ; result.status = "NEW" ; return result ; }
protected void configure ( ) { if ( ! ( com.google.gerrit.gpg.BouncyCastleUtil.havePGP ( ) ) ) { throw new com.google.inject.ProvisionException ( "Bouncy Castle PGP not installed" ) ; } bind ( com.google.gerrit.gpg.PublicKeyStore.class ) . toProvider ( com.google.gerrit.gpg.SignedPushModule.StoreProvider.class ) ; com.google.gerrit.extensions.registration.DynamicSet.bind ( binder ( ) , com.google.gerrit.server.git.ReceivePackInitializer.class ) . to ( com.google.gerrit.gpg.SignedPushModule.Initializer.class ) ; }
public static void put ( @ com.google.gerrit.common.Nullable java.lang.String project , int id , java.lang.String path , java.lang.String content , com.google.gerrit.client.rpc.GerritCallback < com.google.gerrit.client.VoidResult > cb ) { if ( Patch.COMMIT_MSG.equals ( path ) ) { com.google.gerrit.client.changes.ChangeEditApi.putMessage ( project , id , content , cb ) ; } else { com.google.gerrit.client.changes.ChangeEditApi.editFile ( project , id , path ) . put ( content , cb ) ; } }
private java.util.Optional < com.google.gerrit.server.group.InternalGroup > toInternalGroup ( com.google.gson.JsonElement json ) { com.google.gson.JsonElement source = json.getAsJsonObject ( ) . get ( "_source" ) ; if ( source == null ) { source = json.getAsJsonObject ( ) . get ( "fields" ) ; } com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid = new com.google.gerrit.reviewdb.client.AccountGroup.UUID ( source.getAsJsonObject ( ) . get ( GroupField.UUID.getName ( ) ) . getAsString ( ) ) ; return groupCache.get ( ) . get ( uuid ) ; }
protected com.google.gerrit.server.notedb.LoadHandle openHandle ( org.eclipse.jgit.lib.Repository repo ) throws java.io.IOException { if ( ( ( change ) != null ) && ( autoRebuild ) ) { com.google.gerrit.server.notedb.NoteDbChangeState state = com.google.gerrit.server.notedb.NoteDbChangeState.parse ( change ) ; if ( ! ( com.google.gerrit.server.notedb.NoteDbChangeState.areDraftsUpToDate ( state , new com.google.gerrit.server.git.RepoRefCache ( repo ) , getChangeId ( ) , author ) ) ) { return rebuildAndOpen ( repo ) ; } } return super . openHandle ( repo ) ; }
private java.lang.String getRedirectUrl ( java.lang.String pathAndQuery ) throws java.io.IOException , javax.servlet.ServletException { com.google.gitiles.TestViewFilter.Result result = com.google.gitiles.TestViewFilter.service ( repo , pathAndQuery ) ; com.google.common.truth.Truth.assertThat ( result.getResponse ( ) . getStatus ( ) ) . isEqualTo ( 302 ) ; return result.getResponse ( ) . getHeader ( com.google.common.net.HttpHeaders.LOCATION ) ; }
protected void configure ( ) { factory ( LuceneChangeIndex.Factory.class ) ; install ( new com.google.gerrit.server.index.IndexModule ( threads ) ) ; if ( ( ( singleVersion ) == null ) && ( ( base ) == null ) ) { install ( new com.google.gerrit.lucene.LuceneIndexModule.MultiVersionModule ( ) ) ; } else { install ( new com.google.gerrit.lucene.LuceneIndexModule.SingleVersionModule ( ) ) ; } }
public boolean match ( final com.google.gerrit.server.query.change.ChangeData cd ) throws com.google.gwtorm.client.OrmException { if ( cd.fastIsVisibleTo ( user ) ) { return true ; } try { com.google.gerrit.reviewdb.Change c = cd.change ( db ) ; if ( ( c != null ) && ( changeControl.controlFor ( c , user ) . isVisible ( ) ) ) { cd.cacheVisibleTo ( user ) ; return true ; } else { return false ; } } catch ( com.google.gerrit.server.project.NoSuchChangeException e ) { return false ; } }
private com.google.gerrit.extensions.common.ApprovalInfo getVote ( com.google.gerrit.extensions.api.changes.ChangeApi change , java.lang.String label ) throws com.google.gerrit.extensions.restapi.RestApiException { java.util.List < com.google.gerrit.extensions.common.ApprovalInfo > approvals = change.get ( java.util.EnumSet.of ( ListChangesOption.DETAILED_LABELS ) ) . labels.get ( label ) . all ; return approvals.get ( ( ( approvals.size ( ) ) - 1 ) ) ; }
private void appendFileLine ( java.lang.StringBuilder cmts , com.google.gerrit.server.patch.PatchFile fileData , short side , int line ) { java.lang.String lineStr = getLine ( fileData , side , line ) ; cmts.append ( "Line " ) . append ( line ) . append ( ": " ) . append ( lineStr ) . append ( "\n" ) ; }
public java.util.Map < java.lang.String , com.google.gerrit.extensions.common.GpgKeyInfo > putGpgKeys ( com.google.gerrit.server.account.AccountResource account , java.util.List < java.lang.String > add , java.util.List < java.lang.String > delete ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.GpgException { com.google.gerrit.gpg.server.PostGpgKeys.Input in = new com.google.gerrit.gpg.server.PostGpgKeys.Input ( ) ; in.add = add ; in.delete = delete ; try { return postGpgKeys.get ( ) . apply ( account , in ) ; } catch ( org.bouncycastle.openpgp.PGPException | com.google.gwtorm.server.OrmException | java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e ) { throw new com.google.gerrit.server.GpgException ( e ) ; } }
public void setUp ( ) throws java.lang.Exception { index = new com.google.gerrit.server.index.FakeIndex ( FakeIndex.V2 ) ; indexes = new com.google.gerrit.server.index.IndexCollection ( ) ; indexes.setSearchIndex ( index ) ; queryBuilder = new com.google.gerrit.server.index.FakeQueryBuilder ( indexes ) ; rewrite = new com.google.gerrit.server.index.IndexRewriteImpl ( indexes , new com.google.gerrit.server.query.change.BasicChangeRewrites ( null ) ) ; }
public void byKey ( ) throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository < com.google.gerrit.testutil.InMemoryRepositoryManager.Repo > repo = createProject ( "repo" ) ; com.google.gerrit.reviewdb.client.Change change = insert ( repo , newChange ( repo ) ) ; java.lang.String key = change.getKey ( ) . get ( ) ; assertQuery ( "I0000000000000000000000000000000000000000" ) ; for ( int i = 0 ; i <= 36 ; i ++ ) { java.lang.String q = key.substring ( 0 , ( 41 - i ) ) ; assertQuery ( q , change ) ; } }
public static java.util.List < com.google.gitiles.blame.Region > loadBlame ( com.google.gitiles.blame.BlameCacheImpl.Key key ) throws java.io.IOException { try ( org.eclipse.jgit.blame.BlameGenerator gen = new org.eclipse.jgit.blame.BlameGenerator ( key.repo , key.path ) ) { gen.push ( null , key.commitId ) ; return com.google.gitiles.blame.BlameCacheImpl.loadRegions ( gen ) ; } finally { key.repo = null ; } }
public void getRelatedNoResult ( ) throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create ( db , admin.getIdent ( ) ) ; com.google.gerrit.reviewdb.client.PatchSet.Id ps = push.to ( git , "refs/for/master" ) . getPatchSetId ( ) ; java.util.List < com.google.gerrit.server.change.GetRelated.ChangeAndCommit > related = getRelated ( ps ) ; com.google.common.truth.Truth.assertThat ( related ) . isEmpty ( ) ; }
public void bind ( com.googlecode.prolog_cafe.lang.Term t , com.googlecode.prolog_cafe.lang.Trail trail ) { if ( t instanceof com.googlecode.prolog_cafe.lang.VariableTerm ) { com.googlecode.prolog_cafe.lang.VariableTerm v = ( ( com.googlecode.prolog_cafe.lang.VariableTerm ) ( t ) ) ; if ( ( v.timeStamp ) >= ( this . timeStamp ) ) { v.val = this ; if ( ( v.timeStamp ) < ( trail.timeStamp ) ) trail.push ( v ) ; return ; } } val = t ; if ( ( timeStamp ) < ( trail.timeStamp ) ) trail.push ( this ) ; }
public static < T > void mapOf ( com.google.inject.Binder binder , com.google.inject.TypeLiteral < T > member ) { @ java.lang.SuppressWarnings ( value = "unchecked" ) com.google.inject.Key < com.google.gerrit.extensions.registration.DynamicMap < T > > key = ( ( com.google.inject.Key < com.google.gerrit.extensions.registration.DynamicMap < T > > ) ( com.google.inject.Key.get ( com.google.inject.util.Types.newParameterizedType ( com.google.gerrit.extensions.registration.DynamicMap.class , member.getType ( ) ) ) ) ) ; binder.bind ( key ) . toProvider ( new com.google.gerrit.extensions.registration.DynamicMapProvider ( member ) ) . in ( Scopes.SINGLETON ) ; }
private void applyReview ( final com.google.gerrit.server.project.ChangeControl ctl , final com.google.gerrit.reviewdb.client.PatchSet patchSet , final com.google.gerrit.server.change.PostReview.Input review ) throws java.lang.Exception { reviewProvider.get ( ) . apply ( new com.google.gerrit.server.change.RevisionResource ( new com.google.gerrit.server.change.ChangeResource ( ctl ) , patchSet ) , review ) ; }
private com.google.gerrit.extensions.restapi.BinaryResult wrapBlob ( java.lang.String path , final org.eclipse.jgit.lib.ObjectLoader obj , byte [ ] raw , eu.medsea.mimeutil.MimeType contentType , @ com.google.gerrit.common.Nullable java.lang.String suffix ) { return com.google.gerrit.server.change.FileContentUtil.asBinaryResult ( raw , obj ) . setContentType ( contentType.toString ( ) ) . setAttachmentName ( com.google.gerrit.server.change.FileContentUtil.safeFileName ( path , suffix ) ) ; }
protected Project.NameKey createProject ( java.lang.String nameSuffix , com.google.gerrit.reviewdb.client.Project.NameKey parent , boolean createEmptyCommit ) throws com.google.gerrit.extensions.restapi.RestApiException { com.google.gerrit.extensions.api.projects.ProjectInput in = new com.google.gerrit.extensions.api.projects.ProjectInput ( ) ; in.name = name ( nameSuffix ) ; in.parent = ( parent != null ) ? parent.get ( ) : null ; in.createEmptyCommit = createEmptyCommit ; return createProject ( in ) ; }
public com.google.gerrit.extensions.registration.DynamicMap < T > get ( ) { com.google.gerrit.extensions.registration.PrivateInternals_DynamicMapImpl < T > m = new com.google.gerrit.extensions.registration.PrivateInternals_DynamicMapImpl ( ) ; java.util.List < com.google.inject.Binding < T > > bindings = injector.findBindingsByType ( type ) ; if ( bindings != null ) { for ( com.google.inject.Binding < T > b : bindings ) { if ( ( b.getKey ( ) . getAnnotation ( ) ) != null ) { m.put ( "gerrit" , b.getKey ( ) , b.getProvider ( ) ) ; } } } return m ; }
private static boolean isStaticResource ( javax.servlet.http.HttpServletRequest httpRequest ) { java.lang.String requestURI = httpRequest.getRequestURI ( ) ; java.lang.String pathExt = org.apache.commons.lang.StringUtils.substringAfterLast ( requestURI , "." ) ; if ( org.apache.commons.lang.StringUtils.isEmpty ( pathExt ) ) { return false ; } boolean staticResource = com.googlesource.gerrit.plugins.github.oauth.OAuthFilter.GERRIT_STATIC_RESOURCES_EXTS.contains ( pathExt.toLowerCase ( ) ) ; return staticResource ; }
protected com.google.gwtorm.client.OrmException convertError ( final java.lang.String op , final java.sql.SQLException err ) { if ( ( ( err.getCause ( ) ) == null ) && ( ( err.getNextException ( ) ) != null ) ) { err.initCause ( err.getNextException ( ) ) ; } return schema.getDialect ( ) . convertError ( op , com.google.gwtorm.jdbc.JdbcAccess.getRelationName ( ) , err ) ; }
public void testOwnerProject ( ) { com.google.gerrit.server.project.Util.grant ( local , com.google.gerrit.common.data.Permission.OWNER , com.google.gerrit.server.project.Util.ADMIN , "refs/*" ) ; com.google.gerrit.server.project.ProjectControl uBlah = util.user ( local , com.google.gerrit.server.project.Util.DEVS ) ; com.google.gerrit.server.project.ProjectControl uAdmin = util.user ( local , com.google.gerrit.server.project.Util.DEVS , com.google.gerrit.server.project.Util.ADMIN ) ; org.junit.Assert.assertFalse ( "not owner" , uBlah.isOwner ( ) ) ; org.junit.Assert.assertTrue ( "is owner" , uAdmin.isOwner ( ) ) ; }
private void rename ( java.lang.String path , java.lang.String newPath ) { hide ( ) ; com.google.gerrit.client.changes.ChangeEditApi.rename ( project.get ( ) , changeId.get ( ) , path , newPath , new com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.client.VoidResult > ( ) { @ java.lang.Override public void onSuccess ( com.google.gerrit.client.VoidResult result ) { com.google.gerrit.client.Gerrit.display ( com.google.gerrit.common.PageLinks.toChangeInEditMode ( project , changeId ) ) ; } @ java.lang.Override public void onFailure ( java.lang.Throwable caught ) { } } ) ; }
public void setUp ( ) throws java.lang.Exception { normalProject = createProject ( "normal" ) ; secretProject = createProject ( "secret" ) ; secretRefProject = createProject ( "secretRef" ) ; privilegedGroup = group ( createGroup ( "privilegedGroup" ) ) ; privilegedUser = accountCreator.create ( "privilegedUser" , "snowden@nsa.gov" , "Ed Snowden" ) ; gApi.groups ( ) . id ( privilegedGroup.getGroupUUID ( ) . get ( ) ) . addMembers ( privilegedUser.username ) ; com.google.common.truth.Truth.assertThat ( gApi.groups ( ) . id ( privilegedGroup.getGroupUUID ( ) . get ( ) ) . members ( ) . get ( 0 ) . email ) . contains ( "snowden" ) ; grant ( secretProject , "refs/*" , Permission.READ , false , privilegedGroup.getGroupUUID ( ) ) ; block ( secretProject , "refs/*" , Permission.READ , SystemGroupBackend.REGISTERED_USERS ) ; deny ( secretRefProject , "refs/*" , Permission.READ , SystemGroupBackend.ANONYMOUS_USERS ) ; grant ( secretRefProject , "refs/heads/secret/*" , Permission.READ , false , privilegedGroup.getGroupUUID ( ) ) ; block ( secretRefProject , "refs/heads/secret/*" , Permission.READ , SystemGroupBackend.REGISTERED_USERS ) ; grant ( secretRefProject , "refs/heads/*" , Permission.READ , false , SystemGroupBackend.REGISTERED_USERS ) ; }
public void start ( final org.apache.sshd.server.Environment env ) throws java.io.IOException { java.lang.String s = env.getEnv ( ) . get ( Environment.ENV_COLUMNS ) ; if ( ( s != null ) && ( ! ( s.isEmpty ( ) ) ) ) { try { columns = java.lang.Integer.parseInt ( s ) ; } catch ( java.lang.NumberFormatException err ) { columns = 80 ; } } super . start ( env ) ; }
private synchronized void runHook ( java.io.File hook , java.util.List < java.lang.String > args ) { if ( hook.exists ( ) ) { hookQueue.execute ( new com.google.gerrit.common.ChangeHookRunner.HookTask ( null , hook , args ) ) ; } }
private void assertNotFound ( org.eclipse.jgit.lib.ObjectId id ) throws java.lang.Exception { userSession.get ( ( ( ( "/projects/" + ( project.get ( ) ) ) + "/commits/" ) + ( id.name ( ) ) ) ) . assertNotFound ( ) ; }
public com.google.gitiles.GitilesView.Builder setRevision ( com.google.gitiles.Revision revision ) { switch ( type ) { case HOST_INDEX : case REPOSITORY_INDEX : case REFS : case DESCRIBE : throw new java.lang.IllegalStateException ( java.lang.String.format ( "cannot set revision on %s view" , type ) ) ; default : this . revision = com.google.common.base.Preconditions.checkNotNull ( revision ) ; return this ; } }
public java.lang.String replace ( java.lang.String input ) { java.lang.String href = pat.replace ( input , link ) ; if ( ! ( com.google.gwtexpui.safehtml.client.LinkFindReplace.hasValidScheme ( href ) ) ) { throw new java.lang.IllegalArgumentException ( ( ( ( "Invalid scheme (" + ( toString ( ) ) ) + "): " ) + href ) ) ; } return new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder ( ) . openAnchor ( ) . setAttribute ( "href" , href ) . append ( com.google.gwtexpui.safehtml.client.SafeHtml.asis ( input ) ) . closeAnchor ( ) . asString ( ) ; }
private com.google.gerrit.reviewdb.client.PatchSetApproval getSubmitter ( com.google.gerrit.reviewdb.client.PatchSet.Id patchSetId ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.server.notedb.ChangeNotes notes = changeNotesFactory.create ( db , project , patchSetId.getParentKey ( ) ) . load ( ) ; return approvalsUtil.getSubmitter ( db , notes , patchSetId ) ; }
private java.lang.String toHex ( final byte [ ] b ) { final java.lang.StringBuilder sec = new java.lang.StringBuilder ( ) ; for ( byte c : b ) { final int u = ( c > > 4 ) & 15 ; final int l = c & 15 ; sec.append ( org.apache.commons.net.smtp.AuthSMTPClient.hexchar [ u ] ) ; sec.append ( org.apache.commons.net.smtp.AuthSMTPClient.hexchar [ l ] ) ; } return sec.toString ( ) ; }
public org.eclipse.jgit.lib.ObjectId findLastCommit ( org.eclipse.jgit.lib.Repository repo , org.eclipse.jgit.lib.ObjectId commitId , java.lang.String path ) throws java.io.IOException { try ( org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk ( repo ) ) { rw.markStart ( rw.parseCommit ( commitId ) ) ; rw.setRewriteParents ( false ) ; rw.setTreeFilter ( org.eclipse.jgit.treewalk.filter.AndTreeFilter.create ( org.eclipse.jgit.treewalk.filter.PathFilterGroup.createFromStrings ( path ) , TreeFilter.ANY_DIFF ) ) ; return rw.next ( ) ; } }
private void renderActionTextDate ( com.google.gerrit.client.changes.ChangeInfo info ) { java.lang.String action ; if ( info.created ( ) . equals ( info.updated ( ) ) ) { action = Util.C.changeInfoBlockUploaded ( ) ; } else { action = Util.C.changeInfoBlockUpdated ( ) ; } actionText.setInnerText ( action ) ; actionDate.setInnerText ( com.google.gerrit.client.FormatUtil.relativeFormat ( info.updated ( ) ) ) ; }
public com.googlecode.prolog_cafe.lang.Term arg ( int nth ) { com.googlecode.prolog_cafe.lang.Term t = this ; int old_nth = nth ; while ( ( t instanceof com.googlecode.prolog_cafe.lang.ListTerm ) && ( 0 < nth ) ) { nth -- ; t = ( ( com.googlecode.prolog_cafe.lang.ListTerm ) ( t ) ) . cdr.dereference ( ) ; } if ( t instanceof com.googlecode.prolog_cafe.lang.ListTerm ) return ( ( com.googlecode.prolog_cafe.lang.ListTerm ) ( t ) ) . car ; throw new java.lang.ArrayIndexOutOfBoundsException ( old_nth ) ; }
public org.eclipse.jgit.lib.Repository createRepository ( com.google.gerrit.reviewdb.client.Project.NameKey name ) throws com.google.gerrit.server.git.RepositoryCaseMismatchException , org.eclipse.jgit.errors.RepositoryNotFoundException { org.eclipse.jgit.lib.Repository repo = createRepository ( basePath , name ) ; if ( ( ( noteDbPath ) != null ) && ( ! ( noteDbPath.equals ( basePath ) ) ) ) { createRepository ( noteDbPath , name ) ; } return repo ; }
private boolean canCreateServiceUser ( ) { if ( userProvider.get ( ) . isIdentifiedUser ( ) ) { com.google.gerrit.server.account.CapabilityControl ctl = userProvider.get ( ) . getCapabilities ( ) ; return ( ctl.canPerform ( ( ( ( pluginName ) + "-" ) + ( CreateServiceUserCapability.ID ) ) ) ) || ( ctl.canAdministrateServer ( ) ) ; } return false ; }
public org.eclipse.jgit.lib.ObjectId commit ( ) throws com.google.gwtorm.server.OrmException , java.io.IOException { try ( com.google.gerrit.server.notedb.NoteDbUpdateManager updateManager = updateManagerFactory.create ( getProjectName ( ) ) ) { updateManager.add ( this ) ; updateManager.stageAndApplyDelta ( getChange ( ) ) ; updateManager.execute ( ) ; } return getResult ( ) ; }
private void displayFile ( com.google.reviewit.app.Change change , java.lang.String path , com.google.gerrit.extensions.common.FileInfo file ) { java.util.Map < java.lang.String , com.google.gerrit.extensions.common.FileInfo > files = new java.util.HashMap < > ( ) ; files.put ( path , file ) ; displayFiles ( change , files ) ; }
void close ( ) { try { searcherManager.close ( ) ; } catch ( java.io.IOException e ) { com.google.gerrit.lucene.LuceneChangeIndex.log.warn ( "error closing Lucene searcher" , e ) ; } try { writer.close ( true ) ; } catch ( java.io.IOException e ) { com.google.gerrit.lucene.LuceneChangeIndex.log.warn ( "error closing Lucene writer" , e ) ; } try { dir.close ( ) ; } catch ( java.io.IOException e ) { com.google.gerrit.lucene.LuceneChangeIndex.log.warn ( "error closing Lucene directory" , e ) ; } }
private com.google.inject.Injector createWebInjector ( ) { final java.util.List < com.google.inject.Module > modules = new java.util.ArrayList < com.google.inject.Module > ( ) ; if ( sshd ) { modules.add ( sshInjector.getInstance ( com.google.inject.Module.class ) ) ; } modules.add ( sshInjector.getInstance ( com.google.gerrit.httpd.WebModule.class ) ) ; return sysInjector.createChildInjector ( modules ) ; }
public static void replyError ( javax.servlet.http.HttpServletRequest req , javax.servlet.http.HttpServletResponse res , int statusCode , java.lang.String msg , com.google.gerrit.extensions.restapi.CacheControl c , @ com.google.gerrit.common.Nullable java.lang.Throwable err ) throws java.io.IOException { if ( err != null ) { com.google.gerrit.util.http.RequestUtil.setErrorTraceAttribute ( req , err ) ; } com.google.gerrit.httpd.restapi.RestApiServlet.configureCaching ( req , res , null , null , c ) ; res.setStatus ( statusCode ) ; com.google.gerrit.httpd.restapi.RestApiServlet.replyText ( req , res , msg ) ; }
protected org.eclipse.jgit.junit.TestRepository < ? > createProjectWithPush ( java.lang.String name , @ com.google.gerrit.common.Nullable com.google.gerrit.reviewdb.client.Project.NameKey parent , boolean createEmptyCommit , com.google.gerrit.extensions.client.SubmitType submitType ) throws java.lang.Exception { com.google.gerrit.reviewdb.client.Project.NameKey project = createProject ( name , parent , createEmptyCommit , submitType ) ; grant ( project , "refs/heads/*" , Permission.PUSH ) ; grant ( project , "refs/for/refs/heads/*" , Permission.SUBMIT ) ; return cloneProject ( project ) ; }
public void run ( ) { view.getCmFromSide ( DisplaySide.A ) . setOption ( "mode" , mode ) ; view.getCmFromSide ( DisplaySide.B ) . setOption ( "mode" , mode ) ; }
public com.google.gerrit.extensions.restapi.Response < ? > apply ( com.google.gerrit.server.project.ProjectResource project , com.google.gerrit.extensions.api.projects.DeleteBranchesInput input ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gwtorm.server.OrmException , java.io.IOException { if ( ( ( input == null ) || ( ( input.branches ) == null ) ) || ( input.branches.isEmpty ( ) ) ) { throw new com.google.gerrit.extensions.restapi.BadRequestException ( "branches must be specified" ) ; } deleteRefFactory.create ( project ) . refs ( input.branches ) . delete ( ) ; return com.google.gerrit.extensions.restapi.Response.none ( ) ; }
public void extend ( com.google.gerrit.server.data.ChangeAttribute a , com.google.gerrit.reviewdb.client.Change change ) { a.createdOn = ( change.getCreatedOn ( ) . getTime ( ) ) / 1000L ; a.lastUpdated = ( change.getLastUpdatedOn ( ) . getTime ( ) ) / 1000L ; a.open = change.getStatus ( ) . isOpen ( ) ; }
public static void setAssignee ( @ com.google.gerrit.common.Nullable java.lang.String project , int id , java.lang.String user , com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.client.info.AccountInfo > cb ) { com.google.gerrit.client.changes.ChangeApi.AssigneeInput input = com.google.gerrit.client.changes.ChangeApi.AssigneeInput.create ( ) ; input.assignee ( user ) ; com.google.gerrit.client.changes.ChangeApi.change ( project , id ) . view ( "assignee" ) . put ( input , cb ) ; }
public void testWithSubmodule ( ) throws java.lang.Exception { try ( org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk ( repo ) ) { org.eclipse.jgit.revwalk.RevCommit c = makeCommitWithSubmodule ( rw ) ; java.util.List < com.google.gerrit.server.git.validators.CommitValidationMessage > m = com.googlesource.gerrit.plugins.uploadvalidator.SubmoduleValidator.performValidation ( repo , c , rw ) ; com.google.common.truth.Truth.assertThat ( com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.transformMessages ( m ) ) . containsExactly ( "ERROR: submodules are not allowed: modules/library" ) ; } }
private boolean isVisibleTo ( com.google.gerrit.reviewdb.client.Change change , com.google.gerrit.server.IdentifiedUser user , com.google.gerrit.reviewdb.server.ReviewDb db ) throws com.google.gwtorm.server.OrmException { final com.google.gerrit.server.project.ProjectState pe = projectCache.get ( change.getProject ( ) ) ; if ( pe == null ) { return false ; } final com.google.gerrit.server.project.ProjectControl pc = pe.controlFor ( user ) ; return pc.controlFor ( change ) . isVisible ( db ) ; }
public com.google.gerrit.server.notedb.ChangeNotes createChecked ( com.google.gerrit.reviewdb.server.ReviewDb db , com.google.gerrit.reviewdb.client.Project.NameKey project , com.google.gerrit.reviewdb.client.Change.Id changeId ) throws com.google.gerrit.server.project.NoSuchChangeException , com.google.gwtorm.server.OrmException { com.google.gerrit.server.notedb.ChangeNotes notes = create ( db , project , changeId ) ; if ( ( notes.getChange ( ) ) == null ) { throw new com.google.gerrit.server.project.NoSuchChangeException ( changeId ) ; } return notes ; }
java.lang.Runnable newDraftCallback ( net.codemirror.lib.CodeMirror cm ) { if ( ! ( com.google.gerrit.client.Gerrit.isSignedIn ( ) ) ) { return signInCallback ( cm ) ; } return ( ) -> { if ( cm.extras ( ) . hasActiveLine ( ) ) { newDraft ( cm ) ; } } ; }
public void queryChangesOneTerm ( ) throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result r1 = createChange ( ) ; com.google.gerrit.acceptance.PushOneCommit.Result r2 = createChange ( ) ; java.util.List < com.google.gerrit.extensions.common.ChangeInfo > results = query ( "status:open" ) ; com.google.common.truth.Truth.assertThat ( results.size ( ) ) . is ( 2 ) ; com.google.common.truth.Truth.assertThat ( results.get ( 0 ) . changeId ) . isEqualTo ( r2.getChangeId ( ) ) ; com.google.common.truth.Truth.assertThat ( results.get ( 1 ) . changeId ) . isEqualTo ( r1.getChangeId ( ) ) ; }
protected void configure ( ) { factory ( AgreementInfoFactory.Factory.class ) ; factory ( DeleteExternalIds.Factory.class ) ; factory ( ExternalIdDetailFactory.Factory.class ) ; factory ( GroupDetailHandler.Factory.class ) ; factory ( RegisterNewEmailSender.Factory.class ) ; factory ( RenameGroup.Factory.class ) ; }
private void updateScreenHeader ( net.codemirror.lib.ScrollInfo si ) { if ( ( ( si.getTop ( ) ) == 0 ) && ( ! ( com.google.gerrit.client.Gerrit.isHeaderVisible ( ) ) ) ) { diffTable.setHeaderVisible ( true ) ; } else if ( ( ( si.getTop ( ) ) > ( 0.5 * ( si.getClientHeight ( ) ) ) ) && ( com.google.gerrit.client.Gerrit.isHeaderVisible ( ) ) ) { diffTable.setHeaderVisible ( false ) ; } }
private long getEffectiveMaxObjectSizeLimit ( com.google.gerrit.server.project.ProjectState p ) { long global = cfg.getLong ( "receive" , "maxObjectSizeLimit" , 0 ) ; long local = p.getMaxObjectSizeLimit ( ) ; if ( ( global > 0 ) && ( local > 0 ) ) { return java.lang.Math.min ( global , local ) ; } return java.lang.Math.max ( global , local ) ; }
private void load ( ) throws java.io.IOException { if ( ( migration.writeChanges ( ) ) && ( ( getRevision ( ) ) == null ) ) { try ( org.eclipse.jgit.lib.Repository repo = repoManager.openMetadataRepository ( getProjectName ( ) ) ) { load ( repo ) ; } catch ( org.eclipse.jgit.errors.ConfigInvalidException e ) { throw new java.io.IOException ( e ) ; } } }
public void testOneIndexPredicate ( ) throws java.lang.Exception { com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > in = parse ( "foo:a file:b" ) ; com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > out = rewrite ( in ) ; org.junit.Assert.assertSame ( com.google.gerrit.server.query.change.AndSource.class , out.getClass ( ) ) ; org.junit.Assert.assertEquals ( com.google.common.collect.ImmutableList.of ( query ( in.getChild ( 1 ) ) , in.getChild ( 0 ) ) , out.getChildren ( ) ) ; }
public void testToSafeHtml ( ) { final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder b = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder ( ) ; b.append ( 1 ) ; final com.google.gwtexpui.safehtml.client.SafeHtml h = b.toSafeHtml ( ) ; org.junit.Assert.assertNotNull ( h ) ; org.junit.Assert.assertNotSame ( h , b ) ; org.junit.Assert.assertFalse ( ( h instanceof com.google.gwtexpui.safehtml.client.SafeHtmlBuilder ) ) ; org.junit.Assert.assertEquals ( "1" , h.asString ( ) ) ; }
public void testListDrafts ( ) throws java.lang.Exception { assertListDrafts ( revRes1 , java.util.Collections.< java.lang.String , java.util.ArrayList < com.google.gerrit.reviewdb.client.PatchLineComment > > emptyMap ( ) ) ; assertListDrafts ( revRes2 , com.google.common.collect.ImmutableMap.of ( "FileOne.txt" , com.google.common.collect.Lists.newArrayList ( plc4 , plc5 ) ) ) ; }
public void testAppend_StringBuilder ( ) { final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder b = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder ( ) ; org.junit.Assert.assertSame ( b , b.append ( ( ( java.lang.StringBuilder ) ( null ) ) ) ) ; org.junit.Assert.assertEquals ( "" , b.asString ( ) ) ; org.junit.Assert.assertSame ( b , b.append ( new java.lang.StringBuilder ( "foo" ) ) ) ; org.junit.Assert.assertSame ( b , b.append ( new java.lang.StringBuilder ( "bar" ) ) ) ; org.junit.Assert.assertEquals ( "foobar" , b.asString ( ) ) ; }
public void afterRefUpdates ( ) throws com.google.gerrit.extensions.restapi.ResourceConflictException { if ( failAfterRefUpdates ) { throw new com.google.gerrit.extensions.restapi.ResourceConflictException ( "Failing after ref updates" ) ; } }
public void banCommit_Forbidden ( ) throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = userSession.put ( ( ( "/projects/" + ( project.get ( ) ) ) + "/ban/" ) , BanCommit.Input.fromCommits ( "a8a477efffbbf3b44169bb9a1d3a334cbbd9aa96" ) ) ; com.google.common.truth.Truth.assertThat ( r.getStatusCode ( ) ) . isEqualTo ( HttpStatus.SC_FORBIDDEN ) ; }
protected int getInt ( com.google.gerrit.server.config.PluginConfig cfg , java.lang.String name , int defaultValue ) { try { return cfg.getInt ( name , defaultValue ) ; } catch ( java.lang.IllegalArgumentException e ) { com.googlesource.gerrit.plugins.webhooks.Configuration.log.error ( java.lang.String.format ( "invalid value for %s; using default value %d" , name , defaultValue ) ) ; com.googlesource.gerrit.plugins.webhooks.Configuration.log.debug ( ( "Failed retrieve integer value: " + ( e.getMessage ( ) ) ) , e ) ; return defaultValue ; } }
private java.util.Set < java.lang.String > allRefPatterns ( java.lang.String permissionName ) { java.util.Set < java.lang.String > all = new java.util.HashSet < java.lang.String > ( ) ; for ( com.google.gerrit.common.data.AccessSection section : access ( ) ) { com.google.gerrit.common.data.Permission permission = section.getPermission ( permissionName ) ; if ( permission != null ) { all.add ( section.getName ( ) ) ; } } return all ; }
public void testGetPeopleAccess ( ) throws java.lang.Exception { final com.google.gwtorm.data.PhoneBookDb schema = open ( ) ; org.junit.Assert.assertNotNull ( schema.people ( ) ) ; org.junit.Assert.assertEquals ( "people" , schema.people ( ) . getRelationName ( ) ) ; org.junit.Assert.assertEquals ( 1 , schema.people ( ) . getRelationID ( ) ) ; }
protected void configure ( ) { bind ( com.google.gerrit.extensions.api.projects.Projects.class ) . to ( com.google.gerrit.server.api.projects.ProjectsImpl.class ) ; factory ( BranchApiImpl.Factory.class ) ; factory ( TagApiImpl.Factory.class ) ; factory ( ProjectApiImpl.Factory.class ) ; factory ( ChildProjectApiImpl.Factory.class ) ; }
private java.lang.String url ( ) { if ( ( info.hasChangeNumber ( ) ) && ( info.hasRevisionNumber ( ) ) ) { return "#" + ( com.google.gerrit.common.PageLinks.toChange ( new com.google.gerrit.reviewdb.client.Project.NameKey ( info.project ( ) ) , info.patchSetId ( ) ) ) ; } return null ; }
public java.lang.String getCreateSequenceSql ( final com.google.gwtorm.schema.SequenceModel seq ) { final java.lang.StringBuilder r = new java.lang.StringBuilder ( ) ; r.append ( "CREATE TABLE " ) ; r.append ( seq.getSequenceName ( ) ) ; r.append ( "(s SERIAL)" ) ; return r.toString ( ) ; }
public com.google.gerrit.extensions.api.changes.ReviewerInfo format ( com.google.gerrit.extensions.api.changes.ReviewerInfo out , com.google.gerrit.server.permissions.PermissionBackend.ForChange perm , com.google.gerrit.server.query.change.ChangeData cd ) throws com.google.gerrit.server.permissions.PermissionBackendException , com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.PatchSet.Id psId = cd.change ( ) . currentPatchSetId ( ) ; return format ( out , perm , cd , approvalsUtil.byPatchSetUser ( db.get ( ) , cd.notes ( ) , perm.user ( ) , psId , new com.google.gerrit.reviewdb.client.Account.Id ( out._accountId ) , null , null ) ) ; }
private void fire ( com.google.gerrit.extensions.common.ChangeInfo change , com.google.gerrit.extensions.common.ChangeInfo revertChange , java.sql.Timestamp when ) { com.google.gerrit.server.extensions.events.ChangeReverted.Event event = new com.google.gerrit.server.extensions.events.ChangeReverted.Event ( change , revertChange , when ) ; for ( com.google.gerrit.extensions.events.ChangeRevertedListener l : listeners ) { try { l.onChangeReverted ( event ) ; } catch ( java.lang.Exception e ) { util.logEventListenerError ( com.google.gerrit.server.extensions.events.ChangeReverted.log , e ) ; } } }
private void deleteSshKey ( com.google.gerrit.extensions.common.SshKeyInfo i ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.server.permissions.PermissionBackendException , com.google.gwtorm.server.OrmException , java.io.IOException , org.eclipse.jgit.errors.ConfigInvalidException , org.eclipse.jgit.errors.RepositoryNotFoundException { com.google.gerrit.server.account.AccountSshKey sshKey = com.google.gerrit.server.account.AccountSshKey.create ( user.getAccountId ( ) , i.seq , i.sshPublicKey ) ; deleteSshKey.apply ( new com.google.gerrit.server.account.AccountResource.SshKey ( user.asIdentifiedUser ( ) , sshKey ) , null ) ; }
public com.google.gerrit.server.plugins.ServerPlugin get ( java.io.File srcFile , org.eclipse.jgit.internal.storage.file.FileSnapshot snapshot , com.googlesource.gerrit.plugins.cookbook.pluginprovider.PluginDescription pluginDescriptor ) throws com.google.gerrit.server.plugins.InvalidPluginException { java.lang.String name = getPluginName ( srcFile ) ; return new com.google.gerrit.server.plugins.ServerPlugin ( name , pluginDescriptor.canonicalUrl , pluginDescriptor.user , srcFile , snapshot , new com.googlesource.gerrit.plugins.cookbook.pluginprovider.HelloSshPluginContentScanner ( name ) , pluginDescriptor.dataDir , getClass ( ) . getClassLoader ( ) ) ; }
private static java.util.List < com.google.gwtorm.schema.ColumnModel > leaves ( java.util.List < com.google.gwtorm.schema.ColumnModel > in ) { java.util.ArrayList < com.google.gwtorm.schema.ColumnModel > r = new java.util.ArrayList ( in.size ( ) ) ; for ( com.google.gwtorm.schema.ColumnModel m : in ) { if ( m.isNested ( ) ) { r.addAll ( m.getAllLeafColumns ( ) ) ; } else { r.add ( m ) ; } } return r ; }
public void deleteBranchesNotFound ( ) throws java.lang.Exception { com.google.gerrit.extensions.api.projects.DeleteBranchesInput input = new com.google.gerrit.extensions.api.projects.DeleteBranchesInput ( ) ; java.util.List < java.lang.String > branches = com.google.common.collect.Lists.newArrayList ( com.google.gerrit.acceptance.rest.project.DeleteBranchesIT.BRANCHES ) ; branches.add ( "refs/heads/does-not-exist" ) ; input.branches = branches ; try { project ( ) . deleteBranches ( input ) ; fail ( "Expected ResourceConflictException" ) ; } catch ( com.google.gerrit.extensions.restapi.ResourceConflictException e ) { com.google.common.truth.Truth.assertThat ( e ) . hasMessageThat ( ) . isEqualTo ( errorMessageForBranches ( com.google.common.collect.ImmutableList.of ( "refs/heads/does-not-exist" ) ) ) ; } assertBranchesDeleted ( ) ; }
protected static void trimLeadingEmptyLines ( byte [ ] bytes , org.eclipse.jgit.util.MutableInteger p ) { while ( ( ( p.value ) < ( bytes.length ) ) && ( ( bytes [ p.value ] ) == '\n' ) ) { ( p.value ) ++ ; } }
public com.google.gerrit.common.data.Permission getPermission ( java.lang.String name , boolean create ) { for ( com.google.gerrit.common.data.Permission p : getPermissions ( ) ) { if ( p.getName ( ) . equalsIgnoreCase ( name ) ) { return p ; } } if ( create ) { com.google.gerrit.common.data.Permission p = new com.google.gerrit.common.data.Permission ( name ) ; permissions.add ( p ) ; return p ; } return null ; }
public void updateRepo ( com.google.gerrit.server.git.BatchUpdate.RepoContext ctx ) throws com.google.gerrit.extensions.restapi.ResourceConflictException , java.io.IOException { validate ( ctx ) ; if ( ! ( updateRef ) ) { return ; } ctx.addRefUpdate ( new org.eclipse.jgit.transport.ReceiveCommand ( org.eclipse.jgit.lib.ObjectId.zeroId ( ) , commit , patchSet.getRefName ( ) ) ) ; }
public void testRelativeAlternateLocation ( ) { configMock = org.easymock.EasyMock.createNiceMock ( com.google.gerrit.server.config.RepositoryConfig.class ) ; org.easymock.EasyMock.expect ( configMock.getAllBasePaths ( ) ) . andReturn ( java.util.Arrays.asList ( java.nio.file.Paths.get ( "repos" ) ) ) . anyTimes ( ) ; org.easymock.EasyMock.replay ( configMock ) ; repoManager = new com.google.gerrit.server.git.MultiBaseLocalDiskRepositoryManager ( site , cfg , configMock ) ; }
public com.google.gerrit.server.CurrentUser getCurrentUser ( ) { final com.google.gerrit.server.CurrentUser user = session.getCurrentUser ( ) ; if ( user instanceof com.google.gerrit.server.IdentifiedUser ) { return userFactory.create ( ( ( com.google.gerrit.server.IdentifiedUser ) ( user ) ) . getAccountId ( ) ) ; } return user ; }
public com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.Scope [ ] getDefaultScopes ( ) { if ( ( ( scopes ) == null ) || ( ( scopes.get ( "scopes" ) ) == null ) ) { return new com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.Scope [ 0 ] ; } return scopes.get ( "scopes" ) . toArray ( new com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.Scope [ 0 ] ) ; }
public com.google.gerrit.reviewdb.client.Change reloadChange ( ) throws com.google.gwtorm.server.OrmException { notes = notesFactory.create ( db , project , legacyId ) ; change = notes.getChange ( ) ; if ( ( change ) == null ) { throw new com.google.gwtorm.server.OrmException ( ( "Unable to load change " + ( legacyId ) ) ) ; } setPatchSets ( null ) ; return change ; }
public void testReadString ( ) throws java.io.IOException { org.junit.Assert.assertNull ( com.google.gerrit.server.ioutil.BasicSerialization.readString ( com.google.gerrit.server.ioutil.BasicSerializationTest.r ( com.google.gerrit.server.ioutil.BasicSerializationTest.b ( 0 ) ) ) ) ; org.junit.Assert.assertEquals ( "a" , com.google.gerrit.server.ioutil.BasicSerialization.readString ( com.google.gerrit.server.ioutil.BasicSerializationTest.r ( com.google.gerrit.server.ioutil.BasicSerializationTest.b ( 1 , 'a' ) ) ) ) ; org.junit.Assert.assertEquals ( "coffee4" , com.google.gerrit.server.ioutil.BasicSerialization.readString ( com.google.gerrit.server.ioutil.BasicSerializationTest.r ( com.google.gerrit.server.ioutil.BasicSerializationTest.b ( 7 , 'c' , 'o' , 'f' , 'f' , 'e' , 'e' , '4' ) ) ) ) ; }
private void updateSuperProjects ( java.util.Collection < com.google.gerrit.reviewdb.client.Branch.NameKey > branches ) { logDebug ( "Updating superprojects" ) ; com.google.gerrit.server.git.SubmoduleOp subOp = subOpFactory.create ( branches , orm ) ; try { subOp.updateSuperProjects ( ) ; logDebug ( "Updating superprojects done" ) ; } catch ( com.google.gerrit.server.git.SubmoduleException e ) { logError ( ( "The gitlinks were not updated according to the " + "subscriptions" ) , e ) ; } }
private < V , K > com.google.gerrit.server.cache.h2.H2CacheImpl.SqlStore < K , V > newSqlStore ( java.lang.String name , com.google.inject.TypeLiteral < K > keyType , long maxSize ) { java.io.File db = new java.io.File ( cacheDir , name ) . getAbsoluteFile ( ) ; java.lang.String url = "jdbc:h2:" + ( db.toURI ( ) . toString ( ) ) ; return new com.google.gerrit.server.cache.h2.H2CacheImpl.SqlStore ( url , keyType , maxSize ) ; }
private static java.lang.String getUserPreference ( ) { if ( com.google.gerrit.client.Gerrit.isSignedIn ( ) ) { com.google.gerrit.reviewdb.client.AccountGeneralPreferences.DownloadScheme pref = com.google.gerrit.client.Gerrit.getUserAccount ( ) . getGeneralPreferences ( ) . getDownloadUrl ( ) ; if ( pref != null ) { switch ( pref ) { case ANON_GIT : return "git" ; case HTTP : case ANON_HTTP : return "http" ; case SSH : return "ssh" ; default : return null ; } } } return null ; }
protected void configure ( ) { bind ( com.google.inject.Key.get ( javax.sql.DataSource.class , com.google.inject.name.Names.named ( "ReviewDb" ) ) ) . toProvider ( com.google.gerrit.httpd.ReviewDbDataSourceProvider.class ) . in ( com.google.inject.Scopes.SINGLETON ) ; listener ( ) . to ( com.google.gerrit.httpd.ReviewDbDataSourceProvider.class ) ; }
public void close ( ) throws java.io.IOException { }
public void doImport ( org.eclipse.jgit.lib.ProgressMonitor progress ) throws java.lang.Exception { progress.beginTask ( "Setting up Gerrit replication" , 2 ) ; java.lang.String repositoryName = ( ( getOrganisation ( ) ) + "/" ) + ( getRepositoryName ( ) ) ; progress.update ( 1 ) ; replicationConfig.addSecureCredentials ( authUsername , authToken ) ; progress.update ( 1 ) ; replicationConfig.addReplicationRemote ( authUsername , ( ( gitHubUrl ) + "/${name}.git" ) , repositoryName ) ; progress.endTask ( ) ; }
public void close ( ) { newTree = null ; rw.close ( ) ; if ( ( inserter ) != null ) { inserter.close ( ) ; inserter = null ; } if ( ( reader ) != null ) { reader.close ( ) ; reader = null ; } }
public void defaultMessage ( ) throws com.google.gerrit.extensions.restapi.RestApiException , java.io.IOException , org.eclipse.jgit.api.errors.GitAPIException { java.lang.String changeId = createChange ( ) . getChangeId ( ) ; com.google.gerrit.extensions.common.ChangeInfo c = get ( changeId ) ; org.junit.Assert.assertNotNull ( c.messages ) ; org.junit.Assert.assertEquals ( 1 , c.messages.size ( ) ) ; org.junit.Assert.assertEquals ( "Uploaded patch set 1." , c.messages.iterator ( ) . next ( ) . message ) ; }
public void set ( com.google.gerrit.client.projects.ThemeInfo theme ) { if ( theme != null ) { set ( ( ( theme.css ( ) ) != null ? theme.css ( ) : cssText ) , ( ( theme.header ( ) ) != null ? theme.header ( ) : headerHtml ) , ( ( theme.footer ( ) ) != null ? theme.footer ( ) : footerHtml ) ) ; } else { set ( cssText , headerHtml , footerHtml ) ; } }
public void onShowView ( ) { super . onShowView ( ) ; if ( ( cmA ) != null ) { cmA.refresh ( ) ; } if ( ( cmB ) != null ) { cmB.refresh ( ) ; } com.google.gwt.user.client.Window.enableScrolling ( false ) ; for ( com.google.gerrit.client.diff.CommentBox box : initialBoxes ) { box.resizePaddingWidget ( ) ; } }
private java.util.List < com.google.gerrit.extensions.common.WebLinkInfo > getFileWebLinks ( com.google.gerrit.reviewdb.client.Project project , java.lang.String rev , java.lang.String file ) { java.util.List < com.google.gerrit.extensions.common.WebLinkInfo > links = webLinks.getFileLinks ( project.getName ( ) , rev , file ) ; return links.isEmpty ( ) ? null : links ; }
public void byAfter ( ) throws java.lang.Exception { com.google.gerrit.testutil.TestTimeUtil.resetWithClockStep ( 30 , java.util.concurrent.TimeUnit.HOURS ) ; org.eclipse.jgit.junit.TestRepository < com.google.gerrit.testutil.InMemoryRepositoryManager.Repo > repo = createProject ( "repo" ) ; com.google.gerrit.reviewdb.client.Change change1 = insert ( repo , newChange ( repo ) ) ; com.google.gerrit.reviewdb.client.Change change2 = insert ( repo , newChange ( repo ) ) ; com.google.gerrit.testutil.TestTimeUtil.setClockStep ( 0 , java.util.concurrent.TimeUnit.MILLISECONDS ) ; assertQuery ( "after:2009-10-03" ) ; assertQuery ( "after:\"2009-10-01 20:59:59 -0400\"" , change2 ) ; assertQuery ( "after:\"2009-10-01 20:59:59 -0000\"" , change2 ) ; assertQuery ( "after:2009-10-01" , change2 ) ; assertQuery ( "after:2009-09-30" , change2 , change1 ) ; }
protected void configure ( ) { bind ( new com.google.inject.TypeLiteral < com.google.gwtorm.server.SchemaFactory < com.google.gerrit.reviewdb.server.ReviewDb > > ( ) { } ) . toInstance ( db ) ; bind ( com.google.gerrit.server.config.SitePaths.class ) . toInstance ( paths ) ; org.eclipse.jgit.lib.Config cfg = new org.eclipse.jgit.lib.Config ( ) ; cfg.setString ( "user" , null , "name" , "Gerrit Code Review" ) ; cfg.setString ( "user" , null , "email" , "gerrit@localhost" ) ; bind ( org.eclipse.jgit.lib.Config.class ) . annotatedWith ( com.google.gerrit.server.config.GerritServerConfig.class ) . toInstance ( cfg ) ; bind ( org.eclipse.jgit.lib.PersonIdent.class ) . annotatedWith ( com.google.gerrit.server.GerritPersonIdent.class ) . toProvider ( com.google.gerrit.server.GerritPersonIdentProvider.class ) ; bind ( com.google.gerrit.server.config.AllProjectsName.class ) . toInstance ( new com.google.gerrit.server.config.AllProjectsName ( "All-Projects" ) ) ; bind ( com.google.gerrit.server.config.AllUsersName.class ) . toInstance ( new com.google.gerrit.server.config.AllUsersName ( "All-Users" ) ) ; bind ( com.google.gerrit.server.git.GitRepositoryManager.class ) . toInstance ( new com.google.gerrit.testutil.InMemoryRepositoryManager ( ) ) ; bind ( java.lang.String.class ) . annotatedWith ( com.google.gerrit.server.config.AnonymousCowardName.class ) . toProvider ( com.google.gerrit.server.config.AnonymousCowardNameProvider.class ) ; bind ( com.google.gerrit.server.schema.DataSourceType.class ) . to ( com.google.gerrit.testutil.InMemoryH2Type.class ) ; }
public com.google.gerrit.server.patch.IntraLineDiff getIntraLineDiff ( com.google.gerrit.server.patch.IntraLineDiffKey key , com.google.gerrit.server.patch.IntraLineDiffArgs args ) { if ( computeIntraline ) { try { return intraCache.get ( key , intraLoaderFactory.create ( key , args ) ) ; } catch ( java.util.concurrent.ExecutionException | org.eclipse.jgit.errors.LargeObjectException e ) { IntraLineLoader.log.warn ( ( "Error computing " + key ) , e ) ; return new com.google.gerrit.server.patch.IntraLineDiff ( IntraLineDiff.Status.ERROR ) ; } } return new com.google.gerrit.server.patch.IntraLineDiff ( IntraLineDiff.Status.DISABLED ) ; }
public void deleteBranch_Forbidden ( ) throws java.lang.Exception { com.google.gerrit.acceptance.RestResponse r = userSession.delete ( ( ( ( "/projects/" + ( project.get ( ) ) ) + "/branches/" ) + ( branch.getShortName ( ) ) ) ) ; com.google.common.truth.Truth.assertThat ( r.getStatusCode ( ) ) . isEqualTo ( HttpStatus.SC_FORBIDDEN ) ; r.consume ( ) ; }
private void assertReviewers ( com.google.gerrit.reviewdb.client.Change c , com.google.gerrit.acceptance.TestAccount ... expectedReviewers ) throws com.google.gwtorm.server.OrmException { java.lang.Iterable < com.google.gerrit.reviewdb.client.Account.Id > actualIds = approvalsUtil.getReviewers ( db , notesFactory.create ( db , c.getProject ( ) , c.getId ( ) ) ) . values ( ) ; com.google.common.truth.Truth.assertThat ( actualIds ) . containsExactlyElementsIn ( com.google.common.collect.Sets.newHashSet ( com.google.gerrit.acceptance.TestAccount.ids ( expectedReviewers ) ) ) ; }
private java.util.List < com.google.gerrit.server.data.ChangeAttribute > executeSuccessfulQuery ( java.lang.String params ) throws java.lang.Exception { return executeSuccessfulQuery ( params , adminSshSession ) ; }
public void testPreformat2 ( ) { final com.google.gwtexpui.safehtml.client.SafeHtml o = com.google.gwtexpui.safehtml.client.SafeHtml_WikifyPreformatTest.html ( "A\n\n This is pre\n formatted\n\nbut this is not" ) ; final com.google.gwtexpui.safehtml.client.SafeHtml n = o.wikify ( ) ; org.junit.Assert.assertNotSame ( o , n ) ; org.junit.Assert.assertEquals ( ( ( ( ( ( "<p>A</p>" + "<p>" ) + ( com.google.gwtexpui.safehtml.client.SafeHtml_WikifyPreformatTest.pre ( " This is pre" ) ) ) + ( com.google.gwtexpui.safehtml.client.SafeHtml_WikifyPreformatTest.pre ( " formatted" ) ) ) + "</p>" ) + "<p>but this is not</p>" ) , n.asString ( ) ) ; }
public void emptyExceptSubject ( ) throws java.lang.Exception { com.google.gerrit.server.notedb.ChangeUpdate update = newUpdate ( newChange ( ) , changeOwner ) ; update.setSubject ( "Create change" ) ; update.commit ( ) ; org.junit.Assert.assertNotNull ( update.getRevision ( ) ) ; }
public static com.google.gerrit.common.data.GroupReference findExactSuggestion ( com.google.gerrit.server.account.GroupBackend groupBackend , java.lang.String name ) { return com.google.gerrit.server.account.GroupBackends.findExactSuggestion ( groupBackend , name , null ) ; }
private boolean canAddPatchSet ( com.google.gerrit.reviewdb.server.ReviewDb db ) throws com.google.gwtorm.server.OrmException { if ( ( ( ! ( getRefControl ( ) . canUpload ( ) ) ) || ( isPatchSetLocked ( db ) ) ) || ( ! ( isPatchVisible ( patchSetUtil.current ( db , notes ) , db ) ) ) ) { return false ; } if ( isOwner ( ) ) { return true ; } return getRefControl ( ) . canAddPatchSet ( ) ; }
private org.eclipse.jgit.revwalk.RevObject resolve ( java.lang.String name , org.eclipse.jgit.revwalk.RevWalk walk ) throws java.io.IOException { try { org.eclipse.jgit.lib.ObjectId id = repo.resolve ( name ) ; return id != null ? walk.parseAny ( id ) : null ; } catch ( org.eclipse.jgit.errors.AmbiguousObjectException e ) { return null ; } catch ( org.eclipse.jgit.errors.RevisionSyntaxException | org.eclipse.jgit.errors.MissingObjectException e ) { return null ; } }
public void checkTrustChainWithExpiredKey ( ) throws java.lang.Exception { com.google.gerrit.gpg.testutil.TestKey keyA = add ( com.google.gerrit.gpg.testutil.TestTrustKeys.keyA ( ) , user ) ; com.google.gerrit.gpg.testutil.TestKey keyB = add ( com.google.gerrit.gpg.testutil.TestTrustKeys.keyB ( ) , addUser ( "userB" ) ) ; com.google.gerrit.gpg.PublicKeyChecker checker = checkerFactory.create ( user , store ) ; assertProblems ( checker.check ( keyA.getPublicKey ( ) ) , Status.OK , "No path to a trusted key" , ( ( "Certification by " + ( com.google.gerrit.gpg.PublicKeyStore.keyToString ( keyB.getPublicKey ( ) ) ) ) + " is valid, but key is not trusted" ) , "Key D24FE467 used for certification is not in store" ) ; }
private java.lang.String getHtml ( java.lang.String formatterName , com.googlesource.gerrit.plugins.xdocs.formatter.StreamFormatter f , org.eclipse.jgit.lib.Repository repo , org.eclipse.jgit.lib.ObjectLoader loader , com.google.gerrit.reviewdb.client.Project.NameKey project , java.lang.String path , org.eclipse.jgit.lib.ObjectId revId ) throws java.io.IOException { try ( java.io.InputStream raw = loader.openStream ( ) ) { return ( ( com.googlesource.gerrit.plugins.xdocs.formatter.StreamFormatter ) ( f ) ) . format ( project.get ( ) , path , revId.getName ( ) , com.googlesource.gerrit.plugins.xdocs.XDocLoader.getAbbrRevId ( repo , revId ) , getFormatterConfig ( formatterName ) , raw ) ; } }
private void update ( ) { if ( ( ( currentCommand ) != null ) && ( ( currentUrl ) != null ) ) { currentCommand.setCurrentUrl ( currentUrl ) ; } }
public void remove ( final com.google.gerrit.reviewdb.client.Project p ) { remove ( p.getNameKey ( ) ) ; }
public void execute ( ) { com.google.gwt.user.client.Window.scrollTo ( 0 , 0 ) ; message.setFocus ( true ) ; }
public void onSuccess ( com.google.gerrit.client.diff.DiffInfo diffInfo ) { diff = diffInfo ; new net.codemirror.lib.ModeInjector ( ) . add ( getContentType ( diff.meta_a ( ) ) ) . add ( getContentType ( diff.meta_b ( ) ) ) . inject ( modeInjectorCb ) ; }
public void emptyContextPath ( ) { com.google.common.truth.Truth.assertThat ( com.google.gerrit.util.http.RequestUtil.getEncodedPathInfo ( mockRequest ( "/s/foo/bar" , "" , "/s" ) ) ) . isEqualTo ( "/foo/bar" ) ; com.google.common.truth.Truth.assertThat ( com.google.gerrit.util.http.RequestUtil.getEncodedPathInfo ( mockRequest ( "/s/foo%2Fbar" , "" , "/s" ) ) ) . isEqualTo ( "/foo%2Fbar" ) ; }
public void onLoad ( ) { super . onLoad ( ) ; PatchUtil.DETAIL_SVC.unifiedPatchDetail ( patchId , new com.google.gerrit.client.rpc.ScreenLoadCallback < com.google.gerrit.client.data.UnifiedPatchDetail > ( this ) { @ java.lang.Override protected void preDisplay ( final com.google.gerrit.client.data.UnifiedPatchDetail r ) { display ( r ) ; } } ) ; }
static com.google.gerrit.server.query.change.LabelPredicate.Test op ( java.lang.String op ) { if ( "=" . equals ( op ) ) { return com.google.gerrit.server.query.change.LabelPredicate.Test.EQ ; } else if ( ">=" . equals ( op ) ) { return com.google.gerrit.server.query.change.LabelPredicate.Test.GT_EQ ; } else if ( "<=" . equals ( op ) ) { return com.google.gerrit.server.query.change.LabelPredicate.Test.LT_EQ ; } else { throw new java.lang.IllegalArgumentException ( ( "Unsupported operation " + op ) ) ; } }
public void testCarriageReturn ( ) throws java.lang.Exception { try ( org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk ( repo ) ) { org.eclipse.jgit.revwalk.RevCommit c = makeCommit ( rw ) ; com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator validator = new com.googlesource.gerrit.plugins.uploadvalidator.InvalidLineEndingValidator ( null , new com.googlesource.gerrit.plugins.uploadvalidator.ContentTypeUtil ( com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.PATTERN_CACHE ) , null , null , null ) ; java.util.List < com.google.gerrit.server.git.validators.CommitValidationMessage > m = validator.performValidation ( repo , c , rw , com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.EMPTY_PLUGIN_CONFIG ) ; com.google.common.truth.Truth.assertThat ( com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.transformMessages ( m ) ) . containsExactly ( "ERROR: found carriage return (CR) character in file: foo.txt" ) ; } }
protected void onLoad ( ) { super . onLoad ( ) ; if ( ( regFocus ) == null ) { regFocus = com.google.gwtexpui.globalkey.client.GlobalKey.addApplication ( new com.google.gwtexpui.globalkey.client.KeyCommand ( 0 , '/' , Gerrit.C.keySearch ( ) ) { @ java.lang.Override public void onKeyPress ( final com.google.gwt.event.dom.client.KeyPressEvent event ) { event.preventDefault ( ) ; searchBox.setFocus ( true ) ; searchBox.selectAll ( ) ; } } ) ; } }
public void setUp ( ) throws java.lang.Exception { mergeResults = com.google.common.collect.Maps.newHashMap ( ) ; com.google.gerrit.server.CurrentUser listenerUser = factory.create ( user.id ) ; source.addEventListener ( new com.google.gerrit.common.EventListener ( ) { @ java.lang.Override public void onEvent ( com.google.gerrit.server.events.Event event ) { if ( event instanceof com.google.gerrit.server.events.ChangeMergedEvent ) { com.google.gerrit.server.events.ChangeMergedEvent changeMergedEvent = ( ( com.google.gerrit.server.events.ChangeMergedEvent ) ( event ) ) ; mergeResults.put ( changeMergedEvent.change.number , changeMergedEvent.newRev ) ; } } } , listenerUser ) ; }
public java.lang.String toString ( ) { if ( isError ( ) ) { return ( ( ( ( ( "Error AccessToken [error=" + ( error ) ) + ", error_description=" ) + ( errorDescription ) ) + ", error_uri=" ) + ( errorUri ) ) + "]" ; } return ( ( ( "AccessToken [access_token=" + ( accessToken ) ) + ", token_type=" ) + ( tokenType ) ) + "]" ; }
public boolean equals ( java.lang.Object other ) { if ( other instanceof com.google.gerrit.extensions.restapi.IdString ) { return urlEncoded.equals ( ( ( com.google.gerrit.extensions.restapi.IdString ) ( other ) ) . urlEncoded ) ; } return false ; }
protected com.google.gerrit.server.notedb.ChangeUpdate newUpdate ( com.google.gerrit.reviewdb.client.Change c , com.google.gerrit.server.IdentifiedUser user ) throws java.lang.Exception { com.google.gerrit.server.notedb.ChangeUpdate update = com.google.gerrit.testutil.TestChanges.newUpdate ( injector , repoManager , com.google.gerrit.server.notedb.AbstractChangeNotesTest.MIGRATION , c , allUsers , user ) ; return update ; }
private static boolean needsSuperSerializer ( com.google.gwt.core.ext.typeinfo.JClassType type ) { com.google.gwt.core.ext.typeinfo.JClassType t = type.getSuperclass ( ) ; while ( ! ( java.lang.Object.class . getName ( ) . equals ( t.getQualifiedSourceName ( ) ) ) ) { if ( ( com.google.gwtjsonrpc.rebind.SerializerCreator.sortFields ( t ) . length ) > 0 ) { return true ; } t = t.getSuperclass ( ) ; } return false ; }
private static void export ( org.spearce.jgit.lib.RepositoryConfig config , java.sql.ResultSet rs ) throws java.sql.SQLException { com.google.gerrit.pgm.ConvertSystemConfig.sshd ( config , rs ) ; com.google.gerrit.pgm.ConvertSystemConfig.contactstore ( config , rs ) ; com.google.gerrit.pgm.ConvertSystemConfig.user ( config , rs ) ; com.google.gerrit.pgm.ConvertSystemConfig.auth ( config , rs ) ; }
private org.eclipse.jgit.lib.Repository openRepository ( final com.google.gerrit.reviewdb.Change change ) { return openRepository ( change.getProject ( ) ) ; }
public void onSuccess ( com.google.gerrit.client.changes.ChangeInfo info ) { info.revisions ( ) . copyKeysIntoChildren ( "name" ) ; com.google.gwt.core.client.JsArray < com.google.gerrit.client.changes.ChangeInfo.RevisionInfo > list = info.revisions ( ) . values ( ) ; com.google.gerrit.client.changes.ChangeInfo.RevisionInfo.sortRevisionInfoByNumber ( list ) ; diffTable.set ( list , diff ) ; header.setChangeInfo ( info ) ; }
public static com.google.gerrit.server.query.change.ChangeData createForTest ( com.google.gerrit.reviewdb.client.Project.NameKey project , com.google.gerrit.reviewdb.client.Change.Id id , int currentPatchSetId ) { com.google.gerrit.server.query.change.ChangeData cd = new com.google.gerrit.server.query.change.ChangeData ( null , null , null , null , null , null , null , null , null , null , null , null , null , null , null , project , id ) ; cd.currentPatchSet = new com.google.gerrit.reviewdb.client.PatchSet ( new com.google.gerrit.reviewdb.client.PatchSet.Id ( id , currentPatchSetId ) ) ; return cd ; }
public void setUp ( ) throws java.lang.Exception { super . setUp ( ) ; final java.util.Date when = author.getWhen ( ) ; final java.util.TimeZone tz = author.getTimeZone ( ) ; author = new org.eclipse.jgit.lib.PersonIdent ( "J. Author" , "ja@example.com" ) ; author = new org.eclipse.jgit.lib.PersonIdent ( author , when , tz ) ; committer = new org.eclipse.jgit.lib.PersonIdent ( "J. Committer" , "jc@example.com" ) ; committer = new org.eclipse.jgit.lib.PersonIdent ( committer , when , tz ) ; }
private void preMerge ( ) throws com.google.gerrit.server.git.MergeException , com.google.gwtorm.server.OrmException { openBranch ( ) ; validateChangeList ( ) ; mergeTip = branchTip ; switch ( destProject.getSubmitType ( ) ) { case CHERRY_PICK : cherryPickChanges ( ) ; break ; case FAST_FORWARD_ONLY : case MERGE_ALWAYS : case MERGE_IF_NECESSARY : default : reduceToMinimalMerge ( ) ; mergeTopics ( ) ; markCleanMerges ( ) ; break ; } }
private void setDestProject ( ) throws com.google.gerrit.server.git.MergeException { destProject = projectCache.get ( destBranch.getParentKey ( ) ) ; if ( ( destProject ) == null ) { throw new com.google.gerrit.server.git.MergeException ( ( "No such project: " + ( destBranch.getParentKey ( ) ) ) ) ; } }
protected void configure ( ) { bind ( com.google.gerrit.extensions.api.GerritApi.class ) . to ( com.google.gerrit.server.api.GerritApiImpl.class ) ; install ( new com.google.gerrit.server.api.Module ( ) ) ; install ( new com.google.gerrit.server.api.Module ( ) ) ; install ( new com.google.gerrit.server.api.Module ( ) ) ; install ( new com.google.gerrit.server.api.Module ( ) ) ; }
private void columnStatus ( com.google.gwtexpui.safehtml.client.SafeHtmlBuilder sb , com.google.gerrit.client.diff.FileInfo info ) { sb.openTd ( ) . setStyleName ( com.google.gerrit.client.change.FileTable.R.css ( ) . statusTypeCell ( ) ) ; if ( ! ( Patch.COMMIT_MSG.equals ( info.path ( ) ) ) ) { sb.append ( info.status ( ) ) ; } sb.closeTd ( ) ; }
protected void configure ( ) { get ( com.google.gerrit.server.config.ConfigResource.CONFIG_KIND , "config" ) . to ( com.googlesource.gerrit.plugins.imagare.GetConfig.class ) ; put ( com.google.gerrit.server.config.ConfigResource.CONFIG_KIND , "config" ) . to ( com.googlesource.gerrit.plugins.imagare.PutConfig.class ) ; get ( com.google.gerrit.server.account.AccountResource.ACCOUNT_KIND , "preference" ) . to ( com.googlesource.gerrit.plugins.imagare.GetPreference.class ) ; put ( com.google.gerrit.server.account.AccountResource.ACCOUNT_KIND , "preference" ) . to ( com.googlesource.gerrit.plugins.imagare.PutPreference.class ) ; }
io.searchbox.client.http.JestHttpClient build ( ) { io.searchbox.client.JestClientFactory factory = new io.searchbox.client.JestClientFactory ( ) ; factory.setHttpClientConfig ( new io.searchbox.client.config.HttpClientConfig.Builder ( url ) . multiThreaded ( true ) . discoveryEnabled ( false ) . discoveryFrequency ( 1L , java.util.concurrent.TimeUnit.MINUTES ) . build ( ) ) ; return ( ( io.searchbox.client.http.JestHttpClient ) ( factory.getObject ( ) ) ) ; }
public boolean canAbandon ( com.google.gerrit.reviewdb.server.ReviewDb db ) throws com.google.gwtorm.server.OrmException { return ( ( ( ( ( isOwner ( ) ) || ( getRefControl ( ) . isOwner ( ) ) ) || ( getProjectControl ( ) . isOwner ( ) ) ) || ( getUser ( ) . getCapabilities ( ) . canAdministrateServer ( ) ) ) || ( getRefControl ( ) . canAbandon ( ) ) ) && ( ! ( isPatchSetLocked ( db ) ) ) ; }
public void run ( ) throws java.lang.Exception { if ( ( ( impl.getUser ( ) ) != null ) && ( ! ( impl.getProjects ( ) . isEmpty ( ) ) ) ) { throw new com.google.gerrit.sshd.commands.UnloggedFailure ( 1 , "fatal: --user and --project options are not compatible." ) ; } impl.display ( stdout ) ; }
public void createEmptyChange_MissingMessage ( ) throws java.lang.Exception { com.google.gerrit.extensions.common.ChangeInfo ci = new com.google.gerrit.extensions.common.ChangeInfo ( ) ; ci.project = project.get ( ) ; ci.branch = "master" ; com.google.gerrit.acceptance.RestResponse r = adminSession.post ( "/changes/" , ci ) ; com.google.common.truth.Truth.assertThat ( r.getStatusCode ( ) ) . isEqualTo ( HttpStatus.SC_BAD_REQUEST ) ; com.google.common.truth.Truth.assertThat ( r.getEntityContent ( ) ) . contains ( "commit message must be non-empty" ) ; }
protected void alias ( final com.google.gerrit.sshd.CommandName parent , final java.lang.String name , final java.lang.Class < ? extends com.google.gerrit.sshd.BaseCommand > clazz ) { com.google.gerrit.sshd.CommandMetaData meta = clazz.getAnnotation ( com.google.gerrit.sshd.CommandMetaData.class ) ; if ( meta == null ) { throw new java.lang.IllegalStateException ( "no CommandMetaData annotation found" ) ; } bind ( com.google.gerrit.sshd.Commands.key ( parent , name , meta.description ( ) ) ) . to ( clazz ) ; }
private com.google.gwt.user.client.ui.Widget createEditIcon ( ) { com.google.gerrit.reviewdb.client.PatchSet.Id id = ( idActive.isBaseOrAutoMerge ( ) ) ? other.idActive.asPatchSetId ( ) : idActive.asPatchSetId ( ) ; com.google.gwt.user.client.ui.Anchor anchor = new com.google.gwt.user.client.ui.Anchor ( new com.google.gwt.user.client.ui.ImageResourceRenderer ( ) . render ( Gerrit.RESOURCES.edit ( ) ) , ( "#" + ( com.google.gerrit.client.Dispatcher.toEditScreen ( project , id , path ) ) ) ) ; anchor.setTitle ( PatchUtil.C.edit ( ) ) ; return anchor ; }
public void testTagDiv ( ) { final com.google.gwtexpui.safehtml.client.SafeHtmlBuilder b = new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder ( ) ; org.junit.Assert.assertSame ( b , b.openDiv ( ) ) ; org.junit.Assert.assertSame ( b , b.append ( "d<a>ta" ) ) ; org.junit.Assert.assertSame ( b , b.closeDiv ( ) ) ; org.junit.Assert.assertEquals ( "<div>d&lt;a&gt;ta</div>" , b.asString ( ) ) ; }
private void insertNoneRow ( final int row ) { insertRow ( row ) ; table.setText ( row , 0 , Util.C.changeTableNone ( ) ) ; table.getFlexCellFormatter ( ) . setColSpan ( row , 0 , com.google.gerrit.client.changes.ChangeTable.COLUMNS ) ; setStyleName ( row , 0 , "gerrit-ChangeTable-EmptySectionRow" ) ; }
com.google.gerrit.client.changes.CommentInfo createReply ( com.google.gerrit.client.changes.CommentInfo replyTo ) { return com.google.gerrit.client.changes.CommentInfo.create ( path , replyTo.side ( ) , replyTo.line ( ) , replyTo.id ( ) , null ) ; }
public static com.google.gerrit.server.util.LabelVote parseWithEquals ( java.lang.String text ) { com.google.common.base.Preconditions.checkArgument ( ( ! ( com.google.common.base.Strings.isNullOrEmpty ( text ) ) ) , "Empty label vote" ) ; int e = text.lastIndexOf ( '=' ) ; com.google.common.base.Preconditions.checkArgument ( ( e >= 0 ) , "Label vote missing '=': %s" , text ) ; return com.google.gerrit.server.util.LabelVote.create ( text.substring ( 0 , e ) , java.lang.Short.parseShort ( text.substring ( ( e + 1 ) ) , text.length ( ) ) ) ; }
public void addComment ( final java.lang.String issueKey , final java.lang.String comment ) throws java.io.IOException { execute ( ( ) -> { log.debug ( "Adding comment {} to issue {}" , comment , issueKey ) ; client ( ) . addComment ( issueKey , comment ) ; log.debug ( "Added comment {} to issue {}" , comment , issueKey ) ; return issueKey ; } ) ; }
public com.googlesource.gerrit.plugins.replication.SecureCredentialsProvider create ( java.lang.String remoteName ) { try { if ( needsReload ( ) ) { secureCredentialsFactory.compareAndSet ( secureCredentialsFactory.get ( ) , new com.googlesource.gerrit.plugins.replication.SecureCredentialsFactory ( site ) ) ; secureCredentialsFactoryLoadTs = getSecureConfigLastEditTs ( ) ; com.googlesource.gerrit.plugins.replication.AutoReloadSecureCredentialsFactoryDecorator.log.info ( "secure.config reloaded as it was updated on the file system" ) ; } } catch ( java.lang.Exception e ) { com.googlesource.gerrit.plugins.replication.AutoReloadSecureCredentialsFactoryDecorator.log.error ( ( "Unexpected error while trying to reload " + "secure.config: keeping existing credentials" ) , e ) ; } return secureCredentialsFactory.get ( ) . create ( remoteName ) ; }
public void testInheritRead_AppendWithDenyOfRef ( ) { grant ( parent , com.google.gerrit.common.data.Permission.READ , registered , "refs/*" ) ; grant ( local , com.google.gerrit.common.data.Permission.READ , registered , "refs/heads/*" ) . setDeny ( ) ; com.google.gerrit.server.project.ProjectControl u = user ( ) ; assertTrue ( "can read" , u.isVisible ( ) ) ; assertTrue ( "can read" , u.controlForRef ( "refs/master" ) . isVisible ( ) ) ; assertTrue ( "can read" , u.controlForRef ( "refs/tags/foobar" ) . isVisible ( ) ) ; assertTrue ( "no master" , u.controlForRef ( "refs/heads/master" ) . isVisible ( ) ) ; }
com.google.gerrit.server.git.strategy.SubmitStrategy.Arguments create ( com.google.gerrit.extensions.client.SubmitType submitType , com.google.gerrit.reviewdb.client.Branch.NameKey destBranch , com.google.gerrit.server.git.MergeOp.CommitStatus commitStatus , com.google.gerrit.server.git.CodeReviewCommit.CodeReviewRevWalk rw , com.google.gerrit.server.IdentifiedUser caller , com.google.gerrit.server.git.MergeTip mergeTip , org.eclipse.jgit.lib.Repository repo , org.eclipse.jgit.revwalk.RevFlag canMergeFlag , com.google.gerrit.reviewdb.server.ReviewDb db , java.util.Set < org.eclipse.jgit.revwalk.RevCommit > alreadyAccepted , java.util.Set < com.google.gerrit.server.git.CodeReviewCommit > incoming , com.google.gerrit.server.util.RequestId submissionId , com.google.gerrit.extensions.api.changes.NotifyHandling notifyHandling , com.google.common.collect.ListMultimap < com.google.gerrit.extensions.api.changes.RecipientType , com.google.gerrit.reviewdb.client.Account.Id > accountsToNotify , com.google.gerrit.server.git.SubmoduleOp submoduleOp , boolean dryrun ) ;
public static java.lang.String refsEditPrefix ( com.google.gerrit.reviewdb.client.Account.Id accountId ) { return ( ( com.google.gerrit.reviewdb.client.RefNames.refsUsers ( accountId ) ) + '/' ) + ( com.google.gerrit.reviewdb.client.RefNames.EDIT_PREFIX ) ; }
public void testSubsequentGetReads ( ) throws com.google.gwtorm.client.OrmException { db.create ( ) ; final com.google.gerrit.reviewdb.SystemConfig exp = db.getSystemConfig ( ) ; final com.google.gerrit.reviewdb.SystemConfig act = db.getSystemConfig ( ) ; assertNotSame ( exp , act ) ; assertEquals ( exp.adminGroupId , act.adminGroupId ) ; assertEquals ( exp.anonymousGroupId , act.anonymousGroupId ) ; assertEquals ( exp.registeredGroupId , act.registeredGroupId ) ; assertEquals ( exp.sitePath , act.sitePath ) ; assertEquals ( exp.registerEmailPrivateKey , act.registerEmailPrivateKey ) ; }
private void clear ( ) { for ( com.google.reviewit.widget.ScrollWithHeadingsView.Content content : contents ) { removeView ( content.getHeading ( ) . getView ( ) ) ; scrollContent.removeView ( content.getContent ( ) ) ; } contents.clear ( ) ; scroll.getViewTreeObserver ( ) . removeOnScrollChangedListener ( onScrollListener ) ; onScrollListener = null ; }
public void abandonReviewableWipChange ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableWipChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.ABANDONED_CHANGES ) ; abandon ( sc.changeId , sc.owner ) ; assertThat ( sender ) . sent ( "abandon" , sc ) . notTo ( sc.owner ) . cc ( sc.reviewer , sc.ccer ) . to ( sc.reviewerByEmail ) . cc ( sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.ABANDONED_CHANGES ) ; }
public void resetHtml ( final com.google.gwt.user.client.ui.FlexTable myTable , final com.google.gwtexpui.safehtml.client.SafeHtml bodyHtml ) { final com.google.gwt.user.client.Element oldBody = getBodyElement ( myTable ) ; final com.google.gwt.user.client.Element newBody = com.google.gerrit.client.ui.FancyFlexTableImplIE6.parseBody ( bodyHtml ) ; assert newBody != null ; final com.google.gwt.user.client.Element tableElem = com.google.gwt.user.client.DOM.getParent ( oldBody ) ; tableElem.removeChild ( oldBody ) ; com.google.gerrit.client.ui.FancyFlexTableImplIE6.setBodyElement ( myTable , newBody ) ; com.google.gwt.user.client.DOM.appendChild ( tableElem , newBody ) ; }
private org.eclipse.jgit.treewalk.AbstractTreeIterator getTreeIterator ( org.eclipse.jgit.lib.Repository repo , java.lang.String name ) throws java.io.IOException { org.eclipse.jgit.treewalk.CanonicalTreeParser p = new org.eclipse.jgit.treewalk.CanonicalTreeParser ( ) ; org.eclipse.jgit.lib.ObjectReader or = repo.newObjectReader ( ) ; try { p.reset ( or , new org.eclipse.jgit.revwalk.RevWalk ( repo ) . parseTree ( repo.resolve ( name ) ) ) ; return p ; } finally { or.close ( ) ; } }
public void byProject ( ) throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository < com.google.gerrit.testutil.InMemoryRepositoryManager.Repo > repo1 = createProject ( "repo1" ) ; org.eclipse.jgit.junit.TestRepository < com.google.gerrit.testutil.InMemoryRepositoryManager.Repo > repo2 = createProject ( "repo2" ) ; com.google.gerrit.reviewdb.client.Change change1 = insert ( newChange ( repo1 ) ) ; com.google.gerrit.reviewdb.client.Change change2 = insert ( newChange ( repo2 ) ) ; assertQuery ( "project:foo" ) ; assertQuery ( "project:repo" ) ; assertQuery ( "project:repo1" , change1 ) ; assertQuery ( "project:repo2" , change2 ) ; }
public com.google.gitiles.GitilesView.Builder copyFrom ( com.google.gitiles.GitilesView other ) { hostName = other.hostName ; servletPath = other.servletPath ; switch ( type ) { case LOG : case DIFF : oldRevision = other.oldRevision ; case PATH : path = other.path ; case REVISION : revision = other.revision ; case REPOSITORY_INDEX : repositoryName = other.repositoryName ; default : break ; } return this ; }
protected void configure ( ) { propertyExtractor = createMock ( com.googlesource.gerrit.plugins.hooks.util.PropertyExtractor.class ) ; bind ( com.googlesource.gerrit.plugins.hooks.util.PropertyExtractor.class ) . toInstance ( propertyExtractor ) ; ruleBase = createMock ( com.googlesource.gerrit.plugins.hooks.workflow.RuleBase.class ) ; bind ( com.googlesource.gerrit.plugins.hooks.workflow.RuleBase.class ) . toInstance ( ruleBase ) ; actionExecutor = createMock ( com.googlesource.gerrit.plugins.hooks.workflow.ActionExecutor.class ) ; bind ( com.googlesource.gerrit.plugins.hooks.workflow.ActionExecutor.class ) . toInstance ( actionExecutor ) ; bind ( com.googlesource.gerrit.plugins.hooks.its.ItsConfig.class ) . toInstance ( new com.googlesource.gerrit.plugins.hooks.its.ItsConfig ( null , null , null , null ) { @ java.lang.Override public boolean isEnabled ( com.google.gerrit.server.events.ChangeEvent event ) { return true ; } } ) ; }
public com.google.gerrit.extensions.common.AccountInfo accountInfo ( com.google.gerrit.reviewdb.client.Account a ) { if ( ( a == null ) || ( ( a.getId ( ) ) == null ) ) { return null ; } com.google.gerrit.extensions.common.AccountInfo ai = new com.google.gerrit.extensions.common.AccountInfo ( a.getId ( ) . get ( ) ) ; ai.email = a.getPreferredEmail ( ) ; ai.name = a.getFullName ( ) ; ai.username = a.getUserName ( ) ; return ai ; }
public boolean contains ( com.google.gerrit.reviewdb.client.AccountGroup.UUID uuid ) { if ( uuid == null ) { return false ; } com.google.gerrit.server.account.GroupMembership m = membership ( uuid ) ; if ( m == null ) { com.google.gerrit.server.account.UniversalGroupBackend.log.warn ( ( "Unknown GroupMembership for UUID: " + uuid ) ) ; return false ; } return m.contains ( uuid ) ; }
public java.io.File get ( ) { if ( ! ( ready ) ) { synchronized ( dataDir ) { if ( ! ( ready ) ) { if ( ( ! ( dataDir.exists ( ) ) ) && ( ! ( dataDir.mkdirs ( ) ) ) ) { throw new com.google.inject.ProvisionException ( java.lang.String.format ( "Cannot create %s for plugin %s" , dataDir.getAbsolutePath ( ) , getName ( ) ) ) ; } ready = true ; } } } return dataDir ; }
public void queryChangesNoResults ( ) throws java.lang.Exception { createChange ( ) ; java.util.List < com.google.gerrit.extensions.common.ChangeInfo > results = query ( "status:open" ) ; org.junit.Assert.assertEquals ( 1 , results.size ( ) ) ; results = query ( "status:closed" ) ; org.junit.Assert.assertTrue ( results.isEmpty ( ) ) ; }
public boolean match ( com.google.gerrit.server.query.change.ChangeData object ) throws com.google.gwtorm.server.OrmException { java.util.List < java.lang.String > files ; try { files = object.currentFilePaths ( ) ; } catch ( java.io.IOException e ) { throw new com.google.gwtorm.server.OrmException ( e ) ; } return ( java.util.Collections.binarySearch ( files , value ) ) >= 0 ; }
public com.google.gerrit.client.ui.InlineHyperlink getNextPatchLink ( int index ) { int nextPatchIndex = getNextPatch ( index , false , PREFERENCE_VALIDATOR ) ; if ( nextPatchIndex < 0 ) { return null ; } return createLink ( nextPatchIndex , null , com.google.gwtexpui.safehtml.client.SafeHtml.asis ( Util.C.nextPatchLinkIcon ( ) ) ) ; }
private java.net.InetSocketAddress computePreferredAddress ( ) { for ( final java.net.SocketAddress addr : listen ) { if ( ! ( addr instanceof java.net.InetSocketAddress ) ) { continue ; } java.net.InetSocketAddress inetAddr = ( ( java.net.InetSocketAddress ) ( addr ) ) ; if ( inetAddr.getAddress ( ) . isLoopbackAddress ( ) ) { continue ; } return inetAddr ; } for ( final java.net.SocketAddress addr : listen ) { if ( addr instanceof java.net.InetSocketAddress ) { return ( ( java.net.InetSocketAddress ) ( addr ) ) ; } } return null ; }
private void setDefaultConfig ( javax.servlet.FilterConfig filterConfig ) throws javax.servlet.ServletException { if ( ( config ) == null ) { try { config = com.google.gitiles.GitilesConfig.loadDefault ( filterConfig ) ; } catch ( java.io.IOException | org.eclipse.jgit.errors.ConfigInvalidException e ) { throw new javax.servlet.ServletException ( e ) ; } } }
private static void assertInvalid ( final java.lang.String in ) { try { com.google.gerrit.server.mail.Address.parse ( in ) ; org.junit.Assert.fail ( ( "Incorrectly accepted " + in ) ) ; } catch ( java.lang.IllegalArgumentException e ) { org.junit.Assert.assertEquals ( ( "Invalid email address: " + in ) , e.getMessage ( ) ) ; } }
public static com.google.gerrit.server.index.IndexConfig fromConfig ( org.eclipse.jgit.lib.Config cfg ) { return com.google.gerrit.server.index.IndexConfig.create ( cfg.getInt ( "index" , null , "maxLimit" , 0 ) , cfg.getInt ( "index" , null , "maxPages" , 0 ) , cfg.getInt ( "index" , null , "maxTerms" , 0 ) ) ; }
Project.NameKey projectName ( org.eclipse.jgit.lib.Repository repo ) { java.nio.file.Path gitDir = repo.getDirectory ( ) . toPath ( ) ; if ( gitDir.startsWith ( basePath ) ) { java.lang.String p = basePath.relativize ( gitDir ) . toString ( ) ; java.lang.String n = p.substring ( 0 , ( ( p.length ( ) ) - ( ".git" . length ( ) ) ) ) ; return new com.google.gerrit.reviewdb.client.Project.NameKey ( n ) ; } com.googlesource.gerrit.plugins.quota.ProjectNameResolver.log.warn ( ( "Couldn't determine the project name from " + gitDir ) ) ; return null ; }
protected com.google.gerrit.server.GerritServer getGerritServer ( ) throws com.google.gerrit.server.ssh.AbstractCommand.Failure { try { return com.google.gerrit.server.GerritServer.getInstance ( ) ; } catch ( com.google.gwtorm.client.OrmException e ) { throw new com.google.gerrit.server.ssh.AbstractCommand.Failure ( 128 , "fatal: Gerrit is not available" , e ) ; } catch ( com.google.gwtjsonrpc.server.XsrfException e ) { throw new com.google.gerrit.server.ssh.AbstractCommand.Failure ( 128 , "fatal: Gerrit is not available" , e ) ; } }
protected void configure ( ) { install ( new com.google.gerrit.server.index.IndexModule ( threads ) ) ; bind ( com.google.gerrit.server.index.ChangeIndex.class ) . to ( com.google.gerrit.solr.SolrChangeIndex.class ) ; listener ( ) . to ( com.google.gerrit.solr.SolrChangeIndex.class ) ; if ( checkVersion ) { listener ( ) . to ( com.google.gerrit.solr.IndexVersionCheck.class ) ; } }
public void onClick ( final com.google.gwt.event.dom.client.ClickEvent event ) { b.setEnabled ( false ) ; new com.google.gerrit.client.changes.AbandonChangeDialog ( patchSet.getId ( ) , new com.google.gwt.user.client.rpc.AsyncCallback < com.google.gerrit.common.data.ChangeDetail > ( ) { public void onSuccess ( com.google.gerrit.common.data.ChangeDetail result ) { changeScreen.update ( result ) ; } public void onFailure ( java.lang.Throwable caught ) { b.setEnabled ( true ) ; } } ) . center ( ) ; }
public boolean isLoggedIn ( java.util.Set < com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.Scope > scopes ) { boolean loggedIn = ( ( scopesSet.equals ( scopes ) ) && ( ( token ) != null ) ) && ( ( hub ) != null ) ; if ( loggedIn && ( ( myself ) == null ) ) { try { myself = hub.getMyself ( ) ; } catch ( java.lang.Throwable e ) { com.googlesource.gerrit.plugins.github.oauth.GitHubLogin.log.error ( "Connection to GitHub broken: logging out" , e ) ; logout ( ) ; loggedIn = false ; } } return loggedIn ; }
private static boolean autoReindexIfStale ( org.eclipse.jgit.lib.Config cfg ) { return cfg.getBoolean ( "index" , null , "autoReindexIfStale" , true ) ; }
public void checkRemoveReviewer ( com.google.gerrit.server.notedb.ChangeNotes notes , com.google.gerrit.server.CurrentUser currentUser , com.google.gerrit.reviewdb.client.PatchSetApproval approval ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.server.permissions.PermissionBackendException , com.google.gerrit.server.project.NoSuchChangeException , com.google.gwtorm.server.OrmException { if ( canRemoveReviewerWithoutPermissionCheck ( notes.getChange ( ) , currentUser , approval.getAccountId ( ) , approval.getValue ( ) ) ) { return ; } permissionBackend.user ( currentUser ) . change ( notes ) . database ( dbProvider ) . check ( ChangePermission.REMOVE_REVIEWER ) ; }
public java.lang.String encode ( com.google.gerrit.reviewdb.client.Account.Id accountId , java.lang.String emailAddress ) { try { java.lang.String payload = java.lang.String.format ( "%s:%s" , accountId , emailAddress ) ; byte [ ] utf8 = payload.getBytes ( "UTF-8" ) ; java.lang.String base64 = org.eclipse.jgit.util.Base64.encodeBytes ( utf8 ) ; return emailRegistrationToken.newToken ( base64 ) ; } catch ( com.google.gwtjsonrpc.server.XsrfException | java.io.UnsupportedEncodingException e ) { throw new java.lang.IllegalArgumentException ( e ) ; } }
public com.google.gerrit.server.data.AccountAttribute get ( ) { return account != null ? eventFactory.asAccountAttribute ( new com.google.gerrit.reviewdb.client.Account.Id ( account._accountId ) ) : null ; }
private com.google.gerrit.client.ui.Screen createScreen ( ) { if ( ( info ) != null ) { return new com.google.gerrit.client.changes.ChangeScreen ( info ) ; } else if ( ( ps ) != null ) { return new com.google.gerrit.client.changes.ChangeScreen ( ps ) ; } else { return new com.google.gerrit.client.changes.ChangeScreen ( id ) ; } }
public void symlinkText ( ) throws java.lang.Exception { final org.eclipse.jgit.revwalk.RevBlob link = repo.blob ( "foo" ) ; repo.branch ( "master" ) . commit ( ) . edit ( new org.eclipse.jgit.dircache.DirCacheEditor.PathEdit ( "baz" ) { @ java.lang.Override public void apply ( org.eclipse.jgit.dircache.DirCacheEntry ent ) { ent.setFileMode ( FileMode.SYMLINK ) ; ent.setObjectId ( link ) ; } } ) . create ( ) ; java.lang.String text = buildBlob ( "/repo/+/master/baz" , "120000" ) ; com.google.common.truth.Truth.assertThat ( text ) . isEqualTo ( "foo" ) ; }
public void run ( ) { synchronized ( cleanup ) { run = true ; for ( final java.util.Iterator < java.lang.Runnable > i = cleanup.iterator ( ) ; i.hasNext ( ) ; ) { try { i.next ( ) . run ( ) ; } catch ( java.lang.Throwable err ) { com.google.gerrit.server.RequestCleanup.log.error ( "Failed to execute per-request cleanup" , err ) ; } i.remove ( ) ; } } }
private boolean isDraftPatchSet ( com.google.gerrit.reviewdb.client.PatchSet.Id id , com.google.gerrit.reviewdb.server.ReviewDb db ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.reviewdb.client.PatchSet ps = db.patchSets ( ) . get ( id ) ; if ( ps == null ) { throw new com.google.gwtorm.server.OrmException ( ( ( "Patch set " + id ) + " not found" ) ) ; } return ps.isDraft ( ) ; }
private static java.util.Set < java.lang.String > getRefNames ( org.eclipse.jgit.lib.Repository repo , java.lang.String prefix ) throws java.io.IOException { org.eclipse.jgit.lib.RefDatabase refDb = repo.getRefDatabase ( ) ; return refDb.getRefs ( prefix ) . keySet ( ) ; }
public void visit ( org.pegdown.ast.HeaderNode node ) { java.lang.String tag = "h" + ( node.getLevel ( ) ) ; html.open ( tag ) ; html.attribute ( "id" , toc.idFromHeader ( node ) ) ; visitChildren ( node ) ; html.close ( tag ) ; }
public void setParent_Forbidden ( ) throws java.lang.Exception { java.lang.String parent = createProject ( "parent" , null , true ) . get ( ) ; com.google.gerrit.acceptance.RestResponse r = userSession.put ( ( ( "/projects/" + ( project.get ( ) ) ) + "/parent" ) , newParentInput ( parent ) ) ; com.google.common.truth.Truth.assertThat ( r.getStatusCode ( ) ) . isEqualTo ( HttpStatus.SC_FORBIDDEN ) ; r.consume ( ) ; }
private java.util.Optional < com.google.gerrit.reviewdb.client.Account > loadAccount ( com.google.gerrit.reviewdb.client.Account.Id accountId , org.eclipse.jgit.revwalk.RevWalk rw , org.eclipse.jgit.lib.ObjectId commit ) throws java.io.IOException , org.eclipse.jgit.errors.ConfigInvalidException { rw.reset ( ) ; com.google.gerrit.server.account.AccountConfig accountConfig = new com.google.gerrit.server.account.AccountConfig ( accountId ) ; accountConfig.load ( rw , commit ) ; return accountConfig.getLoadedAccount ( ) ; }
private void goUpToChange ( boolean openReplyBox ) { java.lang.String b = ( ( base ) != null ) ? java.lang.String.valueOf ( base.get ( ) ) : null ; java.lang.String rev = java.lang.String.valueOf ( revision.get ( ) ) ; com.google.gerrit.client.Gerrit.display ( com.google.gerrit.common.PageLinks.toChange ( changeId , rev ) , new com.google.gerrit.client.change.ChangeScreen2 ( changeId , b , rev , openReplyBox ) ) ; }
public boolean canRebase ( com.google.gerrit.reviewdb.client.PatchSet patchSet , com.google.gerrit.reviewdb.client.Branch.NameKey dest , org.eclipse.jgit.lib.Repository git , org.eclipse.jgit.revwalk.RevWalk rw ) { try { findBaseRevision ( patchSet , dest , git , rw ) ; return true ; } catch ( com.google.gerrit.extensions.restapi.RestApiException e ) { return false ; } catch ( com.google.gwtorm.server.OrmException | java.io.IOException e ) { com.google.gerrit.server.change.RebaseUtil.log.warn ( java.lang.String.format ( "Error checking if patch set %s on %s can be rebased" , patchSet.getId ( ) , dest ) , e ) ; return false ; } }
private static java.lang.String text ( java.lang.String branch , java.lang.String topic ) { if ( ( topic != null ) && ( ! ( topic.isEmpty ( ) ) ) ) { return ( ( branch + " (" ) + topic ) + ")" ; } return branch ; }
private static java.util.List < com.google.gerrit.reviewdb.client.PatchSet > toPatchSets ( com.google.gerrit.client.changes.ChangeInfo info ) { com.google.gwt.core.client.JsArray < com.google.gerrit.client.changes.ChangeInfo.RevisionInfo > all = info.revisions ( ) . values ( ) ; com.google.gerrit.client.changes.ChangeInfo.RevisionInfo.sortRevisionInfoByNumber ( all ) ; java.util.List < com.google.gerrit.reviewdb.client.PatchSet > r = new java.util.ArrayList ( all.length ( ) ) ; for ( com.google.gerrit.client.changes.ChangeInfo.RevisionInfo rev : com.google.gerrit.client.rpc.Natives.asList ( all ) ) { r.add ( com.google.gerrit.client.changes.ChangeDetailCache.toPatchSet ( info , rev ) ) ; } return r ; }
private void addDiffChunkAndPadding ( net.codemirror.lib.CodeMirror cmToPad , int lineToPad , int lineOnOther , int chunkSize , boolean edit ) { net.codemirror.lib.CodeMirror otherCm = otherCm ( cmToPad ) ; linePaddingOnOtherSideMap.put ( otherCm.getLineHandle ( lineOnOther ) , new com.google.gerrit.client.diff.PaddingManager.LinePaddingWidgetWrapper ( addPaddingWidget ( cmToPad , DiffTable.style.padding ( ) , lineToPad , 0 , Unit.EM , null ) , lineToPad , chunkSize ) ) ; diffChunks.add ( new com.google.gerrit.client.diff.SideBySide2.DiffChunkInfo ( getSideFromCm ( otherCm ) , ( ( lineOnOther - chunkSize ) + 1 ) , lineOnOther , edit ) ) ; }
public com.google.gerrit.server.group.GroupInfo apply ( com.google.gerrit.server.group.GroupResource resource , com.google.gerrit.server.group.AddIncludedGroups.PutIncludedGroup.Input input ) throws com.google.gerrit.extensions.restapi.AuthException , com.google.gerrit.extensions.restapi.BadRequestException , com.google.gerrit.extensions.restapi.MethodNotAllowedException , com.google.gwtorm.server.OrmException { com.google.gerrit.server.group.AddIncludedGroups.Input in = new com.google.gerrit.server.group.AddIncludedGroups.Input ( ) ; in.groups = com.google.common.collect.ImmutableList.of ( id ) ; java.util.List < com.google.gerrit.server.group.GroupInfo > list = put.get ( ) . apply ( resource , in ) ; if ( ( list.size ( ) ) == 1 ) { return list.get ( 0 ) ; } throw new java.lang.IllegalStateException ( ) ; }
private boolean canForceUpdate ( ) { if ( canPushWithForce ( ) ) { return true ; } switch ( getUser ( ) . getAccessPath ( ) ) { case GIT : return false ; case JSON_RPC : case REST_API : case SSH_COMMAND : case UNKNOWN : case WEB_BROWSER : default : return ( ( isOwner ( ) ) && ( ! ( isForceBlocked ( Permission.PUSH ) ) ) ) || ( projectControl.isAdmin ( ) ) ; } }
public static void recursivelyDelete ( java.io.File dir ) throws java.io.IOException { if ( ! ( dir.getPath ( ) . equals ( dir.getCanonicalPath ( ) ) ) ) { return ; } java.io.File [ ] contents = dir.listFiles ( ) ; if ( contents != null ) { for ( java.io.File d : contents ) { if ( d.isDirectory ( ) ) { com.google.gerrit.testutil.TempFileUtil.recursivelyDelete ( d ) ; } else { com.google.gerrit.testutil.TempFileUtil.deleteNowOrOnExit ( d ) ; } } } com.google.gerrit.testutil.TempFileUtil.deleteNowOrOnExit ( dir ) ; }
public long getEffectiveMaxObjectSizeLimit ( com.google.gerrit.server.project.ProjectState p ) { long global = getMaxObjectSizeLimit ( ) ; long local = p.getMaxObjectSizeLimit ( ) ; if ( ( global > 0 ) && ( local > 0 ) ) { return java.lang.Math.min ( global , local ) ; } return java.lang.Math.max ( global , local ) ; }
private com.google.gerrit.extensions.common.CommentInfo addDraft ( java.lang.String changeId , java.lang.String revId , com.google.gerrit.extensions.api.changes.ReviewInput.CommentInput c ) throws java.io.IOException { com.google.gerrit.acceptance.RestResponse r = userSession.put ( ( ( ( ( "/changes/" + changeId ) + "/revisions/" ) + revId ) + "/drafts" ) , c ) ; com.google.common.truth.Truth.assertThat ( r.getStatusCode ( ) ) . isEqualTo ( HttpStatus.SC_CREATED ) ; return newGson ( ) . fromJson ( r.getReader ( ) , com.google.gerrit.extensions.common.CommentInfo.class ) ; }
private void addRanges ( java.util.Map < java.lang.String , java.lang.Object > have , com.google.gerrit.server.account.CapabilityControl cc ) { for ( java.lang.String name : com.google.gerrit.common.data.GlobalCapability.getRangeNames ( ) ) { if ( ( want ( name ) ) && ( cc.hasExplicitRange ( name ) ) ) { have.put ( name , new com.google.gerrit.server.account.GetCapabilities.Range ( cc.getRange ( name ) ) ) ; } } }
private void offer ( com.google.gerrit.server.events.Event event ) { synchronized ( taskLock ) { if ( ! ( queue.offer ( event ) ) ) { dropped = true ; } if ( ( ( task ) == null ) && ( ! ( done ) ) ) { task = pool.submit ( writer ) ; } } }
public void onSuccess ( com.google.gerrit.client.changes.ChangeList result ) { updateColumnsForLabels ( result ) ; sections.get ( 0 ) . display ( result ) ; finishDisplay ( ) ; }
public int shutdown ( ) { int cnt = 0 ; if ( ( pool ) != null ) { com.googlesource.gerrit.plugins.replication.Destination.repLog.warn ( "Cancelling replication events" ) ; cnt = pool.shutdownNow ( ) . size ( ) ; pool = null ; } return cnt ; }
public void go ( ) { if ( ( com.google.gerrit.client.Gerrit.patchScreen ) != null ) { com.google.gerrit.client.Gerrit.patchScreen.setTopView ( PatchScreen.TopView.MAIN ) ; if ( type == ( com.google.gerrit.client.Gerrit.patchScreen.getPatchScreenType ( ) ) ) { com.google.gwt.dom.client.AnchorElement.as ( getElement ( ) ) . blur ( ) ; } else { new com.google.gerrit.client.ui.PatchLink ( "" , type , com.google.gerrit.client.Gerrit.patchScreen ) . go ( ) ; } } }
private static com.google.gerrit.extensions.restapi.BinaryResult base64 ( com.google.gerrit.extensions.restapi.BinaryResult bin ) throws java.io.IOException { int maxSize = com.google.gerrit.httpd.restapi.RestApiServlet.base64MaxSize ( bin.getContentLength ( ) ) ; int estSize = java.lang.Math.min ( com.google.gerrit.httpd.restapi.RestApiServlet.base64MaxSize ( com.google.gerrit.httpd.restapi.RestApiServlet.HEAP_EST_SIZE ) , maxSize ) ; org.eclipse.jgit.util.TemporaryBuffer.Heap buf = com.google.gerrit.httpd.restapi.RestApiServlet.heap ( estSize , maxSize ) ; try ( java.io.OutputStream encoded = com.google.common.io.BaseEncoding.base64 ( ) . encodingStream ( new java.io.OutputStreamWriter ( buf , java.nio.charset.StandardCharsets.ISO_8859_1 ) ) ) { bin.writeTo ( encoded ) ; } return com.google.gerrit.httpd.restapi.RestApiServlet.asBinaryResult ( buf ) ; }
protected void preDisplay ( com.google.gerrit.client.projects.ConfigInfoCache.Entry result ) { commentManager = new com.google.gerrit.client.diff.SideBySideCommentManager ( this , base , revision , path , result.getCommentLinkProcessor ( ) , getChangeStatus ( ) . isOpen ( ) ) ; setTheme ( result.getTheme ( ) ) ; display ( comments ) ; }
private void fireCommentAddedHook ( com.google.gerrit.server.change.RevisionResource rsrc ) { com.google.gerrit.server.IdentifiedUser user = ( ( com.google.gerrit.server.IdentifiedUser ) ( rsrc.getControl ( ) . getCurrentUser ( ) ) ) ; try { hooks.doCommentAddedHook ( change , user.getAccount ( ) , rsrc.getPatchSet ( ) , message.getMessage ( ) , categories , db.get ( ) ) ; } catch ( com.google.gwtorm.server.OrmException e ) { com.google.gerrit.server.change.PostReview.log.warn ( "ChangeHook.doCommentAddedHook delivery failed" , e ) ; } }
protected void setUseSignedOffBy ( com.google.gerrit.extensions.client.InheritableBoolean value ) throws java.lang.Exception { try ( com.google.gerrit.server.git.MetaDataUpdate md = metaDataUpdateFactory.create ( project ) ) { com.google.gerrit.server.git.ProjectConfig config = com.google.gerrit.server.git.ProjectConfig.read ( md ) ; config.getProject ( ) . setUseSignedOffBy ( value ) ; config.commit ( md ) ; projectCache.evict ( config.getProject ( ) ) ; } }
protected void configure ( ) { factory ( ChangeProjectAccess.Factory.class ) ; factory ( ReviewProjectAccess.Factory.class ) ; factory ( ChangeProjectSettings.Factory.class ) ; factory ( ListBranches.Factory.class ) ; factory ( VisibleProjectDetails.Factory.class ) ; factory ( ProjectAccessFactory.Factory.class ) ; factory ( ProjectDetailFactory.Factory.class ) ; }
public static java.lang.String refsEditPrefix ( com.google.gerrit.reviewdb.client.Account.Id accountId , com.google.gerrit.reviewdb.client.Change.Id changeId ) { return ( ( com.google.gerrit.reviewdb.client.RefNames.refsEditPrefix ( accountId ) ) + ( changeId.get ( ) ) ) + '/' ; }
public void funnel ( K from , com.google.common.hash.PrimitiveSink into ) { try { java.io.ObjectOutputStream ser = new java.io.ObjectOutputStream ( new com.google.gerrit.server.cache.h2.H2CacheImpl.SinkOutputStream ( into ) ) ; try { ser.writeObject ( from ) ; ser.flush ( ) ; } finally { ser.close ( ) ; } } catch ( java.io.IOException err ) { throw new java.lang.RuntimeException ( "Cannot hash as Serializable" , err ) ; } }
private boolean isTrusted ( final com.google.gerrit.reviewdb.client.AccountExternalId id ) { if ( id.isScheme ( AccountExternalId.SCHEME_MAILTO ) ) { return true ; } if ( id.isScheme ( AccountExternalId.SCHEME_UUID ) ) { return true ; } if ( id.isScheme ( AccountExternalId.SCHEME_USERNAME ) ) { return true ; } for ( final com.google.gerrit.server.auth.openid.OpenIdProviderPattern p : trustedOpenIDs ) { if ( p.matches ( id ) ) { return true ; } } return false ; }
private java.lang.Iterable < com.google.gerrit.server.query.change.ChangeData > byCommitsOnBranchNotMergedFromIndex ( com.google.gerrit.reviewdb.client.Branch.NameKey branch , java.util.List < java.lang.String > hashes ) throws com.google.gwtorm.server.OrmException { return query ( com.google.gerrit.server.query.Predicate.and ( com.google.gerrit.server.query.change.InternalChangeQuery.ref ( branch ) , com.google.gerrit.server.query.change.InternalChangeQuery.project ( branch.getParentKey ( ) ) , com.google.gerrit.server.query.Predicate.not ( com.google.gerrit.server.query.change.InternalChangeQuery.status ( Change.Status.MERGED ) ) , com.google.gerrit.server.query.Predicate.or ( com.google.gerrit.server.query.change.InternalChangeQuery.commits ( hashes ) ) ) ) ; }
public void testRejectJavaScript_AnchorHref ( ) { final java.lang.String href = "javascript:window.close();" ; try { new com.google.gwtexpui.safehtml.client.SafeHtmlBuilder ( ) . openAnchor ( ) . setAttribute ( "href" , href ) ; org.junit.Assert.fail ( "accepted javascript in a href" ) ; } catch ( java.lang.RuntimeException e ) { org.junit.Assert.assertEquals ( ( "javascript unsafe in href: " + href ) , e.getMessage ( ) ) ; } }
public void onSuccess ( java.lang.Void result ) { }
protected PushOneCommit.Result createChange ( org.eclipse.jgit.api.Git git , java.lang.String subject , java.lang.String fileName , java.lang.String content , java.lang.String topic ) throws java.io.IOException , org.eclipse.jgit.api.errors.GitAPIException { com.google.gerrit.acceptance.PushOneCommit push = pushFactory.create ( db , admin.getIdent ( ) , git , subject , fileName , content ) ; return push.to ( ( "refs/for/master/" + topic ) ) ; }
private void deleteDraft ( java.lang.String changeId , java.lang.String revId , java.lang.String uuid ) throws java.io.IOException { com.google.gerrit.acceptance.RestResponse r = userSession.delete ( ( ( ( ( ( "/changes/" + changeId ) + "/revisions/" ) + revId ) + "/drafts/" ) + uuid ) ) ; com.google.common.truth.Truth.assertThat ( r.getStatusCode ( ) ) . isEqualTo ( HttpStatus.SC_NO_CONTENT ) ; }
public boolean match ( com.google.gerrit.server.query.change.ChangeData object ) throws com.google.gwtorm.server.OrmException { try { for ( com.google.gerrit.server.query.change.ChangeData cData : index.getSource ( com.google.gerrit.server.query.Predicate.and ( new com.google.gerrit.server.query.change.LegacyChangeIdPredicate ( db , object.getId ( ) ) , this ) , 1 ) . read ( ) ) { if ( cData.getId ( ) . equals ( object.getId ( ) ) ) { return true ; } } } catch ( com.google.gerrit.server.query.QueryParseException e ) { throw new com.google.gwtorm.server.OrmException ( e ) ; } return false ; }
public com.google.gerrit.server.CurrentUser getCurrentUser ( ) { if ( ( user ) == null ) { if ( isSignedIn ( ) ) { user = identified.create ( val.getAccountId ( ) ) ; } else { user = anonymousProvider.get ( ) ; } } return user ; }
public com.google.gerrit.server.patch.PatchList get ( com.google.gerrit.client.reviewdb.Change change , com.google.gerrit.client.reviewdb.PatchSet patchSet , com.google.gerrit.client.data.PatchScriptSettings.Whitespace whitespace ) ;
private void setListBox ( final com.google.gwt.user.client.ui.ListBox f , final java.lang.String defaultValue , final java.lang.String currentValue ) { final int n = f.getItemCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( f.getValue ( i ) . equals ( currentValue ) ) { f.setSelectedIndex ( i ) ; return ; } } if ( currentValue != defaultValue ) { setListBox ( f , defaultValue , defaultValue ) ; } }
private com.google.gerrit.extensions.client.SubmitType getSubmitType ( com.google.gerrit.server.query.change.ChangeData cd , com.google.gerrit.reviewdb.client.PatchSet patchSet ) throws com.google.gwtorm.server.OrmException { com.google.gerrit.common.data.SubmitTypeRecord rec = submitRuleEvaluatorFactory.create ( cd ) . setPatchSet ( patchSet ) . getSubmitType ( ) ; if ( ( rec.status ) != ( SubmitTypeRecord.Status.OK ) ) { throw new com.google.gwtorm.server.OrmException ( ( "Submit type rule failed: " + rec ) ) ; } return rec.type ; }
public void testCreateProjectApiWithGitSuffix ( ) throws java.lang.Exception { final java.lang.String newProjectName = "newProject" ; com.google.gerrit.extensions.common.ProjectInfo p = gApi.projects ( ) . create ( ( newProjectName + ".git" ) ) . get ( ) ; com.google.common.truth.Truth.assertThat ( p.name ) . isEqualTo ( newProjectName ) ; com.google.gerrit.server.project.ProjectState projectState = projectCache.get ( new com.google.gerrit.reviewdb.client.Project.NameKey ( newProjectName ) ) ; com.google.common.truth.Truth.assertThat ( projectState ) . isNotNull ( ) ; com.google.gerrit.acceptance.rest.project.ProjectAssert.assertProjectInfo ( projectState.getProject ( ) , p ) ; assertHead ( newProjectName , "refs/heads/master" ) ; }
public void run ( ) { int line = ( cm.extras ( ) . hasActiveLine ( ) ) ? cm.getLineNumber ( cm.extras ( ) . activeLine ( ) ) : 0 ; int res = java.util.Collections.binarySearch ( chunks , new com.google.gerrit.client.diff.UnifiedDiffChunkInfo ( cm.side ( ) , 0 , 0 , 0 , line , false ) , getDiffChunkComparatorCmLine ( ) ) ; diffChunkNavHelper ( chunks , host , res , dir ) ; }
public void abandonReviewableChangeByOwnerCcingSelf ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.ABANDONED_CHANGES ) ; abandon ( sc.changeId , sc.owner , com.google.gerrit.extensions.client.GeneralPreferencesInfo.EmailStrategy.CC_ON_OWN_COMMENTS ) ; assertThat ( sender ) . sent ( "abandon" , sc ) . to ( sc.owner ) . cc ( sc.reviewer , sc.ccer ) . cc ( sc.reviewerByEmail , sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.ABANDONED_CHANGES ) ; }
public void testEquals ( ) throws java.lang.Exception { com.google.common.truth.Truth.assertThat ( entry1.equals ( null ) ) . isFalse ( ) ; com.google.common.truth.Truth.assertThat ( entry1.equals ( "String object" ) ) . isFalse ( ) ; com.google.common.truth.Truth.assertThat ( entry1.equals ( entry2 ) ) . isFalse ( ) ; com.google.common.truth.Truth.assertThat ( entry1.equals ( entry4 ) ) . isTrue ( ) ; }
private static java.util.Set < java.lang.String > scanSectionNames ( com.google.gerrit.server.git.ProjectConfig config ) { java.util.Set < java.lang.String > names = new java.util.HashSet < java.lang.String > ( ) ; for ( com.google.gerrit.common.data.AccessSection section : config.getAccessSections ( ) ) { names.add ( section.getName ( ) ) ; } return names ; }
public org.eclipse.jgit.lib.Repository openRepository ( java.lang.String name ) throws java.io.IOException { name = com.googlesource.gerrit.plugins.supermanifest.SuperManifestRefUpdatedListener.urlToRepoKey ( canonicalWebUrl , name ) ; if ( repos.containsKey ( name ) ) { return repos.get ( name ) ; } org.eclipse.jgit.lib.Repository repo = repoManager.openRepository ( new com.google.gerrit.reviewdb.client.Project.NameKey ( name ) ) ; repos.put ( name , repo ) ; return repo ; }
public void testThreeLevelTreeWithSomeIndexPredicates ( ) throws java.lang.Exception { com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > in = parse ( "-foo:a (file:b OR file:c)" ) ; com.google.gerrit.server.query.Predicate < com.google.gerrit.server.query.change.ChangeData > out = rewrite ( in ) ; org.junit.Assert.assertEquals ( com.google.gerrit.server.query.change.AndSource.class , out.getClass ( ) ) ; org.junit.Assert.assertEquals ( com.google.common.collect.ImmutableList.of ( query ( in.getChild ( 1 ) ) , in.getChild ( 0 ) ) , out.getChildren ( ) ) ; }
private void applyComment ( java.lang.String project , int number , com.google.gerrit.extensions.api.changes.ReviewInput comment ) throws java.lang.Exception { com.google.gerrit.server.change.RevisionResource r = atomicityHelper.getRevisionResource ( project , number ) ; reviewer.get ( ) . apply ( r , comment ) ; }
public boolean isVisible ( com.google.gerrit.reviewdb.server.ReviewDb db ) throws com.google.gwtorm.server.OrmException { return isVisible ( db , null ) ; }
private com.google.common.collect.FluentIterable < com.google.gerrit.server.project.ListBranches.BranchInfo > filterBranches ( com.google.common.collect.FluentIterable < com.google.gerrit.server.project.ListBranches.BranchInfo > branches ) throws com.google.gerrit.extensions.restapi.BadRequestException { if ( ! ( com.google.common.base.Strings.isNullOrEmpty ( matchSubstring ) ) ) { branches = branches.filter ( new com.google.gerrit.server.project.ListBranches.SubstringPredicate ( matchSubstring ) ) ; } else if ( ! ( com.google.common.base.Strings.isNullOrEmpty ( matchRegex ) ) ) { branches = branches.filter ( new com.google.gerrit.server.project.ListBranches.RegexPredicate ( matchRegex ) ) ; } return branches ; }
public void byStatus ( ) throws java.lang.Exception { org.eclipse.jgit.junit.TestRepository < com.google.gerrit.testutil.InMemoryRepositoryManager.Repo > repo = createProject ( "repo" ) ; com.google.gerrit.server.change.ChangeInserter ins1 = newChangeWithStatus ( repo , Change.Status.NEW ) ; com.google.gerrit.reviewdb.client.Change change1 = insert ( repo , ins1 ) ; com.google.gerrit.server.change.ChangeInserter ins2 = newChangeWithStatus ( repo , Change.Status.MERGED ) ; com.google.gerrit.reviewdb.client.Change change2 = insert ( repo , ins2 ) ; assertQuery ( "status:new" , change1 ) ; assertQuery ( "status:NEW" , change1 ) ; assertQuery ( "is:new" , change1 ) ; assertQuery ( "status:merged" , change2 ) ; assertQuery ( "is:merged" , change2 ) ; }
public void emptyPermissionRangeOmitsResult ( ) throws java.lang.Exception { com.google.gerrit.reviewdb.client.PatchSetApproval cr = psa ( userId , "Code-Review" , 1 ) ; com.google.gerrit.reviewdb.client.PatchSetApproval v = psa ( userId , "Verified" , 1 ) ; org.junit.Assert.assertEquals ( com.google.gerrit.server.git.LabelNormalizer.Result.create ( com.google.gerrit.server.git.LabelNormalizerTest.list ( ) , com.google.gerrit.server.git.LabelNormalizerTest.list ( ) , com.google.gerrit.server.git.LabelNormalizerTest.list ( cr , v ) ) , norm.normalize ( notes , com.google.gerrit.server.git.LabelNormalizerTest.list ( cr , v ) ) ) ; }
public java.util.Set < com.google.gerrit.reviewdb.client.PatchSet.Id > patchIds ( ) throws com.google.gwtorm.server.OrmException { java.util.Set < com.google.gerrit.reviewdb.client.PatchSet.Id > ret = new java.util.HashSet < > ( ) ; for ( com.google.gerrit.server.query.change.ChangeData cd : changeData.values ( ) ) { ret.add ( cd.change ( ) . currentPatchSetId ( ) ) ; } return ret ; }
private static void initVimKeys ( ) { net.codemirror.lib.KeyMap km = net.codemirror.lib.CodeMirror.cloneKeyMap ( "vim" ) ; for ( java.lang.String s : new java.lang.String [ ] { "A" , "C" , "O" , "R" , "U" , "Ctrl-C" } ) { km.remove ( s ) ; } net.codemirror.lib.CodeMirror.addKeyMap ( "vim_ro" , km ) ; }
public com.google.gerrit.extensions.common.ChangeInfo apply ( com.google.gerrit.server.change.ChangeResource req , com.google.gerrit.extensions.api.changes.AbandonInput input ) throws com.google.gerrit.extensions.restapi.RestApiException , com.google.gerrit.server.git.UpdateException , com.google.gwtorm.server.OrmException { com.google.gerrit.server.project.ChangeControl control = req.getControl ( ) ; if ( ! ( control.canAbandon ( dbProvider.get ( ) ) ) ) { throw new com.google.gerrit.extensions.restapi.AuthException ( "abandon not permitted" ) ; } com.google.gerrit.reviewdb.client.Change change = abandon ( control , input.message , control.getUser ( ) . asIdentifiedUser ( ) . getAccount ( ) ) ; return json.create ( ChangeJson.NO_OPTIONS ) . format ( change ) ; }
public static com.google.gerrit.server.patch.DiffCacheContent createEmpty ( ) { return new com.google.gerrit.server.patch.DiffCacheContent ( ) ; }
public void skipWhenUserBelongsToGroupUUID ( ) throws java.lang.Exception { java.lang.String config = "[plugin \"uploadvalidator\"]\n" + ( ( "skipValidation=testOp\n" + "skipGroup=testGroup\n" ) + "skipGroup=anotherGroup" ) ; com.googlesource.gerrit.plugins.uploadvalidator.ValidatorConfig validatorConfig = new com.googlesource.gerrit.plugins.uploadvalidator.ValidatorConfig ( new com.googlesource.gerrit.plugins.uploadvalidator.FakeConfigFactory ( projectName , config ) , new com.googlesource.gerrit.plugins.uploadvalidator.FakeGroupCacheUUIDByName ( ) ) ; com.google.common.truth.Truth.assertThat ( validatorConfig.isEnabledForRef ( new com.googlesource.gerrit.plugins.uploadvalidator.FakeUserProvider ( "testGroup" , "yetAnotherGroup" ) . get ( ) , projectName , "anyRef" , "testOp" ) ) . isFalse ( ) ; }
public void addValue ( final java.lang.Short val ) { this . value = val ; }
public com.google.gerrit.server.account.GroupControl controlFor ( final com.google.gerrit.reviewdb.client.AccountGroup.Id groupId ) throws com.google.gerrit.common.errors.NoSuchGroupException { final com.google.gerrit.reviewdb.client.AccountGroup group = groupCache.get ( groupId ) ; if ( group == null ) { throw new com.google.gerrit.common.errors.NoSuchGroupException ( groupId ) ; } return new com.google.gerrit.server.account.GroupControl ( user.get ( ) , group ) ; }
private boolean shouldGet ( ) { if ( console.isBatch ( ) ) { return required ; } else { final java.lang.StringBuilder msg = new java.lang.StringBuilder ( ) ; msg.append ( "\n" ) ; msg.append ( "Gerrit Code Review is not shipped with %s\n" ) ; if ( required ) { msg.append ( "** This library is required for your configuration. **\n" ) ; } else { msg.append ( " If available, Gerrit can take advantage of features\n" ) ; msg.append ( " in the library, but will also function without it.\n" ) ; } msg.append ( "Download and install it now" ) ; return console.yesno ( true , msg.toString ( ) , name ) ; } }
void appendInsert ( int numLines ) { int origLineB = lineB ; lineB += numLines ; int bAheadOfA = ( lineB ) - ( lineA ) ; lineMapAtoB.add ( new com.google.gerrit.client.diff.LineMapper.LineGap ( lineA , ( - 1 ) , bAheadOfA ) ) ; lineMapBtoA.add ( new com.google.gerrit.client.diff.LineMapper.LineGap ( origLineB , ( ( lineB ) - 1 ) , ( - bAheadOfA ) ) ) ; }
public static java.lang.String makeKey ( int change , int patch , java.lang.String branch ) { if ( ( branch.indexOf ( com.googlesource.gerrit.plugins.findowners.Cache.REFS_HEADS ) ) == 0 ) { branch = branch.substring ( com.googlesource.gerrit.plugins.findowners.Cache.REFS_HEADS.length ( ) ) ; } return ( ( ( change + ":" ) + patch ) + ":" ) + branch ; }
private boolean canDelete ( com.google.gerrit.reviewdb.client.Change.Status status ) { switch ( status ) { case NEW : case ABANDONED : return ( ( isOwner ( ) ) && ( getRefControl ( ) . canDeleteOwnChanges ( ) ) ) || ( getProjectControl ( ) . isAdmin ( ) ) ; case MERGED : default : return false ; } }
com.google.gerrit.httpd.WebSessionManager.Val createVal ( final com.google.gerrit.httpd.WebSessionManager.Key key , final com.google.gerrit.httpd.WebSessionManager.Val val ) { final com.google.gerrit.reviewdb.client.Account.Id who = val.getAccountId ( ) ; final boolean remember = val.isPersistentCookie ( ) ; final com.google.gerrit.reviewdb.client.AccountExternalId.Key lastLogin = val.getExternalId ( ) ; return createVal ( key , who , remember , lastLogin , val.sessionId , val.auth ) ; }
public void testBlockedExtensionsCaseInsensitive ( ) throws java.lang.Exception { try ( org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk ( repo ) ) { org.eclipse.jgit.revwalk.RevCommit c = makeCommit ( rw , com.googlesource.gerrit.plugins.uploadvalidator.FileExtensionValidatorTest.BLOCKED_EXTENSIONS_UC ) ; java.util.List < com.google.gerrit.server.git.validators.CommitValidationMessage > m = com.googlesource.gerrit.plugins.uploadvalidator.FileExtensionValidator.performValidation ( repo , c , rw , com.googlesource.gerrit.plugins.uploadvalidator.FileExtensionValidatorTest.BLOCKED_EXTENSIONS_LC ) ; java.util.List < java.lang.String > expected = new java.util.ArrayList < > ( ) ; for ( java.lang.String extension : com.googlesource.gerrit.plugins.uploadvalidator.FileExtensionValidatorTest.BLOCKED_EXTENSIONS_UC ) { expected.add ( ( "ERROR: blocked file: foo." + extension ) ) ; } com.google.common.truth.Truth.assertThat ( com.googlesource.gerrit.plugins.uploadvalidator.TestUtils.transformMessages ( m ) ) . containsExactlyElementsIn ( expected ) ; } }
public void doPost ( final javax.servlet.http.HttpServletRequest req , final javax.servlet.http.HttpServletResponse rsp ) throws java.io.IOException { try { doAuth ( req , rsp ) ; } catch ( java.lang.Exception e ) { getServletContext ( ) . log ( "Unexpected error during authentication" , e ) ; finishLogin ( rsp , null , null ) ; } }
public boolean isVisible ( ) { return ( ( ( ( ( user ) instanceof com.google.gerrit.server.InternalUser ) || ( groupBackend.isVisibleToAll ( group.getGroupUUID ( ) ) ) ) || ( user.getCapabilities ( ) . canAdministrateServer ( ) ) ) || ( isOwner ( ) ) ) || ( user.memberOf ( group.getGroupUUID ( ) ) ) ; }
public void onSuccess ( com.googlesource.gerrit.plugins.verifystatus.client.ConfigInfo info ) { if ( info.showJobsSummaryPanel ( ) ) { com.google.gerrit.plugin.client.Plugin.get ( ) . panel ( GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK , new com.googlesource.gerrit.plugins.verifystatus.client.JobsSummaryPanel.Factory ( ) ) ; } if ( info.showJobsPanel ( ) ) { com.google.gerrit.plugin.client.Plugin.get ( ) . panel ( GerritUiExtensionPoint.CHANGE_SCREEN_BELOW_CHANGE_INFO_BLOCK , new com.googlesource.gerrit.plugins.verifystatus.client.JobsPanel.Factory ( info ) ) ; } if ( info.showJobsDropDownPanel ( ) ) { com.google.gerrit.plugin.client.Plugin.get ( ) . panel ( GerritUiExtensionPoint.CHANGE_SCREEN_HEADER_RIGHT_OF_POP_DOWNS , new com.googlesource.gerrit.plugins.verifystatus.client.JobsDropDownPanel.Factory ( info ) ) ; } }
private static com.google.gerrit.reviewdb.client.AccountGroup missing ( com.google.gerrit.reviewdb.client.AccountGroup.Id key ) { com.google.gerrit.reviewdb.client.AccountGroup.NameKey name = new com.google.gerrit.reviewdb.client.AccountGroup.NameKey ( ( "Deleted Group" + key ) ) ; com.google.gerrit.reviewdb.client.AccountGroup g = new com.google.gerrit.reviewdb.client.AccountGroup ( name , key , null ) ; g.setType ( AccountGroup.Type.SYSTEM ) ; return g ; }
public static void doSignOut ( ) { com.google.gerrit.client.Gerrit.myAccount = null ; com.google.gwt.user.client.Cookies.removeCookie ( com.google.gerrit.client.Gerrit.ACCOUNT_COOKIE ) ; com.google.gwt.user.client.Cookies.removeCookie ( com.google.gerrit.client.Gerrit.OPENIDUSER_COOKIE ) ; for ( final com.google.gerrit.client.SignedInListener l : com.google.gerrit.client.Gerrit.signedInListeners ) { l.onSignOut ( ) ; } com.google.gerrit.client.Gerrit.refreshMenuBar ( ) ; if ( ( com.google.gerrit.client.Gerrit.currentScreen ) != null ) { com.google.gerrit.client.Gerrit.currentScreen.onSignOut ( ) ; } }
public void conflictingChanges ( ) throws java.lang.Exception { com.google.gerrit.acceptance.PushOneCommit.Result change = createChange ( true ) ; com.google.gerrit.acceptance.PushOneCommit.Result conflictingChange1 = createChange ( true ) ; com.google.gerrit.acceptance.PushOneCommit.Result conflictingChange2 = createChange ( true ) ; createChange ( false ) ; java.util.Set < java.lang.String > changes = queryConflictingChanges ( change ) ; assertChanges ( changes , conflictingChange1 , conflictingChange2 ) ; }
public void commentOnReviewableChangeByReviewer ( ) throws java.lang.Exception { com.google.gerrit.acceptance.server.mail.StagedChange sc = stageReviewableChange ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS ) ; review ( sc.reviewer , sc.changeId , com.google.gerrit.extensions.client.GeneralPreferencesInfo.EmailStrategy.ENABLED ) ; assertThat ( sender ) . sent ( "comment" , sc ) . notTo ( sc.reviewer ) . to ( sc.owner ) . to ( sc.reviewerByEmail ) . cc ( sc.ccer ) . cc ( sc.ccerByEmail ) . bcc ( sc.starrer ) . bcc ( com.google.gerrit.server.account.WatchConfig.NotifyType.ALL_COMMENTS ) ; }
private boolean canEditTopicName ( ) { if ( getChange ( ) . getStatus ( ) . isOpen ( ) ) { return ( ( ( ( isOwner ( ) ) || ( getRefControl ( ) . isOwner ( ) ) ) || ( getProjectControl ( ) . isOwner ( ) ) ) || ( getUser ( ) . getCapabilities ( ) . canAdministrateServer ( ) ) ) || ( getRefControl ( ) . canEditTopicName ( ) ) ; } return getRefControl ( ) . canForceEditTopicName ( ) ; }
private static java.lang.Class < ? > scanObjectOrClass ( java.lang.Object element ) { if ( java.lang.Class.class . isAssignableFrom ( element.getClass ( ) ) ) { return ( ( java.lang.Class < ? > ) ( element ) ) ; } return element.getClass ( ) ; }
private void addDiffChunkAndPadding ( net.codemirror.lib.CodeMirror cmToPad , int lineToPad , int lineOnOther , int chunkSize , boolean edit ) { net.codemirror.lib.CodeMirror otherCm = otherCm ( cmToPad ) ; linePaddingOnOtherSideMap.put ( otherCm.getLineHandle ( lineOnOther ) , new com.google.gerrit.client.diff.PaddingManager.LinePaddingWidgetWrapper ( addPaddingWidget ( cmToPad , lineToPad , 0 , Unit.EM , null ) , lineToPad , chunkSize ) ) ; diffChunks.add ( new com.google.gerrit.client.diff.DiffChunkInfo ( getSideFromCm ( otherCm ) , ( ( lineOnOther - chunkSize ) + 1 ) , lineOnOther , edit ) ) ; }
private static org.eclipse.jgit.lib.ObjectId emptyTree ( final org.eclipse.jgit.lib.Repository repo ) throws java.io.IOException { try ( org.eclipse.jgit.lib.ObjectInserter oi = repo.newObjectInserter ( ) ) { org.eclipse.jgit.lib.ObjectId id = oi.insert ( Constants.OBJ_TREE , new byte [ ] { } ) ; oi.flush ( ) ; return id ; } }
private void updateChange ( java.lang.String changeId , com.google.gerrit.extensions.client.ChangeKind changeKind ) throws java.lang.Exception { switch ( changeKind ) { case com.google.gerrit.extensions.client.ChangeKind.NO_CODE_CHANGE : noCodeChange ( changeId ) ; return ; case com.google.gerrit.extensions.client.ChangeKind.REWORK : rework ( changeId ) ; return ; case com.google.gerrit.extensions.client.ChangeKind.TRIVIAL_REBASE : trivialRebase ( changeId ) ; return ; case com.google.gerrit.extensions.client.ChangeKind.MERGE_FIRST_PARENT_UPDATE : updateFirstParent ( changeId ) ; return ; case com.google.gerrit.extensions.client.ChangeKind.NO_CHANGE : noChange ( changeId ) ; return ; default : fail ( ( "unexpected change kind: " + changeKind ) ) ; } }
public void run ( ) { net.codemirror.lib.CodeMirror.Viewport fromTo = cm.getViewport ( ) ; int size = ( ( fromTo.getTo ( ) ) - ( fromTo.getFrom ( ) ) ) + 1 ; if ( ( cm.getOldViewportSize ( ) ) == size ) { return ; } cm.setOldViewportSize ( size ) ; diffTable.sidePanel.adjustGutters ( cmB ) ; }
private static org.bouncycastle.openpgp.PGPPublicKeyRingCollection readPubRing ( final java.io.File pub ) { try ( java.io.InputStream fin = new java.io.FileInputStream ( pub ) ; java.io.InputStream in = org.bouncycastle.openpgp.PGPUtil.getDecoderStream ( fin ) ) { return new org.bouncycastle.openpgp.PGPPublicKeyRingCollection ( in ) ; } catch ( java.io.IOException | org.bouncycastle.openpgp.PGPException e ) { throw new com.google.inject.ProvisionException ( ( "Cannot read " + pub ) , e ) ; } }
protected java.util.List < org.eclipse.jgit.revwalk.RevCommit > getRemoteLog ( ) throws java.io.IOException { org.eclipse.jgit.lib.Repository repo = repoManager.openRepository ( project ) ; try { org.eclipse.jgit.revwalk.RevWalk rw = new org.eclipse.jgit.revwalk.RevWalk ( repo ) ; try { rw.markStart ( rw.parseCommit ( repo.getRef ( "refs/heads/master" ) . getObjectId ( ) ) ) ; return com.google.common.collect.Lists.newArrayList ( rw ) ; } finally { rw.close ( ) ; } } finally { repo.close ( ) ; } }
public com.google.gerrit.pgm.init.api.AllProjectsConfig load ( ) throws java.io.IOException , org.eclipse.jgit.errors.ConfigInvalidException { java.io.File path = getPath ( ) ; if ( path != null ) { try ( org.eclipse.jgit.lib.Repository repo = new org.eclipse.jgit.internal.storage.file.FileRepository ( path ) ) { load ( repo ) ; } } return this ; }
private com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.AccessToken newAccessTokenFromUser ( java.lang.String username ) { com.google.gerrit.server.account.AccountState account = accountCache.getByUsername ( username ) ; java.util.Collection < com.google.gerrit.server.account.externalids.ExternalId > externalIds = account.getExternalIds ( ) ; for ( com.google.gerrit.server.account.externalids.ExternalId accountExternalId : externalIds ) { java.lang.String key = accountExternalId.key ( ) . get ( ) ; if ( key.startsWith ( com.googlesource.gerrit.plugins.github.oauth.IdentifiedUserGitHubLoginProvider.EXTERNAL_ID_PREFIX ) ) { return new com.googlesource.gerrit.plugins.github.oauth.OAuthProtocol.AccessToken ( key.substring ( com.googlesource.gerrit.plugins.github.oauth.IdentifiedUserGitHubLoginProvider.EXTERNAL_ID_PREFIX.length ( ) ) ) ; } } return null ; }
public boolean equals ( final java.lang.Object other ) { if ( other == null ) return false ; if ( ( getClass ( ) ) == ( other.getClass ( ) ) ) { final com.google.gerrit.server.query.VariablePredicate < ? > v = ( ( com.google.gerrit.server.query.VariablePredicate < ? > ) ( other ) ) ; return ( getName ( ) . equals ( v.getName ( ) ) ) && ( getChildren ( ) . equals ( v.getChildren ( ) ) ) ; } return false ; }
